; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave --gnu -o.\temp\obj\f1c100s_clock.o --asm_dir=.\Temp\Lst\ --list_dir=.\Temp\Lst\ --depend=.\temp\obj\f1c100s_clock.d --cpu=ARM9E --apcs=interwork -O0 -Otime --diag_suppress=9931 -I.\users\include -I.\..\machine\include -I.\..\periph\include -I.\..\include -I.\..\emwin\Include -I.\..\tinyusb\src -I.\..\tinyusb\hw -I.\..\display -I.\..\lib\display_gfx -I.\..\lib\printf -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Atmel\SAM9260 -D__RTX -D__UVISION_VERSION=536 -DPCB_TINY200V1 -DCFG_TUSB_MCU=OPT_MCU_F1C100S -DCFG_TUSB_OS=OPT_OS_RTX4 --omf_browse=.\temp\obj\f1c100s_clock.crf ..\periph\f1c100s_clock.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  clk_pll_is_locked PROC
;;;25     // Get PLL lock state
;;;26     uint8_t clk_pll_is_locked(pll_ch_e pll) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
;;;27         uint32_t val = read32(CCU_BASE + pll);
000008  e2840401          ADD      r0,r4,#0x1000000
00000c  e28008c2          ADD      r0,r0,#0xc20000
000010  ebfffffe          BL       read32
000014  e1a05000          MOV      r5,r0
;;;28         return ((val >> 28) & 0x1);
000018  e3a00001          MOV      r0,#1
00001c  e0000e25          AND      r0,r0,r5,LSR #28
;;;29     }
000020  e8bd8070          POP      {r4-r6,pc}
;;;30     
                          ENDP

                  pll_periph_init PROC
;;;179    // out = (24MHz*N) / M
;;;180    static void pll_periph_init(uint8_t mul, uint8_t div) {
000024  e92d4070          PUSH     {r4-r6,lr}
000028  e1a04000          MOV      r4,r0
00002c  e1a05001          MOV      r5,r1
;;;181        if((mul == 0) || (div == 0)) return;
000030  e3540000          CMP      r4,#0
000034  0a000001          BEQ      |L1.64|
000038  e3550000          CMP      r5,#0
00003c  1a000000          BNE      |L1.68|
                  |L1.64|
;;;182        if((mul > 32) || (div > 4)) return;
;;;183    
;;;184        // mul = n
;;;185        // div = m
;;;186    
;;;187        uint32_t val = read32(CCU_BASE + CCU_PLL_PERIPH_CTRL);
;;;188        val &= (1 << 31) | (1 << 28);
;;;189        val |= ((mul - 1) << 8) | ((div - 1) << 4) | (1 << 18); // do we need 24m output?
;;;190        write32(CCU_BASE + CCU_PLL_PERIPH_CTRL, val);
;;;191    }
000040  e8bd8070          POP      {r4-r6,pc}
                  |L1.68|
000044  e3540020          CMP      r4,#0x20              ;182
000048  ca000001          BGT      |L1.84|
00004c  e3550004          CMP      r5,#4                 ;182
000050  da000000          BLE      |L1.88|
                  |L1.84|
000054  eafffff9          B        |L1.64|
                  |L1.88|
000058  e59f0a58          LDR      r0,|L1.2744|
00005c  ebfffffe          BL       read32
000060  e1a06000          MOV      r6,r0                 ;187
000064  e2066209          AND      r6,r6,#0x90000000     ;188
000068  e2440001          SUB      r0,r4,#1              ;189
00006c  e1a00400          LSL      r0,r0,#8              ;189
000070  e2451001          SUB      r1,r5,#1              ;189
000074  e1800201          ORR      r0,r0,r1,LSL #4       ;189
000078  e3800701          ORR      r0,r0,#0x40000        ;189
00007c  e1866000          ORR      r6,r6,r0              ;189
000080  e1a01006          MOV      r1,r6                 ;190
000084  e59f0a2c          LDR      r0,|L1.2744|
000088  ebfffffe          BL       write32
00008c  e1a00000          MOV      r0,r0
000090  eaffffea          B        |L1.64|
;;;192    
                          ENDP

                  pll_video_init PROC
;;;147    // out = (24MHz*N) / M
;;;148    static void pll_video_init(pll_ch_e pll, uint8_t mul, uint8_t div) {
000094  e92d41f0          PUSH     {r4-r8,lr}
000098  e1a06000          MOV      r6,r0
00009c  e1a04001          MOV      r4,r1
0000a0  e1a05002          MOV      r5,r2
;;;149        if((mul == 0) || (div == 0)) return;
0000a4  e3540000          CMP      r4,#0
0000a8  0a000001          BEQ      |L1.180|
0000ac  e3550000          CMP      r5,#0
0000b0  1a000000          BNE      |L1.184|
                  |L1.180|
;;;150        if((mul > 128) || (div > 16)) return;
;;;151    
;;;152        // mul = n
;;;153        // div = m
;;;154    
;;;155        uint32_t val = read32(CCU_BASE + pll);
;;;156        val &= (1 << 31) | (1 << 28);
;;;157        val |= ((mul - 1) << 8) | (div - 1) | (1 << 24);
;;;158        write32(CCU_BASE + pll, val);
;;;159    }
0000b4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.184|
0000b8  e3540080          CMP      r4,#0x80              ;150
0000bc  ca000001          BGT      |L1.200|
0000c0  e3550010          CMP      r5,#0x10              ;150
0000c4  da000000          BLE      |L1.204|
                  |L1.200|
0000c8  eafffff9          B        |L1.180|
                  |L1.204|
0000cc  e2860401          ADD      r0,r6,#0x1000000      ;155
0000d0  e28008c2          ADD      r0,r0,#0xc20000       ;155
0000d4  ebfffffe          BL       read32
0000d8  e1a07000          MOV      r7,r0                 ;155
0000dc  e2077209          AND      r7,r7,#0x90000000     ;156
0000e0  e2450001          SUB      r0,r5,#1              ;157
0000e4  e2441001          SUB      r1,r4,#1              ;157
0000e8  e1800401          ORR      r0,r0,r1,LSL #8       ;157
0000ec  e3800401          ORR      r0,r0,#0x1000000      ;157
0000f0  e1877000          ORR      r7,r7,r0              ;157
0000f4  e2860401          ADD      r0,r6,#0x1000000      ;158
0000f8  e28008c2          ADD      r0,r0,#0xc20000       ;158
0000fc  e1a01007          MOV      r1,r7                 ;158
000100  ebfffffe          BL       write32
000104  e1a00000          MOV      r0,r0
000108  eaffffe9          B        |L1.180|
;;;160    
                          ENDP

                  pll_audio_init PROC
;;;121    // out = (24MHz*N*2) / M
;;;122    static void pll_audio_init(uint16_t mul, uint8_t div) {
00010c  e92d41f0          PUSH     {r4-r8,lr}
000110  e1a04000          MOV      r4,r0
000114  e1a05001          MOV      r5,r1
;;;123        if((mul == 0) || (div == 0)) return;
000118  e3540000          CMP      r4,#0
00011c  0a000001          BEQ      |L1.296|
000120  e3550000          CMP      r5,#0
000124  1a000000          BNE      |L1.300|
                  |L1.296|
;;;124        if((mul > 256) || (div > 32)) return;
;;;125    
;;;126        uint8_t n = (uint8_t)(mul / 2); // mul = n*2
;;;127        // div = m
;;;128    
;;;129        uint32_t val = read32(CCU_BASE + CCU_PLL_AUDIO_CTRL);
;;;130        val &= (1 << 31) | (1 << 28);
;;;131        val |= ((n - 1) << 8) | (div - 1);
;;;132        write32(CCU_BASE + CCU_PLL_AUDIO_CTRL, val);
;;;133    }
000128  e8bd81f0          POP      {r4-r8,pc}
                  |L1.300|
00012c  e3540c01          CMP      r4,#0x100             ;124
000130  ca000001          BGT      |L1.316|
000134  e3550020          CMP      r5,#0x20              ;124
000138  da000000          BLE      |L1.320|
                  |L1.316|
00013c  eafffff9          B        |L1.296|
                  |L1.320|
000140  e1a00004          MOV      r0,r4                 ;126
000144  e0841fa0          ADD      r1,r4,r0,LSR #31      ;126
000148  e1a01b81          LSL      r1,r1,#23             ;126
00014c  e1a07c21          LSR      r7,r1,#24             ;126
000150  e59f0964          LDR      r0,|L1.2748|
000154  ebfffffe          BL       read32
000158  e1a06000          MOV      r6,r0                 ;129
00015c  e2066209          AND      r6,r6,#0x90000000     ;130
000160  e2450001          SUB      r0,r5,#1              ;131
000164  e2471001          SUB      r1,r7,#1              ;131
000168  e1800401          ORR      r0,r0,r1,LSL #8       ;131
00016c  e1866000          ORR      r6,r6,r0              ;131
000170  e1a01006          MOV      r1,r6                 ;132
000174  e59f0940          LDR      r0,|L1.2748|
000178  ebfffffe          BL       write32
00017c  e1a00000          MOV      r0,r0
000180  eaffffe8          B        |L1.296|
;;;134    
                          ENDP

                  pll_cpu_init PROC
;;;76     // out = (24MHz*N*K) / (M*P)
;;;77     static void pll_cpu_init(uint8_t mul, uint8_t div) {
000184  e92d47f0          PUSH     {r4-r10,lr}
000188  e1a08000          MOV      r8,r0
00018c  e1a07001          MOV      r7,r1
;;;78         if((mul == 0) || (div == 0)) return;
000190  e3580000          CMP      r8,#0
000194  0a000001          BEQ      |L1.416|
000198  e3570000          CMP      r7,#0
00019c  1a000000          BNE      |L1.420|
                  |L1.416|
;;;79         if((mul > 128) || (div > 16)) return;
;;;80     
;;;81         uint8_t n, k, m, p;
;;;82         // mul = n*k
;;;83         // n = 1..32
;;;84         // k = 1..4
;;;85         for(k = 1; k <= 4; k++) {
;;;86             n = mul / k;
;;;87             if((n < 32) && (n * k == mul)) break;
;;;88         }
;;;89         if(n * k != mul) return;
;;;90         // div = m*p
;;;91         // m = 1..4
;;;92         // k = 1,2,4
;;;93         for(m = 1; m <= 4; m++) {
;;;94             p = div / m;
;;;95             if(((p == 1) || (p == 2) || (p == 4)) && (m * p == div)) break;
;;;96         }
;;;97         if(m * p != div) return;
;;;98     
;;;99         p--;
;;;100        if(p == 3) p = 2;
;;;101    
;;;102        uint32_t val = read32(CCU_BASE + CCU_PLL_CPU_CTRL);
;;;103        val &= (1 << 31) | (1 << 28);
;;;104        val |= ((n - 1) << 8) | ((k - 1) << 4) | (m - 1) | (p << 16);
;;;105        write32(CCU_BASE + CCU_PLL_CPU_CTRL, val);
;;;106    }
0001a0  e8bd87f0          POP      {r4-r10,pc}
                  |L1.420|
0001a4  e3580080          CMP      r8,#0x80              ;79
0001a8  ca000001          BGT      |L1.436|
0001ac  e3570010          CMP      r7,#0x10              ;79
0001b0  da000000          BLE      |L1.440|
                  |L1.436|
0001b4  eafffff9          B        |L1.416|
                  |L1.440|
0001b8  e3a05001          MOV      r5,#1                 ;85
0001bc  ea00000b          B        |L1.496|
                  |L1.448|
0001c0  e1a01005          MOV      r1,r5                 ;86
0001c4  e1a00008          MOV      r0,r8                 ;86
0001c8  ebfffffe          BL       __aeabi_idivmod
0001cc  e20090ff          AND      r9,r0,#0xff           ;86
0001d0  e3590020          CMP      r9,#0x20              ;87
0001d4  aa000003          BGE      |L1.488|
0001d8  e0000599          MUL      r0,r9,r5              ;87
0001dc  e1500008          CMP      r0,r8                 ;87
0001e0  1a000000          BNE      |L1.488|
0001e4  ea000003          B        |L1.504|
                  |L1.488|
0001e8  e2850001          ADD      r0,r5,#1              ;85
0001ec  e20050ff          AND      r5,r0,#0xff           ;85
                  |L1.496|
0001f0  e3550004          CMP      r5,#4                 ;85
0001f4  dafffff1          BLE      |L1.448|
                  |L1.504|
0001f8  e1a00000          MOV      r0,r0                 ;87
0001fc  e0000599          MUL      r0,r9,r5              ;89
000200  e1500008          CMP      r0,r8                 ;89
000204  0a000000          BEQ      |L1.524|
000208  eaffffe4          B        |L1.416|
                  |L1.524|
00020c  e3a06001          MOV      r6,#1                 ;93
000210  ea00000f          B        |L1.596|
                  |L1.532|
000214  e1a01006          MOV      r1,r6                 ;94
000218  e1a00007          MOV      r0,r7                 ;94
00021c  ebfffffe          BL       __aeabi_idivmod
000220  e20040ff          AND      r4,r0,#0xff           ;94
000224  e3540001          CMP      r4,#1                 ;95
000228  0a000003          BEQ      |L1.572|
00022c  e3540002          CMP      r4,#2                 ;95
000230  0a000001          BEQ      |L1.572|
000234  e3540004          CMP      r4,#4                 ;95
000238  1a000003          BNE      |L1.588|
                  |L1.572|
00023c  e0000496          MUL      r0,r6,r4              ;95
000240  e1500007          CMP      r0,r7                 ;95
000244  1a000000          BNE      |L1.588|
000248  ea000003          B        |L1.604|
                  |L1.588|
00024c  e2860001          ADD      r0,r6,#1              ;93
000250  e20060ff          AND      r6,r0,#0xff           ;93
                  |L1.596|
000254  e3560004          CMP      r6,#4                 ;93
000258  daffffed          BLE      |L1.532|
                  |L1.604|
00025c  e1a00000          MOV      r0,r0                 ;95
000260  e0000496          MUL      r0,r6,r4              ;97
000264  e1500007          CMP      r0,r7                 ;97
000268  0a000000          BEQ      |L1.624|
00026c  eaffffcb          B        |L1.416|
                  |L1.624|
000270  e2440001          SUB      r0,r4,#1              ;99
000274  e20040ff          AND      r4,r0,#0xff           ;99
000278  e3540003          CMP      r4,#3                 ;100
00027c  1a000000          BNE      |L1.644|
000280  e3a04002          MOV      r4,#2                 ;100
                  |L1.644|
000284  e59f0834          LDR      r0,|L1.2752|
000288  ebfffffe          BL       read32
00028c  e1a0a000          MOV      r10,r0                ;102
000290  e20aa209          AND      r10,r10,#0x90000000   ;103
000294  e2490001          SUB      r0,r9,#1              ;104
000298  e1a00400          LSL      r0,r0,#8              ;104
00029c  e2451001          SUB      r1,r5,#1              ;104
0002a0  e1800201          ORR      r0,r0,r1,LSL #4       ;104
0002a4  e2461001          SUB      r1,r6,#1              ;104
0002a8  e1800001          ORR      r0,r0,r1              ;104
0002ac  e1800804          ORR      r0,r0,r4,LSL #16      ;104
0002b0  e18aa000          ORR      r10,r10,r0            ;104
0002b4  e1a0100a          MOV      r1,r10                ;105
0002b8  e59f0800          LDR      r0,|L1.2752|
0002bc  ebfffffe          BL       write32
0002c0  e1a00000          MOV      r0,r0
0002c4  eaffffb5          B        |L1.416|
;;;107    
                          ENDP

                  clk_pll_init PROC
;;;32     // out = 24MHz * mul / div
;;;33     void clk_pll_init(pll_ch_e pll, uint8_t mul, uint8_t div) {
0002c8  e92d4070          PUSH     {r4-r6,lr}
0002cc  e1a06000          MOV      r6,r0
0002d0  e1a04001          MOV      r4,r1
0002d4  e1a05002          MOV      r5,r2
;;;34         switch(pll) {
0002d8  e3560018          CMP      r6,#0x18
0002dc  0a000018          BEQ      |L1.836|
0002e0  ca000006          BGT      |L1.768|
0002e4  e3560000          CMP      r6,#0
0002e8  0a000009          BEQ      |L1.788|
0002ec  e3560008          CMP      r6,#8
0002f0  0a00000c          BEQ      |L1.808|
0002f4  e3560010          CMP      r6,#0x10
0002f8  1a00001d          BNE      |L1.884|
0002fc  ea00000e          B        |L1.828|
                  |L1.768|
000300  e3560020          CMP      r6,#0x20
000304  0a000013          BEQ      |L1.856|
000308  e3560028          CMP      r6,#0x28
00030c  1a000018          BNE      |L1.884|
000310  ea000012          B        |L1.864|
                  |L1.788|
;;;35         case PLL_CPU:
000314  e1a00000          MOV      r0,r0
;;;36             pll_cpu_init(mul, div);
000318  e1a01005          MOV      r1,r5
00031c  e1a00004          MOV      r0,r4
000320  ebfffffe          BL       pll_cpu_init
;;;37             break;
000324  ea000014          B        |L1.892|
                  |L1.808|
;;;38         case PLL_AUDIO:
000328  e1a00000          MOV      r0,r0
;;;39             pll_audio_init(mul, div);
00032c  e1a01005          MOV      r1,r5
000330  e1a00004          MOV      r0,r4
000334  ebfffffe          BL       pll_audio_init
;;;40             break;
000338  ea00000f          B        |L1.892|
                  |L1.828|
;;;41         case PLL_VIDEO:
00033c  e1a00000          MOV      r0,r0
;;;42         case PLL_VE:
000340  e1a00000          MOV      r0,r0
                  |L1.836|
;;;43             pll_video_init(pll, mul, div);
000344  e1a02005          MOV      r2,r5
000348  e1a01004          MOV      r1,r4
00034c  e1a00006          MOV      r0,r6
000350  ebfffffe          BL       pll_video_init
;;;44             break;
000354  ea000008          B        |L1.892|
                  |L1.856|
;;;45         case PLL_DDR:
000358  e1a00000          MOV      r0,r0
;;;46             break; // TODO:
00035c  ea000006          B        |L1.892|
                  |L1.864|
;;;47         case PLL_PERIPH:
000360  e1a00000          MOV      r0,r0
;;;48             pll_periph_init(mul, div);
000364  e1a01005          MOV      r1,r5
000368  e1a00004          MOV      r0,r4
00036c  ebfffffe          BL       pll_periph_init
;;;49             break;
000370  ea000001          B        |L1.892|
                  |L1.884|
;;;50         default:
000374  e1a00000          MOV      r0,r0
;;;51             break;
000378  e1a00000          MOV      r0,r0
                  |L1.892|
00037c  e1a00000          MOV      r0,r0                 ;37
;;;52         }
;;;53     }
000380  e8bd8070          POP      {r4-r6,pc}
;;;54     
                          ENDP

                  pll_periph_get_freq PROC
;;;192    
;;;193    static uint32_t pll_periph_get_freq(void) {
000384  e92d4070          PUSH     {r4-r6,lr}
;;;194        uint32_t reg = read32(CCU_BASE + CCU_PLL_PERIPH_CTRL);
000388  e59f0728          LDR      r0,|L1.2744|
00038c  ebfffffe          BL       read32
000390  e1a04000          MOV      r4,r0
;;;195    
;;;196        uint32_t mul = (reg >> 8) & 0x1F;
000394  e3a0001f          MOV      r0,#0x1f
000398  e0005424          AND      r5,r0,r4,LSR #8
;;;197        uint32_t div = (reg >> 4) & 0x3;
00039c  e3a00003          MOV      r0,#3
0003a0  e0006224          AND      r6,r0,r4,LSR #4
;;;198    
;;;199        return (24000000 * (mul + 1) / (div + 1));
0003a4  e2851001          ADD      r1,r5,#1
0003a8  e59f2714          LDR      r2,|L1.2756|
0003ac  e0000291          MUL      r0,r1,r2
0003b0  e2861001          ADD      r1,r6,#1
0003b4  ebfffffe          BL       __aeabi_uidivmod
;;;200    }
0003b8  e8bd8070          POP      {r4-r6,pc}
;;;201    
                          ENDP

                  pll_ddr_get_freq PROC
;;;202    static uint32_t pll_ddr_get_freq(void) {
0003bc  e92d41f0          PUSH     {r4-r8,lr}
;;;203        uint32_t reg = read32(CCU_BASE + CCU_PLL_DDR_CTRL);
0003c0  e59f0700          LDR      r0,|L1.2760|
0003c4  ebfffffe          BL       read32
0003c8  e1a04000          MOV      r4,r0
;;;204    
;;;205        uint32_t n = (reg >> 8) & 0x1F;
0003cc  e3a0001f          MOV      r0,#0x1f
0003d0  e0005424          AND      r5,r0,r4,LSR #8
;;;206        uint32_t k = (reg >> 4) & 0x3;
0003d4  e3a00003          MOV      r0,#3
0003d8  e0006224          AND      r6,r0,r4,LSR #4
;;;207        uint32_t m = (reg >> 0) & 0x3;
0003dc  e2047003          AND      r7,r4,#3
;;;208    
;;;209        return (24000000 * (n + 1) * (k + 1) / (m + 1));
0003e0  e2851001          ADD      r1,r5,#1
0003e4  e59f26d8          LDR      r2,|L1.2756|
0003e8  e0010192          MUL      r1,r2,r1
0003ec  e2862001          ADD      r2,r6,#1
0003f0  e0000291          MUL      r0,r1,r2
0003f4  e2871001          ADD      r1,r7,#1
0003f8  ebfffffe          BL       __aeabi_uidivmod
;;;210    }
0003fc  e8bd81f0          POP      {r4-r8,pc}
;;;211    
                          ENDP

                  pll_video_get_freq PROC
;;;160    
;;;161    static uint32_t pll_video_get_freq(pll_ch_e pll) {
000400  e92d41f0          PUSH     {r4-r8,lr}
000404  e1a05000          MOV      r5,r0
;;;162        uint32_t reg = read32(CCU_BASE + pll);
000408  e2850401          ADD      r0,r5,#0x1000000
00040c  e28008c2          ADD      r0,r0,#0xc20000
000410  ebfffffe          BL       read32
000414  e1a04000          MOV      r4,r0
;;;163    
;;;164        if((reg & (1 << 24)) == 0) {
000418  e2040401          AND      r0,r4,#0x1000000
00041c  e3500000          CMP      r0,#0
000420  1a000006          BNE      |L1.1088|
;;;165            // Fractional mode
;;;166            if(reg & (1 << 25))
000424  e2040402          AND      r0,r4,#0x2000000
000428  e3500000          CMP      r0,#0
00042c  0a000001          BEQ      |L1.1080|
;;;167                return 297000000;
000430  e59f0694          LDR      r0,|L1.2764|
                  |L1.1076|
;;;168            else
;;;169                return 270000000;
;;;170        } else {
;;;171            // Integer mode
;;;172            uint32_t mul = (reg >> 8) & 0x7F;
;;;173            uint32_t div = (reg >> 0) & 0xF;
;;;174    
;;;175            return (24000000 * (mul + 1) / (div + 1));
;;;176        }
;;;177    }
000434  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1080|
000438  e59f0690          LDR      r0,|L1.2768|
00043c  eafffffc          B        |L1.1076|
                  |L1.1088|
000440  e3a0007f          MOV      r0,#0x7f              ;172
000444  e0006424          AND      r6,r0,r4,LSR #8       ;172
000448  e204700f          AND      r7,r4,#0xf            ;173
00044c  e2861001          ADD      r1,r6,#1              ;175
000450  e59f266c          LDR      r2,|L1.2756|
000454  e0000291          MUL      r0,r1,r2              ;175
000458  e2871001          ADD      r1,r7,#1              ;175
00045c  ebfffffe          BL       __aeabi_uidivmod
000460  eafffff3          B        |L1.1076|
;;;178    
                          ENDP

                  pll_audio_get_freq PROC
;;;134    
;;;135    static uint32_t pll_audio_get_freq(void) {
000464  e92d4070          PUSH     {r4-r6,lr}
;;;136        uint32_t reg = read32(CCU_BASE + CCU_PLL_AUDIO_CTRL);
000468  e59f064c          LDR      r0,|L1.2748|
00046c  ebfffffe          BL       read32
000470  e1a04000          MOV      r4,r0
;;;137    
;;;138        uint32_t mul = (reg >> 8) & 0x7F;
000474  e3a0007f          MOV      r0,#0x7f
000478  e0005424          AND      r5,r0,r4,LSR #8
;;;139        uint32_t div = (reg >> 0) & 0x1F;
00047c  e204601f          AND      r6,r4,#0x1f
;;;140    
;;;141        if(reg & (1 << 24)) // SDM
000480  e2040401          AND      r0,r4,#0x1000000
000484  e3500000          CMP      r0,#0
000488  0a000000          BEQ      |L1.1168|
;;;142            mul &= 0xF;
00048c  e205500f          AND      r5,r5,#0xf
                  |L1.1168|
;;;143    
;;;144        return (24000000 * 2 * (mul + 1) / (div + 1));
000490  e2851001          ADD      r1,r5,#1
000494  e59f2638          LDR      r2,|L1.2772|
000498  e0000291          MUL      r0,r1,r2
00049c  e2861001          ADD      r1,r6,#1
0004a0  ebfffffe          BL       __aeabi_uidivmod
;;;145    }
0004a4  e8bd8070          POP      {r4-r6,pc}
;;;146    
                          ENDP

                  pll_cpu_get_freq PROC
;;;107    
;;;108    static uint32_t pll_cpu_get_freq(void) {
0004a8  e92d41f0          PUSH     {r4-r8,lr}
;;;109        uint32_t reg = read32(CCU_BASE + CCU_PLL_CPU_CTRL);
0004ac  e59f060c          LDR      r0,|L1.2752|
0004b0  ebfffffe          BL       read32
0004b4  e1a04000          MOV      r4,r0
;;;110    
;;;111        uint32_t n = (reg >> 8) & 0x1F;
0004b8  e3a0001f          MOV      r0,#0x1f
0004bc  e0006424          AND      r6,r0,r4,LSR #8
;;;112        uint32_t k = (reg >> 4) & 0x3;
0004c0  e3a00003          MOV      r0,#3
0004c4  e0007224          AND      r7,r0,r4,LSR #4
;;;113        uint32_t m = (reg >> 0) & 0x3;
0004c8  e2048003          AND      r8,r4,#3
;;;114        uint32_t p = (reg >> 16) & 0x3;
0004cc  e0005824          AND      r5,r0,r4,LSR #16
;;;115    
;;;116        p = (1 << p);
0004d0  e3a00001          MOV      r0,#1
0004d4  e1a05510          LSL      r5,r0,r5
;;;117    
;;;118        return (24000000 * (n + 1) * (k + 1) / ((m + 1) * p));
0004d8  e2882001          ADD      r2,r8,#1
0004dc  e0010592          MUL      r1,r2,r5
0004e0  e2862001          ADD      r2,r6,#1
0004e4  e59f35d8          LDR      r3,|L1.2756|
0004e8  e0020293          MUL      r2,r3,r2
0004ec  e2873001          ADD      r3,r7,#1
0004f0  e0000392          MUL      r0,r2,r3
0004f4  ebfffffe          BL       __aeabi_uidivmod
;;;119    }
0004f8  e8bd81f0          POP      {r4-r8,pc}
;;;120    
                          ENDP

                  clk_pll_get_freq PROC
;;;54     
;;;55     uint32_t clk_pll_get_freq(pll_ch_e pll) {
0004fc  e92d4010          PUSH     {r4,lr}
000500  e1a04000          MOV      r4,r0
;;;56         if(!clk_pll_is_locked(pll)) return 0;
000504  e1a00004          MOV      r0,r4
000508  ebfffffe          BL       clk_pll_is_locked
00050c  e3500000          CMP      r0,#0
000510  1a000001          BNE      |L1.1308|
000514  e3a00000          MOV      r0,#0
                  |L1.1304|
;;;57     
;;;58         switch(pll) {
;;;59         case PLL_CPU:
;;;60             return pll_cpu_get_freq();
;;;61         case PLL_AUDIO:
;;;62             return pll_audio_get_freq();
;;;63         case PLL_VIDEO:
;;;64         case PLL_VE:
;;;65             return pll_video_get_freq(pll);
;;;66         case PLL_DDR:
;;;67             return pll_ddr_get_freq();
;;;68         case PLL_PERIPH:
;;;69             return pll_periph_get_freq();
;;;70         default:
;;;71             break;
;;;72         }
;;;73         return 0;
;;;74     }
000518  e8bd8010          POP      {r4,pc}
                  |L1.1308|
00051c  e3540018          CMP      r4,#0x18              ;58
000520  0a000014          BEQ      |L1.1400|
000524  ca000006          BGT      |L1.1348|
000528  e3540000          CMP      r4,#0                 ;58
00052c  0a000009          BEQ      |L1.1368|
000530  e3540008          CMP      r4,#8                 ;58
000534  0a00000a          BEQ      |L1.1380|
000538  e3540010          CMP      r4,#0x10              ;58
00053c  1a000016          BNE      |L1.1436|
000540  ea00000a          B        |L1.1392|
                  |L1.1348|
000544  e3540020          CMP      r4,#0x20              ;58
000548  0a00000d          BEQ      |L1.1412|
00054c  e3540028          CMP      r4,#0x28              ;58
000550  1a000011          BNE      |L1.1436|
000554  ea00000d          B        |L1.1424|
                  |L1.1368|
000558  e1a00000          MOV      r0,r0                 ;59
00055c  ebfffffe          BL       pll_cpu_get_freq
000560  eaffffec          B        |L1.1304|
                  |L1.1380|
000564  e1a00000          MOV      r0,r0                 ;61
000568  ebfffffe          BL       pll_audio_get_freq
00056c  eaffffe9          B        |L1.1304|
                  |L1.1392|
000570  e1a00000          MOV      r0,r0                 ;63
000574  e1a00000          MOV      r0,r0                 ;64
                  |L1.1400|
000578  e1a00004          MOV      r0,r4                 ;65
00057c  ebfffffe          BL       pll_video_get_freq
000580  eaffffe4          B        |L1.1304|
                  |L1.1412|
000584  e1a00000          MOV      r0,r0                 ;66
000588  ebfffffe          BL       pll_ddr_get_freq
00058c  eaffffe1          B        |L1.1304|
                  |L1.1424|
000590  e1a00000          MOV      r0,r0                 ;68
000594  ebfffffe          BL       pll_periph_get_freq
000598  eaffffde          B        |L1.1304|
                  |L1.1436|
00059c  e1a00000          MOV      r0,r0                 ;70
0005a0  e1a00000          MOV      r0,r0                 ;71
0005a4  e1a00000          MOV      r0,r0                 ;71
0005a8  e3a00000          MOV      r0,#0                 ;73
0005ac  eaffffd9          B        |L1.1304|
;;;75     
                          ENDP

                  clk_cpu_config PROC
;;;224    // CPU clock configuration
;;;225    void clk_cpu_config(clk_source_cpu_e source) {
0005b0  e92d4070          PUSH     {r4-r6,lr}
0005b4  e1a04000          MOV      r4,r0
;;;226        uint32_t reg = read32(CCU_BASE + CCU_CPU_CFG) & ~(0x3 << 16);
0005b8  e59f0518          LDR      r0,|L1.2776|
0005bc  ebfffffe          BL       read32
0005c0  e3c05803          BIC      r5,r0,#0x30000
;;;227        write32(CCU_BASE + CCU_CPU_CFG, reg | (source << 16));
0005c4  e1851804          ORR      r1,r5,r4,LSL #16
0005c8  e59f0508          LDR      r0,|L1.2776|
0005cc  ebfffffe          BL       write32
;;;228    }
0005d0  e8bd8070          POP      {r4-r6,pc}
;;;229    
                          ENDP

                  clk_cpu_get_freq PROC
;;;230    uint32_t clk_cpu_get_freq(void) {
0005d4  e92d4010          PUSH     {r4,lr}
;;;231        clk_source_cpu_e src = (read32(CCU_BASE + CCU_CPU_CFG) >> 16) & 0x3;
0005d8  e59f04f8          LDR      r0,|L1.2776|
0005dc  ebfffffe          BL       read32
0005e0  e3a01003          MOV      r1,#3
0005e4  e0014820          AND      r4,r1,r0,LSR #16
;;;232    
;;;233        switch(src) {
0005e8  e3540000          CMP      r4,#0
0005ec  0a000004          BEQ      |L1.1540|
0005f0  e3540001          CMP      r4,#1
0005f4  0a000005          BEQ      |L1.1552|
0005f8  e3540002          CMP      r4,#2
0005fc  1a00000a          BNE      |L1.1580|
000600  ea000005          B        |L1.1564|
                  |L1.1540|
;;;234        case CLK_CPU_SRC_LOSC:
000604  e1a00000          MOV      r0,r0
;;;235            return 32000; // ??
000608  e3a00c7d          MOV      r0,#0x7d00
                  |L1.1548|
;;;236        case CLK_CPU_SRC_OSC24M:
;;;237            return 24000000;
;;;238        case CLK_CPU_SRC_PLL_CPU:
;;;239            return clk_pll_get_freq(PLL_CPU);
;;;240        default:
;;;241            return 0;
;;;242        }
;;;243    }
00060c  e8bd8010          POP      {r4,pc}
                  |L1.1552|
000610  e1a00000          MOV      r0,r0                 ;236
000614  e59f04a8          LDR      r0,|L1.2756|
000618  eafffffb          B        |L1.1548|
                  |L1.1564|
00061c  e1a00000          MOV      r0,r0                 ;238
000620  e3a00000          MOV      r0,#0                 ;239
000624  ebfffffe          BL       clk_pll_get_freq
000628  eafffff7          B        |L1.1548|
                  |L1.1580|
00062c  e1a00000          MOV      r0,r0                 ;240
000630  e3a00000          MOV      r0,#0                 ;241
000634  eafffff4          B        |L1.1548|
;;;244    
                          ENDP

                  clk_hclk_config PROC
;;;245    // HCLK = CPUCLK / div
;;;246    void clk_hclk_config(uint8_t div) {
000638  e92d4070          PUSH     {r4-r6,lr}
00063c  e1a04000          MOV      r4,r0
;;;247        if((div == 0) || (div > 4)) return;
000640  e3540000          CMP      r4,#0
000644  0a000001          BEQ      |L1.1616|
000648  e3540004          CMP      r4,#4
00064c  da000000          BLE      |L1.1620|
                  |L1.1616|
;;;248    
;;;249        uint32_t val = read32(CCU_BASE + CCU_AHB_APB_CFG) & ~(0x3 << 16);
;;;250        write32(CCU_BASE + CCU_AHB_APB_CFG, val | ((div - 1) << 16));
;;;251    }
000650  e8bd8070          POP      {r4-r6,pc}
                  |L1.1620|
000654  e59f0480          LDR      r0,|L1.2780|
000658  ebfffffe          BL       read32
00065c  e3c05803          BIC      r5,r0,#0x30000        ;249
000660  e2440001          SUB      r0,r4,#1              ;250
000664  e1851800          ORR      r1,r5,r0,LSL #16      ;250
000668  e59f046c          LDR      r0,|L1.2780|
00066c  ebfffffe          BL       write32
000670  e1a00000          MOV      r0,r0
000674  eafffff5          B        |L1.1616|
;;;252    
                          ENDP

                  clk_hclk_get_freq PROC
;;;253    uint32_t clk_hclk_get_freq(void) {
000678  e92d4070          PUSH     {r4-r6,lr}
;;;254        uint8_t div = (read32(CCU_BASE + CCU_AHB_APB_CFG) >> 16) & 0x3;
00067c  e59f0458          LDR      r0,|L1.2780|
000680  ebfffffe          BL       read32
000684  e3a01003          MOV      r1,#3
000688  e0014820          AND      r4,r1,r0,LSR #16
;;;255    
;;;256        return (clk_cpu_get_freq() / (div + 1));
00068c  ebfffffe          BL       clk_cpu_get_freq
000690  e1a05000          MOV      r5,r0
000694  e2841001          ADD      r1,r4,#1
000698  ebfffffe          BL       __aeabi_uidivmod
;;;257    }
00069c  e8bd8070          POP      {r4-r6,pc}
;;;258    
                          ENDP

                  clk_ahb_config PROC
;;;259    // AHB = (src or src/prediv)/div
;;;260    void clk_ahb_config(clk_source_ahb_e src, uint8_t prediv, uint8_t div) {
0006a0  e92d41f0          PUSH     {r4-r8,lr}
0006a4  e1a06000          MOV      r6,r0
0006a8  e1a05001          MOV      r5,r1
0006ac  e1a04002          MOV      r4,r2
;;;261        if((prediv == 0) || (prediv > 4)) return;
0006b0  e3550000          CMP      r5,#0
0006b4  0a000001          BEQ      |L1.1728|
0006b8  e3550004          CMP      r5,#4
0006bc  da000000          BLE      |L1.1732|
                  |L1.1728|
;;;262        if((div == 0) || ((div > 4) && (div != 8)) || (div == 3)) return;
;;;263        if(div == 4) div = 3;
;;;264        if(div == 8) div = 4;
;;;265    
;;;266        uint32_t val = read32(CCU_BASE + CCU_AHB_APB_CFG) & ~((0x3 << 12) | (0xF << 4));
;;;267        write32(
;;;268            CCU_BASE + CCU_AHB_APB_CFG, val | (src << 12) | ((prediv - 1) << 6) | ((div - 1) << 4));
;;;269    }
0006c0  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1732|
0006c4  e3540000          CMP      r4,#0                 ;262
0006c8  0a000005          BEQ      |L1.1764|
0006cc  e3540004          CMP      r4,#4                 ;262
0006d0  da000001          BLE      |L1.1756|
0006d4  e3540008          CMP      r4,#8                 ;262
0006d8  1a000001          BNE      |L1.1764|
                  |L1.1756|
0006dc  e3540003          CMP      r4,#3                 ;262
0006e0  1a000000          BNE      |L1.1768|
                  |L1.1764|
0006e4  eafffff5          B        |L1.1728|
                  |L1.1768|
0006e8  e3540004          CMP      r4,#4                 ;263
0006ec  1a000000          BNE      |L1.1780|
0006f0  e3a04003          MOV      r4,#3                 ;263
                  |L1.1780|
0006f4  e3540008          CMP      r4,#8                 ;264
0006f8  1a000000          BNE      |L1.1792|
0006fc  e3a04004          MOV      r4,#4                 ;264
                  |L1.1792|
000700  e59f03d4          LDR      r0,|L1.2780|
000704  ebfffffe          BL       read32
000708  e3c07a03          BIC      r7,r0,#0x3000         ;266
00070c  e3c770f0          BIC      r7,r7,#0xf0           ;266
000710  e1870606          ORR      r0,r7,r6,LSL #12      ;267
000714  e2452001          SUB      r2,r5,#1              ;267
000718  e1800302          ORR      r0,r0,r2,LSL #6       ;267
00071c  e2442001          SUB      r2,r4,#1              ;267
000720  e1801202          ORR      r1,r0,r2,LSL #4       ;267
000724  e59f03b0          LDR      r0,|L1.2780|
000728  ebfffffe          BL       write32
00072c  e1a00000          MOV      r0,r0
000730  eaffffe2          B        |L1.1728|
;;;270    
                          ENDP

                  clk_ahb_get_freq PROC
;;;271    uint32_t clk_ahb_get_freq(void) {
000734  e92d41f0          PUSH     {r4-r8,lr}
;;;272        clk_source_ahb_e src = (read32(CCU_BASE + CCU_AHB_APB_CFG) >> 12) & 0x3;
000738  e59f039c          LDR      r0,|L1.2780|
00073c  ebfffffe          BL       read32
000740  e3a01003          MOV      r1,#3
000744  e0015620          AND      r5,r1,r0,LSR #12
;;;273    
;;;274        uint8_t div    = (read32(CCU_BASE + CCU_AHB_APB_CFG) >> 4) & 0x3;
000748  e59f038c          LDR      r0,|L1.2780|
00074c  ebfffffe          BL       read32
000750  e3a01003          MOV      r1,#3
000754  e0014220          AND      r4,r1,r0,LSR #4
;;;275        uint8_t prediv = (read32(CCU_BASE + CCU_AHB_APB_CFG) >> 6) & 0x3;
000758  e59f037c          LDR      r0,|L1.2780|
00075c  ebfffffe          BL       read32
000760  e3a01003          MOV      r1,#3
000764  e0016320          AND      r6,r1,r0,LSR #6
;;;276    
;;;277        div = (1 << div);
000768  e3a00001          MOV      r0,#1
00076c  e1a00410          LSL      r0,r0,r4
000770  e20040ff          AND      r4,r0,#0xff
;;;278    
;;;279        switch(src) {
000774  e3550000          CMP      r5,#0
000778  0a000006          BEQ      |L1.1944|
00077c  e3550001          CMP      r5,#1
000780  0a000009          BEQ      |L1.1964|
000784  e3550002          CMP      r5,#2
000788  0a00000c          BEQ      |L1.1984|
00078c  e3550003          CMP      r5,#3
000790  1a00001a          BNE      |L1.2048|
000794  ea00000f          B        |L1.2008|
                  |L1.1944|
;;;280        case CLK_AHB_SRC_LOSC:
000798  e1a00000          MOV      r0,r0
;;;281            return (32000 / div);
00079c  e1a01004          MOV      r1,r4
0007a0  e3a00c7d          MOV      r0,#0x7d00
0007a4  ebfffffe          BL       __aeabi_idivmod
                  |L1.1960|
;;;282        case CLK_AHB_SRC_OSC24M:
;;;283            return (24000000 / div);
;;;284        case CLK_AHB_SRC_CPUCLK:
;;;285            return (clk_cpu_get_freq() / div);
;;;286        case CLK_AHB_SRC_PLL_PERIPH_PREDIV:
;;;287            return (clk_pll_get_freq(PLL_PERIPH) / (prediv + 1) / div);
;;;288        default:
;;;289            return 0;
;;;290        }
;;;291    }
0007a8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1964|
0007ac  e1a00000          MOV      r0,r0                 ;282
0007b0  e1a01004          MOV      r1,r4                 ;283
0007b4  e59f0308          LDR      r0,|L1.2756|
0007b8  ebfffffe          BL       __aeabi_idivmod
0007bc  eafffff9          B        |L1.1960|
                  |L1.1984|
0007c0  e1a00000          MOV      r0,r0                 ;284
0007c4  ebfffffe          BL       clk_cpu_get_freq
0007c8  e1a07000          MOV      r7,r0                 ;285
0007cc  e1a01004          MOV      r1,r4                 ;285
0007d0  ebfffffe          BL       __aeabi_uidivmod
0007d4  eafffff3          B        |L1.1960|
                  |L1.2008|
0007d8  e1a00000          MOV      r0,r0                 ;286
0007dc  e3a00028          MOV      r0,#0x28              ;287
0007e0  ebfffffe          BL       clk_pll_get_freq
0007e4  e1a08000          MOV      r8,r0                 ;287
0007e8  e2861001          ADD      r1,r6,#1              ;287
0007ec  ebfffffe          BL       __aeabi_uidivmod
0007f0  e1a07000          MOV      r7,r0                 ;287
0007f4  e1a01004          MOV      r1,r4                 ;287
0007f8  ebfffffe          BL       __aeabi_uidivmod
0007fc  eaffffe9          B        |L1.1960|
                  |L1.2048|
000800  e1a00000          MOV      r0,r0                 ;288
000804  e3a00000          MOV      r0,#0                 ;289
000808  eaffffe6          B        |L1.1960|
;;;292    
                          ENDP

                  clk_apb_config PROC
;;;293    // APB = AHB / div
;;;294    void clk_apb_config(clk_div_apb_e div) {
00080c  e92d4070          PUSH     {r4-r6,lr}
000810  e1a04000          MOV      r4,r0
;;;295        uint32_t val = read32(CCU_BASE + CCU_AHB_APB_CFG) & ~(0x3 << 8);
000814  e59f02c0          LDR      r0,|L1.2780|
000818  ebfffffe          BL       read32
00081c  e3c05c03          BIC      r5,r0,#0x300
;;;296        write32(CCU_BASE + CCU_AHB_APB_CFG, val | (div << 8));
000820  e1851404          ORR      r1,r5,r4,LSL #8
000824  e59f02b0          LDR      r0,|L1.2780|
000828  ebfffffe          BL       write32
;;;297    }
00082c  e8bd8070          POP      {r4-r6,pc}
;;;298    
                          ENDP

                  clk_apb_get_freq PROC
;;;299    uint32_t clk_apb_get_freq(void) {
000830  e92d4010          PUSH     {r4,lr}
;;;300        clk_div_apb_e div = (read32(CCU_BASE + CCU_AHB_APB_CFG) >> 8) & 0x3;
000834  e59f02a0          LDR      r0,|L1.2780|
000838  ebfffffe          BL       read32
00083c  e3a01003          MOV      r1,#3
000840  e0014420          AND      r4,r1,r0,LSR #8
;;;301    
;;;302        switch(div) {
000844  e3540002          CMP      r4,#2
000848  0a000002          BEQ      |L1.2136|
00084c  e3540003          CMP      r4,#3
000850  1a000008          BNE      |L1.2168|
000854  ea000003          B        |L1.2152|
                  |L1.2136|
;;;303        case CLK_APB_DIV_4:
000858  e1a00000          MOV      r0,r0
;;;304            return clk_ahb_get_freq() / 4;
00085c  ebfffffe          BL       clk_ahb_get_freq
000860  e1a00120          LSR      r0,r0,#2
                  |L1.2148|
;;;305        case CLK_APB_DIV_8:
;;;306            return clk_ahb_get_freq() / 8;
;;;307        default:
;;;308            return clk_ahb_get_freq() / 2;
;;;309        }
;;;310    }
000864  e8bd8010          POP      {r4,pc}
                  |L1.2152|
000868  e1a00000          MOV      r0,r0                 ;305
00086c  ebfffffe          BL       clk_ahb_get_freq
000870  e1a001a0          LSR      r0,r0,#3              ;306
000874  eafffffa          B        |L1.2148|
                  |L1.2168|
000878  e1a00000          MOV      r0,r0                 ;307
00087c  ebfffffe          BL       clk_ahb_get_freq
000880  e1a000a0          LSR      r0,r0,#1              ;308
000884  eafffff6          B        |L1.2148|
;;;311    
                          ENDP

                  clk_de_config PROC
;;;312    // DEBE / DEFE clock configuration
;;;313    void clk_de_config(uint32_t reg, clk_source_de_e source, uint8_t div) {
000888  e92d41f0          PUSH     {r4-r8,lr}
00088c  e1a05000          MOV      r5,r0
000890  e1a07001          MOV      r7,r1
000894  e1a04002          MOV      r4,r2
;;;314        if((div == 0) || (div > 16)) return;
000898  e3540000          CMP      r4,#0
00089c  0a000001          BEQ      |L1.2216|
0008a0  e3540010          CMP      r4,#0x10
0008a4  da000000          BLE      |L1.2220|
                  |L1.2216|
;;;315    
;;;316        uint32_t val = read32(CCU_BASE + reg);
;;;317    
;;;318        val &= ~((0x7 << 24) | (0xF));
;;;319        val |= (source << 24) | (div - 1);
;;;320    
;;;321        write32(CCU_BASE + reg, val);
;;;322    }
0008a8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2220|
0008ac  e2850401          ADD      r0,r5,#0x1000000      ;316
0008b0  e28008c2          ADD      r0,r0,#0xc20000       ;316
0008b4  ebfffffe          BL       read32
0008b8  e1a06000          MOV      r6,r0                 ;316
0008bc  e3c6600f          BIC      r6,r6,#0xf            ;318
0008c0  e3c66407          BIC      r6,r6,#0x7000000      ;318
0008c4  e2440001          SUB      r0,r4,#1              ;319
0008c8  e1800c07          ORR      r0,r0,r7,LSL #24      ;319
0008cc  e1866000          ORR      r6,r6,r0              ;319
0008d0  e2850401          ADD      r0,r5,#0x1000000      ;321
0008d4  e28008c2          ADD      r0,r0,#0xc20000       ;321
0008d8  e1a01006          MOV      r1,r6                 ;321
0008dc  ebfffffe          BL       write32
0008e0  e1a00000          MOV      r0,r0
0008e4  eaffffef          B        |L1.2216|
;;;323    
                          ENDP

                  clk_tcon_config PROC
;;;324    // TCON clock configuration
;;;325    void clk_tcon_config(clk_source_vid_e source) {
0008e8  e92d4070          PUSH     {r4-r6,lr}
0008ec  e1a04000          MOV      r4,r0
;;;326        uint32_t val = read32(CCU_BASE + CCU_TCON_CLK) & ~(0x7 << 24);
0008f0  e59f01e8          LDR      r0,|L1.2784|
0008f4  ebfffffe          BL       read32
0008f8  e3c05407          BIC      r5,r0,#0x7000000
;;;327        write32(CCU_BASE + CCU_TCON_CLK, val | (source << 24));
0008fc  e1851c04          ORR      r1,r5,r4,LSL #24
000900  e59f01d8          LDR      r0,|L1.2784|
000904  ebfffffe          BL       write32
;;;328    }
000908  e8bd8070          POP      {r4-r6,pc}
;;;329    
                          ENDP

                  clk_tve_config PROC
;;;330    // Video encoder clock configuration
;;;331    void clk_tve_config(uint8_t div) { // TODO: source select
00090c  e92d4010          PUSH     {r4,lr}
000910  e1a04000          MOV      r4,r0
;;;332        if((div == 0) || (div > 16)) return;
000914  e3540000          CMP      r4,#0
000918  0a000001          BEQ      |L1.2340|
00091c  e3540010          CMP      r4,#0x10
000920  da000000          BLE      |L1.2344|
                  |L1.2340|
;;;333        write32(CCU_BASE + CCU_TVE_CLK, (0x80008100) | (div - 1));
;;;334    }
000924  e8bd8010          POP      {r4,pc}
                  |L1.2344|
000928  e2440001          SUB      r0,r4,#1              ;333
00092c  e3801102          ORR      r1,r0,#0x80000000     ;333
000930  e3811c81          ORR      r1,r1,#0x8100         ;333
000934  e59f01a8          LDR      r0,|L1.2788|
000938  ebfffffe          BL       write32
00093c  e1a00000          MOV      r0,r0
000940  eafffff7          B        |L1.2340|
;;;335    
                          ENDP

                  clk_tvd_config PROC
;;;336    // Video decoder clock configuration
;;;337    void clk_tvd_config(uint8_t div) { // TODO: source select
000944  e92d4010          PUSH     {r4,lr}
000948  e1a04000          MOV      r4,r0
;;;338        if((div == 0) || (div > 16)) return;
00094c  e3540000          CMP      r4,#0
000950  0a000001          BEQ      |L1.2396|
000954  e3540010          CMP      r4,#0x10
000958  da000000          BLE      |L1.2400|
                  |L1.2396|
;;;339        write32(CCU_BASE + CCU_TVD_CLK, (0x80000000) | (div - 1));
;;;340    }
00095c  e8bd8010          POP      {r4,pc}
                  |L1.2400|
000960  e2440001          SUB      r0,r4,#1              ;339
000964  e3801102          ORR      r1,r0,#0x80000000     ;339
000968  e59f0178          LDR      r0,|L1.2792|
00096c  ebfffffe          BL       write32
000970  e1a00000          MOV      r0,r0
000974  eafffff8          B        |L1.2396|
;;;341    
                          ENDP

                  clk_sdc_config PROC
;;;342    // SD card controller clock
;;;343    uint32_t clk_sdc_config(uint32_t reg, uint32_t freq) {
000978  e92d5ff0          PUSH     {r4-r12,lr}
00097c  e1a08000          MOV      r8,r0
000980  e1a06001          MOV      r6,r1
;;;344        uint32_t in_freq = 0;
000984  e3a0b000          MOV      r11,#0
;;;345        uint32_t reg_val = (1 << 31);
000988  e3a04102          MOV      r4,#0x80000000
;;;346    
;;;347        if(freq <= 24000000) {
00098c  e59f0130          LDR      r0,|L1.2756|
000990  e1560000          CMP      r6,r0
000994  8a000002          BHI      |L1.2468|
;;;348            reg_val |= (0 << 24); // OSC24M
000998  e1a00000          MOV      r0,r0
;;;349            in_freq = 24000000;
00099c  e1a0b000          MOV      r11,r0
0009a0  ea000003          B        |L1.2484|
                  |L1.2468|
;;;350        } else {
;;;351            reg_val |= (1 << 24); // PLL_PERIPH
0009a4  e3844401          ORR      r4,r4,#0x1000000
;;;352            in_freq = clk_pll_get_freq(PLL_PERIPH);
0009a8  e3a00028          MOV      r0,#0x28
0009ac  ebfffffe          BL       clk_pll_get_freq
0009b0  e1a0b000          MOV      r11,r0
                  |L1.2484|
;;;353        }
;;;354    
;;;355        uint8_t div = in_freq / freq;
0009b4  e1a01006          MOV      r1,r6
0009b8  e1a0000b          MOV      r0,r11
0009bc  ebfffffe          BL       __aeabi_uidivmod
0009c0  e20050ff          AND      r5,r0,#0xff
;;;356        if(in_freq % freq) div++;
0009c4  e1a01006          MOV      r1,r6
0009c8  e1a0000b          MOV      r0,r11
0009cc  ebfffffe          BL       __aeabi_uidivmod
0009d0  e3510000          CMP      r1,#0
0009d4  0a000001          BEQ      |L1.2528|
0009d8  e2850001          ADD      r0,r5,#1
0009dc  e20050ff          AND      r5,r0,#0xff
                  |L1.2528|
;;;357    
;;;358        uint8_t prediv = 0;
0009e0  e3a07000          MOV      r7,#0
;;;359        while(div > 16) {
0009e4  ea000009          B        |L1.2576|
                  |L1.2536|
;;;360            prediv++;
0009e8  e2870001          ADD      r0,r7,#1
0009ec  e20070ff          AND      r7,r0,#0xff
;;;361            if(prediv > 3) return 0;
0009f0  e3570003          CMP      r7,#3
0009f4  da000001          BLE      |L1.2560|
0009f8  e3a00000          MOV      r0,#0
                  |L1.2556|
;;;362            div = (div + 1) / 2;
;;;363        }
;;;364    
;;;365        /* determine delays */
;;;366        uint8_t samp_phase = 0;
;;;367        uint8_t out_phase  = 0;
;;;368        if(freq <= 400000) {
;;;369            out_phase  = 0;
;;;370            samp_phase = 0;
;;;371        } else if(freq <= 25000000) {
;;;372            out_phase  = 0;
;;;373            samp_phase = 5;
;;;374        } else if(freq <= 52000000) {
;;;375            out_phase  = 3;
;;;376            samp_phase = 4;
;;;377        } else { /* freq > 52000000 */
;;;378            out_phase  = 1;
;;;379            samp_phase = 4;
;;;380        }
;;;381        reg_val |= (samp_phase << 20) | (out_phase << 8);
;;;382        reg_val |= (prediv << 16) | ((div - 1) << 0);
;;;383    
;;;384        write32(CCU_BASE + reg, reg_val);
;;;385    
;;;386        return in_freq / div;
;;;387    }
0009fc  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.2560|
000a00  e2850001          ADD      r0,r5,#1              ;362
000a04  e0801fa0          ADD      r1,r0,r0,LSR #31      ;362
000a08  e1a01b81          LSL      r1,r1,#23             ;362
000a0c  e1a05c21          LSR      r5,r1,#24             ;362
                  |L1.2576|
000a10  e3550010          CMP      r5,#0x10              ;359
000a14  cafffff3          BGT      |L1.2536|
000a18  e3a09000          MOV      r9,#0                 ;366
000a1c  e3a0a000          MOV      r10,#0                ;367
000a20  e59f00c4          LDR      r0,|L1.2796|
000a24  e1560000          CMP      r6,r0                 ;368
000a28  8a000001          BHI      |L1.2612|
000a2c  e1a00000          MOV      r0,r0                 ;369
000a30  ea00000d          B        |L1.2668|
                  |L1.2612|
000a34  e59f00b4          LDR      r0,|L1.2800|
000a38  e1560000          CMP      r6,r0                 ;371
000a3c  8a000002          BHI      |L1.2636|
000a40  e3a0a000          MOV      r10,#0                ;372
000a44  e3a09005          MOV      r9,#5                 ;373
000a48  ea000007          B        |L1.2668|
                  |L1.2636|
000a4c  e59f00a0          LDR      r0,|L1.2804|
000a50  e1560000          CMP      r6,r0                 ;374
000a54  8a000002          BHI      |L1.2660|
000a58  e3a0a003          MOV      r10,#3                ;375
000a5c  e3a09004          MOV      r9,#4                 ;376
000a60  ea000001          B        |L1.2668|
                  |L1.2660|
000a64  e3a0a001          MOV      r10,#1                ;378
000a68  e3a09004          MOV      r9,#4                 ;379
                  |L1.2668|
000a6c  e1a00a09          LSL      r0,r9,#20             ;381
000a70  e180040a          ORR      r0,r0,r10,LSL #8      ;381
000a74  e1844000          ORR      r4,r4,r0              ;381
000a78  e2450001          SUB      r0,r5,#1              ;382
000a7c  e1800807          ORR      r0,r0,r7,LSL #16      ;382
000a80  e1844000          ORR      r4,r4,r0              ;382
000a84  e2880401          ADD      r0,r8,#0x1000000      ;384
000a88  e28008c2          ADD      r0,r0,#0xc20000       ;384
000a8c  e1a01004          MOV      r1,r4                 ;384
000a90  ebfffffe          BL       write32
000a94  e1a01005          MOV      r1,r5                 ;386
000a98  e1a0000b          MOV      r0,r11                ;386
000a9c  ebfffffe          BL       __aeabi_uidivmod
000aa0  eaffffd5          B        |L1.2556|
;;;388    
                          ENDP

                  read32 PROC
;;;19     
;;;20     static __inline uint32_t read32(uint32_t addr)
000aa4  e1a01000          MOV      r1,r0
;;;21     {
;;;22       return (*((volatile uint32_t*)(addr)));
000aa8  e5910000          LDR      r0,[r1,#0]
;;;23     }
000aac  e12fff1e          BX       lr
;;;24     
                          ENDP

                  write32 PROC
;;;39     
;;;40     static __inline void write32(uint32_t addr, uint32_t value)
000ab0  e5801000          STR      r1,[r0,#0]
;;;41     {
;;;42       *((volatile uint32_t*)(addr)) = value;
;;;43     }
000ab4  e12fff1e          BX       lr
;;;44     
                          ENDP

                  |L1.2744|
                          DCD      0x01c20028
                  |L1.2748|
                          DCD      0x01c20008
                  |L1.2752|
                          DCD      0x01c20000
                  |L1.2756|
                          DCD      0x016e3600
                  |L1.2760|
                          DCD      0x01c20020
                  |L1.2764|
                          DCD      0x11b3dc40
                  |L1.2768|
                          DCD      0x1017df80
                  |L1.2772|
                          DCD      0x02dc6c00
                  |L1.2776|
                          DCD      0x01c20050
                  |L1.2780|
                          DCD      0x01c20054
                  |L1.2784|
                          DCD      0x01c20118
                  |L1.2788|
                          DCD      0x01c20120
                  |L1.2792|
                          DCD      0x01c20124
                  |L1.2796|
                          DCD      0x00061a80
                  |L1.2800|
                          DCD      0x017d7840
                  |L1.2804|
                          DCD      0x03197500

                          AREA ||i.clk_pll_enable||, COMGROUP=clk_pll_enable, CODE, READONLY, ALIGN=2

                  clk_pll_enable PROC
;;;15     // Enable PLL
;;;16     inline void clk_pll_enable(pll_ch_e pll) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
;;;17         write32(CCU_BASE + pll, (read32(CCU_BASE + pll) | (1 << 31)));
000008  e2840401          ADD      r0,r4,#0x1000000
00000c  e28008c2          ADD      r0,r0,#0xc20000
000010  ebfffffe          BL       read32
000014  e3805102          ORR      r5,r0,#0x80000000
000018  e2840401          ADD      r0,r4,#0x1000000
00001c  e28008c2          ADD      r0,r0,#0xc20000
000020  e1a01005          MOV      r1,r5
000024  ebfffffe          BL       write32
;;;18     }
000028  e8bd8070          POP      {r4-r6,pc}
;;;19     
                          ENDP


                          AREA ||i.clk_pll_disable||, COMGROUP=clk_pll_disable, CODE, READONLY, ALIGN=2

                  clk_pll_disable PROC
;;;20     // Disable PLL
;;;21     inline void clk_pll_disable(pll_ch_e pll) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
;;;22         write32(CCU_BASE + pll, (read32(CCU_BASE + pll) & ~(1 << 31)));
000008  e2840401          ADD      r0,r4,#0x1000000
00000c  e28008c2          ADD      r0,r0,#0xc20000
000010  ebfffffe          BL       read32
000014  e3c05102          BIC      r5,r0,#0x80000000
000018  e2840401          ADD      r0,r4,#0x1000000
00001c  e28008c2          ADD      r0,r0,#0xc20000
000020  e1a01005          MOV      r1,r5
000024  ebfffffe          BL       write32
;;;23     }
000028  e8bd8070          POP      {r4-r6,pc}
;;;24     
                          ENDP


                          AREA ||i.clk_enable||, COMGROUP=clk_enable, CODE, READONLY, ALIGN=2

                  clk_enable PROC
;;;213    
;;;214    inline void clk_enable(uint32_t reg, uint8_t bit) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;215        set32(CCU_BASE + reg, (1 << bit));
00000c  e2840401          ADD      r0,r4,#0x1000000
000010  e28008c2          ADD      r0,r0,#0xc20000
000014  ebfffffe          BL       read32
000018  e3a01001          MOV      r1,#1
00001c  e1806511          ORR      r6,r0,r1,LSL r5
000020  e2840401          ADD      r0,r4,#0x1000000
000024  e28008c2          ADD      r0,r0,#0xc20000
000028  e1a01006          MOV      r1,r6
00002c  ebfffffe          BL       write32
;;;216    }
000030  e8bd8070          POP      {r4-r6,pc}
;;;217    
                          ENDP


                          AREA ||i.clk_disable||, COMGROUP=clk_disable, CODE, READONLY, ALIGN=2

                  clk_disable PROC
;;;217    
;;;218    inline void clk_disable(uint32_t reg, uint8_t bit) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;219        clear32(CCU_BASE + reg, (1 << bit));
00000c  e2840401          ADD      r0,r4,#0x1000000
000010  e28008c2          ADD      r0,r0,#0xc20000
000014  ebfffffe          BL       read32
000018  e3a01001          MOV      r1,#1
00001c  e1c06511          BIC      r6,r0,r1,LSL r5
000020  e2840401          ADD      r0,r4,#0x1000000
000024  e28008c2          ADD      r0,r0,#0xc20000
000028  e1a01006          MOV      r1,r6
00002c  ebfffffe          BL       write32
;;;220    }
000030  e8bd8070          POP      {r4-r6,pc}
;;;221    
                          ENDP


                          AREA ||i.clk_reset_set||, COMGROUP=clk_reset_set, CODE, READONLY, ALIGN=2

                  clk_reset_set PROC
;;;390    
;;;391    inline void clk_reset_set(uint32_t reg, uint8_t bit) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;392        clear32(CCU_BASE + reg, (1 << bit));
00000c  e2840401          ADD      r0,r4,#0x1000000
000010  e28008c2          ADD      r0,r0,#0xc20000
000014  ebfffffe          BL       read32
000018  e3a01001          MOV      r1,#1
00001c  e1c06511          BIC      r6,r0,r1,LSL r5
000020  e2840401          ADD      r0,r4,#0x1000000
000024  e28008c2          ADD      r0,r0,#0xc20000
000028  e1a01006          MOV      r1,r6
00002c  ebfffffe          BL       write32
;;;393    }
000030  e8bd8070          POP      {r4-r6,pc}
;;;394    
                          ENDP


                          AREA ||i.clk_reset_clear||, COMGROUP=clk_reset_clear, CODE, READONLY, ALIGN=2

                  clk_reset_clear PROC
;;;394    
;;;395    inline void clk_reset_clear(uint32_t reg, uint8_t bit) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;396        set32(CCU_BASE + reg, (1 << bit));
00000c  e2840401          ADD      r0,r4,#0x1000000
000010  e28008c2          ADD      r0,r0,#0xc20000
000014  ebfffffe          BL       read32
000018  e3a01001          MOV      r1,#1
00001c  e1806511          ORR      r6,r0,r1,LSL r5
000020  e2840401          ADD      r0,r4,#0x1000000
000024  e28008c2          ADD      r0,r0,#0xc20000
000028  e1a01006          MOV      r1,r6
00002c  ebfffffe          BL       write32
;;;397    }
000030  e8bd8070          POP      {r4-r6,pc}
                          ENDP

