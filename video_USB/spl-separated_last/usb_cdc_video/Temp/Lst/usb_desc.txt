; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave --gnu -o.\temp\obj\usb_desc.o --asm_dir=.\Temp\Lst\ --list_dir=.\Temp\Lst\ --depend=.\temp\obj\usb_desc.d --cpu=ARM9E --apcs=interwork -O0 -Otime --diag_suppress=9931 -I.\users\include -I.\..\machine\include -I.\..\periph\include -I.\..\include -I.\..\emwin\Include -I.\..\tinyusb\src -I.\..\tinyusb\hw -I.\..\display -I.\..\lib\display_gfx -I.\..\lib\printf -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Atmel\SAM9260 -D__RTX -D__UVISION_VERSION=536 -DPCB_TINY200V1 -DCFG_TUSB_MCU=OPT_MCU_F1C100S -DCFG_TUSB_OS=OPT_OS_RTX4 --omf_browse=.\temp\obj\usb_desc.crf users\usb_desc.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  tud_descriptor_device_cb PROC
;;;73     // Application return pointer to descriptor
;;;74     uint8_t const * tud_descriptor_device_cb(void)
000000  e59f00c0          LDR      r0,|L1.200|
;;;75     {
;;;76       return (uint8_t const *) &desc_device;
;;;77     }
000004  e12fff1e          BX       lr
;;;78     
                          ENDP

                  tud_descriptor_configuration_cb PROC
;;;111    // Descriptor contents must exist long enough for transfer to complete
;;;112    uint8_t const * tud_descriptor_configuration_cb(uint8_t index)
000008  e1a01000          MOV      r1,r0
;;;113    {
;;;114      (void) index; // for multiple configurations
;;;115    
;;;116      return desc_fs_configuration;
00000c  e59f00b8          LDR      r0,|L1.204|
;;;117    }
000010  e12fff1e          BX       lr
;;;118    //--------------------------------------------------------------------+
                          ENDP

                  tud_descriptor_string_cb PROC
;;;124    // Application return pointer to descriptor, whose contents must exist long enough for transfer to complete
;;;125    uint16_t const* tud_descriptor_string_cb(uint8_t index, uint16_t langid)
000014  e92d41f0          PUSH     {r4-r8,lr}
;;;126    {
000018  e1a05000          MOV      r5,r0
00001c  e1a07001          MOV      r7,r1
;;;127      (void) langid;
;;;128    
;;;129      uint8_t chr_count;
;;;130    
;;;131      if ( index == 0)
000020  e3550000          CMP      r5,#0
000024  1a000008          BNE      |L1.76|
;;;132      {
;;;133        memcpy(&_desc_str[1], string_desc_arr[0], 2);
000028  e59f00a0          LDR      r0,|L1.208|
00002c  e5900000          LDR      r0,[r0,#0]  ; string_desc_arr
000030  e59f109c          LDR      r1,|L1.212|
000034  e5d02000          LDRB     r2,[r0,#0]
000038  e5c12002          STRB     r2,[r1,#2]  ; _desc_str
00003c  e5d00001          LDRB     r0,[r0,#1]
000040  e5c10003          STRB     r0,[r1,#3]  ; _desc_str
;;;134        chr_count = 1;
000044  e3a04001          MOV      r4,#1
000048  ea000017          B        |L1.172|
                  |L1.76|
;;;135      }else
;;;136      {
;;;137        // Note: the 0xEE index string is a Microsoft OS 1.0 Descriptors.
;;;138        // https://docs.microsoft.com/en-us/windows-hardware/drivers/usbcon/microsoft-defined-usb-descriptors
;;;139    
;;;140        if ( !(index < sizeof(string_desc_arr)/sizeof(string_desc_arr[0])) ) return NULL;
00004c  e3550005          CMP      r5,#5
000050  3a000001          BCC      |L1.92|
000054  e3a00000          MOV      r0,#0
                  |L1.88|
;;;141    
;;;142        const char* str = string_desc_arr[index];
;;;143    
;;;144        // Cap at max char
;;;145        chr_count = (uint8_t) strlen(str);
;;;146        if ( chr_count > 31 ) chr_count = 31;
;;;147    
;;;148        // Convert ASCII string into UTF-16
;;;149        for(uint8_t i=0; i<chr_count; i++)
;;;150        {
;;;151          _desc_str[1+i] = str[i];
;;;152        }
;;;153      }
;;;154    
;;;155      // first byte is length (including header), second byte is string type
;;;156      _desc_str[0] = (uint16_t) ((TUSB_DESC_STRING << 8 ) | (2*chr_count + 2));
;;;157    
;;;158      return _desc_str;
;;;159    }
000058  e8bd81f0          POP      {r4-r8,pc}
                  |L1.92|
00005c  e59f006c          LDR      r0,|L1.208|
000060  e7906105          LDR      r6,[r0,r5,LSL #2]     ;142
000064  e1a00006          MOV      r0,r6                 ;145
000068  ebfffffe          BL       strlen
00006c  e20040ff          AND      r4,r0,#0xff           ;145
000070  e354001f          CMP      r4,#0x1f              ;146
000074  da000000          BLE      |L1.124|
000078  e3a0401f          MOV      r4,#0x1f              ;146
                  |L1.124|
00007c  e3a00000          MOV      r0,#0                 ;149
000080  ea000006          B        |L1.160|
                  |L1.132|
000084  e7d61000          LDRB     r1,[r6,r0]            ;151
000088  e2802001          ADD      r2,r0,#1              ;151
00008c  e59f3040          LDR      r3,|L1.212|
000090  e0832082          ADD      r2,r3,r2,LSL #1       ;151
000094  e1c210b0          STRH     r1,[r2,#0]            ;151
000098  e2801001          ADD      r1,r0,#1              ;149
00009c  e20100ff          AND      r0,r1,#0xff           ;149
                  |L1.160|
0000a0  e1500004          CMP      r0,r4                 ;149
0000a4  bafffff6          BLT      |L1.132|
0000a8  e1a00000          MOV      r0,r0                 ;153
                  |L1.172|
0000ac  e1a00084          LSL      r0,r4,#1              ;156
0000b0  e2800002          ADD      r0,r0,#2              ;156
0000b4  e3800c03          ORR      r0,r0,#0x300          ;156
0000b8  e59f1014          LDR      r1,|L1.212|
0000bc  e1c100b0          STRH     r0,[r1,#0]            ;156  ; _desc_str
0000c0  e2810000          ADD      r0,r1,#0              ;158
0000c4  eaffffe3          B        |L1.88|
;;;160    
                          ENDP

                  |L1.200|
                          DCD      desc_device
                  |L1.204|
                          DCD      desc_fs_configuration
                  |L1.208|
                          DCD      string_desc_arr
                  |L1.212|
                          DCD      _desc_str

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  _desc_str
                          %        64

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ||<Data1>||
000000  0904              DCB      0x09,0x04
                  desc_device
000002  1201              DCB      0x12,0x01
000004  0200              DCWU     0x0200
000006  ef02              DCB      0xef,0x02
000008  0140              DCB      0x01,0x40
00000a  cafe              DCWU     0xcafe
00000c  40000100          DCWU     0x4000,0x0100
000010  01020301          DCB      0x01,0x02,0x03,0x01
                  desc_fs_configuration
000014  0902b000          DCB      0x09,0x02,0xb0,0x00
000018  02010080          DCB      0x02,0x01,0x00,0x80
00001c  fa080b00          DCB      0xfa,0x08,0x0b,0x00
000020  020e0300          DCB      0x02,0x0e,0x03,0x00
000024  04090400          DCB      0x04,0x09,0x04,0x00
000028  00000e01          DCB      0x00,0x00,0x0e,0x01
00002c  01040d24          DCB      0x01,0x04,0x0d,0x24
000030  01500128          DCB      0x01,0x50,0x01,0x28
000034  00c0fc9b          DCB      0x00,0xc0,0xfc,0x9b
000038  01010112          DCB      0x01,0x01,0x01,0x12
00003c  24020101          DCB      0x24,0x02,0x01,0x01
000040  02000000          DCB      0x02,0x00,0x00,0x00
000044  00000000          DCB      0x00,0x00,0x00,0x00
000048  00030000          DCB      0x00,0x03,0x00,0x00
00004c  00092403          DCB      0x00,0x09,0x24,0x03
000050  02010100          DCB      0x02,0x01,0x01,0x00
000054  01000904          DCB      0x01,0x00,0x09,0x04
000058  0100000e          DCB      0x01,0x00,0x00,0x0e
00005c  0201040e          DCB      0x02,0x01,0x04,0x0e
000060  24010155          DCB      0x24,0x01,0x01,0x55
000064  00810002          DCB      0x00,0x81,0x00,0x02
000068  00000001          DCB      0x00,0x00,0x00,0x01
00006c  001b2404          DCB      0x00,0x1b,0x24,0x04
000070  01015955          DCB      0x01,0x01,0x59,0x55
000074  59320000          DCB      0x59,0x32,0x00,0x00
000078  10008000          DCB      0x10,0x00,0x80,0x00
00007c  00aa0038          DCB      0x00,0xaa,0x00,0x38
000080  9b711001          DCB      0x9b,0x71,0x10,0x01
000084  00000000          DCB      0x00,0x00,0x00,0x00
000088  26240501          DCB      0x26,0x24,0x05,0x01
00008c  004001f0          DCB      0x00,0x40,0x01,0xf0
000090  0000c012          DCB      0x00,0x00,0xc0,0x12
000094  00000077          DCB      0x00,0x00,0x00,0x77
000098  0100c012          DCB      0x01,0x00,0xc0,0x12
00009c  0020a107          DCB      0x00,0x20,0xa1,0x07
0000a0  000020a1          DCB      0x00,0x00,0x20,0xa1
0000a4  07008096          DCB      0x07,0x00,0x80,0x96
0000a8  980020a1          DCB      0x98,0x00,0x20,0xa1
0000ac  07000624          DCB      0x07,0x00,0x06,0x24
0000b0  0d010104          DCB      0x0d,0x01,0x01,0x04
0000b4  09040101          DCB      0x09,0x04,0x01,0x01
0000b8  010e0201          DCB      0x01,0x0e,0x02,0x01
0000bc  04070581          DCB      0x04,0x07,0x05,0x81
0000c0  05000101          DCB      0x05,0x00,0x01,0x01

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  54696e79          DCB      "TinyUSB",0
000004  55534200
000008  54696e79          DCB      "TinyUSB Device",0
00000c  55534220
000010  44657669
000014  636500  
000017  00                DCB      0
000018  31323334          DCB      "123456",0
00001c  353600  
00001f  00                DCB      0
000020  54696e79          DCB      "TinyUSB UVC",0
000024  55534220
000028  55564300

                          AREA ||.data||, DATA, ALIGN=2

                  string_desc_arr
                          DCD      ||<Data1>||
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x8
                          DCD      ||.conststring||+0x18
                          DCD      ||.conststring||+0x20
