; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave --gnu -o.\temp\obj\tusb_fifo.o --asm_dir=.\Temp\Lst\ --list_dir=.\Temp\Lst\ --depend=.\temp\obj\tusb_fifo.d --cpu=ARM9E --apcs=interwork -O0 -Otime --diag_suppress=9931 -I.\users\include -I.\..\machine\include -I.\..\periph\include -I.\..\include -I.\..\emwin\Include -I.\..\tinyusb\src -I.\..\tinyusb\hw -I.\..\display -I.\..\lib\display_gfx -I.\..\lib\printf -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Atmel\SAM9260 -D__RTX -D__UVISION_VERSION=536 -DPCB_TINY200V1 -DCFG_TUSB_MCU=OPT_MCU_F1C100S -DCFG_TUSB_OS=OPT_OS_RTX4 --omf_browse=.\temp\obj\tusb_fifo.crf ..\tinyusb\src\common\tusb_fifo.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  tu_fifo_config PROC
;;;67     
;;;68     bool tu_fifo_config(tu_fifo_t *f, void* buffer, uint16_t depth, uint16_t item_size, bool overwritable)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;69     {
000004  e1a04000          MOV      r4,r0
000008  e1a08001          MOV      r8,r1
00000c  e1a05002          MOV      r5,r2
000010  e1a09003          MOV      r9,r3
;;;70       // Limit index space to 2*depth - this allows for a fast "modulo" calculation
;;;71       // but limits the maximum depth to 2^16/2 = 2^15 and buffer overflows are detectable
;;;72       // only if overflow happens once (important for unsupervised DMA applications)
;;;73       if (depth > 0x8000) return false;
000014  e3550902          CMP      r5,#0x8000
000018  da000001          BLE      |L1.36|
00001c  e3a00000          MOV      r0,#0
                  |L1.32|
;;;74     
;;;75       _ff_lock(f->mutex_wr);
;;;76       _ff_lock(f->mutex_rd);
;;;77     
;;;78       f->buffer       = (uint8_t*) buffer;
;;;79       f->depth        = depth;
;;;80       f->item_size    = (uint16_t) (item_size & 0x7FFF);
;;;81       f->overwritable = overwritable;
;;;82       f->rd_idx       = 0;
;;;83       f->wr_idx       = 0;
;;;84     
;;;85       _ff_unlock(f->mutex_wr);
;;;86       _ff_unlock(f->mutex_rd);
;;;87     
;;;88       return true;
;;;89     }
000020  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.36|
000024  e594600c          LDR      r6,[r4,#0xc]          ;75
000028  e3560000          CMP      r6,#0                 ;75
00002c  0a000011          BEQ      |L1.120|
000030  e1a0a006          MOV      r10,r6                ;75
000034  e3e07000          MVN      r7,#0                 ;75
000038  e1a00007          MOV      r0,r7                 ;75
00003c  e3700001          CMN      r0,#1                 ;75
000040  1a000001          BNE      |L1.76|
000044  e1a01827          LSR      r1,r7,#16             ;75
000048  ea000005          B        |L1.100|
                  |L1.76|
00004c  e59f1e58          LDR      r1,|L1.3756|
000050  e1500001          CMP      r0,r1                 ;75
000054  3a000000          BCC      |L1.92|
000058  ea000001          B        |L1.100|
                  |L1.92|
00005c  e1a01800          LSL      r1,r0,#16             ;75
000060  e1a01821          LSR      r1,r1,#16             ;75
                  |L1.100|
000064  e1a00000          MOV      r0,r0                 ;75
000068  e1a0b001          MOV      r11,r1                ;75
00006c  e1a0000a          MOV      r0,r10                ;75
000070  ebfffffe          BL       os_mut_wait
000074  e1a00000          MOV      r0,r0                 ;75
                  |L1.120|
000078  e1a00000          MOV      r0,r0                 ;75
00007c  e1a00000          MOV      r0,r0                 ;75
000080  e5946010          LDR      r6,[r4,#0x10]         ;76
000084  e3560000          CMP      r6,#0                 ;76
000088  0a000011          BEQ      |L1.212|
00008c  e1a0a006          MOV      r10,r6                ;76
000090  e3e07000          MVN      r7,#0                 ;76
000094  e1a00007          MOV      r0,r7                 ;76
000098  e3700001          CMN      r0,#1                 ;76
00009c  1a000001          BNE      |L1.168|
0000a0  e1a01827          LSR      r1,r7,#16             ;76
0000a4  ea000005          B        |L1.192|
                  |L1.168|
0000a8  e59f1dfc          LDR      r1,|L1.3756|
0000ac  e1500001          CMP      r0,r1                 ;76
0000b0  3a000000          BCC      |L1.184|
0000b4  ea000001          B        |L1.192|
                  |L1.184|
0000b8  e1a01800          LSL      r1,r0,#16             ;76
0000bc  e1a01821          LSR      r1,r1,#16             ;76
                  |L1.192|
0000c0  e1a00000          MOV      r0,r0                 ;76
0000c4  e1a0b001          MOV      r11,r1                ;76
0000c8  e1a0000a          MOV      r0,r10                ;76
0000cc  ebfffffe          BL       os_mut_wait
0000d0  e1a00000          MOV      r0,r0                 ;76
                  |L1.212|
0000d4  e1a00000          MOV      r0,r0                 ;76
0000d8  e1a00000          MOV      r0,r0                 ;76
0000dc  e5848000          STR      r8,[r4,#0]            ;78
0000e0  e1c450b4          STRH     r5,[r4,#4]            ;79
0000e4  e1d400b6          LDRH     r0,[r4,#6]            ;80
0000e8  e2000902          AND      r0,r0,#0x8000         ;80
0000ec  e1a01889          LSL      r1,r9,#17             ;80
0000f0  e1a018a1          LSR      r1,r1,#17             ;80
0000f4  e1800001          ORR      r0,r0,r1              ;80
0000f8  e1c400b6          STRH     r0,[r4,#6]            ;80
0000fc  e5d40007          LDRB     r0,[r4,#7]            ;81
000100  e3c01080          BIC      r1,r0,#0x80           ;81
000104  e3a02080          MOV      r2,#0x80              ;81
000108  e59d0028          LDR      r0,[sp,#0x28]         ;81
00010c  e0020380          AND      r0,r2,r0,LSL #7       ;81
000110  e1800001          ORR      r0,r0,r1              ;81
000114  e5c40007          STRB     r0,[r4,#7]            ;81
000118  e3a00000          MOV      r0,#0                 ;82
00011c  e1c400ba          STRH     r0,[r4,#0xa]          ;82
000120  e1c400b8          STRH     r0,[r4,#8]            ;83
000124  e594600c          LDR      r6,[r4,#0xc]          ;85
000128  e3560000          CMP      r6,#0                 ;85
00012c  0a000003          BEQ      |L1.320|
000130  e1a07006          MOV      r7,r6                 ;85
000134  e1a00007          MOV      r0,r7                 ;85
000138  ebfffffe          BL       os_mut_release
00013c  e1a00000          MOV      r0,r0                 ;85
                  |L1.320|
000140  e1a00000          MOV      r0,r0                 ;85
000144  e1a00000          MOV      r0,r0                 ;85
000148  e5946010          LDR      r6,[r4,#0x10]         ;86
00014c  e3560000          CMP      r6,#0                 ;86
000150  0a000003          BEQ      |L1.356|
000154  e1a07006          MOV      r7,r6                 ;86
000158  e1a00007          MOV      r0,r7                 ;86
00015c  ebfffffe          BL       os_mut_release
000160  e1a00000          MOV      r0,r0                 ;86
                  |L1.356|
000164  e1a00000          MOV      r0,r0                 ;86
000168  e1a00000          MOV      r0,r0                 ;86
00016c  e3a00001          MOV      r0,#1                 ;88
000170  eaffffaa          B        |L1.32|
;;;90     
                          ENDP

                  _ff_push_const_addr PROC
;;;97     // TODO generalize with configurable 1 byte or 4 byte each read
;;;98     static void _ff_push_const_addr(uint8_t * ff_buf, const void * app_buf, uint16_t len)
000174  e92d5ffc          PUSH     {r2-r12,lr}
;;;99     {
000178  e1a04000          MOV      r4,r0
00017c  e1a07001          MOV      r7,r1
000180  e1a05002          MOV      r5,r2
;;;100      volatile const uint32_t * reg_rx = (volatile const uint32_t *) app_buf;
000184  e1a08007          MOV      r8,r7
;;;101    
;;;102      // Reading full available 32 bit words from const app address
;;;103      uint16_t full_words = len >> 2;
000188  e1a00145          ASR      r0,r5,#2
00018c  e58d0004          STR      r0,[sp,#4]
;;;104      while(full_words--)
000190  ea000007          B        |L1.436|
                  |L1.404|
;;;105      {
;;;106        tu_unaligned_write32(ff_buf, *reg_rx);
000194  e1a09004          MOV      r9,r4
000198  e598a000          LDR      r10,[r8,#0]
00019c  e1a0b009          MOV      r11,r9
0001a0  e1a0100b          MOV      r1,r11
0001a4  e1a0000a          MOV      r0,r10
0001a8  ebfffffe          BL       __aeabi_uwrite4
0001ac  e1a00000          MOV      r0,r0
;;;107        ff_buf += 4;
0001b0  e2844004          ADD      r4,r4,#4
                  |L1.436|
0001b4  e59d0004          LDR      r0,[sp,#4]            ;104
0001b8  e2401001          SUB      r1,r0,#1              ;104
0001bc  e1a01801          LSL      r1,r1,#16             ;104
0001c0  e1a01821          LSR      r1,r1,#16             ;104
0001c4  e3500000          CMP      r0,#0                 ;104
0001c8  e58d1004          STR      r1,[sp,#4]            ;104
0001cc  1afffff0          BNE      |L1.404|
;;;108      }
;;;109    
;;;110      // Read the remaining 1-3 bytes from const app address
;;;111      uint8_t const bytes_rem = len & 0x03;
0001d0  e2056003          AND      r6,r5,#3
;;;112      if ( bytes_rem )
0001d4  e3560000          CMP      r6,#0
0001d8  0a000006          BEQ      |L1.504|
;;;113      {
;;;114        uint32_t tmp32 = *reg_rx;
0001dc  e5980000          LDR      r0,[r8,#0]
0001e0  e58d0000          STR      r0,[sp,#0]
;;;115        memcpy(ff_buf, &tmp32, bytes_rem);
0001e4  e1a02006          MOV      r2,r6
0001e8  e1a0100d          MOV      r1,sp
0001ec  e1a00004          MOV      r0,r4
0001f0  ebfffffe          BL       __aeabi_memcpy
;;;116      }
0001f4  e1a00000          MOV      r0,r0
                  |L1.504|
;;;117    }
0001f8  e8bd9ffc          POP      {r2-r12,pc}
;;;118    
                          ENDP

                  _ff_pull_const_addr PROC
;;;120    // where all data is written to a constant address in full word copies
;;;121    static void _ff_pull_const_addr(void * app_buf, const uint8_t * ff_buf, uint16_t len)
0001fc  e92d4ff8          PUSH     {r3-r11,lr}
;;;122    {
000200  e1a07000          MOV      r7,r0
000204  e1a04001          MOV      r4,r1
000208  e1a05002          MOV      r5,r2
;;;123      volatile uint32_t * reg_tx = (volatile uint32_t *) app_buf;
00020c  e1a08007          MOV      r8,r7
;;;124    
;;;125      // Write full available 32 bit words to const address
;;;126      uint16_t full_words = len >> 2;
000210  e1a0a145          ASR      r10,r5,#2
;;;127      while(full_words--)
000214  ea000005          B        |L1.560|
                  |L1.536|
;;;128      {
;;;129        *reg_tx = tu_unaligned_read32(ff_buf);
000218  e1a09004          MOV      r9,r4
00021c  e1a0b009          MOV      r11,r9
000220  e1a0000b          MOV      r0,r11
000224  ebfffffe          BL       __aeabi_uread4
000228  e5880000          STR      r0,[r8,#0]
;;;130        ff_buf += 4;
00022c  e2844004          ADD      r4,r4,#4
                  |L1.560|
000230  e25a0000          SUBS     r0,r10,#0             ;127
000234  e24a1001          SUB      r1,r10,#1             ;127
000238  e1a0a801          LSL      r10,r1,#16            ;127
00023c  e1a0a82a          LSR      r10,r10,#16           ;127
000240  1afffff4          BNE      |L1.536|
;;;131      }
;;;132    
;;;133      // Write the remaining 1-3 bytes into const address
;;;134      uint8_t const bytes_rem = len & 0x03;
000244  e2056003          AND      r6,r5,#3
;;;135      if ( bytes_rem )
000248  e3560000          CMP      r6,#0
00024c  0a000008          BEQ      |L1.628|
;;;136      {
;;;137        uint32_t tmp32 = 0;
000250  e3a00000          MOV      r0,#0
000254  e58d0000          STR      r0,[sp,#0]
;;;138        memcpy(&tmp32, ff_buf, bytes_rem);
000258  e1a02006          MOV      r2,r6
00025c  e1a01004          MOV      r1,r4
000260  e1a0000d          MOV      r0,sp
000264  ebfffffe          BL       __aeabi_memcpy
;;;139    
;;;140        *reg_tx = tmp32;
000268  e59d0000          LDR      r0,[sp,#0]
00026c  e5880000          STR      r0,[r8,#0]
;;;141      }
000270  e1a00000          MOV      r0,r0
                  |L1.628|
;;;142    }
000274  e8bd8ff8          POP      {r3-r11,pc}
;;;143    
                          ENDP

                  _ff_push_n PROC
;;;150    // send n items to fifo WITHOUT updating write pointer
;;;151    static void _ff_push_n(tu_fifo_t* f, void const * app_buf, uint16_t n, uint16_t wr_ptr, tu_fifo_copy_mode_t copy_mode)
000278  e92d5fff          PUSH     {r0-r12,lr}
;;;152    {
00027c  e1a04000          MOV      r4,r0
000280  e1a0a001          MOV      r10,r1
000284  e1a05002          MOV      r5,r2
000288  e1a0b003          MOV      r11,r3
;;;153      uint16_t const lin_count = f->depth - wr_ptr;
00028c  e1d400b4          LDRH     r0,[r4,#4]
000290  e040000b          SUB      r0,r0,r11
000294  e1a08800          LSL      r8,r0,#16
000298  e1a08828          LSR      r8,r8,#16
;;;154      uint16_t const wrap_count = n - lin_count;
00029c  e0450008          SUB      r0,r5,r8
0002a0  e1a00800          LSL      r0,r0,#16
0002a4  e1a00820          LSR      r0,r0,#16
0002a8  e58d000c          STR      r0,[sp,#0xc]
;;;155    
;;;156      uint16_t lin_bytes = lin_count * f->item_size;
0002ac  e1d400b6          LDRH     r0,[r4,#6]
0002b0  e3c00902          BIC      r0,r0,#0x8000
0002b4  e0000098          MUL      r0,r8,r0
0002b8  e1a09800          LSL      r9,r0,#16
0002bc  e1a09829          LSR      r9,r9,#16
;;;157      uint16_t wrap_bytes = wrap_count * f->item_size;
0002c0  e1d400b6          LDRH     r0,[r4,#6]
0002c4  e3c01902          BIC      r1,r0,#0x8000
0002c8  e59d000c          LDR      r0,[sp,#0xc]
0002cc  e0000091          MUL      r0,r1,r0
0002d0  e1a07800          LSL      r7,r0,#16
0002d4  e1a07827          LSR      r7,r7,#16
;;;158    
;;;159      // current buffer of fifo
;;;160      uint8_t* ff_buf = f->buffer + (wr_ptr * f->item_size);
0002d8  e5940000          LDR      r0,[r4,#0]
0002dc  e1d410b6          LDRH     r1,[r4,#6]
0002e0  e3c11902          BIC      r1,r1,#0x8000
0002e4  e026019b          MLA      r6,r11,r1,r0
;;;161    
;;;162      switch (copy_mode)
0002e8  e59d0038          LDR      r0,[sp,#0x38]
0002ec  e3500000          CMP      r0,#0
0002f0  0a000002          BEQ      |L1.768|
0002f4  e3500001          CMP      r0,#1
0002f8  1a00005b          BNE      |L1.1132|
0002fc  ea000012          B        |L1.844|
                  |L1.768|
;;;163      {
;;;164        case TU_FIFO_COPY_INC:
000300  e1a00000          MOV      r0,r0
;;;165          if(n <= lin_count)
000304  e1550008          CMP      r5,r8
000308  ca000006          BGT      |L1.808|
;;;166          {
;;;167            // Linear only
;;;168            memcpy(ff_buf, app_buf, n*f->item_size);
00030c  e1d400b6          LDRH     r0,[r4,#6]
000310  e3c00902          BIC      r0,r0,#0x8000
000314  e0020590          MUL      r2,r0,r5
000318  e1a0100a          MOV      r1,r10
00031c  e1a00006          MOV      r0,r6
000320  ebfffffe          BL       __aeabi_memcpy
000324  ea000007          B        |L1.840|
                  |L1.808|
;;;169          }
;;;170          else
;;;171          {
;;;172            // Wrap around
;;;173    
;;;174            // Write data to linear part of buffer
;;;175            memcpy(ff_buf, app_buf, lin_bytes);
000328  e1a02009          MOV      r2,r9
00032c  e1a0100a          MOV      r1,r10
000330  e1a00006          MOV      r0,r6
000334  ebfffffe          BL       __aeabi_memcpy
;;;176    
;;;177            // Write data wrapped around
;;;178            // TU_ASSERT(nWrap_bytes <= f->depth, );
;;;179            memcpy(f->buffer, ((uint8_t const*) app_buf) + lin_bytes, wrap_bytes);
000338  e08a1009          ADD      r1,r10,r9
00033c  e1a02007          MOV      r2,r7
000340  e5940000          LDR      r0,[r4,#0]
000344  ebfffffe          BL       __aeabi_memcpy
                  |L1.840|
;;;180          }
;;;181          break;
000348  ea000047          B        |L1.1132|
                  |L1.844|
;;;182    
;;;183        case TU_FIFO_COPY_CST_FULL_WORDS:
00034c  e1a00000          MOV      r0,r0
;;;184          // Intended for hardware buffers from which it can be read word by word only
;;;185          if(n <= lin_count)
000350  e1550008          CMP      r5,r8
000354  ca000008          BGT      |L1.892|
;;;186          {
;;;187            // Linear only
;;;188            _ff_push_const_addr(ff_buf, app_buf, n*f->item_size);
000358  e1d400b6          LDRH     r0,[r4,#6]
00035c  e3c00902          BIC      r0,r0,#0x8000
000360  e0000095          MUL      r0,r5,r0
000364  e1a02800          LSL      r2,r0,#16
000368  e1a02822          LSR      r2,r2,#16
00036c  e1a0100a          MOV      r1,r10
000370  e1a00006          MOV      r0,r6
000374  ebfffffe          BL       _ff_push_const_addr
000378  ea00003a          B        |L1.1128|
                  |L1.892|
;;;189          }
;;;190          else
;;;191          {
;;;192            // Wrap around case
;;;193    
;;;194            // Write full words to linear part of buffer
;;;195            uint16_t nLin_4n_bytes = lin_bytes & 0xFFFC;
00037c  e59f0b2c          LDR      r0,|L1.3760|
000380  e0000009          AND      r0,r0,r9
000384  e58d0008          STR      r0,[sp,#8]
;;;196            _ff_push_const_addr(ff_buf, app_buf, nLin_4n_bytes);
000388  e1a0100a          MOV      r1,r10
00038c  e1a00006          MOV      r0,r6
000390  e59d2008          LDR      r2,[sp,#8]
000394  ebfffffe          BL       _ff_push_const_addr
;;;197            ff_buf += nLin_4n_bytes;
000398  e59d0008          LDR      r0,[sp,#8]
00039c  e0866000          ADD      r6,r6,r0
;;;198    
;;;199            // There could be odd 1-3 bytes before the wrap-around boundary
;;;200            uint8_t rem = lin_bytes & 0x03;
0003a0  e2090003          AND      r0,r9,#3
0003a4  e58d0004          STR      r0,[sp,#4]
;;;201            if (rem > 0)
0003a8  e59d0004          LDR      r0,[sp,#4]
0003ac  e3500000          CMP      r0,#0
0003b0  da000024          BLE      |L1.1096|
;;;202            {
;;;203              volatile const uint32_t * rx_fifo = (volatile const uint32_t *) app_buf;
0003b4  e1a0c00a          MOV      r12,r10
;;;204    
;;;205              uint8_t remrem = (uint8_t) tu_min16(wrap_bytes, 4-rem);
0003b8  e1a02007          MOV      r2,r7
0003bc  e59de004          LDR      lr,[sp,#4]
0003c0  e26ee004          RSB      lr,lr,#4
0003c4  e1a0380e          LSL      r3,lr,#16
0003c8  e1a03823          LSR      r3,r3,#16
0003cc  e1520003          CMP      r2,r3
0003d0  aa000001          BGE      |L1.988|
0003d4  e1a0e002          MOV      lr,r2
0003d8  ea000000          B        |L1.992|
                  |L1.988|
0003dc  e1a0e003          MOV      lr,r3
                  |L1.992|
0003e0  e1a00000          MOV      r0,r0
0003e4  e20e10ff          AND      r1,lr,#0xff
;;;206              wrap_bytes -= remrem;
0003e8  e0472001          SUB      r2,r7,r1
0003ec  e1a07802          LSL      r7,r2,#16
0003f0  e1a07827          LSR      r7,r7,#16
;;;207    
;;;208              uint32_t tmp32 = *rx_fifo;
0003f4  e59c2000          LDR      r2,[r12,#0]
0003f8  e58d2000          STR      r2,[sp,#0]
;;;209              uint8_t * src_u8 = ((uint8_t *) &tmp32);
0003fc  e1a0000d          MOV      r0,sp
;;;210    
;;;211              // Write 1-3 bytes before wrapped boundary
;;;212              while(rem--) *ff_buf++ = *src_u8++;
000400  ea000001          B        |L1.1036|
                  |L1.1028|
000404  e4d02001          LDRB     r2,[r0],#1
000408  e4c62001          STRB     r2,[r6],#1
                  |L1.1036|
00040c  e59d2004          LDR      r2,[sp,#4]
000410  e2423001          SUB      r3,r2,#1
000414  e20330ff          AND      r3,r3,#0xff
000418  e3520000          CMP      r2,#0
00041c  e58d3004          STR      r3,[sp,#4]
000420  1afffff7          BNE      |L1.1028|
;;;213    
;;;214              // Read more bytes to beginning to complete a word
;;;215              ff_buf = f->buffer;
000424  e5946000          LDR      r6,[r4,#0]
;;;216              while(remrem--) *ff_buf++ = *src_u8++;
000428  ea000001          B        |L1.1076|
                  |L1.1068|
00042c  e4d02001          LDRB     r2,[r0],#1
000430  e4c62001          STRB     r2,[r6],#1
                  |L1.1076|
000434  e2512000          SUBS     r2,r1,#0
000438  e2413001          SUB      r3,r1,#1
00043c  e20310ff          AND      r1,r3,#0xff
000440  1afffff9          BNE      |L1.1068|
;;;217            }
000444  ea000000          B        |L1.1100|
                  |L1.1096|
;;;218            else
;;;219            {
;;;220              ff_buf = f->buffer; // wrap around to beginning
000448  e5946000          LDR      r6,[r4,#0]
                  |L1.1100|
;;;221            }
;;;222    
;;;223            // Write data wrapped part
;;;224            if (wrap_bytes > 0) _ff_push_const_addr(ff_buf, app_buf, wrap_bytes);
00044c  e3570000          CMP      r7,#0
000450  da000003          BLE      |L1.1124|
000454  e1a02007          MOV      r2,r7
000458  e1a0100a          MOV      r1,r10
00045c  e1a00006          MOV      r0,r6
000460  ebfffffe          BL       _ff_push_const_addr
                  |L1.1124|
;;;225          }
000464  e1a00000          MOV      r0,r0
                  |L1.1128|
;;;226          break;
000468  e1a00000          MOV      r0,r0
                  |L1.1132|
00046c  e1a00000          MOV      r0,r0                 ;181
;;;227      }
;;;228    }
000470  e8bd9fff          POP      {r0-r12,pc}
;;;229    
                          ENDP

                  _ff_pull_n PROC
;;;236    // get n items from fifo WITHOUT updating read pointer
;;;237    static void _ff_pull_n(tu_fifo_t* f, void* app_buf, uint16_t n, uint16_t rd_ptr, tu_fifo_copy_mode_t copy_mode)
000474  e92d5fff          PUSH     {r0-r12,lr}
;;;238    {
000478  e1a04000          MOV      r4,r0
00047c  e1a08001          MOV      r8,r1
000480  e1a05002          MOV      r5,r2
000484  e1a0b003          MOV      r11,r3
;;;239      uint16_t const lin_count = f->depth - rd_ptr;
000488  e1d400b4          LDRH     r0,[r4,#4]
00048c  e040000b          SUB      r0,r0,r11
000490  e1a09800          LSL      r9,r0,#16
000494  e1a09829          LSR      r9,r9,#16
;;;240      uint16_t const wrap_count = n - lin_count; // only used if wrapped
000498  e0450009          SUB      r0,r5,r9
00049c  e1a00800          LSL      r0,r0,#16
0004a0  e1a00820          LSR      r0,r0,#16
0004a4  e58d000c          STR      r0,[sp,#0xc]
;;;241    
;;;242      uint16_t lin_bytes = lin_count * f->item_size;
0004a8  e1d400b6          LDRH     r0,[r4,#6]
0004ac  e3c00902          BIC      r0,r0,#0x8000
0004b0  e0000099          MUL      r0,r9,r0
0004b4  e1a0a800          LSL      r10,r0,#16
0004b8  e1a0a82a          LSR      r10,r10,#16
;;;243      uint16_t wrap_bytes = wrap_count * f->item_size;
0004bc  e1d400b6          LDRH     r0,[r4,#6]
0004c0  e3c01902          BIC      r1,r0,#0x8000
0004c4  e59d000c          LDR      r0,[sp,#0xc]
0004c8  e0000091          MUL      r0,r1,r0
0004cc  e1a07800          LSL      r7,r0,#16
0004d0  e1a07827          LSR      r7,r7,#16
;;;244    
;;;245      // current buffer of fifo
;;;246      uint8_t* ff_buf = f->buffer + (rd_ptr * f->item_size);
0004d4  e5940000          LDR      r0,[r4,#0]
0004d8  e1d410b6          LDRH     r1,[r4,#6]
0004dc  e3c11902          BIC      r1,r1,#0x8000
0004e0  e026019b          MLA      r6,r11,r1,r0
;;;247    
;;;248      switch (copy_mode)
0004e4  e59d0038          LDR      r0,[sp,#0x38]
0004e8  e3500000          CMP      r0,#0
0004ec  0a000002          BEQ      |L1.1276|
0004f0  e3500001          CMP      r0,#1
0004f4  1a00005d          BNE      |L1.1648|
0004f8  ea000012          B        |L1.1352|
                  |L1.1276|
;;;249      {
;;;250        case TU_FIFO_COPY_INC:
0004fc  e1a00000          MOV      r0,r0
;;;251          if ( n <= lin_count )
000500  e1550009          CMP      r5,r9
000504  ca000006          BGT      |L1.1316|
;;;252          {
;;;253            // Linear only
;;;254            memcpy(app_buf, ff_buf, n*f->item_size);
000508  e1d400b6          LDRH     r0,[r4,#6]
00050c  e3c00902          BIC      r0,r0,#0x8000
000510  e0020590          MUL      r2,r0,r5
000514  e1a01006          MOV      r1,r6
000518  e1a00008          MOV      r0,r8
00051c  ebfffffe          BL       __aeabi_memcpy
000520  ea000007          B        |L1.1348|
                  |L1.1316|
;;;255          }
;;;256          else
;;;257          {
;;;258            // Wrap around
;;;259    
;;;260            // Read data from linear part of buffer
;;;261            memcpy(app_buf, ff_buf, lin_bytes);
000524  e1a0200a          MOV      r2,r10
000528  e1a01006          MOV      r1,r6
00052c  e1a00008          MOV      r0,r8
000530  ebfffffe          BL       __aeabi_memcpy
;;;262    
;;;263            // Read data wrapped part
;;;264            memcpy((uint8_t*) app_buf + lin_bytes, f->buffer, wrap_bytes);
000534  e088000a          ADD      r0,r8,r10
000538  e1a02007          MOV      r2,r7
00053c  e5941000          LDR      r1,[r4,#0]
000540  ebfffffe          BL       __aeabi_memcpy
                  |L1.1348|
;;;265          }
;;;266        break;
000544  ea00004b          B        |L1.1656|
                  |L1.1352|
;;;267    
;;;268        case TU_FIFO_COPY_CST_FULL_WORDS:
000548  e1a00000          MOV      r0,r0
;;;269          if ( n <= lin_count )
00054c  e1550009          CMP      r5,r9
000550  ca000008          BGT      |L1.1400|
;;;270          {
;;;271            // Linear only
;;;272            _ff_pull_const_addr(app_buf, ff_buf, n*f->item_size);
000554  e1d400b6          LDRH     r0,[r4,#6]
000558  e3c00902          BIC      r0,r0,#0x8000
00055c  e0000095          MUL      r0,r5,r0
000560  e1a02800          LSL      r2,r0,#16
000564  e1a02822          LSR      r2,r2,#16
000568  e1a01006          MOV      r1,r6
00056c  e1a00008          MOV      r0,r8
000570  ebfffffe          BL       _ff_pull_const_addr
000574  ea00003c          B        |L1.1644|
                  |L1.1400|
;;;273          }
;;;274          else
;;;275          {
;;;276            // Wrap around case
;;;277    
;;;278            // Read full words from linear part of buffer
;;;279            uint16_t lin_4n_bytes = lin_bytes & 0xFFFC;
000578  e59f0930          LDR      r0,|L1.3760|
00057c  e000000a          AND      r0,r0,r10
000580  e58d0008          STR      r0,[sp,#8]
;;;280            _ff_pull_const_addr(app_buf, ff_buf, lin_4n_bytes);
000584  e1a01006          MOV      r1,r6
000588  e1a00008          MOV      r0,r8
00058c  e59d2008          LDR      r2,[sp,#8]
000590  ebfffffe          BL       _ff_pull_const_addr
;;;281            ff_buf += lin_4n_bytes;
000594  e59d0008          LDR      r0,[sp,#8]
000598  e0866000          ADD      r6,r6,r0
;;;282    
;;;283            // There could be odd 1-3 bytes before the wrap-around boundary
;;;284            uint8_t rem = lin_bytes & 0x03;
00059c  e20a0003          AND      r0,r10,#3
0005a0  e58d0004          STR      r0,[sp,#4]
;;;285            if (rem > 0)
0005a4  e59d0004          LDR      r0,[sp,#4]
0005a8  e3500000          CMP      r0,#0
0005ac  da000026          BLE      |L1.1612|
;;;286            {
;;;287              volatile uint32_t * reg_tx = (volatile uint32_t *) app_buf;
0005b0  e1a0c008          MOV      r12,r8
;;;288    
;;;289              uint8_t remrem = (uint8_t) tu_min16(wrap_bytes, 4-rem);
0005b4  e1a02007          MOV      r2,r7
0005b8  e59de004          LDR      lr,[sp,#4]
0005bc  e26ee004          RSB      lr,lr,#4
0005c0  e1a0380e          LSL      r3,lr,#16
0005c4  e1a03823          LSR      r3,r3,#16
0005c8  e1520003          CMP      r2,r3
0005cc  aa000001          BGE      |L1.1496|
0005d0  e1a0e002          MOV      lr,r2
0005d4  ea000000          B        |L1.1500|
                  |L1.1496|
0005d8  e1a0e003          MOV      lr,r3
                  |L1.1500|
0005dc  e1a00000          MOV      r0,r0
0005e0  e20e10ff          AND      r1,lr,#0xff
;;;290              wrap_bytes -= remrem;
0005e4  e0472001          SUB      r2,r7,r1
0005e8  e1a07802          LSL      r7,r2,#16
0005ec  e1a07827          LSR      r7,r7,#16
;;;291    
;;;292              uint32_t tmp32=0;
0005f0  e3a02000          MOV      r2,#0
0005f4  e58d2000          STR      r2,[sp,#0]
;;;293              uint8_t * dst_u8 = (uint8_t *)&tmp32;
0005f8  e1a0000d          MOV      r0,sp
;;;294    
;;;295              // Read 1-3 bytes before wrapped boundary
;;;296              while(rem--) *dst_u8++ = *ff_buf++;
0005fc  ea000001          B        |L1.1544|
                  |L1.1536|
000600  e4d62001          LDRB     r2,[r6],#1
000604  e4c02001          STRB     r2,[r0],#1
                  |L1.1544|
000608  e59d2004          LDR      r2,[sp,#4]
00060c  e2423001          SUB      r3,r2,#1
000610  e20330ff          AND      r3,r3,#0xff
000614  e3520000          CMP      r2,#0
000618  e58d3004          STR      r3,[sp,#4]
00061c  1afffff7          BNE      |L1.1536|
;;;297    
;;;298              // Read more bytes from beginning to complete a word
;;;299              ff_buf = f->buffer;
000620  e5946000          LDR      r6,[r4,#0]
;;;300              while(remrem--) *dst_u8++ = *ff_buf++;
000624  ea000001          B        |L1.1584|
                  |L1.1576|
000628  e4d62001          LDRB     r2,[r6],#1
00062c  e4c02001          STRB     r2,[r0],#1
                  |L1.1584|
000630  e2512000          SUBS     r2,r1,#0
000634  e2413001          SUB      r3,r1,#1
000638  e20310ff          AND      r1,r3,#0xff
00063c  1afffff9          BNE      |L1.1576|
;;;301    
;;;302              *reg_tx = tmp32;
000640  e59d2000          LDR      r2,[sp,#0]
000644  e58c2000          STR      r2,[r12,#0]
;;;303            }
000648  ea000000          B        |L1.1616|
                  |L1.1612|
;;;304            else
;;;305            {
;;;306              ff_buf = f->buffer; // wrap around to beginning
00064c  e5946000          LDR      r6,[r4,#0]
                  |L1.1616|
;;;307            }
;;;308    
;;;309            // Read data wrapped part
;;;310            if (wrap_bytes > 0) _ff_pull_const_addr(app_buf, ff_buf, wrap_bytes);
000650  e3570000          CMP      r7,#0
000654  da000003          BLE      |L1.1640|
000658  e1a02007          MOV      r2,r7
00065c  e1a01006          MOV      r1,r6
000660  e1a00008          MOV      r0,r8
000664  ebfffffe          BL       _ff_pull_const_addr
                  |L1.1640|
;;;311          }
000668  e1a00000          MOV      r0,r0
                  |L1.1644|
;;;312        break;
00066c  ea000001          B        |L1.1656|
                  |L1.1648|
;;;313    
;;;314        default: break;
000670  e1a00000          MOV      r0,r0
000674  e1a00000          MOV      r0,r0
                  |L1.1656|
000678  e1a00000          MOV      r0,r0                 ;266
;;;315      }
;;;316    }
00067c  e8bd9fff          POP      {r0-r12,pc}
;;;317    
                          ENDP

                  advance_index PROC
;;;349    // "absolute" index is only in the range of [0..2*depth)
;;;350    static uint16_t advance_index(uint16_t depth, uint16_t idx, uint16_t offset)
000680  e92d4030          PUSH     {r4,r5,lr}
;;;351    {
000684  e1a03000          MOV      r3,r0
;;;352      // We limit the index space of p such that a correct wrap around happens
;;;353      // Check for a wrap around or if we are in unused index space - This has to be checked first!!
;;;354      // We are exploiting the wrap around to the correct index
;;;355      uint16_t new_idx = (uint16_t) (idx + offset);
000688  e081c002          ADD      r12,r1,r2
00068c  e1a0080c          LSL      r0,r12,#16
000690  e1a00820          LSR      r0,r0,#16
;;;356      if ( (idx > new_idx) || (new_idx >= 2*depth) )
000694  e1510000          CMP      r1,r0
000698  ca000002          BGT      |L1.1704|
00069c  e1a0c083          LSL      r12,r3,#1
0006a0  e15c0000          CMP      r12,r0
0006a4  ca000007          BGT      |L1.1736|
                  |L1.1704|
;;;357      {
;;;358        uint16_t const non_used_index_space = (uint16_t) (UINT16_MAX - (2*depth-1));
0006a8  e1a04083          LSL      r4,r3,#1
0006ac  e2444001          SUB      r4,r4,#1
0006b0  e3e05000          MVN      r5,#0
0006b4  e0454004          SUB      r4,r5,r4
0006b8  e004c825          AND      r12,r4,r5,LSR #16
;;;359        new_idx = (uint16_t) (new_idx + non_used_index_space);
0006bc  e080400c          ADD      r4,r0,r12
0006c0  e0040825          AND      r0,r4,r5,LSR #16
;;;360      }
0006c4  e1a00000          MOV      r0,r0
                  |L1.1736|
;;;361    
;;;362      return new_idx;
;;;363    }
0006c8  e8bd8030          POP      {r4,r5,pc}
;;;364    
                          ENDP

                  _tu_fifo_peek PROC
;;;413    // Must be protected by mutexes since in case of an overflow read pointer gets modified
;;;414    static bool _tu_fifo_peek(tu_fifo_t* f, void * p_buffer, uint16_t wr_idx, uint16_t rd_idx)
0006cc  e92d47f0          PUSH     {r4-r10,lr}
;;;415    {
0006d0  e1a04000          MOV      r4,r0
0006d4  e1a08001          MOV      r8,r1
0006d8  e1a05002          MOV      r5,r2
0006dc  e1a07003          MOV      r7,r3
;;;416      uint16_t cnt = _ff_count(f->depth, wr_idx, rd_idx);
0006e0  e1d420b4          LDRH     r2,[r4,#4]
0006e4  e1a01005          MOV      r1,r5
0006e8  e1a00007          MOV      r0,r7
0006ec  e1510000          CMP      r1,r0
0006f0  ba000003          BLT      |L1.1796|
0006f4  e0413000          SUB      r3,r1,r0
0006f8  e1a03803          LSL      r3,r3,#16
0006fc  e1a03823          LSR      r3,r3,#16
000700  ea000003          B        |L1.1812|
                  |L1.1796|
000704  e040c001          SUB      r12,r0,r1
000708  e06c3082          RSB      r3,r12,r2,LSL #1
00070c  e1a03803          LSL      r3,r3,#16
000710  e1a03823          LSR      r3,r3,#16
                  |L1.1812|
000714  e1a00000          MOV      r0,r0
000718  e1a09003          MOV      r9,r3
;;;417    
;;;418      // nothing to peek
;;;419      if ( cnt == 0 ) return false;
00071c  e3590000          CMP      r9,#0
000720  1a000001          BNE      |L1.1836|
000724  e3a00000          MOV      r0,#0
                  |L1.1832|
;;;420    
;;;421      // Check overflow and correct if required
;;;422      if ( cnt > f->depth )
;;;423      {
;;;424        rd_idx = _ff_correct_read_index(f, wr_idx);
;;;425        cnt = f->depth;
;;;426      }
;;;427    
;;;428      uint16_t rd_ptr = idx2ptr(f->depth, rd_idx);
;;;429    
;;;430      // Peek data
;;;431      _ff_pull(f, p_buffer, rd_ptr);
;;;432    
;;;433      return true;
;;;434    }
000728  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1836|
00072c  e1d400b4          LDRH     r0,[r4,#4]            ;422
000730  e1500009          CMP      r0,r9                 ;422
000734  aa000012          BGE      |L1.1924|
000738  e1a00004          MOV      r0,r4                 ;424
00073c  e1a01005          MOV      r1,r5                 ;424
000740  e1d030b4          LDRH     r3,[r0,#4]            ;424
000744  e1530001          CMP      r3,r1                 ;424
000748  ca000004          BGT      |L1.1888|
00074c  e1d030b4          LDRH     r3,[r0,#4]            ;424
000750  e0413003          SUB      r3,r1,r3              ;424
000754  e1a02803          LSL      r2,r3,#16             ;424
000758  e1a02822          LSR      r2,r2,#16             ;424
00075c  ea000003          B        |L1.1904|
                  |L1.1888|
000760  e1d030b4          LDRH     r3,[r0,#4]            ;424
000764  e0833001          ADD      r3,r3,r1              ;424
000768  e1a02803          LSL      r2,r3,#16             ;424
00076c  e1a02822          LSR      r2,r2,#16             ;424
                  |L1.1904|
000770  e1a00000          MOV      r0,r0                 ;424
000774  e1c020ba          STRH     r2,[r0,#0xa]          ;424
000778  e1a00000          MOV      r0,r0                 ;424
00077c  e1a07002          MOV      r7,r2                 ;424
000780  e1d490b4          LDRH     r9,[r4,#4]            ;425
                  |L1.1924|
000784  e1d410b4          LDRH     r1,[r4,#4]            ;428
000788  e1a00007          MOV      r0,r7                 ;428
00078c  ea000002          B        |L1.1948|
                  |L1.1936|
000790  e0402001          SUB      r2,r0,r1              ;428
000794  e1a00802          LSL      r0,r2,#16             ;428
000798  e1a00820          LSR      r0,r0,#16             ;428
                  |L1.1948|
00079c  e1500001          CMP      r0,r1                 ;428
0007a0  aafffffa          BGE      |L1.1936|
0007a4  e1a06000          MOV      r6,r0                 ;428
0007a8  e1a00000          MOV      r0,r0                 ;431
0007ac  e5940000          LDR      r0,[r4,#0]            ;431
0007b0  e1d430b6          LDRH     r3,[r4,#6]            ;431
0007b4  e3c33902          BIC      r3,r3,#0x8000         ;431
0007b8  e0210396          MLA      r1,r6,r3,r0           ;431
0007bc  e1d400b6          LDRH     r0,[r4,#6]            ;431
0007c0  e3c02902          BIC      r2,r0,#0x8000         ;431
0007c4  e1a00008          MOV      r0,r8                 ;431
0007c8  ebfffffe          BL       __aeabi_memcpy
0007cc  e1a00000          MOV      r0,r0                 ;431
0007d0  e3a00001          MOV      r0,#1                 ;433
0007d4  eaffffd3          B        |L1.1832|
;;;435    
                          ENDP

                  _tu_fifo_peek_n PROC
;;;437    // Must be protected by mutexes since in case of an overflow read pointer gets modified
;;;438    static uint16_t _tu_fifo_peek_n(tu_fifo_t* f, void * p_buffer, uint16_t n, uint16_t wr_idx, uint16_t rd_idx, tu_fifo_copy_mode_t copy_mode)
0007d8  e92d4ff8          PUSH     {r3-r11,lr}
;;;439    {
0007dc  e1a04000          MOV      r4,r0
0007e0  e1a0a001          MOV      r10,r1
0007e4  e1a07002          MOV      r7,r2
0007e8  e1a05003          MOV      r5,r3
0007ec  e59d8028          LDR      r8,[sp,#0x28]
0007f0  e59db02c          LDR      r11,[sp,#0x2c]
;;;440      uint16_t cnt = _ff_count(f->depth, wr_idx, rd_idx);
0007f4  e1d420b4          LDRH     r2,[r4,#4]
0007f8  e1a01005          MOV      r1,r5
0007fc  e1a00008          MOV      r0,r8
000800  e1510000          CMP      r1,r0
000804  ba000003          BLT      |L1.2072|
000808  e0413000          SUB      r3,r1,r0
00080c  e1a03803          LSL      r3,r3,#16
000810  e1a03823          LSR      r3,r3,#16
000814  ea000003          B        |L1.2088|
                  |L1.2072|
000818  e040c001          SUB      r12,r0,r1
00081c  e06c3082          RSB      r3,r12,r2,LSL #1
000820  e1a03803          LSL      r3,r3,#16
000824  e1a03823          LSR      r3,r3,#16
                  |L1.2088|
000828  e1a00000          MOV      r0,r0
00082c  e1a06003          MOV      r6,r3
;;;441    
;;;442      // nothing to peek
;;;443      if ( cnt == 0 ) return 0;
000830  e3560000          CMP      r6,#0
000834  1a000001          BNE      |L1.2112|
000838  e3a00000          MOV      r0,#0
                  |L1.2108|
;;;444    
;;;445      // Check overflow and correct if required
;;;446      if ( cnt > f->depth )
;;;447      {
;;;448        rd_idx = _ff_correct_read_index(f, wr_idx);
;;;449        cnt = f->depth;
;;;450      }
;;;451    
;;;452      // Check if we can read something at and after offset - if too less is available we read what remains
;;;453      if ( cnt < n ) n = cnt;
;;;454    
;;;455      uint16_t rd_ptr = idx2ptr(f->depth, rd_idx);
;;;456    
;;;457      // Peek data
;;;458      _ff_pull_n(f, p_buffer, n, rd_ptr, copy_mode);
;;;459    
;;;460      return n;
;;;461    }
00083c  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.2112|
000840  e1d400b4          LDRH     r0,[r4,#4]            ;446
000844  e1500006          CMP      r0,r6                 ;446
000848  aa000012          BGE      |L1.2200|
00084c  e1a00004          MOV      r0,r4                 ;448
000850  e1a01005          MOV      r1,r5                 ;448
000854  e1d030b4          LDRH     r3,[r0,#4]            ;448
000858  e1530001          CMP      r3,r1                 ;448
00085c  ca000004          BGT      |L1.2164|
000860  e1d030b4          LDRH     r3,[r0,#4]            ;448
000864  e0413003          SUB      r3,r1,r3              ;448
000868  e1a02803          LSL      r2,r3,#16             ;448
00086c  e1a02822          LSR      r2,r2,#16             ;448
000870  ea000003          B        |L1.2180|
                  |L1.2164|
000874  e1d030b4          LDRH     r3,[r0,#4]            ;448
000878  e0833001          ADD      r3,r3,r1              ;448
00087c  e1a02803          LSL      r2,r3,#16             ;448
000880  e1a02822          LSR      r2,r2,#16             ;448
                  |L1.2180|
000884  e1a00000          MOV      r0,r0                 ;448
000888  e1c020ba          STRH     r2,[r0,#0xa]          ;448
00088c  e1a00000          MOV      r0,r0                 ;448
000890  e1a08002          MOV      r8,r2                 ;448
000894  e1d460b4          LDRH     r6,[r4,#4]            ;449
                  |L1.2200|
000898  e1560007          CMP      r6,r7                 ;453
00089c  aa000000          BGE      |L1.2212|
0008a0  e1a07006          MOV      r7,r6                 ;453
                  |L1.2212|
0008a4  e1d410b4          LDRH     r1,[r4,#4]            ;455
0008a8  e1a00008          MOV      r0,r8                 ;455
0008ac  ea000002          B        |L1.2236|
                  |L1.2224|
0008b0  e0402001          SUB      r2,r0,r1              ;455
0008b4  e1a00802          LSL      r0,r2,#16             ;455
0008b8  e1a00820          LSR      r0,r0,#16             ;455
                  |L1.2236|
0008bc  e1500001          CMP      r0,r1                 ;455
0008c0  aafffffa          BGE      |L1.2224|
0008c4  e1a09000          MOV      r9,r0                 ;455
0008c8  e1a03009          MOV      r3,r9                 ;458
0008cc  e1a02007          MOV      r2,r7                 ;458
0008d0  e1a0100a          MOV      r1,r10                ;458
0008d4  e1a00004          MOV      r0,r4                 ;458
0008d8  e58db000          STR      r11,[sp,#0]           ;458
0008dc  ebfffffe          BL       _ff_pull_n
0008e0  e1a00007          MOV      r0,r7                 ;460
0008e4  eaffffd4          B        |L1.2108|
;;;462    
                          ENDP

                  _tu_fifo_write_n PROC
;;;463    static uint16_t _tu_fifo_write_n(tu_fifo_t* f, const void * data, uint16_t n, tu_fifo_copy_mode_t copy_mode)
0008e8  e92d4fff          PUSH     {r0-r11,lr}
;;;464    {
0008ec  e24dd00c          SUB      sp,sp,#0xc
0008f0  e1a04000          MOV      r4,r0
0008f4  e1a05002          MOV      r5,r2
0008f8  e1a08003          MOV      r8,r3
;;;465      if ( n == 0 ) return 0;
0008fc  e3550000          CMP      r5,#0
000900  1a000002          BNE      |L1.2320|
000904  e3a00000          MOV      r0,#0
                  |L1.2312|
000908  e28dd01c          ADD      sp,sp,#0x1c
;;;466    
;;;467      _ff_lock(f->mutex_wr);
;;;468    
;;;469      uint16_t wr_idx = f->wr_idx;
;;;470      uint16_t rd_idx = f->rd_idx;
;;;471    
;;;472      uint8_t const* buf8 = (uint8_t const*) data;
;;;473    
;;;474      TU_LOG(TU_FIFO_DBG, "rd = %3u, wr = %3u, count = %3u, remain = %3u, n = %3u:  ",
;;;475                           rd_idx, wr_idx, _ff_count(f->depth, wr_idx, rd_idx), _ff_remaining(f->depth, wr_idx, rd_idx), n);
;;;476    
;;;477      if ( !f->overwritable )
;;;478      {
;;;479        // limit up to full
;;;480        uint16_t const remain = _ff_remaining(f->depth, wr_idx, rd_idx);
;;;481        n = tu_min16(n, remain);
;;;482      }
;;;483      else
;;;484      {
;;;485        // In over-writable mode, fifo_write() is allowed even when fifo is full. In such case,
;;;486        // oldest data in fifo i.e at read pointer data will be overwritten
;;;487        // Note: we can modify read buffer contents but we must not modify the read index itself within a write function!
;;;488        // Since it would end up in a race condition with read functions!
;;;489        if ( n >= f->depth )
;;;490        {
;;;491          // Only copy last part
;;;492          if ( copy_mode == TU_FIFO_COPY_INC )
;;;493          {
;;;494            buf8 += (n - f->depth) * f->item_size;
;;;495          }else
;;;496          {
;;;497            // TODO should read from hw fifo to discard data, however reading an odd number could
;;;498            // accidentally discard data.
;;;499          }
;;;500    
;;;501          n = f->depth;
;;;502    
;;;503          // We start writing at the read pointer's position since we fill the whole buffer
;;;504          wr_idx = rd_idx;
;;;505        }
;;;506        else
;;;507        {
;;;508          uint16_t const overflowable_count = _ff_count(f->depth, wr_idx, rd_idx);
;;;509          if (overflowable_count + n >= 2*f->depth)
;;;510          {
;;;511            // Double overflowed
;;;512            // Index is bigger than the allowed range [0,2*depth)
;;;513            // re-position write index to have a full fifo after pushed
;;;514            wr_idx = advance_index(f->depth, rd_idx, f->depth - n);
;;;515    
;;;516            // TODO we should also shift out n bytes from read index since we avoid changing rd index !!
;;;517            // However memmove() is expensive due to actual copying + wrapping consideration.
;;;518            // Also race condition could happen anyway if read() is invoke while moving result in corrupted memory
;;;519            // currently deliberately not implemented --> result in incorrect data read back
;;;520          }else
;;;521          {
;;;522            // normal + single overflowed:
;;;523            // Index is in the range of [0,2*depth) and thus detect and recoverable. Recovering is handled in read()
;;;524            // Therefore we just increase write index
;;;525            // we will correct (re-position) read index later on in fifo_read() function
;;;526          }
;;;527        }
;;;528      }
;;;529    
;;;530      if (n)
;;;531      {
;;;532        uint16_t wr_ptr = idx2ptr(f->depth, wr_idx);
;;;533    
;;;534        TU_LOG(TU_FIFO_DBG, "actual_n = %u, wr_ptr = %u", n, wr_ptr);
;;;535    
;;;536        // Write data
;;;537        _ff_push_n(f, buf8, n, wr_ptr, copy_mode);
;;;538    
;;;539        // Advance index
;;;540        f->wr_idx = advance_index(f->depth, wr_idx, n);
;;;541    
;;;542        TU_LOG(TU_FIFO_DBG, "\tnew_wr = %u\n", f->wr_idx);
;;;543      }
;;;544    
;;;545      _ff_unlock(f->mutex_wr);
;;;546    
;;;547      return n;
;;;548    }
00090c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.2320|
000910  e594900c          LDR      r9,[r4,#0xc]          ;467
000914  e3590000          CMP      r9,#0                 ;467
000918  0a000011          BEQ      |L1.2404|
00091c  e1a0b009          MOV      r11,r9                ;467
000920  e3e0a000          MVN      r10,#0                ;467
000924  e1a0000a          MOV      r0,r10                ;467
000928  e3700001          CMN      r0,#1                 ;467
00092c  1a000001          BNE      |L1.2360|
000930  e1a0182a          LSR      r1,r10,#16            ;467
000934  ea000005          B        |L1.2384|
                  |L1.2360|
000938  e59f156c          LDR      r1,|L1.3756|
00093c  e1500001          CMP      r0,r1                 ;467
000940  3a000000          BCC      |L1.2376|
000944  ea000001          B        |L1.2384|
                  |L1.2376|
000948  e1a01800          LSL      r1,r0,#16             ;467
00094c  e1a01821          LSR      r1,r1,#16             ;467
                  |L1.2384|
000950  e1a00000          MOV      r0,r0                 ;467
000954  e1a0000b          MOV      r0,r11                ;467
000958  e58d1004          STR      r1,[sp,#4]            ;467
00095c  ebfffffe          BL       os_mut_wait
000960  e1a00000          MOV      r0,r0                 ;467
                  |L1.2404|
000964  e1a00000          MOV      r0,r0                 ;467
000968  e1a00000          MOV      r0,r0                 ;467
00096c  e1d460b8          LDRH     r6,[r4,#8]            ;469
000970  e1d470ba          LDRH     r7,[r4,#0xa]          ;470
000974  e59d0010          LDR      r0,[sp,#0x10]         ;472
000978  e58d0008          STR      r0,[sp,#8]            ;472
00097c  e5d40007          LDRB     r0,[r4,#7]            ;477
000980  e1a003a0          LSR      r0,r0,#7              ;477
000984  e3500000          CMP      r0,#0                 ;477
000988  1a000025          BNE      |L1.2596|
00098c  e1d430b4          LDRH     r3,[r4,#4]            ;480
000990  e1a0c006          MOV      r12,r6                ;480
000994  e1a09007          MOV      r9,r7                 ;480
000998  e1a0a003          MOV      r10,r3                ;480
00099c  e1a0000c          MOV      r0,r12                ;480
0009a0  e1a01009          MOV      r1,r9                 ;480
0009a4  e1500001          CMP      r0,r1                 ;480
0009a8  ba000003          BLT      |L1.2492|
0009ac  e040b001          SUB      r11,r0,r1             ;480
0009b0  e1a0b80b          LSL      r11,r11,#16           ;480
0009b4  e1a0b82b          LSR      r11,r11,#16           ;480
0009b8  ea000003          B        |L1.2508|
                  |L1.2492|
0009bc  e041e000          SUB      lr,r1,r0              ;480
0009c0  e06eb08a          RSB      r11,lr,r10,LSL #1     ;480
0009c4  e1a0b80b          LSL      r11,r11,#16           ;480
0009c8  e1a0b82b          LSR      r11,r11,#16           ;480
                  |L1.2508|
0009cc  e1a00000          MOV      r0,r0                 ;480
0009d0  e58db004          STR      r11,[sp,#4]           ;480
0009d4  e59db004          LDR      r11,[sp,#4]           ;480
0009d8  e153000b          CMP      r3,r11                ;480
0009dc  da000002          BLE      |L1.2540|
0009e0  e59d0004          LDR      r0,[sp,#4]            ;480
0009e4  e0430000          SUB      r0,r3,r0              ;480
0009e8  ea000000          B        |L1.2544|
                  |L1.2540|
0009ec  e3a00000          MOV      r0,#0                 ;480
                  |L1.2544|
0009f0  e1a02800          LSL      r2,r0,#16             ;480
0009f4  e1a02822          LSR      r2,r2,#16             ;480
0009f8  e1a00000          MOV      r0,r0                 ;480
0009fc  e1a01005          MOV      r1,r5                 ;481
000a00  e1a00002          MOV      r0,r2                 ;481
000a04  e1510000          CMP      r1,r0                 ;481
000a08  aa000001          BGE      |L1.2580|
000a0c  e1a03001          MOV      r3,r1                 ;481
000a10  ea000000          B        |L1.2584|
                  |L1.2580|
000a14  e1a03000          MOV      r3,r0                 ;481
                  |L1.2584|
000a18  e1a00000          MOV      r0,r0                 ;481
000a1c  e1a05003          MOV      r5,r3                 ;481
000a20  ea00002b          B        |L1.2772|
                  |L1.2596|
000a24  e1d400b4          LDRH     r0,[r4,#4]            ;489
000a28  e1500005          CMP      r0,r5                 ;489
000a2c  ca00000b          BGT      |L1.2656|
000a30  e3580000          CMP      r8,#0                 ;492
000a34  1a000006          BNE      |L1.2644|
000a38  e59d0008          LDR      r0,[sp,#8]            ;494
000a3c  e1d410b4          LDRH     r1,[r4,#4]            ;494
000a40  e0451001          SUB      r1,r5,r1              ;494
000a44  e1d420b6          LDRH     r2,[r4,#6]            ;494
000a48  e3c22902          BIC      r2,r2,#0x8000         ;494
000a4c  e0200291          MLA      r0,r1,r2,r0           ;494
000a50  e58d0008          STR      r0,[sp,#8]            ;494
                  |L1.2644|
000a54  e1d450b4          LDRH     r5,[r4,#4]            ;501
000a58  e1a06007          MOV      r6,r7                 ;504
000a5c  ea00001c          B        |L1.2772|
                  |L1.2656|
000a60  e1d420b4          LDRH     r2,[r4,#4]            ;508
000a64  e1a00006          MOV      r0,r6                 ;508
000a68  e1a01007          MOV      r1,r7                 ;508
000a6c  e1500001          CMP      r0,r1                 ;508
000a70  ba000003          BLT      |L1.2692|
000a74  e0403001          SUB      r3,r0,r1              ;508
000a78  e1a03803          LSL      r3,r3,#16             ;508
000a7c  e1a03823          LSR      r3,r3,#16             ;508
000a80  ea000003          B        |L1.2708|
                  |L1.2692|
000a84  e041c000          SUB      r12,r1,r0             ;508
000a88  e06c3082          RSB      r3,r12,r2,LSL #1      ;508
000a8c  e1a03803          LSL      r3,r3,#16             ;508
000a90  e1a03823          LSR      r3,r3,#16             ;508
                  |L1.2708|
000a94  e1a00000          MOV      r0,r0                 ;508
000a98  e1a09003          MOV      r9,r3                 ;508
000a9c  e0890005          ADD      r0,r9,r5              ;509
000aa0  e1d410b4          LDRH     r1,[r4,#4]            ;509
000aa4  e1a01081          LSL      r1,r1,#1              ;509
000aa8  e1500001          CMP      r0,r1                 ;509
000aac  ba000007          BLT      |L1.2768|
000ab0  e1d410b4          LDRH     r1,[r4,#4]            ;514
000ab4  e0411005          SUB      r1,r1,r5              ;514
000ab8  e1a02801          LSL      r2,r1,#16             ;514
000abc  e1a02822          LSR      r2,r2,#16             ;514
000ac0  e1d400b4          LDRH     r0,[r4,#4]            ;514
000ac4  e1a01007          MOV      r1,r7                 ;514
000ac8  ebfffffe          BL       advance_index
000acc  e1a06000          MOV      r6,r0                 ;514
                  |L1.2768|
000ad0  e1a00000          MOV      r0,r0                 ;527
                  |L1.2772|
000ad4  e3550000          CMP      r5,#0                 ;530
000ad8  0a000014          BEQ      |L1.2864|
000adc  e1d410b4          LDRH     r1,[r4,#4]            ;532
000ae0  e1a00006          MOV      r0,r6                 ;532
000ae4  ea000002          B        |L1.2804|
                  |L1.2792|
000ae8  e0402001          SUB      r2,r0,r1              ;532
000aec  e1a00802          LSL      r0,r2,#16             ;532
000af0  e1a00820          LSR      r0,r0,#16             ;532
                  |L1.2804|
000af4  e1500001          CMP      r0,r1                 ;532
000af8  aafffffa          BGE      |L1.2792|
000afc  e1a09000          MOV      r9,r0                 ;532
000b00  e1a03009          MOV      r3,r9                 ;537
000b04  e1a02005          MOV      r2,r5                 ;537
000b08  e58d8000          STR      r8,[sp,#0]            ;537
000b0c  e1a00004          MOV      r0,r4                 ;537
000b10  e59d1008          LDR      r1,[sp,#8]            ;537
000b14  ebfffffe          BL       _ff_push_n
000b18  e1d400b4          LDRH     r0,[r4,#4]            ;540
000b1c  e1a02005          MOV      r2,r5                 ;540
000b20  e1a01006          MOV      r1,r6                 ;540
000b24  ebfffffe          BL       advance_index
000b28  e1c400b8          STRH     r0,[r4,#8]            ;540
000b2c  e1a00000          MOV      r0,r0                 ;543
                  |L1.2864|
000b30  e594900c          LDR      r9,[r4,#0xc]          ;545
000b34  e3590000          CMP      r9,#0                 ;545
000b38  0a000003          BEQ      |L1.2892|
000b3c  e1a0a009          MOV      r10,r9                ;545
000b40  e1a0000a          MOV      r0,r10                ;545
000b44  ebfffffe          BL       os_mut_release
000b48  e1a00000          MOV      r0,r0                 ;545
                  |L1.2892|
000b4c  e1a00000          MOV      r0,r0                 ;545
000b50  e1a00000          MOV      r0,r0                 ;545
000b54  e1a00005          MOV      r0,r5                 ;547
000b58  eaffff6a          B        |L1.2312|
;;;549    
                          ENDP

                  _tu_fifo_read_n PROC
;;;550    static uint16_t _tu_fifo_read_n(tu_fifo_t* f, void * buffer, uint16_t n, tu_fifo_copy_mode_t copy_mode)
000b5c  e92d5ffc          PUSH     {r2-r12,lr}
;;;551    {
000b60  e1a04000          MOV      r4,r0
000b64  e1a0a001          MOV      r10,r1
000b68  e1a07002          MOV      r7,r2
000b6c  e1a08003          MOV      r8,r3
;;;552      _ff_lock(f->mutex_rd);
000b70  e5945010          LDR      r5,[r4,#0x10]
000b74  e3550000          CMP      r5,#0
000b78  0a000011          BEQ      |L1.3012|
000b7c  e1a09005          MOV      r9,r5
000b80  e3e06000          MVN      r6,#0
000b84  e1a00006          MOV      r0,r6
000b88  e3700001          CMN      r0,#1
000b8c  1a000001          BNE      |L1.2968|
000b90  e1a01826          LSR      r1,r6,#16
000b94  ea000005          B        |L1.2992|
                  |L1.2968|
000b98  e59f130c          LDR      r1,|L1.3756|
000b9c  e1500001          CMP      r0,r1
000ba0  3a000000          BCC      |L1.2984|
000ba4  ea000001          B        |L1.2992|
                  |L1.2984|
000ba8  e1a01800          LSL      r1,r0,#16
000bac  e1a01821          LSR      r1,r1,#16
                  |L1.2992|
000bb0  e1a00000          MOV      r0,r0
000bb4  e1a0b001          MOV      r11,r1
000bb8  e1a00009          MOV      r0,r9
000bbc  ebfffffe          BL       os_mut_wait
000bc0  e1a00000          MOV      r0,r0
                  |L1.3012|
000bc4  e1a00000          MOV      r0,r0
000bc8  e1a00000          MOV      r0,r0
;;;553    
;;;554      // Peek the data
;;;555      // f->rd_idx might get modified in case of an overflow so we can not use a local variable
;;;556      n = _tu_fifo_peek_n(f, buffer, n, f->wr_idx, f->rd_idx, copy_mode);
000bcc  e1d400ba          LDRH     r0,[r4,#0xa]
000bd0  e88d0101          STM      sp,{r0,r8}
000bd4  e1d430b8          LDRH     r3,[r4,#8]
000bd8  e1a02007          MOV      r2,r7
000bdc  e1a0100a          MOV      r1,r10
000be0  e1a00004          MOV      r0,r4
000be4  ebfffffe          BL       _tu_fifo_peek_n
000be8  e1a07000          MOV      r7,r0
;;;557    
;;;558      // Advance read pointer
;;;559      f->rd_idx = advance_index(f->depth, f->rd_idx, n);
000bec  e1d410ba          LDRH     r1,[r4,#0xa]
000bf0  e1d400b4          LDRH     r0,[r4,#4]
000bf4  e1a02007          MOV      r2,r7
000bf8  ebfffffe          BL       advance_index
000bfc  e1c400ba          STRH     r0,[r4,#0xa]
;;;560    
;;;561      _ff_unlock(f->mutex_rd);
000c00  e5945010          LDR      r5,[r4,#0x10]
000c04  e3550000          CMP      r5,#0
000c08  0a000003          BEQ      |L1.3100|
000c0c  e1a06005          MOV      r6,r5
000c10  e1a00006          MOV      r0,r6
000c14  ebfffffe          BL       os_mut_release
000c18  e1a00000          MOV      r0,r0
                  |L1.3100|
000c1c  e1a00000          MOV      r0,r0
000c20  e1a00000          MOV      r0,r0
;;;562      return n;
000c24  e1a00007          MOV      r0,r7
;;;563    }
000c28  e8bd9ffc          POP      {r2-r12,pc}
;;;564    
                          ENDP

                  tu_fifo_count PROC
;;;583    /******************************************************************************/
;;;584    uint16_t tu_fifo_count(tu_fifo_t* f)
000c2c  e92d4070          PUSH     {r4-r6,lr}
;;;585    {
000c30  e1a01000          MOV      r1,r0
;;;586      return tu_min16(_ff_count(f->depth, f->wr_idx, f->rd_idx), f->depth);
000c34  e1d1c0b4          LDRH     r12,[r1,#4]
000c38  e1d100b8          LDRH     r0,[r1,#8]
000c3c  e1d120ba          LDRH     r2,[r1,#0xa]
000c40  e1500002          CMP      r0,r2
000c44  ba000003          BLT      |L1.3160|
000c48  e0405002          SUB      r5,r0,r2
000c4c  e1a05805          LSL      r5,r5,#16
000c50  e1a05825          LSR      r5,r5,#16
000c54  ea000003          B        |L1.3176|
                  |L1.3160|
000c58  e0426000          SUB      r6,r2,r0
000c5c  e066508c          RSB      r5,r6,r12,LSL #1
000c60  e1a05805          LSL      r5,r5,#16
000c64  e1a05825          LSR      r5,r5,#16
                  |L1.3176|
000c68  e1a00000          MOV      r0,r0
000c6c  e1a04005          MOV      r4,r5
000c70  e1d130b4          LDRH     r3,[r1,#4]
000c74  e1540003          CMP      r4,r3
000c78  aa000001          BGE      |L1.3204|
000c7c  e1a00004          MOV      r0,r4
000c80  ea000000          B        |L1.3208|
                  |L1.3204|
000c84  e1a00003          MOV      r0,r3
                  |L1.3208|
000c88  e1a00000          MOV      r0,r0
;;;587    }
000c8c  e8bd8070          POP      {r4-r6,pc}
;;;588    
                          ENDP

                  tu_fifo_empty PROC
;;;601    /******************************************************************************/
;;;602    bool tu_fifo_empty(tu_fifo_t* f)
000c90  e1a01000          MOV      r1,r0
;;;603    {
;;;604      return f->wr_idx == f->rd_idx;
000c94  e1d100b8          LDRH     r0,[r1,#8]
000c98  e1d120ba          LDRH     r2,[r1,#0xa]
000c9c  e1500002          CMP      r0,r2
000ca0  1a000001          BNE      |L1.3244|
000ca4  e3a00001          MOV      r0,#1
                  |L1.3240|
;;;605    }
000ca8  e12fff1e          BX       lr
                  |L1.3244|
000cac  e3a00000          MOV      r0,#0                 ;604
000cb0  eafffffc          B        |L1.3240|
;;;606    
                          ENDP

                  tu_fifo_full PROC
;;;619    /******************************************************************************/
;;;620    bool tu_fifo_full(tu_fifo_t* f)
000cb4  e92d4010          PUSH     {r4,lr}
;;;621    {
000cb8  e1a01000          MOV      r1,r0
;;;622      return _ff_count(f->depth, f->wr_idx, f->rd_idx) >= f->depth;
000cbc  e1d130b4          LDRH     r3,[r1,#4]
000cc0  e1d100b8          LDRH     r0,[r1,#8]
000cc4  e1d120ba          LDRH     r2,[r1,#0xa]
000cc8  e1500002          CMP      r0,r2
000ccc  ba000003          BLT      |L1.3296|
000cd0  e040c002          SUB      r12,r0,r2
000cd4  e1a0c80c          LSL      r12,r12,#16
000cd8  e1a0c82c          LSR      r12,r12,#16
000cdc  ea000003          B        |L1.3312|
                  |L1.3296|
000ce0  e0424000          SUB      r4,r2,r0
000ce4  e064c083          RSB      r12,r4,r3,LSL #1
000ce8  e1a0c80c          LSL      r12,r12,#16
000cec  e1a0c82c          LSR      r12,r12,#16
                  |L1.3312|
000cf0  e1a00000          MOV      r0,r0
000cf4  e1d100b4          LDRH     r0,[r1,#4]
000cf8  e15c0000          CMP      r12,r0
000cfc  ba000001          BLT      |L1.3336|
000d00  e3a00001          MOV      r0,#1
                  |L1.3332|
;;;623    }
000d04  e8bd8010          POP      {r4,pc}
                  |L1.3336|
000d08  e3a00000          MOV      r0,#0                 ;622
000d0c  eafffffc          B        |L1.3332|
;;;624    
                          ENDP

                  tu_fifo_remaining PROC
;;;637    /******************************************************************************/
;;;638    uint16_t tu_fifo_remaining(tu_fifo_t* f)
000d10  e92d41f0          PUSH     {r4-r8,lr}
;;;639    {
000d14  e1a02000          MOV      r2,r0
;;;640      return _ff_remaining(f->depth, f->wr_idx, f->rd_idx);
000d18  e1d230b4          LDRH     r3,[r2,#4]
000d1c  e1d2c0b8          LDRH     r12,[r2,#8]
000d20  e1d240ba          LDRH     r4,[r2,#0xa]
000d24  e1a05003          MOV      r5,r3
000d28  e1a0000c          MOV      r0,r12
000d2c  e1a01004          MOV      r1,r4
000d30  e1500001          CMP      r0,r1
000d34  ba000003          BLT      |L1.3400|
000d38  e0407001          SUB      r7,r0,r1
000d3c  e1a07807          LSL      r7,r7,#16
000d40  e1a07827          LSR      r7,r7,#16
000d44  ea000003          B        |L1.3416|
                  |L1.3400|
000d48  e0418000          SUB      r8,r1,r0
000d4c  e0687085          RSB      r7,r8,r5,LSL #1
000d50  e1a07807          LSL      r7,r7,#16
000d54  e1a07827          LSR      r7,r7,#16
                  |L1.3416|
000d58  e1a00000          MOV      r0,r0
000d5c  e1a06007          MOV      r6,r7
000d60  e1530006          CMP      r3,r6
000d64  da000001          BLE      |L1.3440|
000d68  e0430006          SUB      r0,r3,r6
000d6c  ea000000          B        |L1.3444|
                  |L1.3440|
000d70  e3a00000          MOV      r0,#0
                  |L1.3444|
000d74  e1a00800          LSL      r0,r0,#16
000d78  e1a00820          LSR      r0,r0,#16
;;;641    }
000d7c  e8bd81f0          POP      {r4-r8,pc}
;;;642    
                          ENDP

                  tu_fifo_overflowed PROC
;;;663    /******************************************************************************/
;;;664    bool tu_fifo_overflowed(tu_fifo_t* f)
000d80  e92d4010          PUSH     {r4,lr}
;;;665    {
000d84  e1a01000          MOV      r1,r0
;;;666      return _ff_count(f->depth, f->wr_idx, f->rd_idx) > f->depth;
000d88  e1d130b4          LDRH     r3,[r1,#4]
000d8c  e1d100b8          LDRH     r0,[r1,#8]
000d90  e1d120ba          LDRH     r2,[r1,#0xa]
000d94  e1500002          CMP      r0,r2
000d98  ba000003          BLT      |L1.3500|
000d9c  e040c002          SUB      r12,r0,r2
000da0  e1a0c80c          LSL      r12,r12,#16
000da4  e1a0c82c          LSR      r12,r12,#16
000da8  ea000003          B        |L1.3516|
                  |L1.3500|
000dac  e0424000          SUB      r4,r2,r0
000db0  e064c083          RSB      r12,r4,r3,LSL #1
000db4  e1a0c80c          LSL      r12,r12,#16
000db8  e1a0c82c          LSR      r12,r12,#16
                  |L1.3516|
000dbc  e1a00000          MOV      r0,r0
000dc0  e1d100b4          LDRH     r0,[r1,#4]
000dc4  e15c0000          CMP      r12,r0
000dc8  da000001          BLE      |L1.3540|
000dcc  e3a00001          MOV      r0,#1
                  |L1.3536|
;;;667    }
000dd0  e8bd8010          POP      {r4,pc}
                  |L1.3540|
000dd4  e3a00000          MOV      r0,#0                 ;666
000dd8  eafffffc          B        |L1.3536|
;;;668    
                          ENDP

                  tu_fifo_correct_read_pointer PROC
;;;669    // Only use in case tu_fifo_overflow() returned true!
;;;670    void tu_fifo_correct_read_pointer(tu_fifo_t* f)
000ddc  e92d41f0          PUSH     {r4-r8,lr}
;;;671    {
000de0  e1a04000          MOV      r4,r0
;;;672      _ff_lock(f->mutex_rd);
000de4  e5945010          LDR      r5,[r4,#0x10]
000de8  e3550000          CMP      r5,#0
000dec  0a000011          BEQ      |L1.3640|
000df0  e1a07005          MOV      r7,r5
000df4  e3e06000          MVN      r6,#0
000df8  e1a00006          MOV      r0,r6
000dfc  e3700001          CMN      r0,#1
000e00  1a000001          BNE      |L1.3596|
000e04  e1a01826          LSR      r1,r6,#16
000e08  ea000005          B        |L1.3620|
                  |L1.3596|
000e0c  e59f1098          LDR      r1,|L1.3756|
000e10  e1500001          CMP      r0,r1
000e14  3a000000          BCC      |L1.3612|
000e18  ea000001          B        |L1.3620|
                  |L1.3612|
000e1c  e1a01800          LSL      r1,r0,#16
000e20  e1a01821          LSR      r1,r1,#16
                  |L1.3620|
000e24  e1a00000          MOV      r0,r0
000e28  e1a08001          MOV      r8,r1
000e2c  e1a00007          MOV      r0,r7
000e30  ebfffffe          BL       os_mut_wait
000e34  e1a00000          MOV      r0,r0
                  |L1.3640|
000e38  e1a00000          MOV      r0,r0
000e3c  e1a00000          MOV      r0,r0
;;;673      _ff_correct_read_index(f, f->wr_idx);
000e40  e1a00004          MOV      r0,r4
000e44  e1d410b8          LDRH     r1,[r4,#8]
000e48  e1d030b4          LDRH     r3,[r0,#4]
000e4c  e1530001          CMP      r3,r1
000e50  ca000004          BGT      |L1.3688|
000e54  e1d030b4          LDRH     r3,[r0,#4]
000e58  e0413003          SUB      r3,r1,r3
000e5c  e1a02803          LSL      r2,r3,#16
000e60  e1a02822          LSR      r2,r2,#16
000e64  ea000003          B        |L1.3704|
                  |L1.3688|
000e68  e1d030b4          LDRH     r3,[r0,#4]
000e6c  e0833001          ADD      r3,r3,r1
000e70  e1a02803          LSL      r2,r3,#16
000e74  e1a02822          LSR      r2,r2,#16
                  |L1.3704|
000e78  e1a00000          MOV      r0,r0
000e7c  e1c020ba          STRH     r2,[r0,#0xa]
000e80  e1a00000          MOV      r0,r0
;;;674      _ff_unlock(f->mutex_rd);
000e84  e5945010          LDR      r5,[r4,#0x10]
000e88  e3550000          CMP      r5,#0
000e8c  0a000003          BEQ      |L1.3744|
000e90  e1a06005          MOV      r6,r5
000e94  e1a00006          MOV      r0,r6
000e98  ebfffffe          BL       os_mut_release
000e9c  e1a00000          MOV      r0,r0
                  |L1.3744|
000ea0  e1a00000          MOV      r0,r0
000ea4  e1a00000          MOV      r0,r0
;;;675    }
000ea8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3756|
                          DCD      0x0000fffe
                  |L1.3760|
                          DCD      0x0000fffc
                          ENDP

                  tu_fifo_read PROC
;;;692    /******************************************************************************/
;;;693    bool tu_fifo_read(tu_fifo_t* f, void * buffer)
000eb4  e92d47f0          PUSH     {r4-r10,lr}
;;;694    {
000eb8  e1a04000          MOV      r4,r0
000ebc  e1a08001          MOV      r8,r1
;;;695      _ff_lock(f->mutex_rd);
000ec0  e5945010          LDR      r5,[r4,#0x10]
000ec4  e3550000          CMP      r5,#0
000ec8  0a000011          BEQ      |L1.3860|
000ecc  e1a07005          MOV      r7,r5
000ed0  e3e06000          MVN      r6,#0
000ed4  e1a00006          MOV      r0,r6
000ed8  e3700001          CMN      r0,#1
000edc  1a000001          BNE      |L1.3816|
000ee0  e1a01826          LSR      r1,r6,#16
000ee4  ea000005          B        |L1.3840|
                  |L1.3816|
000ee8  e51f1044          LDR      r1,|L1.3756|
000eec  e1500001          CMP      r0,r1
000ef0  3a000000          BCC      |L1.3832|
000ef4  ea000001          B        |L1.3840|
                  |L1.3832|
000ef8  e1a01800          LSL      r1,r0,#16
000efc  e1a01821          LSR      r1,r1,#16
                  |L1.3840|
000f00  e1a00000          MOV      r0,r0
000f04  e1a0a001          MOV      r10,r1
000f08  e1a00007          MOV      r0,r7
000f0c  ebfffffe          BL       os_mut_wait
000f10  e1a00000          MOV      r0,r0
                  |L1.3860|
000f14  e1a00000          MOV      r0,r0
000f18  e1a00000          MOV      r0,r0
;;;696    
;;;697      // Peek the data
;;;698      // f->rd_idx might get modified in case of an overflow so we can not use a local variable
;;;699      bool ret = _tu_fifo_peek(f, buffer, f->wr_idx, f->rd_idx);
000f1c  e1d430ba          LDRH     r3,[r4,#0xa]
000f20  e1d420b8          LDRH     r2,[r4,#8]
000f24  e1a01008          MOV      r1,r8
000f28  e1a00004          MOV      r0,r4
000f2c  ebfffffe          BL       _tu_fifo_peek
000f30  e1a09000          MOV      r9,r0
;;;700    
;;;701      // Advance pointer
;;;702      f->rd_idx = advance_index(f->depth, f->rd_idx, ret);
000f34  e1d410ba          LDRH     r1,[r4,#0xa]
000f38  e1d400b4          LDRH     r0,[r4,#4]
000f3c  e1a02009          MOV      r2,r9
000f40  ebfffffe          BL       advance_index
000f44  e1c400ba          STRH     r0,[r4,#0xa]
;;;703    
;;;704      _ff_unlock(f->mutex_rd);
000f48  e5945010          LDR      r5,[r4,#0x10]
000f4c  e3550000          CMP      r5,#0
000f50  0a000003          BEQ      |L1.3940|
000f54  e1a06005          MOV      r6,r5
000f58  e1a00006          MOV      r0,r6
000f5c  ebfffffe          BL       os_mut_release
000f60  e1a00000          MOV      r0,r0
                  |L1.3940|
000f64  e1a00000          MOV      r0,r0
000f68  e1a00000          MOV      r0,r0
;;;705      return ret;
000f6c  e1a00009          MOV      r0,r9
;;;706    }
000f70  e8bd87f0          POP      {r4-r10,pc}
;;;707    
                          ENDP

                  tu_fifo_read_n PROC
;;;723    /******************************************************************************/
;;;724    uint16_t tu_fifo_read_n(tu_fifo_t* f, void * buffer, uint16_t n)
000f74  e92d4070          PUSH     {r4-r6,lr}
;;;725    {
000f78  e1a04000          MOV      r4,r0
000f7c  e1a05001          MOV      r5,r1
000f80  e1a06002          MOV      r6,r2
;;;726      return _tu_fifo_read_n(f, buffer, n, TU_FIFO_COPY_INC);
000f84  e3a03000          MOV      r3,#0
000f88  e1a02006          MOV      r2,r6
000f8c  e1a01005          MOV      r1,r5
000f90  e1a00004          MOV      r0,r4
000f94  ebfffffe          BL       _tu_fifo_read_n
;;;727    }
000f98  e8bd8070          POP      {r4-r6,pc}
;;;728    
                          ENDP

                  tu_fifo_read_n_const_addr_full_words PROC
;;;729    uint16_t tu_fifo_read_n_const_addr_full_words(tu_fifo_t* f, void * buffer, uint16_t n)
000f9c  e92d4070          PUSH     {r4-r6,lr}
;;;730    {
000fa0  e1a04000          MOV      r4,r0
000fa4  e1a05001          MOV      r5,r1
000fa8  e1a06002          MOV      r6,r2
;;;731      return _tu_fifo_read_n(f, buffer, n, TU_FIFO_COPY_CST_FULL_WORDS);
000fac  e3a03001          MOV      r3,#1
000fb0  e1a02006          MOV      r2,r6
000fb4  e1a01005          MOV      r1,r5
000fb8  e1a00004          MOV      r0,r4
000fbc  ebfffffe          BL       _tu_fifo_read_n
;;;732    }
000fc0  e8bd8070          POP      {r4-r6,pc}
;;;733    
                          ENDP

                  tu_fifo_peek PROC
;;;746    /******************************************************************************/
;;;747    bool tu_fifo_peek(tu_fifo_t* f, void * p_buffer)
000fc4  e92d47f0          PUSH     {r4-r10,lr}
;;;748    {
000fc8  e1a04000          MOV      r4,r0
000fcc  e1a08001          MOV      r8,r1
;;;749      _ff_lock(f->mutex_rd);
000fd0  e5945010          LDR      r5,[r4,#0x10]
000fd4  e3550000          CMP      r5,#0
000fd8  0a000011          BEQ      |L1.4132|
000fdc  e1a07005          MOV      r7,r5
000fe0  e3e06000          MVN      r6,#0
000fe4  e1a00006          MOV      r0,r6
000fe8  e3700001          CMN      r0,#1
000fec  1a000001          BNE      |L1.4088|
000ff0  e1a01826          LSR      r1,r6,#16
000ff4  ea000005          B        |L1.4112|
                  |L1.4088|
000ff8  e51f1154          LDR      r1,|L1.3756|
000ffc  e1500001          CMP      r0,r1
001000  3a000000          BCC      |L1.4104|
001004  ea000001          B        |L1.4112|
                  |L1.4104|
001008  e1a01800          LSL      r1,r0,#16
00100c  e1a01821          LSR      r1,r1,#16
                  |L1.4112|
001010  e1a00000          MOV      r0,r0
001014  e1a0a001          MOV      r10,r1
001018  e1a00007          MOV      r0,r7
00101c  ebfffffe          BL       os_mut_wait
001020  e1a00000          MOV      r0,r0
                  |L1.4132|
001024  e1a00000          MOV      r0,r0
001028  e1a00000          MOV      r0,r0
;;;750      bool ret = _tu_fifo_peek(f, p_buffer, f->wr_idx, f->rd_idx);
00102c  e1d430ba          LDRH     r3,[r4,#0xa]
001030  e1d420b8          LDRH     r2,[r4,#8]
001034  e1a01008          MOV      r1,r8
001038  e1a00004          MOV      r0,r4
00103c  ebfffffe          BL       _tu_fifo_peek
001040  e1a09000          MOV      r9,r0
;;;751      _ff_unlock(f->mutex_rd);
001044  e5945010          LDR      r5,[r4,#0x10]
001048  e3550000          CMP      r5,#0
00104c  0a000003          BEQ      |L1.4192|
001050  e1a06005          MOV      r6,r5
001054  e1a00006          MOV      r0,r6
001058  ebfffffe          BL       os_mut_release
00105c  e1a00000          MOV      r0,r0
                  |L1.4192|
001060  e1a00000          MOV      r0,r0
001064  e1a00000          MOV      r0,r0
;;;752      return ret;
001068  e1a00009          MOV      r0,r9
;;;753    }
00106c  e8bd87f0          POP      {r4-r10,pc}
;;;754    
                          ENDP

                  tu_fifo_peek_n PROC
;;;769    /******************************************************************************/
;;;770    uint16_t tu_fifo_peek_n(tu_fifo_t* f, void * p_buffer, uint16_t n)
001070  e92d5ffc          PUSH     {r2-r12,lr}
;;;771    {
001074  e1a04000          MOV      r4,r0
001078  e1a09001          MOV      r9,r1
00107c  e1a0a002          MOV      r10,r2
;;;772      _ff_lock(f->mutex_rd);
001080  e5945010          LDR      r5,[r4,#0x10]
001084  e3550000          CMP      r5,#0
001088  0a000011          BEQ      |L1.4308|
00108c  e1a08005          MOV      r8,r5
001090  e3e06000          MVN      r6,#0
001094  e1a00006          MOV      r0,r6
001098  e3700001          CMN      r0,#1
00109c  1a000001          BNE      |L1.4264|
0010a0  e1a01826          LSR      r1,r6,#16
0010a4  ea000005          B        |L1.4288|
                  |L1.4264|
0010a8  e51f1204          LDR      r1,|L1.3756|
0010ac  e1500001          CMP      r0,r1
0010b0  3a000000          BCC      |L1.4280|
0010b4  ea000001          B        |L1.4288|
                  |L1.4280|
0010b8  e1a01800          LSL      r1,r0,#16
0010bc  e1a01821          LSR      r1,r1,#16
                  |L1.4288|
0010c0  e1a00000          MOV      r0,r0
0010c4  e1a0b001          MOV      r11,r1
0010c8  e1a00008          MOV      r0,r8
0010cc  ebfffffe          BL       os_mut_wait
0010d0  e1a00000          MOV      r0,r0
                  |L1.4308|
0010d4  e1a00000          MOV      r0,r0
0010d8  e1a00000          MOV      r0,r0
;;;773      uint16_t ret = _tu_fifo_peek_n(f, p_buffer, n, f->wr_idx, f->rd_idx, TU_FIFO_COPY_INC);
0010dc  e3a01000          MOV      r1,#0
0010e0  e1d400ba          LDRH     r0,[r4,#0xa]
0010e4  e1cd00f0          STRD     r0,r1,[sp,#0]
0010e8  e1d430b8          LDRH     r3,[r4,#8]
0010ec  e1a0200a          MOV      r2,r10
0010f0  e1a01009          MOV      r1,r9
0010f4  e1a00004          MOV      r0,r4
0010f8  ebfffffe          BL       _tu_fifo_peek_n
0010fc  e1a07000          MOV      r7,r0
;;;774      _ff_unlock(f->mutex_rd);
001100  e5945010          LDR      r5,[r4,#0x10]
001104  e3550000          CMP      r5,#0
001108  0a000003          BEQ      |L1.4380|
00110c  e1a06005          MOV      r6,r5
001110  e1a00006          MOV      r0,r6
001114  ebfffffe          BL       os_mut_release
001118  e1a00000          MOV      r0,r0
                  |L1.4380|
00111c  e1a00000          MOV      r0,r0
001120  e1a00000          MOV      r0,r0
;;;775      return ret;
001124  e1a00007          MOV      r0,r7
;;;776    }
001128  e8bd9ffc          POP      {r2-r12,pc}
;;;777    
                          ENDP

                  tu_fifo_write PROC
;;;793    /******************************************************************************/
;;;794    bool tu_fifo_write(tu_fifo_t* f, const void * data)
00112c  e92d5ff0          PUSH     {r4-r12,lr}
;;;795    {
001130  e1a04000          MOV      r4,r0
001134  e1a06001          MOV      r6,r1
;;;796      _ff_lock(f->mutex_wr);
001138  e594500c          LDR      r5,[r4,#0xc]
00113c  e3550000          CMP      r5,#0
001140  0a000011          BEQ      |L1.4492|
001144  e1a0a005          MOV      r10,r5
001148  e3e09000          MVN      r9,#0
00114c  e1a00009          MOV      r0,r9
001150  e3700001          CMN      r0,#1
001154  1a000001          BNE      |L1.4448|
001158  e1a01829          LSR      r1,r9,#16
00115c  ea000005          B        |L1.4472|
                  |L1.4448|
001160  e51f12bc          LDR      r1,|L1.3756|
001164  e1500001          CMP      r0,r1
001168  3a000000          BCC      |L1.4464|
00116c  ea000001          B        |L1.4472|
                  |L1.4464|
001170  e1a01800          LSL      r1,r0,#16
001174  e1a01821          LSR      r1,r1,#16
                  |L1.4472|
001178  e1a00000          MOV      r0,r0
00117c  e1a0b001          MOV      r11,r1
001180  e1a0000a          MOV      r0,r10
001184  ebfffffe          BL       os_mut_wait
001188  e1a00000          MOV      r0,r0
                  |L1.4492|
00118c  e1a00000          MOV      r0,r0
001190  e1a00000          MOV      r0,r0
;;;797    
;;;798      bool ret;
;;;799      uint16_t const wr_idx = f->wr_idx;
001194  e1d480b8          LDRH     r8,[r4,#8]
;;;800    
;;;801      if ( tu_fifo_full(f) && !f->overwritable )
001198  e1a00004          MOV      r0,r4
00119c  ebfffffe          BL       tu_fifo_full
0011a0  e3500000          CMP      r0,#0
0011a4  0a000005          BEQ      |L1.4544|
0011a8  e5d40007          LDRB     r0,[r4,#7]
0011ac  e1a003a0          LSR      r0,r0,#7
0011b0  e3500000          CMP      r0,#0
0011b4  1a000001          BNE      |L1.4544|
;;;802      {
;;;803        ret = false;
0011b8  e3a07000          MOV      r7,#0
0011bc  ea000019          B        |L1.4648|
                  |L1.4544|
;;;804      }else
;;;805      {
;;;806        uint16_t wr_ptr = idx2ptr(f->depth, wr_idx);
0011c0  e1d410b4          LDRH     r1,[r4,#4]
0011c4  e1a00008          MOV      r0,r8
0011c8  ea000002          B        |L1.4568|
                  |L1.4556|
0011cc  e0402001          SUB      r2,r0,r1
0011d0  e1a00802          LSL      r0,r2,#16
0011d4  e1a00820          LSR      r0,r0,#16
                  |L1.4568|
0011d8  e1500001          CMP      r0,r1
0011dc  aafffffa          BGE      |L1.4556|
0011e0  e1a05000          MOV      r5,r0
;;;807    
;;;808        // Write data
;;;809        _ff_push(f, data, wr_ptr);
0011e4  e1a00000          MOV      r0,r0
0011e8  e5941000          LDR      r1,[r4,#0]
0011ec  e1d430b6          LDRH     r3,[r4,#6]
0011f0  e3c33902          BIC      r3,r3,#0x8000
0011f4  e0201395          MLA      r0,r5,r3,r1
0011f8  e1d410b6          LDRH     r1,[r4,#6]
0011fc  e3c12902          BIC      r2,r1,#0x8000
001200  e1a01006          MOV      r1,r6
001204  ebfffffe          BL       __aeabi_memcpy
001208  e1a00000          MOV      r0,r0
;;;810    
;;;811        // Advance pointer
;;;812        f->wr_idx = advance_index(f->depth, wr_idx, 1);
00120c  e1d400b4          LDRH     r0,[r4,#4]
001210  e3a02001          MOV      r2,#1
001214  e1a01008          MOV      r1,r8
001218  ebfffffe          BL       advance_index
00121c  e1c400b8          STRH     r0,[r4,#8]
;;;813    
;;;814        ret = true;
001220  e3a07001          MOV      r7,#1
;;;815      }
001224  e1a00000          MOV      r0,r0
                  |L1.4648|
;;;816    
;;;817      _ff_unlock(f->mutex_wr);
001228  e594500c          LDR      r5,[r4,#0xc]
00122c  e3550000          CMP      r5,#0
001230  0a000003          BEQ      |L1.4676|
001234  e1a09005          MOV      r9,r5
001238  e1a00009          MOV      r0,r9
00123c  ebfffffe          BL       os_mut_release
001240  e1a00000          MOV      r0,r0
                  |L1.4676|
001244  e1a00000          MOV      r0,r0
001248  e1a00000          MOV      r0,r0
;;;818    
;;;819      return ret;
00124c  e1a00007          MOV      r0,r7
;;;820    }
001250  e8bd9ff0          POP      {r4-r12,pc}
;;;821    
                          ENDP

                  tu_fifo_write_n PROC
;;;835    /******************************************************************************/
;;;836    uint16_t tu_fifo_write_n(tu_fifo_t* f, const void * data, uint16_t n)
001254  e92d4070          PUSH     {r4-r6,lr}
;;;837    {
001258  e1a04000          MOV      r4,r0
00125c  e1a05001          MOV      r5,r1
001260  e1a06002          MOV      r6,r2
;;;838      return _tu_fifo_write_n(f, data, n, TU_FIFO_COPY_INC);
001264  e3a03000          MOV      r3,#0
001268  e1a02006          MOV      r2,r6
00126c  e1a01005          MOV      r1,r5
001270  e1a00004          MOV      r0,r4
001274  ebfffffe          BL       _tu_fifo_write_n
;;;839    }
001278  e8bd8070          POP      {r4-r6,pc}
;;;840    
                          ENDP

                  tu_fifo_write_n_const_addr_full_words PROC
;;;855    /******************************************************************************/
;;;856    uint16_t tu_fifo_write_n_const_addr_full_words(tu_fifo_t* f, const void * data, uint16_t n)
00127c  e92d4070          PUSH     {r4-r6,lr}
;;;857    {
001280  e1a04000          MOV      r4,r0
001284  e1a05001          MOV      r5,r1
001288  e1a06002          MOV      r6,r2
;;;858      return _tu_fifo_write_n(f, data, n, TU_FIFO_COPY_CST_FULL_WORDS);
00128c  e3a03001          MOV      r3,#1
001290  e1a02006          MOV      r2,r6
001294  e1a01005          MOV      r1,r5
001298  e1a00004          MOV      r0,r4
00129c  ebfffffe          BL       _tu_fifo_write_n
;;;859    }
0012a0  e8bd8070          POP      {r4-r6,pc}
;;;860    
                          ENDP

                  tu_fifo_clear PROC
;;;868    /******************************************************************************/
;;;869    bool tu_fifo_clear(tu_fifo_t *f)
0012a4  e92d41f0          PUSH     {r4-r8,lr}
;;;870    {
0012a8  e1a04000          MOV      r4,r0
;;;871      _ff_lock(f->mutex_wr);
0012ac  e594500c          LDR      r5,[r4,#0xc]
0012b0  e3550000          CMP      r5,#0
0012b4  0a000011          BEQ      |L1.4864|
0012b8  e1a07005          MOV      r7,r5
0012bc  e3e06000          MVN      r6,#0
0012c0  e1a00006          MOV      r0,r6
0012c4  e3700001          CMN      r0,#1
0012c8  1a000001          BNE      |L1.4820|
0012cc  e1a01826          LSR      r1,r6,#16
0012d0  ea000005          B        |L1.4844|
                  |L1.4820|
0012d4  e51f1430          LDR      r1,|L1.3756|
0012d8  e1500001          CMP      r0,r1
0012dc  3a000000          BCC      |L1.4836|
0012e0  ea000001          B        |L1.4844|
                  |L1.4836|
0012e4  e1a01800          LSL      r1,r0,#16
0012e8  e1a01821          LSR      r1,r1,#16
                  |L1.4844|
0012ec  e1a00000          MOV      r0,r0
0012f0  e1a08001          MOV      r8,r1
0012f4  e1a00007          MOV      r0,r7
0012f8  ebfffffe          BL       os_mut_wait
0012fc  e1a00000          MOV      r0,r0
                  |L1.4864|
001300  e1a00000          MOV      r0,r0
001304  e1a00000          MOV      r0,r0
;;;872      _ff_lock(f->mutex_rd);
001308  e5945010          LDR      r5,[r4,#0x10]
00130c  e3550000          CMP      r5,#0
001310  0a000011          BEQ      |L1.4956|
001314  e1a07005          MOV      r7,r5
001318  e3e06000          MVN      r6,#0
00131c  e1a00006          MOV      r0,r6
001320  e3700001          CMN      r0,#1
001324  1a000001          BNE      |L1.4912|
001328  e1a01826          LSR      r1,r6,#16
00132c  ea000005          B        |L1.4936|
                  |L1.4912|
001330  e51f148c          LDR      r1,|L1.3756|
001334  e1500001          CMP      r0,r1
001338  3a000000          BCC      |L1.4928|
00133c  ea000001          B        |L1.4936|
                  |L1.4928|
001340  e1a01800          LSL      r1,r0,#16
001344  e1a01821          LSR      r1,r1,#16
                  |L1.4936|
001348  e1a00000          MOV      r0,r0
00134c  e1a08001          MOV      r8,r1
001350  e1a00007          MOV      r0,r7
001354  ebfffffe          BL       os_mut_wait
001358  e1a00000          MOV      r0,r0
                  |L1.4956|
00135c  e1a00000          MOV      r0,r0
001360  e1a00000          MOV      r0,r0
;;;873    
;;;874      f->rd_idx = 0;
001364  e3a00000          MOV      r0,#0
001368  e1c400ba          STRH     r0,[r4,#0xa]
;;;875      f->wr_idx = 0;
00136c  e1c400b8          STRH     r0,[r4,#8]
;;;876    
;;;877      _ff_unlock(f->mutex_wr);
001370  e594500c          LDR      r5,[r4,#0xc]
001374  e3550000          CMP      r5,#0
001378  0a000003          BEQ      |L1.5004|
00137c  e1a06005          MOV      r6,r5
001380  e1a00006          MOV      r0,r6
001384  ebfffffe          BL       os_mut_release
001388  e1a00000          MOV      r0,r0
                  |L1.5004|
00138c  e1a00000          MOV      r0,r0
001390  e1a00000          MOV      r0,r0
;;;878      _ff_unlock(f->mutex_rd);
001394  e5945010          LDR      r5,[r4,#0x10]
001398  e3550000          CMP      r5,#0
00139c  0a000003          BEQ      |L1.5040|
0013a0  e1a06005          MOV      r6,r5
0013a4  e1a00006          MOV      r0,r6
0013a8  ebfffffe          BL       os_mut_release
0013ac  e1a00000          MOV      r0,r0
                  |L1.5040|
0013b0  e1a00000          MOV      r0,r0
0013b4  e1a00000          MOV      r0,r0
;;;879      return true;
0013b8  e3a00001          MOV      r0,#1
;;;880    }
0013bc  e8bd81f0          POP      {r4-r8,pc}
;;;881    
                          ENDP

                  tu_fifo_set_overwritable PROC
;;;891    /******************************************************************************/
;;;892    bool tu_fifo_set_overwritable(tu_fifo_t *f, bool overwritable)
0013c0  e92d47f0          PUSH     {r4-r10,lr}
;;;893    {
0013c4  e1a04000          MOV      r4,r0
0013c8  e1a07001          MOV      r7,r1
;;;894      _ff_lock(f->mutex_wr);
0013cc  e594500c          LDR      r5,[r4,#0xc]
0013d0  e3550000          CMP      r5,#0
0013d4  0a000011          BEQ      |L1.5152|
0013d8  e1a08005          MOV      r8,r5
0013dc  e3e06000          MVN      r6,#0
0013e0  e1a00006          MOV      r0,r6
0013e4  e3700001          CMN      r0,#1
0013e8  1a000001          BNE      |L1.5108|
0013ec  e1a01826          LSR      r1,r6,#16
0013f0  ea000005          B        |L1.5132|
                  |L1.5108|
0013f4  e51f1550          LDR      r1,|L1.3756|
0013f8  e1500001          CMP      r0,r1
0013fc  3a000000          BCC      |L1.5124|
001400  ea000001          B        |L1.5132|
                  |L1.5124|
001404  e1a01800          LSL      r1,r0,#16
001408  e1a01821          LSR      r1,r1,#16
                  |L1.5132|
00140c  e1a00000          MOV      r0,r0
001410  e1a09001          MOV      r9,r1
001414  e1a00008          MOV      r0,r8
001418  ebfffffe          BL       os_mut_wait
00141c  e1a00000          MOV      r0,r0
                  |L1.5152|
001420  e1a00000          MOV      r0,r0
001424  e1a00000          MOV      r0,r0
;;;895      _ff_lock(f->mutex_rd);
001428  e5945010          LDR      r5,[r4,#0x10]
00142c  e3550000          CMP      r5,#0
001430  0a000011          BEQ      |L1.5244|
001434  e1a08005          MOV      r8,r5
001438  e3e06000          MVN      r6,#0
00143c  e1a00006          MOV      r0,r6
001440  e3700001          CMN      r0,#1
001444  1a000001          BNE      |L1.5200|
001448  e1a01826          LSR      r1,r6,#16
00144c  ea000005          B        |L1.5224|
                  |L1.5200|
001450  e51f15ac          LDR      r1,|L1.3756|
001454  e1500001          CMP      r0,r1
001458  3a000000          BCC      |L1.5216|
00145c  ea000001          B        |L1.5224|
                  |L1.5216|
001460  e1a01800          LSL      r1,r0,#16
001464  e1a01821          LSR      r1,r1,#16
                  |L1.5224|
001468  e1a00000          MOV      r0,r0
00146c  e1a09001          MOV      r9,r1
001470  e1a00008          MOV      r0,r8
001474  ebfffffe          BL       os_mut_wait
001478  e1a00000          MOV      r0,r0
                  |L1.5244|
00147c  e1a00000          MOV      r0,r0
001480  e1a00000          MOV      r0,r0
;;;896    
;;;897      f->overwritable = overwritable;
001484  e5d40007          LDRB     r0,[r4,#7]
001488  e3c00080          BIC      r0,r0,#0x80
00148c  e3a01080          MOV      r1,#0x80
001490  e0011387          AND      r1,r1,r7,LSL #7
001494  e1800001          ORR      r0,r0,r1
001498  e5c40007          STRB     r0,[r4,#7]
;;;898    
;;;899      _ff_unlock(f->mutex_wr);
00149c  e594500c          LDR      r5,[r4,#0xc]
0014a0  e3550000          CMP      r5,#0
0014a4  0a000003          BEQ      |L1.5304|
0014a8  e1a06005          MOV      r6,r5
0014ac  e1a00006          MOV      r0,r6
0014b0  ebfffffe          BL       os_mut_release
0014b4  e1a00000          MOV      r0,r0
                  |L1.5304|
0014b8  e1a00000          MOV      r0,r0
0014bc  e1a00000          MOV      r0,r0
;;;900      _ff_unlock(f->mutex_rd);
0014c0  e5945010          LDR      r5,[r4,#0x10]
0014c4  e3550000          CMP      r5,#0
0014c8  0a000003          BEQ      |L1.5340|
0014cc  e1a06005          MOV      r6,r5
0014d0  e1a00006          MOV      r0,r6
0014d4  ebfffffe          BL       os_mut_release
0014d8  e1a00000          MOV      r0,r0
                  |L1.5340|
0014dc  e1a00000          MOV      r0,r0
0014e0  e1a00000          MOV      r0,r0
;;;901    
;;;902      return true;
0014e4  e3a00001          MOV      r0,#1
;;;903    }
0014e8  e8bd87f0          POP      {r4-r10,pc}
;;;904    
                          ENDP

                  tu_fifo_advance_write_pointer PROC
;;;920    /******************************************************************************/
;;;921    void tu_fifo_advance_write_pointer(tu_fifo_t *f, uint16_t n)
0014ec  e92d4070          PUSH     {r4-r6,lr}
;;;922    {
0014f0  e1a04000          MOV      r4,r0
0014f4  e1a05001          MOV      r5,r1
;;;923      f->wr_idx = advance_index(f->depth, f->wr_idx, n);
0014f8  e1d410b8          LDRH     r1,[r4,#8]
0014fc  e1d400b4          LDRH     r0,[r4,#4]
001500  e1a02005          MOV      r2,r5
001504  ebfffffe          BL       advance_index
001508  e1c400b8          STRH     r0,[r4,#8]
;;;924    }
00150c  e8bd8070          POP      {r4-r6,pc}
;;;925    
                          ENDP

                  tu_fifo_advance_read_pointer PROC
;;;941    /******************************************************************************/
;;;942    void tu_fifo_advance_read_pointer(tu_fifo_t *f, uint16_t n)
001510  e92d4070          PUSH     {r4-r6,lr}
;;;943    {
001514  e1a04000          MOV      r4,r0
001518  e1a05001          MOV      r5,r1
;;;944      f->rd_idx = advance_index(f->depth, f->rd_idx, n);
00151c  e1d410ba          LDRH     r1,[r4,#0xa]
001520  e1d400b4          LDRH     r0,[r4,#4]
001524  e1a02005          MOV      r2,r5
001528  ebfffffe          BL       advance_index
00152c  e1c400ba          STRH     r0,[r4,#0xa]
;;;945    }
001530  e8bd8070          POP      {r4-r6,pc}
;;;946    
                          ENDP

                  tu_fifo_get_read_info PROC
;;;961    /******************************************************************************/
;;;962    void tu_fifo_get_read_info(tu_fifo_t *f, tu_fifo_buffer_info_t *info)
001534  e92d4ffe          PUSH     {r1-r11,lr}
;;;963    {
001538  e1a04000          MOV      r4,r0
00153c  e1a05001          MOV      r5,r1
;;;964      // Operate on temporary values in case they change in between
;;;965      uint16_t wr_idx = f->wr_idx;
001540  e1d460b8          LDRH     r6,[r4,#8]
;;;966      uint16_t rd_idx = f->rd_idx;
001544  e1d490ba          LDRH     r9,[r4,#0xa]
;;;967    
;;;968      uint16_t cnt = _ff_count(f->depth, wr_idx, rd_idx);
001548  e1d420b4          LDRH     r2,[r4,#4]
00154c  e1a00006          MOV      r0,r6
001550  e1a01009          MOV      r1,r9
001554  e1500001          CMP      r0,r1
001558  ba000003          BLT      |L1.5484|
00155c  e0403001          SUB      r3,r0,r1
001560  e1a03803          LSL      r3,r3,#16
001564  e1a03823          LSR      r3,r3,#16
001568  ea000003          B        |L1.5500|
                  |L1.5484|
00156c  e041c000          SUB      r12,r1,r0
001570  e06c3082          RSB      r3,r12,r2,LSL #1
001574  e1a03803          LSL      r3,r3,#16
001578  e1a03823          LSR      r3,r3,#16
                  |L1.5500|
00157c  e1a00000          MOV      r0,r0
001580  e1a07003          MOV      r7,r3
;;;969    
;;;970      // Check overflow and correct if required - may happen in case a DMA wrote too fast
;;;971      if (cnt > f->depth)
001584  e1d400b4          LDRH     r0,[r4,#4]
001588  e1500007          CMP      r0,r7
00158c  aa000032          BGE      |L1.5724|
;;;972      {
;;;973        _ff_lock(f->mutex_rd);
001590  e594a010          LDR      r10,[r4,#0x10]
001594  e35a0000          CMP      r10,#0
001598  0a000011          BEQ      |L1.5604|
00159c  e3e0b000          MVN      r11,#0
0015a0  e58da004          STR      r10,[sp,#4]
0015a4  e1a0000b          MOV      r0,r11
0015a8  e3700001          CMN      r0,#1
0015ac  1a000001          BNE      |L1.5560|
0015b0  e1a0182b          LSR      r1,r11,#16
0015b4  ea000005          B        |L1.5584|
                  |L1.5560|
0015b8  e51f1714          LDR      r1,|L1.3756|
0015bc  e1500001          CMP      r0,r1
0015c0  3a000000          BCC      |L1.5576|
0015c4  ea000001          B        |L1.5584|
                  |L1.5576|
0015c8  e1a01800          LSL      r1,r0,#16
0015cc  e1a01821          LSR      r1,r1,#16
                  |L1.5584|
0015d0  e1a00000          MOV      r0,r0
0015d4  e58d1000          STR      r1,[sp,#0]
0015d8  e59d0004          LDR      r0,[sp,#4]
0015dc  ebfffffe          BL       os_mut_wait
0015e0  e1a00000          MOV      r0,r0
                  |L1.5604|
0015e4  e1a00000          MOV      r0,r0
0015e8  e1a00000          MOV      r0,r0
;;;974        rd_idx = _ff_correct_read_index(f, wr_idx);
0015ec  e1a00004          MOV      r0,r4
0015f0  e1a01006          MOV      r1,r6
0015f4  e1d030b4          LDRH     r3,[r0,#4]
0015f8  e1530001          CMP      r3,r1
0015fc  ca000004          BGT      |L1.5652|
001600  e1d030b4          LDRH     r3,[r0,#4]
001604  e0413003          SUB      r3,r1,r3
001608  e1a02803          LSL      r2,r3,#16
00160c  e1a02822          LSR      r2,r2,#16
001610  ea000003          B        |L1.5668|
                  |L1.5652|
001614  e1d030b4          LDRH     r3,[r0,#4]
001618  e0833001          ADD      r3,r3,r1
00161c  e1a02803          LSL      r2,r3,#16
001620  e1a02822          LSR      r2,r2,#16
                  |L1.5668|
001624  e1a00000          MOV      r0,r0
001628  e1c020ba          STRH     r2,[r0,#0xa]
00162c  e1a00000          MOV      r0,r0
001630  e1a09002          MOV      r9,r2
;;;975        _ff_unlock(f->mutex_rd);
001634  e594a010          LDR      r10,[r4,#0x10]
001638  e35a0000          CMP      r10,#0
00163c  0a000003          BEQ      |L1.5712|
001640  e1a0b00a          MOV      r11,r10
001644  e1a0000b          MOV      r0,r11
001648  ebfffffe          BL       os_mut_release
00164c  e1a00000          MOV      r0,r0
                  |L1.5712|
001650  e1a00000          MOV      r0,r0
001654  e1a00000          MOV      r0,r0
;;;976    
;;;977        cnt = f->depth;
001658  e1d470b4          LDRH     r7,[r4,#4]
                  |L1.5724|
;;;978      }
;;;979    
;;;980      // Check if fifo is empty
;;;981      if (cnt == 0)
00165c  e3570000          CMP      r7,#0
001660  1a000005          BNE      |L1.5756|
;;;982      {
;;;983        info->len_lin  = 0;
001664  e3a00000          MOV      r0,#0
001668  e1c500b0          STRH     r0,[r5,#0]
;;;984        info->len_wrap = 0;
00166c  e1c500b2          STRH     r0,[r5,#2]
;;;985        info->ptr_lin  = NULL;
001670  e5850004          STR      r0,[r5,#4]
;;;986        info->ptr_wrap = NULL;
001674  e5850008          STR      r0,[r5,#8]
                  |L1.5752|
;;;987        return;
;;;988      }
;;;989    
;;;990      // Get relative pointers
;;;991      uint16_t wr_ptr = idx2ptr(f->depth, wr_idx);
;;;992      uint16_t rd_ptr = idx2ptr(f->depth, rd_idx);
;;;993    
;;;994      // Copy pointer to buffer to start reading from
;;;995      info->ptr_lin = &f->buffer[rd_ptr];
;;;996    
;;;997      // Check if there is a wrap around necessary
;;;998      if (wr_ptr > rd_ptr)
;;;999      {
;;;1000       // Non wrapping case
;;;1001       info->len_lin  = cnt;
;;;1002   
;;;1003       info->len_wrap = 0;
;;;1004       info->ptr_wrap = NULL;
;;;1005     }
;;;1006     else
;;;1007     {
;;;1008       info->len_lin  = f->depth - rd_ptr;   // Also the case if FIFO was full
;;;1009   
;;;1010       info->len_wrap = cnt - info->len_lin;
;;;1011       info->ptr_wrap = f->buffer;
;;;1012     }
;;;1013   }
001678  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.5756|
00167c  e1d410b4          LDRH     r1,[r4,#4]            ;991
001680  e1a00006          MOV      r0,r6                 ;991
001684  ea000002          B        |L1.5780|
                  |L1.5768|
001688  e0402001          SUB      r2,r0,r1              ;991
00168c  e1a00802          LSL      r0,r2,#16             ;991
001690  e1a00820          LSR      r0,r0,#16             ;991
                  |L1.5780|
001694  e1500001          CMP      r0,r1                 ;991
001698  aafffffa          BGE      |L1.5768|
00169c  e58d0008          STR      r0,[sp,#8]            ;991
0016a0  e1d410b4          LDRH     r1,[r4,#4]            ;992
0016a4  e1a00009          MOV      r0,r9                 ;992
0016a8  ea000002          B        |L1.5816|
                  |L1.5804|
0016ac  e0402001          SUB      r2,r0,r1              ;992
0016b0  e1a00802          LSL      r0,r2,#16             ;992
0016b4  e1a00820          LSR      r0,r0,#16             ;992
                  |L1.5816|
0016b8  e1500001          CMP      r0,r1                 ;992
0016bc  aafffffa          BGE      |L1.5804|
0016c0  e1a08000          MOV      r8,r0                 ;992
0016c4  e5941000          LDR      r1,[r4,#0]            ;995
0016c8  e0810008          ADD      r0,r1,r8              ;995
0016cc  e5850004          STR      r0,[r5,#4]            ;995
0016d0  e59d1008          LDR      r1,[sp,#8]            ;998
0016d4  e1510008          CMP      r1,r8                 ;998
0016d8  da000004          BLE      |L1.5872|
0016dc  e1c570b0          STRH     r7,[r5,#0]            ;1001
0016e0  e3a00000          MOV      r0,#0                 ;1003
0016e4  e1c500b2          STRH     r0,[r5,#2]            ;1003
0016e8  e5850008          STR      r0,[r5,#8]            ;1004
0016ec  ea000007          B        |L1.5904|
                  |L1.5872|
0016f0  e1d400b4          LDRH     r0,[r4,#4]            ;1008
0016f4  e0400008          SUB      r0,r0,r8              ;1008
0016f8  e1c500b0          STRH     r0,[r5,#0]            ;1008
0016fc  e1d500b0          LDRH     r0,[r5,#0]            ;1010
001700  e0470000          SUB      r0,r7,r0              ;1010
001704  e1c500b2          STRH     r0,[r5,#2]            ;1010
001708  e5940000          LDR      r0,[r4,#0]            ;1011
00170c  e5850008          STR      r0,[r5,#8]            ;1011
                  |L1.5904|
001710  e1a00000          MOV      r0,r0
001714  eaffffd7          B        |L1.5752|
;;;1014   
                          ENDP

                  tu_fifo_get_write_info PROC
;;;1029   /******************************************************************************/
;;;1030   void tu_fifo_get_write_info(tu_fifo_t *f, tu_fifo_buffer_info_t *info)
001718  e92d4ffc          PUSH     {r2-r11,lr}
;;;1031   {
;;;1032     uint16_t wr_idx = f->wr_idx;
00171c  e1d040b8          LDRH     r4,[r0,#8]
;;;1033     uint16_t rd_idx = f->rd_idx;
001720  e1d050ba          LDRH     r5,[r0,#0xa]
;;;1034     uint16_t remain = _ff_remaining(f->depth, wr_idx, rd_idx);
001724  e1d070b4          LDRH     r7,[r0,#4]
001728  e1a09004          MOV      r9,r4
00172c  e1a0a005          MOV      r10,r5
001730  e1a03009          MOV      r3,r9
001734  e1a0c00a          MOV      r12,r10
001738  e58d7000          STR      r7,[sp,#0]
00173c  e153000c          CMP      r3,r12
001740  ba000003          BLT      |L1.5972|
001744  e043b00c          SUB      r11,r3,r12
001748  e1a0b80b          LSL      r11,r11,#16
00174c  e1a0b82b          LSR      r11,r11,#16
001750  ea000004          B        |L1.5992|
                  |L1.5972|
001754  e04ce003          SUB      lr,r12,r3
001758  e59db000          LDR      r11,[sp,#0]
00175c  e06eb08b          RSB      r11,lr,r11,LSL #1
001760  e1a0b80b          LSL      r11,r11,#16
001764  e1a0b82b          LSR      r11,r11,#16
                  |L1.5992|
001768  e1a00000          MOV      r0,r0
00176c  e58db004          STR      r11,[sp,#4]
001770  e59db004          LDR      r11,[sp,#4]
001774  e157000b          CMP      r7,r11
001778  da000002          BLE      |L1.6024|
00177c  e59d3004          LDR      r3,[sp,#4]
001780  e0473003          SUB      r3,r7,r3
001784  ea000000          B        |L1.6028|
                  |L1.6024|
001788  e3a03000          MOV      r3,#0
                  |L1.6028|
00178c  e1a06803          LSL      r6,r3,#16
001790  e1a06826          LSR      r6,r6,#16
001794  e1a00000          MOV      r0,r0
;;;1035   
;;;1036     if (remain == 0)
001798  e3560000          CMP      r6,#0
00179c  1a000005          BNE      |L1.6072|
;;;1037     {
;;;1038       info->len_lin  = 0;
0017a0  e3a03000          MOV      r3,#0
0017a4  e1c130b0          STRH     r3,[r1,#0]
;;;1039       info->len_wrap = 0;
0017a8  e1c130b2          STRH     r3,[r1,#2]
;;;1040       info->ptr_lin  = NULL;
0017ac  e5813004          STR      r3,[r1,#4]
;;;1041       info->ptr_wrap = NULL;
0017b0  e5813008          STR      r3,[r1,#8]
                  |L1.6068|
;;;1042       return;
;;;1043     }
;;;1044   
;;;1045     // Get relative pointers
;;;1046     uint16_t wr_ptr = idx2ptr(f->depth, wr_idx);
;;;1047     uint16_t rd_ptr = idx2ptr(f->depth, rd_idx);
;;;1048   
;;;1049     // Copy pointer to buffer to start writing to
;;;1050     info->ptr_lin = &f->buffer[wr_ptr];
;;;1051   
;;;1052     if (wr_ptr < rd_ptr)
;;;1053     {
;;;1054       // Non wrapping case
;;;1055       info->len_lin  = rd_ptr-wr_ptr;
;;;1056       info->len_wrap = 0;
;;;1057       info->ptr_wrap = NULL;
;;;1058     }
;;;1059     else
;;;1060     {
;;;1061       info->len_lin  = f->depth - wr_ptr;
;;;1062       info->len_wrap = remain - info->len_lin; // Remaining length - n already was limited to remain or FIFO depth
;;;1063       info->ptr_wrap = f->buffer;              // Always start of buffer
;;;1064     }
;;;1065   }
0017b4  e8bd8ffc          POP      {r2-r11,pc}
                  |L1.6072|
0017b8  e1d0c0b4          LDRH     r12,[r0,#4]           ;1046
0017bc  e1a03004          MOV      r3,r4                 ;1046
0017c0  ea000002          B        |L1.6096|
                  |L1.6084|
0017c4  e043700c          SUB      r7,r3,r12             ;1046
0017c8  e1a03807          LSL      r3,r7,#16             ;1046
0017cc  e1a03823          LSR      r3,r3,#16             ;1046
                  |L1.6096|
0017d0  e153000c          CMP      r3,r12                ;1046
0017d4  aafffffa          BGE      |L1.6084|
0017d8  e1a02003          MOV      r2,r3                 ;1046
0017dc  e1d0c0b4          LDRH     r12,[r0,#4]           ;1047
0017e0  e1a03005          MOV      r3,r5                 ;1047
0017e4  ea000002          B        |L1.6132|
                  |L1.6120|
0017e8  e043700c          SUB      r7,r3,r12             ;1047
0017ec  e1a03807          LSL      r3,r7,#16             ;1047
0017f0  e1a03823          LSR      r3,r3,#16             ;1047
                  |L1.6132|
0017f4  e153000c          CMP      r3,r12                ;1047
0017f8  aafffffa          BGE      |L1.6120|
0017fc  e1a08003          MOV      r8,r3                 ;1047
001800  e5903000          LDR      r3,[r0,#0]            ;1050
001804  e0833002          ADD      r3,r3,r2              ;1050
001808  e5813004          STR      r3,[r1,#4]            ;1050
00180c  e1520008          CMP      r2,r8                 ;1052
001810  aa000005          BGE      |L1.6188|
001814  e0483002          SUB      r3,r8,r2              ;1055
001818  e1c130b0          STRH     r3,[r1,#0]            ;1055
00181c  e3a03000          MOV      r3,#0                 ;1056
001820  e1c130b2          STRH     r3,[r1,#2]            ;1056
001824  e5813008          STR      r3,[r1,#8]            ;1057
001828  ea000007          B        |L1.6220|
                  |L1.6188|
00182c  e1d030b4          LDRH     r3,[r0,#4]            ;1061
001830  e0433002          SUB      r3,r3,r2              ;1061
001834  e1c130b0          STRH     r3,[r1,#0]            ;1061
001838  e1d130b0          LDRH     r3,[r1,#0]            ;1062
00183c  e0463003          SUB      r3,r6,r3              ;1062
001840  e1c130b2          STRH     r3,[r1,#2]            ;1062
001844  e5903000          LDR      r3,[r0,#0]            ;1063
001848  e5813008          STR      r3,[r1,#8]            ;1063
                  |L1.6220|
00184c  e1a00000          MOV      r0,r0
001850  eaffffd7          B        |L1.6068|
                          ENDP

