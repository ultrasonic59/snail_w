; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave --gnu -o.\temp\obj\printf.o --asm_dir=.\Temp\Lst\ --list_dir=.\Temp\Lst\ --depend=.\temp\obj\printf.d --cpu=ARM9E --apcs=interwork -O0 -Otime --diag_suppress=9931 -I.\users\include -I.\..\machine\include -I.\..\periph\include -I.\..\include -I.\..\emwin\Include -I.\..\tinyusb\src -I.\..\tinyusb\hw -I.\..\display -I.\..\lib\display_gfx -I.\..\lib\printf -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Atmel\SAM9260 -D__RTX -D__UVISION_VERSION=536 -DPCB_TINY200V1 -DCFG_TUSB_MCU=OPT_MCU_F1C100S -DCFG_TUSB_OS=OPT_OS_RTX4 --omf_browse=.\temp\obj\printf.crf ..\lib\printf\printf.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  putchar_via_gadget PROC
;;;318    // assumes that the output gadget has been properly initialized.
;;;319    static inline void putchar_via_gadget(output_gadget_t* gadget, char c) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;320        printf_size_t write_pos = gadget->pos++;
00000c  e594600c          LDR      r6,[r4,#0xc]
000010  e2860001          ADD      r0,r6,#1
000014  e584000c          STR      r0,[r4,#0xc]
;;;321        // We're _always_ increasing pos, so as to count how may characters
;;;322        // _would_ have been written if not for the max_chars limitation
;;;323        if(write_pos >= gadget->max_chars) {
000018  e5940010          LDR      r0,[r4,#0x10]
00001c  e1500006          CMP      r0,r6
000020  8a000000          BHI      |L1.40|
                  |L1.36|
;;;324            return;
;;;325        }
;;;326        if(gadget->function != NULL) {
;;;327            // No check for c == '\0' .
;;;328            gadget->function(c, gadget->extra_function_arg);
;;;329        } else {
;;;330            // it must be the case that gadget->buffer != NULL , due to the constraint
;;;331            // on output_gadget_t ; and note we're relying on write_pos being non-negative.
;;;332            gadget->buffer[write_pos] = c;
;;;333        }
;;;334    }
000024  e8bd8070          POP      {r4-r6,pc}
                  |L1.40|
000028  e5940000          LDR      r0,[r4,#0]            ;326
00002c  e3500000          CMP      r0,#0                 ;326
000030  0a000004          BEQ      |L1.72|
000034  e1a00005          MOV      r0,r5                 ;328
000038  e5941004          LDR      r1,[r4,#4]            ;328
00003c  e5942000          LDR      r2,[r4,#0]            ;328
000040  e12fff32          BLX      r2                    ;328
000044  ea000001          B        |L1.80|
                  |L1.72|
000048  e5940008          LDR      r0,[r4,#8]            ;332
00004c  e7c05006          STRB     r5,[r0,r6]            ;332
                  |L1.80|
000050  e1a00000          MOV      r0,r0
000054  eafffff2          B        |L1.36|
;;;335    
                          ENDP

                  discarding_gadget PROC
;;;355    
;;;356    static inline output_gadget_t discarding_gadget(void) {
000058  e92d4010          PUSH     {r4,lr}
00005c  e24dd018          SUB      sp,sp,#0x18
000060  e1a04000          MOV      r4,r0
;;;357        output_gadget_t gadget;
;;;358        gadget.function           = NULL;
000064  e3a00000          MOV      r0,#0
000068  e58d0004          STR      r0,[sp,#4]
;;;359        gadget.extra_function_arg = NULL;
00006c  e58d0008          STR      r0,[sp,#8]
;;;360        gadget.buffer             = NULL;
000070  e58d000c          STR      r0,[sp,#0xc]
;;;361        gadget.pos                = 0;
000074  e58d0010          STR      r0,[sp,#0x10]
;;;362        gadget.max_chars          = 0;
000078  e58d0014          STR      r0,[sp,#0x14]
;;;363        return gadget;
00007c  e3a02014          MOV      r2,#0x14
000080  e28d1004          ADD      r1,sp,#4
000084  e1a00004          MOV      r0,r4
000088  ebfffffe          BL       __aeabi_memcpy4
;;;364    }
00008c  e28dd018          ADD      sp,sp,#0x18
000090  e8bd8010          POP      {r4,pc}
;;;365    
                          ENDP

                  function_gadget PROC
;;;377    
;;;378    static inline output_gadget_t function_gadget(void (*function)(char, void*), void* extra_arg) {
000094  e92d4070          PUSH     {r4-r6,lr}
000098  e24dd018          SUB      sp,sp,#0x18
00009c  e1a06000          MOV      r6,r0
0000a0  e1a04001          MOV      r4,r1
0000a4  e1a05002          MOV      r5,r2
;;;379        output_gadget_t result    = discarding_gadget();
0000a8  e28d0004          ADD      r0,sp,#4
0000ac  ebfffffe          BL       discarding_gadget
;;;380        result.function           = function;
0000b0  e58d4004          STR      r4,[sp,#4]
;;;381        result.extra_function_arg = extra_arg;
0000b4  e58d5008          STR      r5,[sp,#8]
;;;382        result.max_chars          = PRINTF_MAX_POSSIBLE_BUFFER_SIZE;
0000b8  e3e00102          MVN      r0,#0x80000000
0000bc  e58d0014          STR      r0,[sp,#0x14]
;;;383        return result;
0000c0  e3a02014          MOV      r2,#0x14
0000c4  e28d1004          ADD      r1,sp,#4
0000c8  e1a00006          MOV      r0,r6
0000cc  ebfffffe          BL       __aeabi_memcpy4
;;;384    }
0000d0  e28dd018          ADD      sp,sp,#0x18
0000d4  e8bd8070          POP      {r4-r6,pc}
;;;385    
                          ENDP

                  atou_ PROC
;;;407    // internal ASCII string to printf_size_t conversion
;;;408    static printf_size_t atou_(const char** str) {
0000d8  e92d4070          PUSH     {r4-r6,lr}
0000dc  e1a04000          MOV      r4,r0
;;;409        printf_size_t i = 0U;
0000e0  e3a05000          MOV      r5,#0
;;;410        while(is_digit_(**str)) {
0000e4  ea000006          B        |L1.260|
                  |L1.232|
;;;411            i = i * 10U + (printf_size_t)(*((*str)++) - '0');
0000e8  e5940000          LDR      r0,[r4,#0]
0000ec  e2801001          ADD      r1,r0,#1
0000f0  e5841000          STR      r1,[r4,#0]
0000f4  e5d00000          LDRB     r0,[r0,#0]
0000f8  e2400030          SUB      r0,r0,#0x30
0000fc  e0851105          ADD      r1,r5,r5,LSL #2
000100  e0805081          ADD      r5,r0,r1,LSL #1
                  |L1.260|
000104  e5941000          LDR      r1,[r4,#0]            ;410
000108  e5d10000          LDRB     r0,[r1,#0]            ;410
00010c  ebfffffe          BL       is_digit_
000110  e3500000          CMP      r0,#0                 ;410
000114  1afffff3          BNE      |L1.232|
;;;412        }
;;;413        return i;
000118  e1a00005          MOV      r0,r5
;;;414    }
00011c  e8bd8070          POP      {r4-r6,pc}
;;;415    
                          ENDP

                  out_rev_ PROC
;;;416    // output the specified string in reverse, taking care of any zero-padding
;;;417    static void out_rev_(
000120  e92d47f0          PUSH     {r4-r10,lr}
;;;418        output_gadget_t* output,
;;;419        const char* buf,
;;;420        printf_size_t len,
;;;421        printf_size_t width,
;;;422        printf_flags_t flags) {
000124  e1a05000          MOV      r5,r0
000128  e1a08001          MOV      r8,r1
00012c  e1a04002          MOV      r4,r2
000130  e1a06003          MOV      r6,r3
000134  e59d7020          LDR      r7,[sp,#0x20]
;;;423        const printf_size_t start_pos = output->pos;
000138  e595a00c          LDR      r10,[r5,#0xc]
;;;424    
;;;425        // pad spaces up to given width
;;;426        if(!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
00013c  e2070002          AND      r0,r7,#2
000140  e3500000          CMP      r0,#0
000144  1a00000a          BNE      |L1.372|
000148  e2070001          AND      r0,r7,#1
00014c  e3500000          CMP      r0,#0
000150  1a000007          BNE      |L1.372|
;;;427            for(printf_size_t i = len; i < width; i++) {
000154  e1a09004          MOV      r9,r4
000158  ea000003          B        |L1.364|
                  |L1.348|
;;;428                putchar_via_gadget(output, ' ');
00015c  e3a01020          MOV      r1,#0x20
000160  e1a00005          MOV      r0,r5
000164  ebfffffe          BL       putchar_via_gadget
000168  e2899001          ADD      r9,r9,#1              ;427
                  |L1.364|
00016c  e1590006          CMP      r9,r6                 ;427
000170  3afffff9          BCC      |L1.348|
                  |L1.372|
;;;429            }
;;;430        }
;;;431    
;;;432        // reverse string
;;;433        while(len) {
000174  ea000004          B        |L1.396|
                  |L1.376|
;;;434            putchar_via_gadget(output, buf[--len]);
000178  e2440001          SUB      r0,r4,#1
00017c  e1a04000          MOV      r4,r0
000180  e7d81000          LDRB     r1,[r8,r0]
000184  e1a00005          MOV      r0,r5
000188  ebfffffe          BL       putchar_via_gadget
                  |L1.396|
00018c  e3540000          CMP      r4,#0                 ;433
000190  1afffff8          BNE      |L1.376|
;;;435        }
;;;436    
;;;437        // append pad spaces up to given width
;;;438        if(flags & FLAGS_LEFT) {
000194  e2070002          AND      r0,r7,#2
000198  e3500000          CMP      r0,#0
00019c  0a000007          BEQ      |L1.448|
;;;439            while(output->pos - start_pos < width) {
0001a0  ea000002          B        |L1.432|
                  |L1.420|
;;;440                putchar_via_gadget(output, ' ');
0001a4  e3a01020          MOV      r1,#0x20
0001a8  e1a00005          MOV      r0,r5
0001ac  ebfffffe          BL       putchar_via_gadget
                  |L1.432|
0001b0  e595000c          LDR      r0,[r5,#0xc]          ;439
0001b4  e040000a          SUB      r0,r0,r10             ;439
0001b8  e1500006          CMP      r0,r6                 ;439
0001bc  3afffff8          BCC      |L1.420|
                  |L1.448|
;;;441            }
;;;442        }
;;;443    }
0001c0  e8bd87f0          POP      {r4-r10,pc}
;;;444    
                          ENDP

                  print_integer_finalization PROC
;;;446    // work on the number's prefix (as the number is initially printed in reverse order)
;;;447    static void print_integer_finalization(
0001c4  e92d4fff          PUSH     {r0-r11,lr}
;;;448        output_gadget_t* output,
;;;449        char* buf,
;;;450        printf_size_t len,
;;;451        bool negative,
;;;452        numeric_base_t base,
;;;453        printf_size_t precision,
;;;454        printf_size_t width,
;;;455        printf_flags_t flags) {
0001c8  e24dd004          SUB      sp,sp,#4
0001cc  e1a06001          MOV      r6,r1
0001d0  e1a04002          MOV      r4,r2
0001d4  e1a09003          MOV      r9,r3
0001d8  e59d5044          LDR      r5,[sp,#0x44]
0001dc  e59d7038          LDR      r7,[sp,#0x38]
0001e0  e59db03c          LDR      r11,[sp,#0x3c]
0001e4  e59d8040          LDR      r8,[sp,#0x40]
;;;456        printf_size_t unpadded_len = len;
0001e8  e1a0a004          MOV      r10,r4
;;;457    
;;;458        // pad with leading zeros
;;;459        {
;;;460            if(!(flags & FLAGS_LEFT)) {
0001ec  e2050002          AND      r0,r5,#2
0001f0  e3500000          CMP      r0,#0
0001f4  1a000016          BNE      |L1.596|
;;;461                if(width && (flags & FLAGS_ZEROPAD) &&
0001f8  e3580000          CMP      r8,#0
0001fc  0a000008          BEQ      |L1.548|
000200  e2050001          AND      r0,r5,#1
000204  e3500000          CMP      r0,#0
000208  0a000005          BEQ      |L1.548|
;;;462                   (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
00020c  e3590000          CMP      r9,#0
000210  1a000002          BNE      |L1.544|
000214  e205000c          AND      r0,r5,#0xc
000218  e3500000          CMP      r0,#0
00021c  0a000000          BEQ      |L1.548|
                  |L1.544|
;;;463                    width--;
000220  e2488001          SUB      r8,r8,#1
                  |L1.548|
;;;464                }
;;;465                while((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_INTEGER_BUFFER_SIZE)) {
000224  ea000003          B        |L1.568|
                  |L1.552|
;;;466                    buf[len++] = '0';
000228  e3a01030          MOV      r1,#0x30
00022c  e1a00004          MOV      r0,r4
000230  e2844001          ADD      r4,r4,#1
000234  e7c61000          STRB     r1,[r6,r0]
                  |L1.568|
000238  e2050001          AND      r0,r5,#1              ;465
00023c  e3500000          CMP      r0,#0                 ;465
000240  0a000003          BEQ      |L1.596|
000244  e1540008          CMP      r4,r8                 ;465
000248  2a000001          BCS      |L1.596|
00024c  e3540020          CMP      r4,#0x20              ;465
000250  3afffff4          BCC      |L1.552|
                  |L1.596|
;;;467                }
;;;468            }
;;;469    
;;;470            while((len < precision) && (len < PRINTF_INTEGER_BUFFER_SIZE)) {
000254  ea000003          B        |L1.616|
                  |L1.600|
;;;471                buf[len++] = '0';
000258  e3a01030          MOV      r1,#0x30
00025c  e1a00004          MOV      r0,r4
000260  e2844001          ADD      r4,r4,#1
000264  e7c61000          STRB     r1,[r6,r0]
                  |L1.616|
000268  e154000b          CMP      r4,r11                ;470
00026c  2a000001          BCS      |L1.632|
000270  e3540020          CMP      r4,#0x20              ;470
000274  3afffff7          BCC      |L1.600|
                  |L1.632|
;;;472            }
;;;473    
;;;474            if(base == BASE_OCTAL && (len > unpadded_len)) {
000278  e3570008          CMP      r7,#8
00027c  1a000002          BNE      |L1.652|
000280  e154000a          CMP      r4,r10
000284  9a000000          BLS      |L1.652|
;;;475                // Since we've written some zeros, we've satisfied the alternative format leading space requirement
;;;476                flags &= ~FLAGS_HASH;
000288  e3c55010          BIC      r5,r5,#0x10
                  |L1.652|
;;;477            }
;;;478        }
;;;479    
;;;480        // handle hash
;;;481        if(flags & (FLAGS_HASH | FLAGS_POINTER)) {
00028c  e59f0e54          LDR      r0,|L1.4328|
000290  e0000005          AND      r0,r0,r5
000294  e3500000          CMP      r0,#0
000298  0a00003a          BEQ      |L1.904|
;;;482            if(!(flags & FLAGS_PRECISION) && len && ((len == precision) || (len == width))) {
00029c  e2050b02          AND      r0,r5,#0x800
0002a0  e3500000          CMP      r0,#0
0002a4  1a000011          BNE      |L1.752|
0002a8  e3540000          CMP      r4,#0
0002ac  0a00000f          BEQ      |L1.752|
0002b0  e154000b          CMP      r4,r11
0002b4  0a000001          BEQ      |L1.704|
0002b8  e1540008          CMP      r4,r8
0002bc  1a00000b          BNE      |L1.752|
                  |L1.704|
;;;483                // Let's take back some padding digits to fit in what will eventually
;;;484                // be the format-specific prefix
;;;485                if(unpadded_len < len) {
0002c0  e15a0004          CMP      r10,r4
0002c4  2a000000          BCS      |L1.716|
;;;486                    len--; // This should suffice for BASE_OCTAL
0002c8  e2444001          SUB      r4,r4,#1
                  |L1.716|
;;;487                }
;;;488                if(len && (base == BASE_HEX || base == BASE_BINARY) && (unpadded_len < len)) {
0002cc  e3540000          CMP      r4,#0
0002d0  0a000006          BEQ      |L1.752|
0002d4  e3570010          CMP      r7,#0x10
0002d8  0a000001          BEQ      |L1.740|
0002dc  e3570002          CMP      r7,#2
0002e0  1a000002          BNE      |L1.752|
                  |L1.740|
0002e4  e15a0004          CMP      r10,r4
0002e8  2a000000          BCS      |L1.752|
;;;489                    len--; // ... and an extra one for 0x or 0b
0002ec  e2444001          SUB      r4,r4,#1
                  |L1.752|
;;;490                }
;;;491            }
;;;492            if((base == BASE_HEX) && !(flags & FLAGS_UPPERCASE) &&
0002f0  e3570010          CMP      r7,#0x10
0002f4  1a000009          BNE      |L1.800|
0002f8  e2050020          AND      r0,r5,#0x20
0002fc  e3500000          CMP      r0,#0
000300  1a000006          BNE      |L1.800|
;;;493               (len < PRINTF_INTEGER_BUFFER_SIZE)) {
000304  e3540020          CMP      r4,#0x20
000308  2a000004          BCS      |L1.800|
;;;494                buf[len++] = 'x';
00030c  e3a01078          MOV      r1,#0x78
000310  e1a00004          MOV      r0,r4
000314  e2844001          ADD      r4,r4,#1
000318  e7c61000          STRB     r1,[r6,r0]
00031c  ea000013          B        |L1.880|
                  |L1.800|
;;;495            } else if(
000320  e3570010          CMP      r7,#0x10
000324  1a000009          BNE      |L1.848|
;;;496                (base == BASE_HEX) && (flags & FLAGS_UPPERCASE) &&
000328  e2050020          AND      r0,r5,#0x20
00032c  e3500000          CMP      r0,#0
000330  0a000006          BEQ      |L1.848|
;;;497                (len < PRINTF_INTEGER_BUFFER_SIZE)) {
000334  e3540020          CMP      r4,#0x20
000338  2a000004          BCS      |L1.848|
;;;498                buf[len++] = 'X';
00033c  e3a01058          MOV      r1,#0x58
000340  e1a00004          MOV      r0,r4
000344  e2844001          ADD      r4,r4,#1
000348  e7c61000          STRB     r1,[r6,r0]
00034c  ea000007          B        |L1.880|
                  |L1.848|
;;;499            } else if((base == BASE_BINARY) && (len < PRINTF_INTEGER_BUFFER_SIZE)) {
000350  e3570002          CMP      r7,#2
000354  1a000005          BNE      |L1.880|
000358  e3540020          CMP      r4,#0x20
00035c  2a000003          BCS      |L1.880|
;;;500                buf[len++] = 'b';
000360  e3a01062          MOV      r1,#0x62
000364  e1a00004          MOV      r0,r4
000368  e2844001          ADD      r4,r4,#1
00036c  e7c61000          STRB     r1,[r6,r0]
                  |L1.880|
;;;501            }
;;;502            if(len < PRINTF_INTEGER_BUFFER_SIZE) {
000370  e3540020          CMP      r4,#0x20
000374  2a000003          BCS      |L1.904|
;;;503                buf[len++] = '0';
000378  e3a01030          MOV      r1,#0x30
00037c  e1a00004          MOV      r0,r4
000380  e2844001          ADD      r4,r4,#1
000384  e7c61000          STRB     r1,[r6,r0]
                  |L1.904|
;;;504            }
;;;505        }
;;;506    
;;;507        if(len < PRINTF_INTEGER_BUFFER_SIZE) {
000388  e3540020          CMP      r4,#0x20
00038c  2a000015          BCS      |L1.1000|
;;;508            if(negative) {
000390  e3590000          CMP      r9,#0
000394  0a000004          BEQ      |L1.940|
;;;509                buf[len++] = '-';
000398  e3a0102d          MOV      r1,#0x2d
00039c  e1a00004          MOV      r0,r4
0003a0  e2844001          ADD      r4,r4,#1
0003a4  e7c61000          STRB     r1,[r6,r0]
0003a8  ea00000e          B        |L1.1000|
                  |L1.940|
;;;510            } else if(flags & FLAGS_PLUS) {
0003ac  e2050004          AND      r0,r5,#4
0003b0  e3500000          CMP      r0,#0
0003b4  0a000004          BEQ      |L1.972|
;;;511                buf[len++] = '+'; // ignore the space if the '+' exists
0003b8  e3a0102b          MOV      r1,#0x2b
0003bc  e1a00004          MOV      r0,r4
0003c0  e2844001          ADD      r4,r4,#1
0003c4  e7c61000          STRB     r1,[r6,r0]
0003c8  ea000006          B        |L1.1000|
                  |L1.972|
;;;512            } else if(flags & FLAGS_SPACE) {
0003cc  e2050008          AND      r0,r5,#8
0003d0  e3500000          CMP      r0,#0
0003d4  0a000003          BEQ      |L1.1000|
;;;513                buf[len++] = ' ';
0003d8  e3a01020          MOV      r1,#0x20
0003dc  e1a00004          MOV      r0,r4
0003e0  e2844001          ADD      r4,r4,#1
0003e4  e7c61000          STRB     r1,[r6,r0]
                  |L1.1000|
;;;514            }
;;;515        }
;;;516    
;;;517        out_rev_(output, buf, len, width, flags);
0003e8  e1a03008          MOV      r3,r8
0003ec  e1a02004          MOV      r2,r4
0003f0  e1a01006          MOV      r1,r6
0003f4  e58d5000          STR      r5,[sp,#0]
0003f8  e59d0004          LDR      r0,[sp,#4]
0003fc  ebfffffe          BL       out_rev_
;;;518    }
000400  e28dd014          ADD      sp,sp,#0x14
000404  e8bd8ff0          POP      {r4-r11,pc}
;;;519    
                          ENDP

                  print_integer PROC
;;;520    // An internal itoa-like function
;;;521    static void print_integer(
000408  e92d4ff0          PUSH     {r4-r11,lr}
;;;522        output_gadget_t* output,
;;;523        printf_unsigned_value_t value,
;;;524        bool negative,
;;;525        numeric_base_t base,
;;;526        printf_size_t precision,
;;;527        printf_size_t width,
;;;528        printf_flags_t flags) {
00040c  e24dd034          SUB      sp,sp,#0x34
000410  e1a0a000          MOV      r10,r0
000414  e1a04002          MOV      r4,r2
000418  e1a05003          MOV      r5,r3
00041c  e59d605c          LDR      r6,[sp,#0x5c]
000420  e59d7068          LDR      r7,[sp,#0x68]
000424  e59db064          LDR      r11,[sp,#0x64]
;;;529        char buf[PRINTF_INTEGER_BUFFER_SIZE];
;;;530        printf_size_t len = 0U;
000428  e3a08000          MOV      r8,#0
00042c  e3a01000          MOV      r1,#0
000430  e1a00001          MOV      r0,r1
000434  e0211004          EOR      r1,r1,r4
000438  e0200005          EOR      r0,r0,r5
;;;531    
;;;532        if(!value) {
00043c  e1900001          ORRS     r0,r0,r1
000440  1a00000d          BNE      |L1.1148|
;;;533            if(!(flags & FLAGS_PRECISION)) {
000444  e2070b02          AND      r0,r7,#0x800
000448  e3500000          CMP      r0,#0
00044c  1a000006          BNE      |L1.1132|
;;;534                buf[len++] = '0';
000450  e3a01030          MOV      r1,#0x30
000454  e1a00008          MOV      r0,r8
000458  e2888001          ADD      r8,r8,#1
00045c  e28d2014          ADD      r2,sp,#0x14
000460  e7c21000          STRB     r1,[r2,r0]
;;;535                flags &= ~FLAGS_HASH;
000464  e3c77010          BIC      r7,r7,#0x10
000468  ea00002a          B        |L1.1304|
                  |L1.1132|
;;;536                // We drop this flag this since either the alternative and regular modes of the specifier
;;;537                // don't differ on 0 values, or (in the case of octal) we've already provided the special
;;;538                // handling for this mode.
;;;539            } else if(base == BASE_HEX) {
00046c  e3560010          CMP      r6,#0x10
000470  1a000028          BNE      |L1.1304|
;;;540                flags &= ~FLAGS_HASH;
000474  e3c77010          BIC      r7,r7,#0x10
000478  ea000026          B        |L1.1304|
                  |L1.1148|
;;;541                // We drop this flag this since either the alternative and regular modes of the specifier
;;;542                // don't differ on 0 values
;;;543            }
;;;544        } else {
;;;545            do {
00047c  e1a00000          MOV      r0,r0
                  |L1.1152|
;;;546                const char digit = (char)(value % base);
000480  e1a02006          MOV      r2,r6
000484  e3a03000          MOV      r3,#0
000488  e1a00004          MOV      r0,r4
00048c  e1a01005          MOV      r1,r5
000490  ebfffffe          BL       __aeabi_uldivmod
000494  e20290ff          AND      r9,r2,#0xff
;;;547                buf[len++] =
000498  e359000a          CMP      r9,#0xa
00049c  aa000001          BGE      |L1.1192|
;;;548                    (char)(digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10);
0004a0  e2890030          ADD      r0,r9,#0x30
0004a4  ea000007          B        |L1.1224|
                  |L1.1192|
0004a8  e2070020          AND      r0,r7,#0x20
0004ac  e3500000          CMP      r0,#0
0004b0  0a000001          BEQ      |L1.1212|
0004b4  e3a00041          MOV      r0,#0x41
0004b8  ea000000          B        |L1.1216|
                  |L1.1212|
0004bc  e3a00061          MOV      r0,#0x61
                  |L1.1216|
0004c0  e0800009          ADD      r0,r0,r9
0004c4  e240000a          SUB      r0,r0,#0xa
                  |L1.1224|
0004c8  e20010ff          AND      r1,r0,#0xff
0004cc  e1a00008          MOV      r0,r8
0004d0  e2888001          ADD      r8,r8,#1
0004d4  e28d2014          ADD      r2,sp,#0x14
0004d8  e7c21000          STRB     r1,[r2,r0]
;;;549                value /= base;
0004dc  e1a02006          MOV      r2,r6
0004e0  e3a03000          MOV      r3,#0
0004e4  e1a00004          MOV      r0,r4
0004e8  e1a01005          MOV      r1,r5
0004ec  ebfffffe          BL       __aeabi_uldivmod
0004f0  e1a04000          MOV      r4,r0
0004f4  e1a05001          MOV      r5,r1
0004f8  e3a01000          MOV      r1,#0
0004fc  e1a00001          MOV      r0,r1
000500  e0211004          EOR      r1,r1,r4
000504  e0200005          EOR      r0,r0,r5
;;;550            } while(value && (len < PRINTF_INTEGER_BUFFER_SIZE));
000508  e1900001          ORRS     r0,r0,r1
00050c  0a000001          BEQ      |L1.1304|
000510  e3580020          CMP      r8,#0x20
000514  3affffd9          BCC      |L1.1152|
                  |L1.1304|
;;;551        }
;;;552    
;;;553        print_integer_finalization(output, buf, len, negative, base, precision, width, flags);
000518  e59d0060          LDR      r0,[sp,#0x60]
00051c  e98d0801          STMIB    sp,{r0,r11}
000520  e58d6000          STR      r6,[sp,#0]
000524  e58d700c          STR      r7,[sp,#0xc]
000528  e1a02008          MOV      r2,r8
00052c  e59d3058          LDR      r3,[sp,#0x58]
000530  e28d1014          ADD      r1,sp,#0x14
000534  e1a0000a          MOV      r0,r10
000538  ebfffffe          BL       print_integer_finalization
;;;554    }
00053c  e28dd034          ADD      sp,sp,#0x34
000540  e8bd8ff0          POP      {r4-r11,pc}
;;;555    
                          ENDP

                  get_components PROC
;;;594    // Taken the precision into account, but does not change it even internally.
;;;595    static struct double_components get_components(double number, printf_size_t precision) {
000544  e92d5fff          PUSH     {r0-r12,lr}
000548  e24dd028          SUB      sp,sp,#0x28
00054c  e1a06002          MOV      r6,r2
000550  e1a07003          MOV      r7,r3
000554  e59da060          LDR      r10,[sp,#0x60]
;;;596        struct double_components number_;
;;;597        number_.is_negative = get_sign_bit(number);
000558  e1a00006          MOV      r0,r6
00055c  e1a01007          MOV      r1,r7
000560  ebfffffe          BL       get_sign_bit
000564  e3500000          CMP      r0,#0
000568  0a000001          BEQ      |L1.1396|
00056c  e3a00001          MOV      r0,#1
000570  ea000000          B        |L1.1400|
                  |L1.1396|
000574  e3a00000          MOV      r0,#0
                  |L1.1400|
000578  e5cd0020          STRB     r0,[sp,#0x20]
;;;598        double abs_number   = (number_.is_negative) ? -number : number;
00057c  e5dd0020          LDRB     r0,[sp,#0x20]
000580  e3500000          CMP      r0,#0
000584  0a000002          BEQ      |L1.1428|
000588  e1a00006          MOV      r0,r6
00058c  e2271102          EOR      r1,r7,#0x80000000
000590  ea000001          B        |L1.1436|
                  |L1.1428|
000594  e1a00006          MOV      r0,r6
000598  e1a01007          MOV      r1,r7
                  |L1.1436|
00059c  e1a08000          MOV      r8,r0
0005a0  e1a09001          MOV      r9,r1
;;;599        number_.integral    = (int_fast64_t)abs_number;
0005a4  e1a00008          MOV      r0,r8
0005a8  e1a01009          MOV      r1,r9
0005ac  ebfffffe          BL       __aeabi_d2lz
0005b0  e1cd01f0          STRD     r0,r1,[sp,#0x10]
;;;600        double remainder    = (abs_number - (double)number_.integral) * powers_of_10[precision];
0005b4  e59d2010          LDR      r2,[sp,#0x10]
0005b8  e1a00002          MOV      r0,r2
0005bc  e59d1014          LDR      r1,[sp,#0x14]
0005c0  ebfffffe          BL       __aeabi_l2d
0005c4  e1a02008          MOV      r2,r8
0005c8  e1a03009          MOV      r3,r9
0005cc  e1cd00f0          STRD     r0,r1,[sp,#0]
0005d0  ebfffffe          BL       __aeabi_drsub
0005d4  e1cd00f8          STRD     r0,r1,[sp,#8]
0005d8  e59f0b0c          LDR      r0,|L1.4332|
0005dc  e7b0b18a          LDR      r11,[r0,r10,LSL #3]!
0005e0  e1a0200b          MOV      r2,r11
0005e4  e5903004          LDR      r3,[r0,#4]
0005e8  e59d0008          LDR      r0,[sp,#8]
0005ec  ebfffffe          BL       __aeabi_dmul
0005f0  e1a04000          MOV      r4,r0
0005f4  e1a05001          MOV      r5,r1
;;;601        number_.fractional  = (int_fast64_t)remainder;
0005f8  e1a00004          MOV      r0,r4
0005fc  e1a01005          MOV      r1,r5
000600  ebfffffe          BL       __aeabi_d2lz
000604  e1cd01f8          STRD     r0,r1,[sp,#0x18]
;;;602    
;;;603        remainder -= (double)number_.fractional;
000608  e59d2018          LDR      r2,[sp,#0x18]
00060c  e1a00002          MOV      r0,r2
000610  e59d101c          LDR      r1,[sp,#0x1c]
000614  ebfffffe          BL       __aeabi_l2d
000618  e1a02004          MOV      r2,r4
00061c  e1a03005          MOV      r3,r5
000620  e1cd00f8          STRD     r0,r1,[sp,#8]
000624  ebfffffe          BL       __aeabi_drsub
000628  e1a04000          MOV      r4,r0
00062c  e1a05001          MOV      r5,r1
000630  e3a02000          MOV      r2,#0
000634  e59f3ab4          LDR      r3,|L1.4336|
;;;604    
;;;605        if(remainder > 0.5) {
000638  e1a00004          MOV      r0,r4
00063c  e1a01005          MOV      r1,r5
000640  ebfffffe          BL       __aeabi_cdrcmple
000644  2a00001c          BCS      |L1.1724|
;;;606            ++number_.fractional;
000648  e59d2018          LDR      r2,[sp,#0x18]
00064c  e2922001          ADDS     r2,r2,#1
000650  e59d001c          LDR      r0,[sp,#0x1c]
000654  e2a00000          ADC      r0,r0,#0
000658  e58d001c          STR      r0,[sp,#0x1c]
00065c  e58d2018          STR      r2,[sp,#0x18]
;;;607            // handle rollover, e.g. case 0.99 with precision 1 is 1.0
;;;608            if((double)number_.fractional >= powers_of_10[precision]) {
000660  e59d2018          LDR      r2,[sp,#0x18]
000664  e1a00002          MOV      r0,r2
000668  e59d101c          LDR      r1,[sp,#0x1c]
00066c  ebfffffe          BL       __aeabi_l2d
000670  e1cd00f8          STRD     r0,r1,[sp,#8]
000674  e59f0a70          LDR      r0,|L1.4332|
000678  e080118a          ADD      r1,r0,r10,LSL #3
00067c  e591b000          LDR      r11,[r1,#0]
000680  e1a0200b          MOV      r2,r11
000684  e5913004          LDR      r3,[r1,#4]
000688  e1cd00d8          LDRD     r0,r1,[sp,#8]
00068c  ebfffffe          BL       __aeabi_cdrcmple
000690  8a000023          BHI      |L1.1828|
000694  e3a01000          MOV      r1,#0
;;;609                number_.fractional = 0;
000698  e58d1018          STR      r1,[sp,#0x18]
00069c  e58d101c          STR      r1,[sp,#0x1c]
;;;610                ++number_.integral;
0006a0  e59d1010          LDR      r1,[sp,#0x10]
0006a4  e59d2014          LDR      r2,[sp,#0x14]
0006a8  e2911001          ADDS     r1,r1,#1
0006ac  e2a20000          ADC      r0,r2,#0
0006b0  e58d0014          STR      r0,[sp,#0x14]
0006b4  e58d1010          STR      r1,[sp,#0x10]
0006b8  ea000019          B        |L1.1828|
                  |L1.1724|
0006bc  e3a02000          MOV      r2,#0
0006c0  e59f3a28          LDR      r3,|L1.4336|
;;;611            }
;;;612        } else if((remainder == 0.5) && ((number_.fractional == 0U) || (number_.fractional & 1U))) {
0006c4  e1a00004          MOV      r0,r4
0006c8  e1a01005          MOV      r1,r5
0006cc  ebfffffe          BL       __aeabi_cdcmpeq
0006d0  1a000013          BNE      |L1.1828|
0006d4  e3a03000          MOV      r3,#0
0006d8  e59d0018          LDR      r0,[sp,#0x18]
0006dc  e59d201c          LDR      r2,[sp,#0x1c]
0006e0  e0200003          EOR      r0,r0,r3
0006e4  e0221003          EOR      r1,r2,r3
0006e8  e1900001          ORRS     r0,r0,r1
0006ec  0a000007          BEQ      |L1.1808|
0006f0  e59d1018          LDR      r1,[sp,#0x18]
0006f4  e2011001          AND      r1,r1,#1
0006f8  e3a02000          MOV      r2,#0
0006fc  e59d001c          LDR      r0,[sp,#0x1c]
000700  e0210002          EOR      r0,r1,r2
000704  e0221002          EOR      r1,r2,r2
000708  e1900001          ORRS     r0,r0,r1
00070c  0a000004          BEQ      |L1.1828|
                  |L1.1808|
;;;613            // if halfway, round up if odd OR if last digit is 0
;;;614            ++number_.fractional;
000710  e1cd21d8          LDRD     r2,r3,[sp,#0x18]
000714  e2921001          ADDS     r1,r2,#1
000718  e2a30000          ADC      r0,r3,#0
00071c  e58d001c          STR      r0,[sp,#0x1c]
000720  e58d1018          STR      r1,[sp,#0x18]
                  |L1.1828|
;;;615        }
;;;616    
;;;617        if(precision == 0U) {
000724  e35a0000          CMP      r10,#0
000728  1a000021          BNE      |L1.1972|
;;;618            remainder = abs_number - (double)number_.integral;
00072c  e59d2010          LDR      r2,[sp,#0x10]
000730  e1a00002          MOV      r0,r2
000734  e59d1014          LDR      r1,[sp,#0x14]
000738  ebfffffe          BL       __aeabi_l2d
00073c  e1a02008          MOV      r2,r8
000740  e1a03009          MOV      r3,r9
000744  e1cd00f8          STRD     r0,r1,[sp,#8]
000748  ebfffffe          BL       __aeabi_drsub
00074c  e1a04000          MOV      r4,r0
000750  e1a05001          MOV      r5,r1
000754  e3a02000          MOV      r2,#0
000758  e59f3990          LDR      r3,|L1.4336|
;;;619            if((!(remainder < 0.5) || (remainder > 0.5)) && (number_.integral & 1)) {
00075c  e1a00004          MOV      r0,r4
000760  e1a01005          MOV      r1,r5
000764  ebfffffe          BL       __aeabi_cdcmple
000768  2a000005          BCS      |L1.1924|
00076c  e3a02000          MOV      r2,#0
000770  e59f3978          LDR      r3,|L1.4336|
000774  e1a00004          MOV      r0,r4
000778  e1a01005          MOV      r1,r5
00077c  ebfffffe          BL       __aeabi_cdrcmple
000780  2a00000b          BCS      |L1.1972|
                  |L1.1924|
000784  e1cd01d0          LDRD     r0,r1,[sp,#0x10]
000788  e2000001          AND      r0,r0,#1
00078c  e3a03000          MOV      r3,#0
000790  e0200003          EOR      r0,r0,r3
000794  e0231003          EOR      r1,r3,r3
000798  e1900001          ORRS     r0,r0,r1
00079c  0a000004          BEQ      |L1.1972|
;;;620                // exactly 0.5 and ODD, then round up
;;;621                // 1.5 -> 2, but 2.5 -> 2
;;;622                ++number_.integral;
0007a0  e59d0010          LDR      r0,[sp,#0x10]
0007a4  e59d2014          LDR      r2,[sp,#0x14]
0007a8  e2900001          ADDS     r0,r0,#1
0007ac  e2a21000          ADC      r1,r2,#0
0007b0  e1cd01f0          STRD     r0,r1,[sp,#0x10]
                  |L1.1972|
;;;623            }
;;;624        }
;;;625        return number_;
0007b4  e3a02018          MOV      r2,#0x18
0007b8  e28d1010          ADD      r1,sp,#0x10
0007bc  e59d0028          LDR      r0,[sp,#0x28]
0007c0  ebfffffe          BL       __aeabi_memcpy4
;;;626    }
0007c4  e28dd038          ADD      sp,sp,#0x38
0007c8  e8bd9ff0          POP      {r4-r12,pc}
;;;627    
                          ENDP

                  apply_scaling PROC
;;;633    
;;;634    static double apply_scaling(double num, struct scaling_factor normalization) {
0007cc  e92d000f          PUSH     {r0-r3}
0007d0  e92d41f0          PUSH     {r4-r8,lr}
0007d4  e1a04000          MOV      r4,r0
0007d8  e1a05001          MOV      r5,r1
;;;635        return normalization.multiply ? num * normalization.raw_factor :
0007dc  e5dd0028          LDRB     r0,[sp,#0x28]
0007e0  e3500000          CMP      r0,#0
0007e4  0a000007          BEQ      |L1.2056|
0007e8  e59d6020          LDR      r6,[sp,#0x20]
0007ec  e1a02006          MOV      r2,r6
0007f0  e1a00004          MOV      r0,r4
0007f4  e1a01005          MOV      r1,r5
0007f8  e59d3024          LDR      r3,[sp,#0x24]
0007fc  ebfffffe          BL       __aeabi_dmul
                  |L1.2048|
000800  e8bd01f0          POP      {r4-r8}
;;;636                                        num / normalization.raw_factor;
;;;637    }
000804  e49df014          LDR      pc,[sp],#0x14
                  |L1.2056|
000808  e59d6020          LDR      r6,[sp,#0x20]         ;636
00080c  e1a02006          MOV      r2,r6                 ;636
000810  e1a00004          MOV      r0,r4                 ;636
000814  e1a01005          MOV      r1,r5                 ;636
000818  e59d3024          LDR      r3,[sp,#0x24]         ;636
00081c  ebfffffe          BL       __aeabi_ddiv
000820  eafffff6          B        |L1.2048|
;;;638    
                          ENDP

                  unapply_scaling PROC
;;;639    static double unapply_scaling(double normalized, struct scaling_factor normalization) {
000824  e92d000f          PUSH     {r0-r3}
000828  e92d41f0          PUSH     {r4-r8,lr}
00082c  e1a04000          MOV      r4,r0
000830  e1a05001          MOV      r5,r1
;;;640    #ifdef __GNUC__
;;;641    // accounting for a static analysis bug in GCC 6.x and earlier
;;;642    #pragma GCC diagnostic push
;;;643    #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
;;;644    #endif
;;;645        return normalization.multiply ? normalized / normalization.raw_factor :
000834  e5dd0028          LDRB     r0,[sp,#0x28]
000838  e3500000          CMP      r0,#0
00083c  0a000007          BEQ      |L1.2144|
000840  e59d6020          LDR      r6,[sp,#0x20]
000844  e1a02006          MOV      r2,r6
000848  e1a00004          MOV      r0,r4
00084c  e1a01005          MOV      r1,r5
000850  e59d3024          LDR      r3,[sp,#0x24]
000854  ebfffffe          BL       __aeabi_ddiv
                  |L1.2136|
000858  e8bd01f0          POP      {r4-r8}
;;;646                                        normalized * normalization.raw_factor;
;;;647    #ifdef __GNUC__
;;;648    #pragma GCC diagnostic pop
;;;649    #endif
;;;650    }
00085c  e49df014          LDR      pc,[sp],#0x14
                  |L1.2144|
000860  e59d6020          LDR      r6,[sp,#0x20]         ;646
000864  e1a02006          MOV      r2,r6                 ;646
000868  e1a00004          MOV      r0,r4                 ;646
00086c  e1a01005          MOV      r1,r5                 ;646
000870  e59d3024          LDR      r3,[sp,#0x24]         ;646
000874  ebfffffe          BL       __aeabi_dmul
000878  eafffff6          B        |L1.2136|
;;;651    
                          ENDP

                  update_normalization PROC
;;;652    static struct scaling_factor
;;;653        update_normalization(struct scaling_factor sf, double extra_multiplicative_factor) {
00087c  e92d000f          PUSH     {r0-r3}
000880  e92d47f0          PUSH     {r4-r10,lr}
000884  e24dd018          SUB      sp,sp,#0x18
000888  e1a08000          MOV      r8,r0
00088c  e1cd45d0          LDRD     r4,r5,[sp,#0x50]
;;;654        struct scaling_factor result;
;;;655        if(sf.multiply) {
000890  e5dd0048          LDRB     r0,[sp,#0x48]
000894  e3500000          CMP      r0,#0
000898  0a000009          BEQ      |L1.2244|
;;;656            result.multiply   = true;
00089c  e3a00001          MOV      r0,#1
0008a0  e5cd0010          STRB     r0,[sp,#0x10]
;;;657            result.raw_factor = sf.raw_factor * extra_multiplicative_factor;
0008a4  e1a02004          MOV      r2,r4
0008a8  e1a03005          MOV      r3,r5
0008ac  e59d6040          LDR      r6,[sp,#0x40]
0008b0  e1a00006          MOV      r0,r6
0008b4  e59d1044          LDR      r1,[sp,#0x44]
0008b8  ebfffffe          BL       __aeabi_dmul
0008bc  e1cd00f8          STRD     r0,r1,[sp,#8]
0008c0  ea00002e          B        |L1.2432|
                  |L1.2244|
;;;658        } else {
;;;659            int factor_exp2       = get_exp2(get_bit_access(sf.raw_factor));
0008c4  e59d6040          LDR      r6,[sp,#0x40]
0008c8  e1a02006          MOV      r2,r6
0008cc  e59d3044          LDR      r3,[sp,#0x44]
0008d0  e1a0000d          MOV      r0,sp
0008d4  ebfffffe          BL       get_bit_access
0008d8  e1cd00d0          LDRD     r0,r1,[sp,#0]
0008dc  ebfffffe          BL       get_exp2
0008e0  e1a09000          MOV      r9,r0
;;;660            int extra_factor_exp2 = get_exp2(get_bit_access(extra_multiplicative_factor));
0008e4  e1a02004          MOV      r2,r4
0008e8  e1a03005          MOV      r3,r5
0008ec  e1a0000d          MOV      r0,sp
0008f0  ebfffffe          BL       get_bit_access
0008f4  e1cd00d0          LDRD     r0,r1,[sp,#0]
0008f8  ebfffffe          BL       get_exp2
0008fc  e1a0a000          MOV      r10,r0
;;;661    
;;;662            // Divide the larger-exponent raw raw_factor by the smaller
;;;663            if(PRINTF_ABS(factor_exp2) > PRINTF_ABS(extra_factor_exp2)) {
000900  e3590000          CMP      r9,#0
000904  da000001          BLE      |L1.2320|
000908  e1a00009          MOV      r0,r9
00090c  ea000000          B        |L1.2324|
                  |L1.2320|
000910  e2690000          RSB      r0,r9,#0
                  |L1.2324|
000914  e35a0000          CMP      r10,#0
000918  da000001          BLE      |L1.2340|
00091c  e1a0100a          MOV      r1,r10
000920  ea000000          B        |L1.2344|
                  |L1.2340|
000924  e26a1000          RSB      r1,r10,#0
                  |L1.2344|
000928  e1500001          CMP      r0,r1
00092c  da000009          BLE      |L1.2392|
;;;664                result.multiply   = false;
000930  e3a00000          MOV      r0,#0
000934  e5cd0010          STRB     r0,[sp,#0x10]
;;;665                result.raw_factor = sf.raw_factor / extra_multiplicative_factor;
000938  e1a02004          MOV      r2,r4
00093c  e1a03005          MOV      r3,r5
000940  e59d6040          LDR      r6,[sp,#0x40]
000944  e1a00006          MOV      r0,r6
000948  e59d1044          LDR      r1,[sp,#0x44]
00094c  ebfffffe          BL       __aeabi_ddiv
000950  e1cd00f8          STRD     r0,r1,[sp,#8]
000954  ea000008          B        |L1.2428|
                  |L1.2392|
;;;666            } else {
;;;667                result.multiply   = true;
000958  e3a00001          MOV      r0,#1
00095c  e5cd0010          STRB     r0,[sp,#0x10]
;;;668                result.raw_factor = extra_multiplicative_factor / sf.raw_factor;
000960  e59d6040          LDR      r6,[sp,#0x40]
000964  e1a02006          MOV      r2,r6
000968  e1a00004          MOV      r0,r4
00096c  e1a01005          MOV      r1,r5
000970  e59d3044          LDR      r3,[sp,#0x44]
000974  ebfffffe          BL       __aeabi_ddiv
000978  e1cd00f8          STRD     r0,r1,[sp,#8]
                  |L1.2428|
;;;669            }
;;;670        }
00097c  e1a00000          MOV      r0,r0
                  |L1.2432|
;;;671        return result;
000980  e1cd00d8          LDRD     r0,r1,[sp,#8]
000984  e1cd21d0          LDRD     r2,r3,[sp,#0x10]
000988  e888000f          STM      r8,{r0-r3}
;;;672    }
00098c  e28dd018          ADD      sp,sp,#0x18
000990  e8bd07f0          POP      {r4-r10}
000994  e49df014          LDR      pc,[sp],#0x14
;;;673    
                          ENDP

                  get_normalized_components PROC
;;;674    static struct double_components get_normalized_components(
000998  e92d4fff          PUSH     {r0-r11,lr}
;;;675        bool negative,
;;;676        printf_size_t precision,
;;;677        double non_normalized,
;;;678        struct scaling_factor normalization,
;;;679        int floored_exp10) {
00099c  e24dd054          SUB      sp,sp,#0x54
;;;680        struct double_components components;
;;;681        components.is_negative = negative;
0009a0  e59d0058          LDR      r0,[sp,#0x58]
0009a4  e5cd0048          STRB     r0,[sp,#0x48]
;;;682        double scaled          = apply_scaling(non_normalized, normalization);
0009a8  e1cd09d8          LDRD     r0,r1,[sp,#0x98]
0009ac  e1cd00f0          STRD     r0,r1,[sp,#0]
0009b0  e1cd08d8          LDRD     r0,r1,[sp,#0x88]
0009b4  e1cd29d0          LDRD     r2,r3,[sp,#0x90]
0009b8  ebfffffe          BL       apply_scaling
0009bc  e1a04000          MOV      r4,r0
0009c0  e1a05001          MOV      r5,r1
;;;683    
;;;684        bool close_to_representation_extremum =
0009c4  e59d00a0          LDR      r0,[sp,#0xa0]
0009c8  e2601000          RSB      r1,r0,#0
0009cc  e59d005c          LDR      r0,[sp,#0x5c]
0009d0  e0800001          ADD      r0,r0,r1
0009d4  e59f1718          LDR      r1,|L1.4340|
0009d8  e1500001          CMP      r0,r1
0009dc  ba000001          BLT      |L1.2536|
0009e0  e3a00001          MOV      r0,#1
0009e4  ea000000          B        |L1.2540|
                  |L1.2536|
0009e8  e3a00000          MOV      r0,#0
                  |L1.2540|
0009ec  e58d0034          STR      r0,[sp,#0x34]
;;;685            ((-floored_exp10 + (int)precision) >= DBL_MAX_10_EXP - 1);
;;;686        if(close_to_representation_extremum) {
0009f0  e59d0034          LDR      r0,[sp,#0x34]
0009f4  e3500000          CMP      r0,#0
0009f8  0a000010          BEQ      |L1.2624|
;;;687            // We can't have a normalization factor which also accounts for the precision, i.e. moves
;;;688            // some decimal digits into the mantissa, since it's unrepresentable, or nearly unrepresentable.
;;;689            // So, we'll give up early on getting extra precision...
;;;690            return get_components(negative ? -scaled : scaled, precision);
0009fc  e59d0058          LDR      r0,[sp,#0x58]
000a00  e3500000          CMP      r0,#0
000a04  0a000002          BEQ      |L1.2580|
000a08  e1a00004          MOV      r0,r4
000a0c  e2251102          EOR      r1,r5,#0x80000000
000a10  ea000001          B        |L1.2588|
                  |L1.2580|
000a14  e1a00004          MOV      r0,r4
000a18  e1a01005          MOV      r1,r5
                  |L1.2588|
000a1c  e1cd01f0          STRD     r0,r1,[sp,#0x10]
000a20  e59d005c          LDR      r0,[sp,#0x5c]
000a24  e58d0000          STR      r0,[sp,#0]
000a28  e1a03001          MOV      r3,r1
000a2c  e59d0054          LDR      r0,[sp,#0x54]
000a30  e59d2010          LDR      r2,[sp,#0x10]
000a34  ebfffffe          BL       get_components
                  |L1.2616|
;;;691        }
;;;692        components.integral = (int_fast64_t)scaled;
;;;693        double remainder =
;;;694            non_normalized - unapply_scaling((double)components.integral, normalization);
;;;695        double prec_power_of_10 = powers_of_10[precision];
;;;696        struct scaling_factor account_for_precision =
;;;697            update_normalization(normalization, prec_power_of_10);
;;;698        double scaled_remainder   = apply_scaling(remainder, account_for_precision);
;;;699        double rounding_threshold = 0.5;
;;;700    
;;;701        components.fractional =
;;;702            (int_fast64_t)scaled_remainder; // when precision == 0, the assigned value should be 0
;;;703        scaled_remainder -=
;;;704            (double)components.fractional; //when precision == 0, this will not change scaled_remainder
;;;705    
;;;706        components.fractional += (scaled_remainder >= rounding_threshold);
;;;707        if(scaled_remainder == rounding_threshold) {
;;;708            // banker's rounding: Round towards the even number (making the mean error 0)
;;;709            components.fractional &= ~((int_fast64_t)0x1);
;;;710        }
;;;711        // handle rollover, e.g. the case of 0.99 with precision 1 becoming (0,100),
;;;712        // and must then be corrected into (1, 0).
;;;713        // Note: for precision = 0, this will "translate" the rounding effect from
;;;714        // the fractional part to the integral part where it should actually be
;;;715        // felt (as prec_power_of_10 is 1)
;;;716        if((double)components.fractional >= prec_power_of_10) {
;;;717            components.fractional = 0;
;;;718            ++components.integral;
;;;719        }
;;;720        return components;
;;;721    }
000a38  e28dd064          ADD      sp,sp,#0x64
000a3c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.2624|
000a40  e1a00004          MOV      r0,r4                 ;692
000a44  e1a01005          MOV      r1,r5                 ;692
000a48  ebfffffe          BL       __aeabi_d2lz
000a4c  e1cd03f8          STRD     r0,r1,[sp,#0x38]      ;692
000a50  e59d2038          LDR      r2,[sp,#0x38]         ;693
000a54  e1a00002          MOV      r0,r2                 ;693
000a58  e59d103c          LDR      r1,[sp,#0x3c]         ;693
000a5c  ebfffffe          BL       __aeabi_l2d
000a60  e1cd00f8          STRD     r0,r1,[sp,#8]         ;693
000a64  e1cd09d8          LDRD     r0,r1,[sp,#0x98]      ;693
000a68  e1cd00f0          STRD     r0,r1,[sp,#0]         ;693
000a6c  e1cd00d8          LDRD     r0,r1,[sp,#8]         ;693
000a70  e1cd29d0          LDRD     r2,r3,[sp,#0x90]      ;693
000a74  ebfffffe          BL       unapply_scaling
000a78  e1cd01f0          STRD     r0,r1,[sp,#0x10]      ;693
000a7c  e1cd28d8          LDRD     r2,r3,[sp,#0x88]      ;693
000a80  ebfffffe          BL       __aeabi_drsub
000a84  e1cd02f8          STRD     r0,r1,[sp,#0x28]      ;693
000a88  e59f165c          LDR      r1,|L1.4332|
000a8c  e59d005c          LDR      r0,[sp,#0x5c]         ;695
000a90  e0810180          ADD      r0,r1,r0,LSL #3       ;695
000a94  e1c060d0          LDRD     r6,r7,[r0,#0]         ;695
000a98  e1cd60f8          STRD     r6,r7,[sp,#8]         ;696
000a9c  e1cd09d8          LDRD     r0,r1,[sp,#0x98]      ;696
000aa0  e1cd00f0          STRD     r0,r1,[sp,#0]         ;696
000aa4  e1cd29d0          LDRD     r2,r3,[sp,#0x90]      ;696
000aa8  e28d0018          ADD      r0,sp,#0x18           ;696
000aac  ebfffffe          BL       update_normalization
000ab0  e1cd02d0          LDRD     r0,r1,[sp,#0x20]      ;698
000ab4  e1cd00f0          STRD     r0,r1,[sp,#0]         ;698
000ab8  e1cd02d8          LDRD     r0,r1,[sp,#0x28]      ;698
000abc  e1cd21d8          LDRD     r2,r3,[sp,#0x18]      ;698
000ac0  ebfffffe          BL       apply_scaling
000ac4  e1a08000          MOV      r8,r0                 ;698
000ac8  e1a09001          MOV      r9,r1                 ;698
000acc  e3a0a000          MOV      r10,#0                ;698
000ad0  e59fb618          LDR      r11,|L1.4336|
000ad4  e1a00008          MOV      r0,r8                 ;701
000ad8  e1a01009          MOV      r1,r9                 ;701
000adc  ebfffffe          BL       __aeabi_d2lz
000ae0  e1cd04f0          STRD     r0,r1,[sp,#0x40]      ;701
000ae4  e59d2040          LDR      r2,[sp,#0x40]         ;703
000ae8  e1a00002          MOV      r0,r2                 ;703
000aec  e59d1044          LDR      r1,[sp,#0x44]         ;703
000af0  ebfffffe          BL       __aeabi_l2d
000af4  e1a02008          MOV      r2,r8                 ;703
000af8  e1a03009          MOV      r3,r9                 ;703
000afc  e1cd01f0          STRD     r0,r1,[sp,#0x10]      ;703
000b00  ebfffffe          BL       __aeabi_drsub
000b04  e1a08000          MOV      r8,r0                 ;703
000b08  e1a09001          MOV      r9,r1                 ;703
000b0c  e1a0200a          MOV      r2,r10                ;706
000b10  e1a0300b          MOV      r3,r11                ;706
000b14  e1a00008          MOV      r0,r8                 ;706
000b18  e1a01009          MOV      r1,r9                 ;706
000b1c  ebfffffe          BL       __aeabi_cdrcmple
000b20  8a000001          BHI      |L1.2860|
000b24  e3a00001          MOV      r0,#1                 ;706
000b28  ea000000          B        |L1.2864|
                  |L1.2860|
000b2c  e3a00000          MOV      r0,#0                 ;706
                  |L1.2864|
000b30  e1a03fc0          ASR      r3,r0,#31             ;706
000b34  e59d1040          LDR      r1,[sp,#0x40]         ;706
000b38  e59d2044          LDR      r2,[sp,#0x44]         ;706
000b3c  e0900001          ADDS     r0,r0,r1              ;706
000b40  e0a31002          ADC      r1,r3,r2              ;706
000b44  e1cd04f0          STRD     r0,r1,[sp,#0x40]      ;706
000b48  e1a0200a          MOV      r2,r10                ;707
000b4c  e1a0300b          MOV      r3,r11                ;707
000b50  e1a00008          MOV      r0,r8                 ;707
000b54  e1a01009          MOV      r1,r9                 ;707
000b58  ebfffffe          BL       __aeabi_cdcmpeq
000b5c  1a000002          BNE      |L1.2924|
000b60  e1cd04d0          LDRD     r0,r1,[sp,#0x40]      ;709
000b64  e3c00001          BIC      r0,r0,#1              ;709
000b68  e1cd04f0          STRD     r0,r1,[sp,#0x40]      ;709
                  |L1.2924|
000b6c  e59d2040          LDR      r2,[sp,#0x40]         ;716
000b70  e1a00002          MOV      r0,r2                 ;716
000b74  e59d1044          LDR      r1,[sp,#0x44]         ;716
000b78  ebfffffe          BL       __aeabi_l2d
000b7c  e1a02006          MOV      r2,r6                 ;716
000b80  e1a03007          MOV      r3,r7                 ;716
000b84  e1cd01f0          STRD     r0,r1,[sp,#0x10]      ;716
000b88  ebfffffe          BL       __aeabi_cdrcmple
000b8c  8a000008          BHI      |L1.2996|
000b90  e3a01000          MOV      r1,#0                 ;716
000b94  e58d1040          STR      r1,[sp,#0x40]         ;717
000b98  e58d1044          STR      r1,[sp,#0x44]         ;717
000b9c  e59d1038          LDR      r1,[sp,#0x38]         ;718
000ba0  e59d203c          LDR      r2,[sp,#0x3c]         ;718
000ba4  e2911001          ADDS     r1,r1,#1              ;718
000ba8  e2a20000          ADC      r0,r2,#0              ;718
000bac  e58d003c          STR      r0,[sp,#0x3c]         ;718
000bb0  e58d1038          STR      r1,[sp,#0x38]         ;718
                  |L1.2996|
000bb4  e3a02018          MOV      r2,#0x18              ;720
000bb8  e28d1038          ADD      r1,sp,#0x38           ;720
000bbc  e59d0054          LDR      r0,[sp,#0x54]         ;720
000bc0  ebfffffe          BL       __aeabi_memcpy4
000bc4  e1a00000          MOV      r0,r0                 ;720
000bc8  eaffff9a          B        |L1.2616|
;;;722    #endif // PRINTF_SUPPORT_EXPONENTIAL_SPECIFIERS
                          ENDP

                  print_broken_up_decimal PROC
;;;723    
;;;724    static void print_broken_up_decimal(
000bcc  e92d000f          PUSH     {r0-r3}
;;;725        struct double_components number_,
;;;726        output_gadget_t* output,
;;;727        printf_size_t precision,
;;;728        printf_size_t width,
;;;729        printf_flags_t flags,
;;;730        char* buf,
;;;731        printf_size_t len) {
000bd0  e92d5ffc          PUSH     {r2-r12,lr}
000bd4  e59d405c          LDR      r4,[sp,#0x5c]
000bd8  e59d5054          LDR      r5,[sp,#0x54]
000bdc  e59d6058          LDR      r6,[sp,#0x58]
000be0  e59d9050          LDR      r9,[sp,#0x50]
000be4  e59da04c          LDR      r10,[sp,#0x4c]
;;;732        if(precision != 0U) {
000be8  e35a0000          CMP      r10,#0
000bec  0a000060          BEQ      |L1.3444|
;;;733            // do fractional part, as an unsigned number
;;;734    
;;;735            printf_size_t count = precision;
000bf0  e1a0b00a          MOV      r11,r10
;;;736    
;;;737            // %g/%G mandates we skip the trailing 0 digits...
;;;738            if((flags & FLAGS_ADAPT_EXP) && !(flags & FLAGS_HASH) && (number_.fractional > 0)) {
000bf4  e2050a01          AND      r0,r5,#0x1000
000bf8  e3500000          CMP      r0,#0
000bfc  0a000021          BEQ      |L1.3208|
000c00  e2050010          AND      r0,r5,#0x10
000c04  e3500000          CMP      r0,#0
000c08  1a00001e          BNE      |L1.3208|
000c0c  e3a02000          MOV      r2,#0
000c10  e1cd03d8          LDRD     r0,r1,[sp,#0x38]
000c14  e0520000          SUBS     r0,r2,r0
000c18  e0d20001          SBCS     r0,r2,r1
000c1c  aa000019          BGE      |L1.3208|
;;;739                while(true) {
000c20  ea000016          B        |L1.3200|
                  |L1.3108|
;;;740                    int_fast64_t digit = number_.fractional % 10U;
000c24  e3a0200a          MOV      r2,#0xa
000c28  e3a03000          MOV      r3,#0
000c2c  e59d7038          LDR      r7,[sp,#0x38]
000c30  e1a00007          MOV      r0,r7
000c34  e59d103c          LDR      r1,[sp,#0x3c]
000c38  ebfffffe          BL       __aeabi_ldivmod
000c3c  e1cd20f0          STRD     r2,r3,[sp,#0]
;;;741                    if(digit != 0) {
000c40  e3a03000          MOV      r3,#0
000c44  e1cd00d0          LDRD     r0,r1,[sp,#0]
000c48  e0200003          EOR      r0,r0,r3
000c4c  e0211003          EOR      r1,r1,r3
000c50  e1900001          ORRS     r0,r0,r1
000c54  0a000000          BEQ      |L1.3164|
;;;742                        break;
000c58  ea000009          B        |L1.3204|
                  |L1.3164|
;;;743                    }
;;;744                    --count;
000c5c  e24bb001          SUB      r11,r11,#1
;;;745                    number_.fractional /= 10U;
000c60  e3a0200a          MOV      r2,#0xa
000c64  e3a03000          MOV      r3,#0
000c68  e59d7038          LDR      r7,[sp,#0x38]
000c6c  e1a00007          MOV      r0,r7
000c70  e59d103c          LDR      r1,[sp,#0x3c]
000c74  ebfffffe          BL       __aeabi_ldivmod
000c78  e1cd03f8          STRD     r0,r1,[sp,#0x38]
;;;746                }
000c7c  e1a00000          MOV      r0,r0
                  |L1.3200|
000c80  eaffffe7          B        |L1.3108|
                  |L1.3204|
000c84  e1a00000          MOV      r0,r0                 ;742
                  |L1.3208|
;;;747                // ... and even the decimal point if there are no
;;;748                // non-zero fractional part digits (see below)
;;;749            }
;;;750    
;;;751            if(number_.fractional > 0 || !(flags & FLAGS_ADAPT_EXP) || (flags & FLAGS_HASH)) {
000c88  e3a01000          MOV      r1,#0
000c8c  e1a03001          MOV      r3,r1
000c90  e59d2038          LDR      r2,[sp,#0x38]
000c94  e0511002          SUBS     r1,r1,r2
000c98  e59d003c          LDR      r0,[sp,#0x3c]
000c9c  e0d30000          SBCS     r0,r3,r0
000ca0  ba000005          BLT      |L1.3260|
000ca4  e2050a01          AND      r0,r5,#0x1000
000ca8  e3500000          CMP      r0,#0
000cac  0a000002          BEQ      |L1.3260|
000cb0  e2050010          AND      r0,r5,#0x10
000cb4  e3500000          CMP      r0,#0
000cb8  0a00002c          BEQ      |L1.3440|
                  |L1.3260|
;;;752                while(len < PRINTF_DECIMAL_BUFFER_SIZE) {
000cbc  ea000018          B        |L1.3364|
                  |L1.3264|
;;;753                    --count;
000cc0  e24bb001          SUB      r11,r11,#1
;;;754                    buf[len++] = (char)('0' + number_.fractional % 10U);
000cc4  e3a0200a          MOV      r2,#0xa
000cc8  e3a03000          MOV      r3,#0
000ccc  e59d7038          LDR      r7,[sp,#0x38]
000cd0  e1a00007          MOV      r0,r7
000cd4  e59d103c          LDR      r1,[sp,#0x3c]
000cd8  ebfffffe          BL       __aeabi_ldivmod
000cdc  e2920030          ADDS     r0,r2,#0x30
000ce0  e20010ff          AND      r1,r0,#0xff
000ce4  e1a00004          MOV      r0,r4
000ce8  e2844001          ADD      r4,r4,#1
000cec  e7c61000          STRB     r1,[r6,r0]
;;;755                    if(!(number_.fractional /= 10U)) {
000cf0  e3a0200a          MOV      r2,#0xa
000cf4  e3a03000          MOV      r3,#0
000cf8  e59d7038          LDR      r7,[sp,#0x38]
000cfc  e1a00007          MOV      r0,r7
000d00  e59d103c          LDR      r1,[sp,#0x3c]
000d04  ebfffffe          BL       __aeabi_ldivmod
000d08  e3a03000          MOV      r3,#0
000d0c  e1cd03f8          STRD     r0,r1,[sp,#0x38]
000d10  e0200003          EOR      r0,r0,r3
000d14  e0211003          EOR      r1,r1,r3
000d18  e1900001          ORRS     r0,r0,r1
000d1c  1a000000          BNE      |L1.3364|
;;;756                        break;
000d20  ea000001          B        |L1.3372|
                  |L1.3364|
000d24  e3540020          CMP      r4,#0x20              ;752
000d28  3affffe4          BCC      |L1.3264|
                  |L1.3372|
000d2c  e1a00000          MOV      r0,r0
;;;757                    }
;;;758                }
;;;759                // add extra 0s
;;;760                while((len < PRINTF_DECIMAL_BUFFER_SIZE) && (count > 0U)) {
000d30  ea000004          B        |L1.3400|
                  |L1.3380|
;;;761                    buf[len++] = '0';
000d34  e3a01030          MOV      r1,#0x30
000d38  e1a00004          MOV      r0,r4
000d3c  e2844001          ADD      r4,r4,#1
000d40  e7c61000          STRB     r1,[r6,r0]
;;;762                    --count;
000d44  e24bb001          SUB      r11,r11,#1
                  |L1.3400|
000d48  e3540020          CMP      r4,#0x20              ;760
000d4c  2a000001          BCS      |L1.3416|
000d50  e35b0000          CMP      r11,#0                ;760
000d54  1afffff6          BNE      |L1.3380|
                  |L1.3416|
;;;763                }
;;;764                if(len < PRINTF_DECIMAL_BUFFER_SIZE) {
000d58  e3540020          CMP      r4,#0x20
000d5c  2a000003          BCS      |L1.3440|
;;;765                    buf[len++] = '.';
000d60  e3a0102e          MOV      r1,#0x2e
000d64  e1a00004          MOV      r0,r4
000d68  e2844001          ADD      r4,r4,#1
000d6c  e7c61000          STRB     r1,[r6,r0]
                  |L1.3440|
;;;766                }
;;;767            }
;;;768        } else {
000d70  ea000008          B        |L1.3480|
                  |L1.3444|
;;;769            if((flags & FLAGS_HASH) && (len < PRINTF_DECIMAL_BUFFER_SIZE)) {
000d74  e2050010          AND      r0,r5,#0x10
000d78  e3500000          CMP      r0,#0
000d7c  0a000005          BEQ      |L1.3480|
000d80  e3540020          CMP      r4,#0x20
000d84  2a000003          BCS      |L1.3480|
;;;770                buf[len++] = '.';
000d88  e3a0102e          MOV      r1,#0x2e
000d8c  e1a00004          MOV      r0,r4
000d90  e2844001          ADD      r4,r4,#1
000d94  e7c61000          STRB     r1,[r6,r0]
                  |L1.3480|
;;;771            }
;;;772        }
;;;773    
;;;774        // Write the integer part of the number (it comes after the fractional
;;;775        // since the character order is reversed)
;;;776        while(len < PRINTF_DECIMAL_BUFFER_SIZE) {
000d98  ea000017          B        |L1.3580|
                  |L1.3484|
;;;777            buf[len++] = (char)('0' + (number_.integral % 10));
000d9c  e3a0200a          MOV      r2,#0xa
000da0  e3a03000          MOV      r3,#0
000da4  e59d7030          LDR      r7,[sp,#0x30]
000da8  e1a00007          MOV      r0,r7
000dac  e59d1034          LDR      r1,[sp,#0x34]
000db0  ebfffffe          BL       __aeabi_ldivmod
000db4  e2920030          ADDS     r0,r2,#0x30
000db8  e20010ff          AND      r1,r0,#0xff
000dbc  e1a00004          MOV      r0,r4
000dc0  e2844001          ADD      r4,r4,#1
000dc4  e7c61000          STRB     r1,[r6,r0]
;;;778            if(!(number_.integral /= 10)) {
000dc8  e3a0200a          MOV      r2,#0xa
000dcc  e3a03000          MOV      r3,#0
000dd0  e59d7030          LDR      r7,[sp,#0x30]
000dd4  e1a00007          MOV      r0,r7
000dd8  e59d1034          LDR      r1,[sp,#0x34]
000ddc  ebfffffe          BL       __aeabi_ldivmod
000de0  e3a02000          MOV      r2,#0
000de4  e1cd03f0          STRD     r0,r1,[sp,#0x30]
000de8  e0200002          EOR      r0,r0,r2
000dec  e0211002          EOR      r1,r1,r2
000df0  e1900001          ORRS     r0,r0,r1
000df4  1a000000          BNE      |L1.3580|
;;;779                break;
000df8  ea000001          B        |L1.3588|
                  |L1.3580|
000dfc  e3540020          CMP      r4,#0x20              ;776
000e00  3affffe5          BCC      |L1.3484|
                  |L1.3588|
000e04  e1a00000          MOV      r0,r0
;;;780            }
;;;781        }
;;;782    
;;;783        // pad leading zeros
;;;784        if(!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
000e08  e2050002          AND      r0,r5,#2
000e0c  e3500000          CMP      r0,#0
000e10  1a000014          BNE      |L1.3688|
000e14  e2050001          AND      r0,r5,#1
000e18  e3500000          CMP      r0,#0
000e1c  0a000011          BEQ      |L1.3688|
;;;785            if(width && (number_.is_negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
000e20  e3590000          CMP      r9,#0
000e24  0a000006          BEQ      |L1.3652|
000e28  e5dd0040          LDRB     r0,[sp,#0x40]
000e2c  e3500000          CMP      r0,#0
000e30  1a000002          BNE      |L1.3648|
000e34  e205000c          AND      r0,r5,#0xc
000e38  e3500000          CMP      r0,#0
000e3c  0a000000          BEQ      |L1.3652|
                  |L1.3648|
;;;786                width--;
000e40  e2499001          SUB      r9,r9,#1
                  |L1.3652|
;;;787            }
;;;788            while((len < width) && (len < PRINTF_DECIMAL_BUFFER_SIZE)) {
000e44  ea000003          B        |L1.3672|
                  |L1.3656|
;;;789                buf[len++] = '0';
000e48  e3a01030          MOV      r1,#0x30
000e4c  e1a00004          MOV      r0,r4
000e50  e2844001          ADD      r4,r4,#1
000e54  e7c61000          STRB     r1,[r6,r0]
                  |L1.3672|
000e58  e1540009          CMP      r4,r9                 ;788
000e5c  2a000001          BCS      |L1.3688|
000e60  e3540020          CMP      r4,#0x20              ;788
000e64  3afffff7          BCC      |L1.3656|
                  |L1.3688|
;;;790            }
;;;791        }
;;;792    
;;;793        if(len < PRINTF_DECIMAL_BUFFER_SIZE) {
000e68  e3540020          CMP      r4,#0x20
000e6c  2a000016          BCS      |L1.3788|
;;;794            if(number_.is_negative) {
000e70  e5dd0040          LDRB     r0,[sp,#0x40]
000e74  e3500000          CMP      r0,#0
000e78  0a000004          BEQ      |L1.3728|
;;;795                buf[len++] = '-';
000e7c  e3a0102d          MOV      r1,#0x2d
000e80  e1a00004          MOV      r0,r4
000e84  e2844001          ADD      r4,r4,#1
000e88  e7c61000          STRB     r1,[r6,r0]
000e8c  ea00000e          B        |L1.3788|
                  |L1.3728|
;;;796            } else if(flags & FLAGS_PLUS) {
000e90  e2050004          AND      r0,r5,#4
000e94  e3500000          CMP      r0,#0
000e98  0a000004          BEQ      |L1.3760|
;;;797                buf[len++] = '+'; // ignore the space if the '+' exists
000e9c  e3a0102b          MOV      r1,#0x2b
000ea0  e1a00004          MOV      r0,r4
000ea4  e2844001          ADD      r4,r4,#1
000ea8  e7c61000          STRB     r1,[r6,r0]
000eac  ea000006          B        |L1.3788|
                  |L1.3760|
;;;798            } else if(flags & FLAGS_SPACE) {
000eb0  e2050008          AND      r0,r5,#8
000eb4  e3500000          CMP      r0,#0
000eb8  0a000003          BEQ      |L1.3788|
;;;799                buf[len++] = ' ';
000ebc  e3a01020          MOV      r1,#0x20
000ec0  e1a00004          MOV      r0,r4
000ec4  e2844001          ADD      r4,r4,#1
000ec8  e7c61000          STRB     r1,[r6,r0]
                  |L1.3788|
;;;800            }
;;;801        }
;;;802    
;;;803        out_rev_(output, buf, len, width, flags);
000ecc  e1a03009          MOV      r3,r9
000ed0  e1a02004          MOV      r2,r4
000ed4  e1a01006          MOV      r1,r6
000ed8  e58d5000          STR      r5,[sp,#0]
000edc  e59d0048          LDR      r0,[sp,#0x48]
000ee0  ebfffffe          BL       out_rev_
;;;804    }
000ee4  e8bd1ffc          POP      {r2-r12}
000ee8  e49df014          LDR      pc,[sp],#0x14
;;;805    
                          ENDP

                  print_decimal_number PROC
;;;806    // internal ftoa for fixed decimal floating point
;;;807    static void print_decimal_number(
000eec  e92d4ff0          PUSH     {r4-r11,lr}
;;;808        output_gadget_t* output,
;;;809        double number,
;;;810        printf_size_t precision,
;;;811        printf_size_t width,
;;;812        printf_flags_t flags,
;;;813        char* buf,
;;;814        printf_size_t len) {
000ef0  e24dd03c          SUB      sp,sp,#0x3c
000ef4  e1a04000          MOV      r4,r0
000ef8  e1a06002          MOV      r6,r2
000efc  e1a07003          MOV      r7,r3
000f00  e28db060          ADD      r11,sp,#0x60
000f04  e89b0f20          LDM      r11,{r5,r8-r11}
;;;815        struct double_components value_ = get_components(number, precision);
000f08  e1a02006          MOV      r2,r6
000f0c  e1a03007          MOV      r3,r7
000f10  e58d5000          STR      r5,[sp,#0]
000f14  e28d0020          ADD      r0,sp,#0x20
000f18  ebfffffe          BL       get_components
;;;816        print_broken_up_decimal(value_, output, precision, width, flags, buf, len);
000f1c  e28d0008          ADD      r0,sp,#8
000f20  e8800f30          STM      r0,{r4,r5,r8-r11}
000f24  e1cd03d0          LDRD     r0,r1,[sp,#0x30]
000f28  e1cd00f0          STRD     r0,r1,[sp,#0]
000f2c  e1cd02d0          LDRD     r0,r1,[sp,#0x20]
000f30  e1cd22d8          LDRD     r2,r3,[sp,#0x28]
000f34  ebfffffe          BL       print_broken_up_decimal
;;;817    }
000f38  e28dd03c          ADD      sp,sp,#0x3c
000f3c  e8bd8ff0          POP      {r4-r11,pc}
;;;818    
                          ENDP

                  bastardized_floor PROC
;;;822    // floor value is representable by an int.
;;;823    static int bastardized_floor(double x) {
000f40  e92d41f0          PUSH     {r4-r8,lr}
000f44  e1a04000          MOV      r4,r0
000f48  e1a05001          MOV      r5,r1
000f4c  e3a02000          MOV      r2,#0
000f50  e1a03002          MOV      r3,r2
;;;824        if(x >= 0) {
000f54  e1a00004          MOV      r0,r4
000f58  e1a01005          MOV      r1,r5
000f5c  ebfffffe          BL       __aeabi_cdrcmple
000f60  8a000003          BHI      |L1.3956|
;;;825            return (int)x;
000f64  e1a00004          MOV      r0,r4
000f68  e1a01005          MOV      r1,r5
000f6c  ebfffffe          BL       __aeabi_d2iz
                  |L1.3952|
;;;826        }
;;;827        int n = (int)x;
;;;828        return (((double)n) == x) ? n : n - 1;
;;;829    }
000f70  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3956|
000f74  e1a00004          MOV      r0,r4                 ;827
000f78  e1a01005          MOV      r1,r5                 ;827
000f7c  ebfffffe          BL       __aeabi_d2iz
000f80  e1a08000          MOV      r8,r0                 ;827
000f84  e1a00008          MOV      r0,r8                 ;828
000f88  ebfffffe          BL       __aeabi_i2d
000f8c  e1a06000          MOV      r6,r0                 ;828
000f90  e1a02004          MOV      r2,r4                 ;828
000f94  e1a03005          MOV      r3,r5                 ;828
000f98  ebfffffe          BL       __aeabi_cdcmpeq
000f9c  1a000001          BNE      |L1.4008|
000fa0  e1a00008          MOV      r0,r8                 ;828
000fa4  eafffff1          B        |L1.3952|
                  |L1.4008|
000fa8  e2480001          SUB      r0,r8,#1              ;828
000fac  eaffffef          B        |L1.3952|
;;;830    
                          ENDP

                  log10_of_positive PROC
;;;832    // positive number (not infinity or NaN, nor a sub-normal)
;;;833    static double log10_of_positive(double positive_number) {
000fb0  e92d4ff0          PUSH     {r4-r11,lr}
000fb4  e24dd03c          SUB      sp,sp,#0x3c
000fb8  e1a06000          MOV      r6,r0
000fbc  e1a07001          MOV      r7,r1
;;;834        // The implementation follows David Gay (https://www.ampl.com/netlib/fp/dtoa.c).
;;;835        //
;;;836        // Since log_10 ( M * 2^x ) = log_10(M) + x , we can separate the components of
;;;837        // our input number, and need only solve log_10(M) for M between 1 and 2 (as
;;;838        // the base-2 mantissa is always 1-point-something). In that limited range, a
;;;839        // Taylor series expansion of log10(x) should serve us well enough; and we'll
;;;840        // take the mid-point, 1.5, as the point of expansion.
;;;841    
;;;842        double_with_bit_access dwba = get_bit_access(positive_number);
000fc0  e1a02006          MOV      r2,r6
000fc4  e1a03007          MOV      r3,r7
000fc8  e28d0030          ADD      r0,sp,#0x30
000fcc  ebfffffe          BL       get_bit_access
;;;843        // based on the algorithm by David Gay (https://www.ampl.com/netlib/fp/dtoa.c)
;;;844        int exp2 = get_exp2(dwba);
000fd0  e1cd03d0          LDRD     r0,r1,[sp,#0x30]
000fd4  ebfffffe          BL       get_exp2
000fd8  e58d002c          STR      r0,[sp,#0x2c]
;;;845        // drop the exponent, so dwba.F comes into the range [1,2)
;;;846        dwba.U = (dwba.U & (((double_uint_t)(1) << DOUBLE_STORED_MANTISSA_BITS) - 1U)) |
000fdc  e1cd03d0          LDRD     r0,r1,[sp,#0x30]
000fe0  e59f2110          LDR      r2,|L1.4344|
000fe4  e0011002          AND      r1,r1,r2
000fe8  e59f210c          LDR      r2,|L1.4348|
000fec  e1811002          ORR      r1,r1,r2
000ff0  e1cd03f0          STRD     r0,r1,[sp,#0x30]
;;;847                 ((double_uint_t)DOUBLE_BASE_EXPONENT << DOUBLE_STORED_MANTISSA_BITS);
;;;848        double z = (dwba.F - 1.5);
000ff4  e3a02000          MOV      r2,#0
000ff8  e59d1034          LDR      r1,[sp,#0x34]
000ffc  e59d8030          LDR      r8,[sp,#0x30]
001000  e59f30f8          LDR      r3,|L1.4352|
001004  e1a00008          MOV      r0,r8
001008  ebfffffe          BL       __aeabi_dsub
00100c  e1a04000          MOV      r4,r0
001010  e1a05001          MOV      r5,r1
;;;849        return (
001014  e59d002c          LDR      r0,[sp,#0x2c]
001018  ebfffffe          BL       __aeabi_i2d
00101c  e1a08000          MOV      r8,r0
001020  e59f20dc          LDR      r2,|L1.4356|
001024  e59f30dc          LDR      r3,|L1.4360|
001028  ebfffffe          BL       __aeabi_dmul
00102c  e1a02004          MOV      r2,r4
001030  e1a03005          MOV      r3,r5
001034  e1cd02f0          STRD     r0,r1,[sp,#0x20]
001038  e1a00004          MOV      r0,r4
00103c  e1a01005          MOV      r1,r5
001040  ebfffffe          BL       __aeabi_dmul
001044  e1a08000          MOV      r8,r0
001048  e1a02004          MOV      r2,r4
00104c  e1a03005          MOV      r3,r5
001050  ebfffffe          BL       __aeabi_dmul
001054  e1a0a000          MOV      r10,r0
001058  e59f20ac          LDR      r2,|L1.4364|
00105c  e59f30ac          LDR      r3,|L1.4368|
001060  ebfffffe          BL       __aeabi_dmul
001064  e1a02004          MOV      r2,r4
001068  e1a03005          MOV      r3,r5
00106c  e1cd01f0          STRD     r0,r1,[sp,#0x10]
001070  e1a00004          MOV      r0,r4
001074  e1a01005          MOV      r1,r5
001078  ebfffffe          BL       __aeabi_dmul
00107c  e1a08000          MOV      r8,r0
001080  e59f208c          LDR      r2,|L1.4372|
001084  e59f308c          LDR      r3,|L1.4376|
001088  ebfffffe          BL       __aeabi_dmul
00108c  e1a0a000          MOV      r10,r0
001090  e1a0b001          MOV      r11,r1
001094  e59f2080          LDR      r2,|L1.4380|
001098  e59f3080          LDR      r3,|L1.4384|
00109c  e1a00004          MOV      r0,r4
0010a0  e1a01005          MOV      r1,r5
0010a4  ebfffffe          BL       __aeabi_dmul
0010a8  e1a08000          MOV      r8,r0
0010ac  e59f2070          LDR      r2,|L1.4388|
0010b0  e59f3070          LDR      r3,|L1.4392|
0010b4  ebfffffe          BL       __aeabi_dadd
0010b8  e1a0200a          MOV      r2,r10
0010bc  e1a0300b          MOV      r3,r11
0010c0  e1cd00f0          STRD     r0,r1,[sp,#0]
0010c4  ebfffffe          BL       __aeabi_dsub
0010c8  e1cd00f8          STRD     r0,r1,[sp,#8]
0010cc  e1cd21d0          LDRD     r2,r3,[sp,#0x10]
0010d0  ebfffffe          BL       __aeabi_dadd
0010d4  e1cd01f8          STRD     r0,r1,[sp,#0x18]
0010d8  e1cd22d0          LDRD     r2,r3,[sp,#0x20]
0010dc  ebfffffe          BL       __aeabi_dadd
0010e0  e28dd03c          ADD      sp,sp,#0x3c
;;;850            // Taylor expansion around 1.5:
;;;851            0.1760912590556812420 // Expansion term 0: ln(1.5)            / ln(10)
;;;852            + z * 0.2895296546021678851 // Expansion term 1: (M - 1.5)   * 2/3  / ln(10)
;;;853    #if PRINTF_LOG10_TAYLOR_TERMS > 2
;;;854            - z * z * 0.0965098848673892950 // Expansion term 2: (M - 1.5)^2 * 2/9  / ln(10)
;;;855    #if PRINTF_LOG10_TAYLOR_TERMS > 3
;;;856            + z * z * z * 0.0428932821632841311 // Expansion term 2: (M - 1.5)^3 * 8/81 / ln(10)
;;;857    #endif
;;;858    #endif
;;;859            // exact log_2 of the exponent x, with logarithm base change
;;;860            + exp2 * 0.30102999566398119521 // = exp2 * log_10(2) = exp2 * ln(2)/ln(10)
;;;861        );
;;;862    }
0010e4  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.4328|
                          DCD      0x00002010
                  |L1.4332|
                          DCD      powers_of_10
                  |L1.4336|
                          DCD      0x3fe00000
                  |L1.4340|
                          DCD      0x00000133
                  |L1.4344|
                          DCD      0x000fffff
                  |L1.4348|
                          DCD      0x3ff00000
                  |L1.4352|
                          DCD      0x3ff80000
                  |L1.4356|
                          DCD      0x509f79ff
                  |L1.4360|
                          DCD      0x3fd34413
                  |L1.4364|
                          DCD      0xb83803ff
                  |L1.4368|
                          DCD      0x3fa5f61b
                  |L1.4372|
                          DCD      0x2f3f047e
                  |L1.4376|
                          DCD      0x3fb8b4df
                  |L1.4380|
                          DCD      0x636f435f
                  |L1.4384|
                          DCD      0x3fd287a7
                  |L1.4388|
                          DCD      0x8b60b7fc
                  |L1.4392|
                          DCD      0x3fc68a28
                          ENDP

                  pow10_of_int PROC
;;;863    
;;;864    static double pow10_of_int(int floored_exp10) {
00112c  e92d4ff0          PUSH     {r4-r11,lr}
001130  e24dd054          SUB      sp,sp,#0x54
001134  e1a0b000          MOV      r11,r0
;;;865        // A crude hack for avoiding undesired behavior with barely-normal or slightly-subnormal values.
;;;866        if(floored_exp10 == DOUBLE_MAX_SUBNORMAL_EXPONENT_OF_10) {
001138  e37b0f4d          CMN      r11,#0x134
00113c  1a000003          BNE      |L1.4432|
001140  e3a00000          MOV      r0,#0
001144  e1a01000          MOV      r1,r0
                  |L1.4424|
;;;867            return DOUBLE_MAX_SUBNORMAL_POWER_OF_10;
001148  e28dd054          ADD      sp,sp,#0x54
;;;868        }
;;;869        // Compute 10^(floored_exp10) but (try to) make sure that doesn't overflow
;;;870        double_with_bit_access dwba;
;;;871        int exp2        = bastardized_floor(floored_exp10 * 3.321928094887362 + 0.5);
;;;872        const double z  = floored_exp10 * 2.302585092994046 - exp2 * 0.6931471805599453;
;;;873        const double z2 = z * z;
;;;874        dwba.U = ((double_uint_t)(exp2) + DOUBLE_BASE_EXPONENT) << DOUBLE_STORED_MANTISSA_BITS;
;;;875        // compute exp(z) using continued fractions,
;;;876        // see https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
;;;877        dwba.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
;;;878        return dwba.F;
;;;879    }
00114c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.4432|
001150  e1a0000b          MOV      r0,r11                ;871
001154  ebfffffe          BL       __aeabi_i2d
001158  e1cd03f8          STRD     r0,r1,[sp,#0x38]      ;871
00115c  e59f2900          LDR      r2,|L1.6756|
001160  e59f3900          LDR      r3,|L1.6760|
001164  ebfffffe          BL       __aeabi_dmul
001168  e3a02000          MOV      r2,#0                 ;871
00116c  e1cd04f0          STRD     r0,r1,[sp,#0x40]      ;871
001170  e51f3088          LDR      r3,|L1.4336|
001174  ebfffffe          BL       __aeabi_dadd
001178  e1a08000          MOV      r8,r0                 ;871
00117c  ebfffffe          BL       bastardized_floor
001180  e1a0a000          MOV      r10,r0                ;871
001184  e1a0000a          MOV      r0,r10                ;872
001188  ebfffffe          BL       __aeabi_i2d
00118c  e1a08000          MOV      r8,r0                 ;872
001190  e59f28d4          LDR      r2,|L1.6764|
001194  e59f38d4          LDR      r3,|L1.6768|
001198  ebfffffe          BL       __aeabi_dmul
00119c  e1cd04f0          STRD     r0,r1,[sp,#0x40]      ;872
0011a0  e1a0000b          MOV      r0,r11                ;872
0011a4  ebfffffe          BL       __aeabi_i2d
0011a8  e1a08000          MOV      r8,r0                 ;872
0011ac  e59f28c0          LDR      r2,|L1.6772|
0011b0  e59f38c0          LDR      r3,|L1.6776|
0011b4  ebfffffe          BL       __aeabi_dmul
0011b8  e1cd03f8          STRD     r0,r1,[sp,#0x38]      ;872
0011bc  e1cd24d0          LDRD     r2,r3,[sp,#0x40]      ;872
0011c0  ebfffffe          BL       __aeabi_dsub
0011c4  e1a04000          MOV      r4,r0                 ;872
0011c8  e1a05001          MOV      r5,r1                 ;872
0011cc  e1a02004          MOV      r2,r4                 ;873
0011d0  e1a03005          MOV      r3,r5                 ;873
0011d4  e1a00004          MOV      r0,r4                 ;873
0011d8  e1a01005          MOV      r1,r5                 ;873
0011dc  ebfffffe          BL       __aeabi_dmul
0011e0  e1a06000          MOV      r6,r0                 ;873
0011e4  e1a07001          MOV      r7,r1                 ;873
0011e8  e59f088c          LDR      r0,|L1.6780|
0011ec  e090000a          ADDS     r0,r0,r10             ;873
0011f0  e1a00a00          LSL      r0,r0,#20             ;874
0011f4  e3a01000          MOV      r1,#0                 ;874
0011f8  e58d004c          STR      r0,[sp,#0x4c]         ;874
0011fc  e58d1048          STR      r1,[sp,#0x48]         ;874
001200  e3a02000          MOV      r2,#0                 ;874
001204  e59f3874          LDR      r3,|L1.6784|
001208  e1a00006          MOV      r0,r6                 ;877
00120c  e1a01007          MOV      r1,r7                 ;877
001210  ebfffffe          BL       __aeabi_ddiv
001214  e1a08000          MOV      r8,r0                 ;877
001218  e3a02000          MOV      r2,#0                 ;877
00121c  e59f3860          LDR      r3,|L1.6788|
001220  ebfffffe          BL       __aeabi_dadd
001224  e1cd00f0          STRD     r0,r1,[sp,#0]         ;877
001228  e1a02000          MOV      r2,r0                 ;877
00122c  e1a03001          MOV      r3,r1                 ;877
001230  e1a00006          MOV      r0,r6                 ;877
001234  e1a01007          MOV      r1,r7                 ;877
001238  ebfffffe          BL       __aeabi_ddiv
00123c  e3a02000          MOV      r2,#0                 ;877
001240  e1cd00f8          STRD     r0,r1,[sp,#8]         ;877
001244  e59f383c          LDR      r3,|L1.6792|
001248  ebfffffe          BL       __aeabi_dadd
00124c  e1cd01f0          STRD     r0,r1,[sp,#0x10]      ;877
001250  e1a02000          MOV      r2,r0                 ;877
001254  e1a03001          MOV      r3,r1                 ;877
001258  e1a00006          MOV      r0,r6                 ;877
00125c  e1a01007          MOV      r1,r7                 ;877
001260  ebfffffe          BL       __aeabi_ddiv
001264  e1a02004          MOV      r2,r4                 ;877
001268  e1a03005          MOV      r3,r5                 ;877
00126c  e1cd02f0          STRD     r0,r1,[sp,#0x20]      ;877
001270  e3a00000          MOV      r0,#0                 ;877
001274  e3a01101          MOV      r1,#0x40000000        ;877
001278  ebfffffe          BL       __aeabi_dsub
00127c  e1cd01f8          STRD     r0,r1,[sp,#0x18]      ;877
001280  e1cd22d0          LDRD     r2,r3,[sp,#0x20]      ;877
001284  ebfffffe          BL       __aeabi_dadd
001288  e1a02004          MOV      r2,r4                 ;877
00128c  e1a03005          MOV      r3,r5                 ;877
001290  e1cd03f0          STRD     r0,r1,[sp,#0x30]      ;877
001294  e3a00000          MOV      r0,#0                 ;877
001298  e3a01101          MOV      r1,#0x40000000        ;877
00129c  ebfffffe          BL       __aeabi_dmul
0012a0  e1cd02f8          STRD     r0,r1,[sp,#0x28]      ;877
0012a4  e1cd23d0          LDRD     r2,r3,[sp,#0x30]      ;877
0012a8  ebfffffe          BL       __aeabi_ddiv
0012ac  e3a02000          MOV      r2,#0                 ;877
0012b0  e1cd03f8          STRD     r0,r1,[sp,#0x38]      ;877
0012b4  e51f31c0          LDR      r3,|L1.4348|
0012b8  ebfffffe          BL       __aeabi_dadd
0012bc  e1cd04f0          STRD     r0,r1,[sp,#0x40]      ;877
0012c0  e59d8048          LDR      r8,[sp,#0x48]         ;877
0012c4  e1a02008          MOV      r2,r8                 ;877
0012c8  e59d304c          LDR      r3,[sp,#0x4c]         ;877
0012cc  ebfffffe          BL       __aeabi_dmul
0012d0  e1cd04f8          STRD     r0,r1,[sp,#0x48]      ;877
0012d4  e1cd04d8          LDRD     r0,r1,[sp,#0x48]      ;878
0012d8  eaffff9a          B        |L1.4424|
;;;880    
                          ENDP

                  print_exponential_number PROC
;;;881    static void print_exponential_number(
0012dc  e92d5fff          PUSH     {r0-r12,lr}
;;;882        output_gadget_t* output,
;;;883        double number,
;;;884        printf_size_t precision,
;;;885        printf_size_t width,
;;;886        printf_flags_t flags,
;;;887        char* buf,
;;;888        printf_size_t len) {
0012e0  e24dd098          SUB      sp,sp,#0x98
0012e4  e1a09002          MOV      r9,r2
0012e8  e1a0a003          MOV      r10,r3
0012ec  e59d70d0          LDR      r7,[sp,#0xd0]
0012f0  e59d80d8          LDR      r8,[sp,#0xd8]
;;;889        const bool negative = get_sign_bit(number);
0012f4  e1a00009          MOV      r0,r9
0012f8  e1a0100a          MOV      r1,r10
0012fc  ebfffffe          BL       get_sign_bit
001300  e3500000          CMP      r0,#0
001304  0a000001          BEQ      |L1.4880|
001308  e3a00001          MOV      r0,#1
00130c  ea000000          B        |L1.4884|
                  |L1.4880|
001310  e3a00000          MOV      r0,#0
                  |L1.4884|
001314  e58d0094          STR      r0,[sp,#0x94]
;;;890        // This number will decrease gradually (by factors of 10) as we "extract" the exponent out of it
;;;891        double abs_number = negative ? -number : number;
001318  e59d0094          LDR      r0,[sp,#0x94]
00131c  e3500000          CMP      r0,#0
001320  0a000002          BEQ      |L1.4912|
001324  e1a00009          MOV      r0,r9
001328  e22a1102          EOR      r1,r10,#0x80000000
00132c  ea000001          B        |L1.4920|
                  |L1.4912|
001330  e1a00009          MOV      r0,r9
001334  e1a0100a          MOV      r1,r10
                  |L1.4920|
001338  e1a05000          MOV      r5,r0
00133c  e1a06001          MOV      r6,r1
;;;892    
;;;893        int floored_exp10;
;;;894        bool abs_exp10_covered_by_powers_table = false;
001340  e3a00000          MOV      r0,#0
001344  e58d0090          STR      r0,[sp,#0x90]
001348  e3a02000          MOV      r2,#0
00134c  e1a03002          MOV      r3,r2
;;;895        struct scaling_factor normalization;
;;;896    
;;;897        // Determine the decimal exponent
;;;898        if(abs_number == 0.0) {
001350  e1a00005          MOV      r0,r5
001354  e1a01006          MOV      r1,r6
001358  ebfffffe          BL       __aeabi_cdcmpeq
00135c  1a000001          BNE      |L1.4968|
;;;899            // TODO: This is a special-case for 0.0 (and -0.0); but proper handling is required for denormals more generally.
;;;900            floored_exp10 =
001360  e3a04000          MOV      r4,#0
001364  ea00002e          B        |L1.5156|
                  |L1.4968|
;;;901                0; // ... and no need to set a normalization factor or check the powers table
;;;902        } else {
;;;903            double exp10  = log10_of_positive(abs_number);
001368  e1a00005          MOV      r0,r5
00136c  e1a01006          MOV      r1,r6
001370  ebfffffe          BL       log10_of_positive
001374  e1cd04f8          STRD     r0,r1,[sp,#0x48]
;;;904            floored_exp10 = bastardized_floor(exp10);
001378  e1cd04d8          LDRD     r0,r1,[sp,#0x48]
00137c  ebfffffe          BL       bastardized_floor
001380  e1a04000          MOV      r4,r0
;;;905            double p10    = pow10_of_int(floored_exp10);
001384  e1a00004          MOV      r0,r4
001388  ebfffffe          BL       pow10_of_int
00138c  e1cd04f0          STRD     r0,r1,[sp,#0x40]
;;;906            // correct for rounding errors
;;;907            if(abs_number < p10) {
001390  e1a00005          MOV      r0,r5
001394  e1a01006          MOV      r1,r6
001398  e1cd24d0          LDRD     r2,r3,[sp,#0x40]
00139c  ebfffffe          BL       __aeabi_cdcmple
0013a0  2a000005          BCS      |L1.5052|
;;;908                floored_exp10--;
0013a4  e2444001          SUB      r4,r4,#1
0013a8  e3a02000          MOV      r2,#0
0013ac  e59f36d0          LDR      r3,|L1.6788|
;;;909                p10 /= 10;
0013b0  e1cd04d0          LDRD     r0,r1,[sp,#0x40]
0013b4  ebfffffe          BL       __aeabi_ddiv
0013b8  e1cd04f0          STRD     r0,r1,[sp,#0x40]
                  |L1.5052|
;;;910            }
;;;911            abs_exp10_covered_by_powers_table = PRINTF_ABS(floored_exp10) <
0013bc  e3540000          CMP      r4,#0
0013c0  da000001          BLE      |L1.5068|
0013c4  e1a00004          MOV      r0,r4
0013c8  ea000000          B        |L1.5072|
                  |L1.5068|
0013cc  e2640000          RSB      r0,r4,#0
                  |L1.5072|
0013d0  e3500012          CMP      r0,#0x12
0013d4  aa000001          BGE      |L1.5088|
0013d8  e3a00001          MOV      r0,#1
0013dc  ea000000          B        |L1.5092|
                  |L1.5088|
0013e0  e3a00000          MOV      r0,#0
                  |L1.5092|
0013e4  e58d0090          STR      r0,[sp,#0x90]
;;;912                                                PRINTF_MAX_PRECOMPUTED_POWER_OF_10;
;;;913            normalization.raw_factor =
0013e8  e59d0090          LDR      r0,[sp,#0x90]
0013ec  e3500000          CMP      r0,#0
0013f0  0a000008          BEQ      |L1.5144|
;;;914                abs_exp10_covered_by_powers_table ? powers_of_10[PRINTF_ABS(floored_exp10)] : p10;
0013f4  e3540000          CMP      r4,#0
0013f8  da000001          BLE      |L1.5124|
0013fc  e1a00004          MOV      r0,r4
001400  ea000000          B        |L1.5128|
                  |L1.5124|
001404  e2640000          RSB      r0,r4,#0
                  |L1.5128|
001408  e51f1324          LDR      r1,|L1.4332|
00140c  e7b10180          LDR      r0,[r1,r0,LSL #3]!
001410  e5911004          LDR      r1,[r1,#4]
001414  ea000000          B        |L1.5148|
                  |L1.5144|
001418  e1cd04d0          LDRD     r0,r1,[sp,#0x40]
                  |L1.5148|
00141c  e1cd08f0          STRD     r0,r1,[sp,#0x80]
;;;915        }
001420  e1a00000          MOV      r0,r0
                  |L1.5156|
;;;916    
;;;917        // We now begin accounting for the widths of the two parts of our printed field:
;;;918        // the decimal part after decimal exponent extraction, and the base-10 exponent part.
;;;919        // For both of these, the value of 0 has a special meaning, but not the same one:
;;;920        // a 0 exponent-part width means "don't print the exponent"; a 0 decimal-part width
;;;921        // means "use as many characters as necessary".
;;;922    
;;;923        bool fall_back_to_decimal_only_mode = false;
001424  e3a0b000          MOV      r11,#0
;;;924        if(flags & FLAGS_ADAPT_EXP) {
001428  e2080a01          AND      r0,r8,#0x1000
00142c  e3500000          CMP      r0,#0
001430  0a00001c          BEQ      |L1.5288|
;;;925            int required_significant_digits = (precision == 0) ? 1 : (int)precision;
001434  e3570000          CMP      r7,#0
001438  1a000001          BNE      |L1.5188|
00143c  e3a02001          MOV      r2,#1
001440  ea000000          B        |L1.5192|
                  |L1.5188|
001444  e1a02007          MOV      r2,r7
                  |L1.5192|
001448  e1a00002          MOV      r0,r2
;;;926            // Should we want to fall-back to "%f" mode, and only print the decimal part?
;;;927            fall_back_to_decimal_only_mode =
00144c  e3740004          CMN      r4,#4
001450  ba000003          BLT      |L1.5220|
;;;928                (floored_exp10 >= -4 && floored_exp10 < required_significant_digits);
001454  e1540000          CMP      r4,r0
001458  aa000001          BGE      |L1.5220|
00145c  e3a02001          MOV      r2,#1
001460  ea000000          B        |L1.5224|
                  |L1.5220|
001464  e3a02000          MOV      r2,#0
                  |L1.5224|
001468  e1a0b002          MOV      r11,r2
;;;929            // Now, let's adjust the precision
;;;930            // This also decided how we adjust the precision value - as in "%g" mode,
;;;931            // "precision" is the number of _significant digits_, and this is when we "translate"
;;;932            // the precision value to an actual number of decimal digits.
;;;933            int precision_ =
00146c  e35b0000          CMP      r11,#0
001470  0a000002          BEQ      |L1.5248|
;;;934                fall_back_to_decimal_only_mode ?
;;;935                    (int)precision - 1 - floored_exp10 :
001474  e2472001          SUB      r2,r7,#1
001478  e0422004          SUB      r2,r2,r4
00147c  ea000000          B        |L1.5252|
                  |L1.5248|
;;;936                    (int)precision -
001480  e2472001          SUB      r2,r7,#1
                  |L1.5252|
001484  e1a01002          MOV      r1,r2
;;;937                        1; // the presence of the exponent ensures only one significant digit comes before the decimal point
;;;938            precision = (precision_ > 0 ? (unsigned)precision_ : 0U);
001488  e3510000          CMP      r1,#0
00148c  da000001          BLE      |L1.5272|
001490  e1a02001          MOV      r2,r1
001494  ea000000          B        |L1.5276|
                  |L1.5272|
001498  e3a02000          MOV      r2,#0
                  |L1.5276|
00149c  e1a07002          MOV      r7,r2
;;;939            flags |= FLAGS_PRECISION; // make sure print_broken_up_decimal respects our choice above
0014a0  e3888b02          ORR      r8,r8,#0x800
;;;940        }
0014a4  e1a00000          MOV      r0,r0
                  |L1.5288|
;;;941    
;;;942        normalization.multiply         = (floored_exp10 < 0 && abs_exp10_covered_by_powers_table);
0014a8  e3540000          CMP      r4,#0
0014ac  aa000004          BGE      |L1.5316|
0014b0  e59d0090          LDR      r0,[sp,#0x90]
0014b4  e3500000          CMP      r0,#0
0014b8  0a000001          BEQ      |L1.5316|
0014bc  e3a00001          MOV      r0,#1
0014c0  ea000000          B        |L1.5320|
                  |L1.5316|
0014c4  e3a00000          MOV      r0,#0
                  |L1.5320|
0014c8  e5cd0088          STRB     r0,[sp,#0x88]
;;;943        bool should_skip_normalization = (fall_back_to_decimal_only_mode || floored_exp10 == 0);
0014cc  e35b0000          CMP      r11,#0
0014d0  1a000001          BNE      |L1.5340|
0014d4  e3540000          CMP      r4,#0
0014d8  1a000001          BNE      |L1.5348|
                  |L1.5340|
0014dc  e3a00001          MOV      r0,#1
0014e0  ea000000          B        |L1.5352|
                  |L1.5348|
0014e4  e3a00000          MOV      r0,#0
                  |L1.5352|
0014e8  e58d007c          STR      r0,[sp,#0x7c]
;;;944        struct double_components decimal_part_components =
0014ec  e59d007c          LDR      r0,[sp,#0x7c]
0014f0  e3500000          CMP      r0,#0
0014f4  0a000012          BEQ      |L1.5444|
0014f8  e59d0094          LDR      r0,[sp,#0x94]
0014fc  e3500000          CMP      r0,#0
001500  0a000002          BEQ      |L1.5392|
;;;945            should_skip_normalization ?
;;;946                get_components(negative ? -abs_number : abs_number, precision) :
001504  e1a00005          MOV      r0,r5
001508  e2261102          EOR      r1,r6,#0x80000000
00150c  ea000001          B        |L1.5400|
                  |L1.5392|
001510  e1a00005          MOV      r0,r5
001514  e1a01006          MOV      r1,r6
                  |L1.5400|
001518  e1cd01f8          STRD     r0,r1,[sp,#0x18]
00151c  e1a02000          MOV      r2,r0
001520  e1a03001          MOV      r3,r1
001524  e58d7000          STR      r7,[sp,#0]
001528  e28d0020          ADD      r0,sp,#0x20
00152c  ebfffffe          BL       get_components
001530  e3a02018          MOV      r2,#0x18
001534  e28d1020          ADD      r1,sp,#0x20
001538  e28d0060          ADD      r0,sp,#0x60
00153c  ebfffffe          BL       __aeabi_memcpy4
001540  ea00000d          B        |L1.5500|
                  |L1.5444|
001544  e58d4018          STR      r4,[sp,#0x18]
001548  e1cd08d0          LDRD     r0,r1,[sp,#0x80]
00154c  e1cd28d8          LDRD     r2,r3,[sp,#0x88]
001550  e1cd00f8          STRD     r0,r1,[sp,#8]
001554  e1cd21f0          STRD     r2,r3,[sp,#0x10]
001558  e1a02007          MOV      r2,r7
00155c  e88d0060          STM      sp,{r5,r6}
001560  e59d1094          LDR      r1,[sp,#0x94]
001564  e28d0038          ADD      r0,sp,#0x38
001568  ebfffffe          BL       get_normalized_components
00156c  e3a02018          MOV      r2,#0x18
001570  e28d1038          ADD      r1,sp,#0x38
001574  e28d0060          ADD      r0,sp,#0x60
001578  ebfffffe          BL       __aeabi_memcpy4
                  |L1.5500|
;;;947                get_normalized_components(
;;;948                    negative, precision, abs_number, normalization, floored_exp10);
;;;949    
;;;950        // Account for roll-over, e.g. rounding from 9.99 to 100.0 - which effects
;;;951        // the exponent and may require additional tweaking of the parts
;;;952        if(fall_back_to_decimal_only_mode) {
00157c  e35b0000          CMP      r11,#0
001580  0a000017          BEQ      |L1.5604|
;;;953            if((flags & FLAGS_ADAPT_EXP) && floored_exp10 >= -1 &&
001584  e2080a01          AND      r0,r8,#0x1000
001588  e3500000          CMP      r0,#0
00158c  0a000020          BEQ      |L1.5652|
001590  e3740001          CMN      r4,#1
001594  ba00001e          BLT      |L1.5652|
;;;954               decimal_part_components.integral == powers_of_10[floored_exp10 + 1]) {
001598  e59d2060          LDR      r2,[sp,#0x60]
00159c  e1a00002          MOV      r0,r2
0015a0  e59d1064          LDR      r1,[sp,#0x64]
0015a4  ebfffffe          BL       __aeabi_l2d
0015a8  e1cd04f8          STRD     r0,r1,[sp,#0x48]
0015ac  e51f04c8          LDR      r0,|L1.4332|
0015b0  e2841001          ADD      r1,r4,#1
0015b4  e7b01181          LDR      r1,[r0,r1,LSL #3]!
0015b8  e5900004          LDR      r0,[r0,#4]
0015bc  e58d1040          STR      r1,[sp,#0x40]
0015c0  e1a02001          MOV      r2,r1
0015c4  e58d0044          STR      r0,[sp,#0x44]
0015c8  e1a03000          MOV      r3,r0
0015cc  e1cd04d8          LDRD     r0,r1,[sp,#0x48]
0015d0  ebfffffe          BL       __aeabi_cdcmpeq
0015d4  1a00000e          BNE      |L1.5652|
;;;955                floored_exp10++; // Not strictly necessary, since floored_exp10 is no longer really used
0015d8  e2844001          ADD      r4,r4,#1
;;;956                precision--;
0015dc  e2477001          SUB      r7,r7,#1
0015e0  ea00000b          B        |L1.5652|
                  |L1.5604|
;;;957                // ... and it should already be the case that decimal_part_components.fractional == 0
;;;958            }
;;;959            // TODO: What about rollover strictly within the fractional part?
;;;960        } else {
;;;961            if(decimal_part_components.integral >= 10) {
0015e4  e59d3060          LDR      r3,[sp,#0x60]
0015e8  e253000a          SUBS     r0,r3,#0xa
0015ec  e59d1064          LDR      r1,[sp,#0x64]
0015f0  e2d10000          SBCS     r0,r1,#0
0015f4  ba000006          BLT      |L1.5652|
;;;962                floored_exp10++;
0015f8  e2844001          ADD      r4,r4,#1
0015fc  e3a01001          MOV      r1,#1
001600  e3a00000          MOV      r0,#0
;;;963                decimal_part_components.integral   = 1;
001604  e58d0064          STR      r0,[sp,#0x64]
001608  e58d1060          STR      r1,[sp,#0x60]
;;;964                decimal_part_components.fractional = 0;
00160c  e58d0068          STR      r0,[sp,#0x68]
001610  e58d006c          STR      r0,[sp,#0x6c]
                  |L1.5652|
;;;965            }
;;;966        }
;;;967    
;;;968        // the floored_exp10 format is "E%+03d" and largest possible floored_exp10 value for a 64-bit double
;;;969        // is "307" (for 2^1023), so we set aside 4-5 characters overall
;;;970        printf_size_t exp10_part_width = fall_back_to_decimal_only_mode    ? 0U :
001614  e35b0000          CMP      r11,#0
001618  0a000001          BEQ      |L1.5668|
00161c  e3a00000          MOV      r0,#0
001620  ea000009          B        |L1.5708|
                  |L1.5668|
;;;971                                         (PRINTF_ABS(floored_exp10) < 100) ? 4U :
001624  e3540000          CMP      r4,#0
001628  da000001          BLE      |L1.5684|
00162c  e1a00004          MOV      r0,r4
001630  ea000000          B        |L1.5688|
                  |L1.5684|
001634  e2640000          RSB      r0,r4,#0
                  |L1.5688|
001638  e3500064          CMP      r0,#0x64
00163c  aa000001          BGE      |L1.5704|
001640  e3a00004          MOV      r0,#4
001644  ea000000          B        |L1.5708|
                  |L1.5704|
;;;972                                                                             5U;
001648  e3a00005          MOV      r0,#5
                  |L1.5708|
00164c  e58d005c          STR      r0,[sp,#0x5c]
;;;973    
;;;974        printf_size_t decimal_part_width =
001650  e2080002          AND      r0,r8,#2
001654  e3500000          CMP      r0,#0
001658  0a000004          BEQ      |L1.5744|
;;;975            ((flags & FLAGS_LEFT) && exp10_part_width) ?
00165c  e59d005c          LDR      r0,[sp,#0x5c]
001660  e3500000          CMP      r0,#0
001664  0a000001          BEQ      |L1.5744|
;;;976                // We're padding on the right, so the width constraint is the exponent part's
;;;977                // problem, not the decimal part's, so we'll use as many characters as we need:
;;;978                0U :
001668  e3a00000          MOV      r0,#0
00166c  ea000008          B        |L1.5780|
                  |L1.5744|
;;;979                // We're padding on the left; so the width constraint is the decimal part's
;;;980                // problem. Well, can both the decimal part and the exponent part fit within our overall width?
;;;981                ((width > exp10_part_width) ?
001670  e59d00d4          LDR      r0,[sp,#0xd4]
001674  e59d105c          LDR      r1,[sp,#0x5c]
001678  e1500001          CMP      r0,r1
00167c  9a000003          BLS      |L1.5776|
;;;982                     // Yes, so we limit our decimal part's width.
;;;983                     // (Note this is trivially valid even if we've fallen back to "%f" mode)
;;;984                     width - exp10_part_width :
001680  e59d00d4          LDR      r0,[sp,#0xd4]
001684  e59d105c          LDR      r1,[sp,#0x5c]
001688  e0400001          SUB      r0,r0,r1
00168c  ea000000          B        |L1.5780|
                  |L1.5776|
;;;985                     // No; we just give up on any restriction on the decimal part and use as many
;;;986                     // characters as we need
;;;987                     0U);
001690  e3a00000          MOV      r0,#0
                  |L1.5780|
001694  e58d0058          STR      r0,[sp,#0x58]
;;;988    
;;;989        const printf_size_t printed_exponential_start_pos = output->pos;
001698  e59d0098          LDR      r0,[sp,#0x98]
00169c  e590000c          LDR      r0,[r0,#0xc]
0016a0  e58d0054          STR      r0,[sp,#0x54]
;;;990        print_broken_up_decimal(
0016a4  e59d0058          LDR      r0,[sp,#0x58]
0016a8  e59d10e0          LDR      r1,[sp,#0xe0]
0016ac  e59d20dc          LDR      r2,[sp,#0xdc]
0016b0  e58d0010          STR      r0,[sp,#0x10]
0016b4  e58d8014          STR      r8,[sp,#0x14]
0016b8  e58d101c          STR      r1,[sp,#0x1c]
0016bc  e58d2018          STR      r2,[sp,#0x18]
0016c0  e59d0098          LDR      r0,[sp,#0x98]
0016c4  e58d0008          STR      r0,[sp,#8]
0016c8  e58d700c          STR      r7,[sp,#0xc]
0016cc  e1cd07d0          LDRD     r0,r1,[sp,#0x70]
0016d0  e1cd00f0          STRD     r0,r1,[sp,#0]
0016d4  e1cd06d0          LDRD     r0,r1,[sp,#0x60]
0016d8  e1cd26d8          LDRD     r2,r3,[sp,#0x68]
0016dc  ebfffffe          BL       print_broken_up_decimal
;;;991            decimal_part_components, output, precision, decimal_part_width, flags, buf, len);
;;;992    
;;;993        if(!fall_back_to_decimal_only_mode) {
0016e0  e35b0000          CMP      r11,#0
0016e4  1a00002e          BNE      |L1.6052|
;;;994            putchar_via_gadget(output, (flags & FLAGS_UPPERCASE) ? 'E' : 'e');
0016e8  e2080020          AND      r0,r8,#0x20
0016ec  e3500000          CMP      r0,#0
0016f0  0a000001          BEQ      |L1.5884|
0016f4  e3a00045          MOV      r0,#0x45
0016f8  ea000000          B        |L1.5888|
                  |L1.5884|
0016fc  e3a00065          MOV      r0,#0x65
                  |L1.5888|
001700  e1a01000          MOV      r1,r0
001704  e59d0098          LDR      r0,[sp,#0x98]
001708  ebfffffe          BL       putchar_via_gadget
;;;995            print_integer(
00170c  e3a01005          MOV      r1,#5
001710  e59d005c          LDR      r0,[sp,#0x5c]
001714  e2400001          SUB      r0,r0,#1
001718  e3a02000          MOV      r2,#0
00171c  e3a0300a          MOV      r3,#0xa
001720  e58d000c          STR      r0,[sp,#0xc]
001724  e58d1010          STR      r1,[sp,#0x10]
001728  e1a00fa4          LSR      r0,r4,#31
00172c  e3540000          CMP      r4,#0
001730  e88d0009          STM      sp,{r0,r3}
001734  e58d2008          STR      r2,[sp,#8]
001738  da000002          BLE      |L1.5960|
;;;996                output,
;;;997                ABS_FOR_PRINTING(floored_exp10),
00173c  e1a03fc4          ASR      r3,r4,#31
001740  e1a00004          MOV      r0,r4
001744  ea000003          B        |L1.5976|
                  |L1.5960|
001748  e1a00fc4          ASR      r0,r4,#31
00174c  e2741000          RSBS     r1,r4,#0
001750  e2e03000          RSC      r3,r0,#0
001754  e1a00001          MOV      r0,r1
                  |L1.5976|
001758  e58d0048          STR      r0,[sp,#0x48]
00175c  e58d304c          STR      r3,[sp,#0x4c]
001760  e1a02000          MOV      r2,r0
001764  e59d0098          LDR      r0,[sp,#0x98]
001768  ebfffffe          BL       print_integer
;;;998                floored_exp10 < 0,
;;;999                10,
;;;1000               0,
;;;1001               exp10_part_width - 1,
;;;1002               FLAGS_ZEROPAD | FLAGS_PLUS);
;;;1003           if(flags & FLAGS_LEFT) {
00176c  e2080002          AND      r0,r8,#2
001770  e3500000          CMP      r0,#0
001774  0a00000a          BEQ      |L1.6052|
;;;1004               // We need to right-pad with spaces to meet the width requirement
;;;1005               while(output->pos - printed_exponential_start_pos < width) {
001778  ea000002          B        |L1.6024|
                  |L1.6012|
;;;1006                   putchar_via_gadget(output, ' ');
00177c  e3a01020          MOV      r1,#0x20
001780  e59d0098          LDR      r0,[sp,#0x98]
001784  ebfffffe          BL       putchar_via_gadget
                  |L1.6024|
001788  e59d0098          LDR      r0,[sp,#0x98]         ;1005
00178c  e590100c          LDR      r1,[r0,#0xc]          ;1005
001790  e59d0054          LDR      r0,[sp,#0x54]         ;1005
001794  e0411000          SUB      r1,r1,r0              ;1005
001798  e59d00d4          LDR      r0,[sp,#0xd4]         ;1005
00179c  e1510000          CMP      r1,r0                 ;1005
0017a0  3afffff5          BCC      |L1.6012|
                  |L1.6052|
;;;1007               }
;;;1008           }
;;;1009       }
;;;1010   }
0017a4  e28dd0a8          ADD      sp,sp,#0xa8
0017a8  e8bd9ff0          POP      {r4-r12,pc}
;;;1011   #endif // PRINTF_SUPPORT_EXPONENTIAL_SPECIFIERS
                          ENDP

                  print_floating_point PROC
;;;1012   
;;;1013   static void print_floating_point(
0017ac  e92d4ff0          PUSH     {r4-r11,lr}
;;;1014       output_gadget_t* output,
;;;1015       double value,
;;;1016       printf_size_t precision,
;;;1017       printf_size_t width,
;;;1018       printf_flags_t flags,
;;;1019       bool prefer_exponential) {
0017b0  e24dd034          SUB      sp,sp,#0x34
0017b4  e1a0b000          MOV      r11,r0
0017b8  e1a04002          MOV      r4,r2
0017bc  e1a05003          MOV      r5,r3
0017c0  e59d6060          LDR      r6,[sp,#0x60]
0017c4  e59da064          LDR      r10,[sp,#0x64]
0017c8  e59d7058          LDR      r7,[sp,#0x58]
0017cc  e59d905c          LDR      r9,[sp,#0x5c]
;;;1020       char buf[PRINTF_DECIMAL_BUFFER_SIZE];
;;;1021       printf_size_t len = 0U;
0017d0  e3a08000          MOV      r8,#0
;;;1022   
;;;1023       // test for special values
;;;1024       if(value != value) {
0017d4  e1a02004          MOV      r2,r4
0017d8  e1a03005          MOV      r3,r5
0017dc  e1a00004          MOV      r0,r4
0017e0  e1a01005          MOV      r1,r5
0017e4  ebfffffe          BL       __aeabi_cdcmpeq
0017e8  0a000007          BEQ      |L1.6156|
;;;1025           out_rev_(output, "nan", 3, width, flags);
0017ec  e1a03009          MOV      r3,r9
0017f0  e3a02003          MOV      r2,#3
0017f4  e28f1e29          ADR      r1,|L1.6796|
0017f8  e1a0000b          MOV      r0,r11
0017fc  e58d6000          STR      r6,[sp,#0]
001800  ebfffffe          BL       out_rev_
                  |L1.6148|
;;;1026           return;
;;;1027       }
;;;1028       if(value < -DBL_MAX) {
;;;1029           out_rev_(output, "fni-", 4, width, flags);
;;;1030           return;
;;;1031       }
;;;1032       if(value > DBL_MAX) {
;;;1033           out_rev_(
;;;1034               output,
;;;1035               (flags & FLAGS_PLUS) ? "fni+" : "fni",
;;;1036               (flags & FLAGS_PLUS) ? 4U : 3U,
;;;1037               width,
;;;1038               flags);
;;;1039           return;
;;;1040       }
;;;1041   
;;;1042       if(!prefer_exponential &&
;;;1043          ((value > PRINTF_FLOAT_NOTATION_THRESHOLD) || (value < -PRINTF_FLOAT_NOTATION_THRESHOLD))) {
;;;1044           // The required behavior of standard printf is to print _every_ integral-part digit -- which could mean
;;;1045           // printing hundreds of characters, overflowing any fixed internal buffer and necessitating a more complicated
;;;1046           // implementation.
;;;1047   #if PRINTF_SUPPORT_EXPONENTIAL_SPECIFIERS
;;;1048           print_exponential_number(output, value, precision, width, flags, buf, len);
;;;1049   #endif
;;;1050           return;
;;;1051       }
;;;1052   
;;;1053       // set default precision, if not set explicitly
;;;1054       if(!(flags & FLAGS_PRECISION)) {
;;;1055           precision = PRINTF_DEFAULT_FLOAT_PRECISION;
;;;1056       }
;;;1057   
;;;1058       // limit precision so that our integer holding the fractional part does not overflow
;;;1059       while((len < PRINTF_DECIMAL_BUFFER_SIZE) && (precision > PRINTF_MAX_SUPPORTED_PRECISION)) {
;;;1060           buf[len++] = '0'; // This respects the precision in terms of result length only
;;;1061           precision--;
;;;1062       }
;;;1063   
;;;1064   #if PRINTF_SUPPORT_EXPONENTIAL_SPECIFIERS
;;;1065       if(prefer_exponential)
;;;1066           print_exponential_number(output, value, precision, width, flags, buf, len);
;;;1067       else
;;;1068   #endif
;;;1069           print_decimal_number(output, value, precision, width, flags, buf, len);
;;;1070   }
001804  e28dd034          ADD      sp,sp,#0x34
001808  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.6156|
00180c  e3e02000          MVN      r2,#0                 ;1026
001810  e3e03601          MVN      r3,#0x100000          ;1026
001814  e1a00004          MOV      r0,r4                 ;1028
001818  e1a01005          MOV      r1,r5                 ;1028
00181c  ebfffffe          BL       __aeabi_cdcmple
001820  2a000006          BCS      |L1.6208|
001824  e1a03009          MOV      r3,r9                 ;1029
001828  e3a02004          MOV      r2,#4                 ;1029
00182c  e28f1f97          ADR      r1,|L1.6800|
001830  e1a0000b          MOV      r0,r11                ;1029
001834  e58d6000          STR      r6,[sp,#0]            ;1029
001838  ebfffffe          BL       out_rev_
00183c  eafffff0          B        |L1.6148|
                  |L1.6208|
001840  e3e02000          MVN      r2,#0                 ;1030
001844  e59f324c          LDR      r3,|L1.6808|
001848  e1a00004          MOV      r0,r4                 ;1032
00184c  e1a01005          MOV      r1,r5                 ;1032
001850  ebfffffe          BL       __aeabi_cdrcmple
001854  2a000012          BCS      |L1.6308|
001858  e58d6000          STR      r6,[sp,#0]            ;1033
00185c  e2060004          AND      r0,r6,#4              ;1033
001860  e3500000          CMP      r0,#0                 ;1033
001864  0a000001          BEQ      |L1.6256|
001868  e3a00004          MOV      r0,#4                 ;1036
00186c  ea000000          B        |L1.6260|
                  |L1.6256|
001870  e3a00003          MOV      r0,#3                 ;1036
                  |L1.6260|
001874  e1a02000          MOV      r2,r0                 ;1036
001878  e2060004          AND      r0,r6,#4              ;1036
00187c  e3500000          CMP      r0,#0                 ;1036
001880  0a000001          BEQ      |L1.6284|
001884  e28f0e21          ADR      r0,|L1.6812|
001888  ea000000          B        |L1.6288|
                  |L1.6284|
00188c  e28f0e21          ADR      r0,|L1.6820|
                  |L1.6288|
001890  e1a01000          MOV      r1,r0                 ;1035
001894  e1a03009          MOV      r3,r9                 ;1035
001898  e1a0000b          MOV      r0,r11                ;1035
00189c  ebfffffe          BL       out_rev_
0018a0  eaffffd7          B        |L1.6148|
                  |L1.6308|
0018a4  e35a0000          CMP      r10,#0                ;1042
0018a8  1a000015          BNE      |L1.6404|
0018ac  e3a02000          MOV      r2,#0                 ;1042
0018b0  e59f31f0          LDR      r3,|L1.6824|
0018b4  e1a00004          MOV      r0,r4                 ;1043
0018b8  e1a01005          MOV      r1,r5                 ;1043
0018bc  ebfffffe          BL       __aeabi_cdrcmple
0018c0  3a000005          BCC      |L1.6364|
0018c4  e3a02000          MOV      r2,#0                 ;1043
0018c8  e59f31dc          LDR      r3,|L1.6828|
0018cc  e1a00004          MOV      r0,r4                 ;1043
0018d0  e1a01005          MOV      r1,r5                 ;1043
0018d4  ebfffffe          BL       __aeabi_cdcmple
0018d8  2a000009          BCS      |L1.6404|
                  |L1.6364|
0018dc  e28d0014          ADD      r0,sp,#0x14           ;1048
0018e0  e1a02004          MOV      r2,r4                 ;1048
0018e4  e1a03005          MOV      r3,r5                 ;1048
0018e8  e58d000c          STR      r0,[sp,#0xc]          ;1048
0018ec  e58d8010          STR      r8,[sp,#0x10]         ;1048
0018f0  e1a0000b          MOV      r0,r11                ;1048
0018f4  e58d6008          STR      r6,[sp,#8]            ;1048
0018f8  e88d0280          STM      sp,{r7,r9}            ;1048
0018fc  ebfffffe          BL       print_exponential_number
001900  eaffffbf          B        |L1.6148|
                  |L1.6404|
001904  e2060b02          AND      r0,r6,#0x800          ;1054
001908  e3500000          CMP      r0,#0                 ;1054
00190c  1a000000          BNE      |L1.6420|
001910  e3a07006          MOV      r7,#6                 ;1055
                  |L1.6420|
001914  ea000005          B        |L1.6448|
                  |L1.6424|
001918  e3a01030          MOV      r1,#0x30              ;1060
00191c  e1a00008          MOV      r0,r8                 ;1060
001920  e2888001          ADD      r8,r8,#1              ;1060
001924  e28d2014          ADD      r2,sp,#0x14           ;1060
001928  e7c21000          STRB     r1,[r2,r0]            ;1060
00192c  e2477001          SUB      r7,r7,#1              ;1061
                  |L1.6448|
001930  e3580020          CMP      r8,#0x20              ;1059
001934  2a000001          BCS      |L1.6464|
001938  e3570011          CMP      r7,#0x11              ;1059
00193c  8afffff5          BHI      |L1.6424|
                  |L1.6464|
001940  e35a0000          CMP      r10,#0                ;1065
001944  0a000009          BEQ      |L1.6512|
001948  e28d0014          ADD      r0,sp,#0x14           ;1066
00194c  e1a02004          MOV      r2,r4                 ;1066
001950  e1a03005          MOV      r3,r5                 ;1066
001954  e58d000c          STR      r0,[sp,#0xc]          ;1066
001958  e58d8010          STR      r8,[sp,#0x10]         ;1066
00195c  e1a0000b          MOV      r0,r11                ;1066
001960  e58d6008          STR      r6,[sp,#8]            ;1066
001964  e88d0280          STM      sp,{r7,r9}            ;1066
001968  ebfffffe          BL       print_exponential_number
00196c  ea000008          B        |L1.6548|
                  |L1.6512|
001970  e28d0014          ADD      r0,sp,#0x14           ;1069
001974  e1a02004          MOV      r2,r4                 ;1069
001978  e1a03005          MOV      r3,r5                 ;1069
00197c  e58d000c          STR      r0,[sp,#0xc]          ;1069
001980  e58d8010          STR      r8,[sp,#0x10]         ;1069
001984  e1a0000b          MOV      r0,r11                ;1069
001988  e58d6008          STR      r6,[sp,#8]            ;1069
00198c  e88d0280          STM      sp,{r7,r9}            ;1069
001990  ebfffffe          BL       print_decimal_number
                  |L1.6548|
001994  e1a00000          MOV      r0,r0
001998  eaffff99          B        |L1.6148|
;;;1071   
                          ENDP

                  parse_flags PROC
;;;1075   // due to the characters passed
;;;1076   static printf_flags_t parse_flags(const char** format) {
00199c  e1a01000          MOV      r1,r0
;;;1077       printf_flags_t flags = 0U;
0019a0  e3a00000          MOV      r0,#0
;;;1078       do {
0019a4  e1a00000          MOV      r0,r0
                  |L1.6568|
;;;1079           switch(**format) {
0019a8  e5912000          LDR      r2,[r1,#0]
0019ac  e5d22000          LDRB     r2,[r2,#0]
0019b0  e352002b          CMP      r2,#0x2b
0019b4  0a000014          BEQ      |L1.6668|
0019b8  ca000004          BGT      |L1.6608|
0019bc  e3520020          CMP      r2,#0x20
0019c0  0a000017          BEQ      |L1.6692|
0019c4  e3520023          CMP      r2,#0x23
0019c8  1a000021          BNE      |L1.6740|
0019cc  ea00001a          B        |L1.6716|
                  |L1.6608|
0019d0  e352002d          CMP      r2,#0x2d
0019d4  0a000006          BEQ      |L1.6644|
0019d8  e3520030          CMP      r2,#0x30
0019dc  1a00001c          BNE      |L1.6740|
;;;1080           case '0':
;;;1081               flags |= FLAGS_ZEROPAD;
0019e0  e3800001          ORR      r0,r0,#1
;;;1082               (*format)++;
0019e4  e5912000          LDR      r2,[r1,#0]
0019e8  e2822001          ADD      r2,r2,#1
0019ec  e5812000          STR      r2,[r1,#0]
;;;1083               break;
0019f0  ea000019          B        |L1.6748|
                  |L1.6644|
;;;1084           case '-':
0019f4  e1a00000          MOV      r0,r0
;;;1085               flags |= FLAGS_LEFT;
0019f8  e3800002          ORR      r0,r0,#2
;;;1086               (*format)++;
0019fc  e5912000          LDR      r2,[r1,#0]
001a00  e2822001          ADD      r2,r2,#1
001a04  e5812000          STR      r2,[r1,#0]
;;;1087               break;
001a08  ea000013          B        |L1.6748|
                  |L1.6668|
;;;1088           case '+':
001a0c  e1a00000          MOV      r0,r0
;;;1089               flags |= FLAGS_PLUS;
001a10  e3800004          ORR      r0,r0,#4
;;;1090               (*format)++;
001a14  e5912000          LDR      r2,[r1,#0]
001a18  e2822001          ADD      r2,r2,#1
001a1c  e5812000          STR      r2,[r1,#0]
;;;1091               break;
001a20  ea00000d          B        |L1.6748|
                  |L1.6692|
;;;1092           case ' ':
001a24  e1a00000          MOV      r0,r0
;;;1093               flags |= FLAGS_SPACE;
001a28  e3800008          ORR      r0,r0,#8
;;;1094               (*format)++;
001a2c  e5912000          LDR      r2,[r1,#0]
001a30  e2822001          ADD      r2,r2,#1
001a34  e5812000          STR      r2,[r1,#0]
;;;1095               break;
001a38  ea000007          B        |L1.6748|
                  |L1.6716|
;;;1096           case '#':
001a3c  e1a00000          MOV      r0,r0
;;;1097               flags |= FLAGS_HASH;
001a40  e3800010          ORR      r0,r0,#0x10
;;;1098               (*format)++;
001a44  e5912000          LDR      r2,[r1,#0]
001a48  e2822001          ADD      r2,r2,#1
001a4c  e5812000          STR      r2,[r1,#0]
;;;1099               break;
001a50  ea000001          B        |L1.6748|
                  |L1.6740|
;;;1100           default:
001a54  e1a00000          MOV      r0,r0
;;;1101               return flags;
;;;1102           }
;;;1103       } while(true);
;;;1104   }
001a58  e12fff1e          BX       lr
                  |L1.6748|
001a5c  e1a00000          MOV      r0,r0                 ;1083
001a60  eaffffd0          B        |L1.6568|
                  |L1.6756|
                          DCD      0x0979a371
                  |L1.6760|
                          DCD      0x400a934f
                  |L1.6764|
                          DCD      0xfefa39ef
                  |L1.6768|
                          DCD      0x3fe62e42
                  |L1.6772|
                          DCD      0xbbb55516
                  |L1.6776|
                          DCD      0x40026bb1
                  |L1.6780|
                          DCD      0x000003ff
                  |L1.6784|
                          DCD      0x402c0000
                  |L1.6788|
                          DCD      0x40240000
                  |L1.6792|
                          DCD      0x40180000
                  |L1.6796|
001a8c  6e616e00          DCB      "nan",0
                  |L1.6800|
001a90  666e692d          DCB      "fni-",0
001a94  00      
001a95  00                DCB      0
001a96  00                DCB      0
001a97  00                DCB      0
                  |L1.6808|
                          DCD      0x7fefffff
                  |L1.6812|
001a9c  666e692b          DCB      "fni+",0
001aa0  00      
001aa1  00                DCB      0
001aa2  00                DCB      0
001aa3  00                DCB      0
                  |L1.6820|
001aa4  666e6900          DCB      "fni",0
                  |L1.6824|
                          DCD      0x41cdcd65
                  |L1.6828|
                          DCD      0xc1cdcd65
                          ENDP

                  format_string_loop PROC
;;;1105   
;;;1106   static inline void format_string_loop(output_gadget_t* output, const char* format, va_list args) {
001ab0  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
001ab4  e24dd018          SUB      sp,sp,#0x18
001ab8  e1a0a000          MOV      r10,r0
;;;1107   #if PRINTF_CHECK_FOR_NUL_IN_FORMAT_SPECIFIER
;;;1108   #define ADVANCE_IN_FORMAT_STRING(cptr_) \
;;;1109       do {                                \
;;;1110           (cptr_)++;                      \
;;;1111           if(!*(cptr_)) return;           \
;;;1112       } while(0)
;;;1113   #else
;;;1114   #define ADVANCE_IN_FORMAT_STRING(cptr_) (cptr_)++
;;;1115   #endif
;;;1116   
;;;1117       while(*format) {
001abc  ea000329          B        |L1.10088|
                  |L1.6848|
;;;1118           if(*format != '%') {
001ac0  e59d001c          LDR      r0,[sp,#0x1c]
001ac4  e5d00000          LDRB     r0,[r0,#0]
001ac8  e3500025          CMP      r0,#0x25
001acc  0a000007          BEQ      |L1.6896|
;;;1119               // A regular content character
;;;1120               putchar_via_gadget(output, *format);
001ad0  e59d001c          LDR      r0,[sp,#0x1c]
001ad4  e5d01000          LDRB     r1,[r0,#0]
001ad8  e1a0000a          MOV      r0,r10
001adc  ebfffffe          BL       putchar_via_gadget
;;;1121               format++;
001ae0  e59d001c          LDR      r0,[sp,#0x1c]
001ae4  e2800001          ADD      r0,r0,#1
001ae8  e58d001c          STR      r0,[sp,#0x1c]
;;;1122               continue;
001aec  ea00031d          B        |L1.10088|
                  |L1.6896|
;;;1123           }
;;;1124           // We're parsing a format specifier: %[flags][width][.precision][length]
;;;1125           ADVANCE_IN_FORMAT_STRING(format);
001af0  e1a00000          MOV      r0,r0
001af4  e59d001c          LDR      r0,[sp,#0x1c]
001af8  e2800001          ADD      r0,r0,#1
001afc  e58d001c          STR      r0,[sp,#0x1c]
001b00  e59d001c          LDR      r0,[sp,#0x1c]
001b04  e5d00000          LDRB     r0,[r0,#0]
001b08  e3500000          CMP      r0,#0
001b0c  1a000001          BNE      |L1.6936|
                  |L1.6928|
;;;1126   
;;;1127           printf_flags_t flags = parse_flags(&format);
;;;1128   
;;;1129           // evaluate width field
;;;1130           printf_size_t width = 0U;
;;;1131           if(is_digit_(*format)) {
;;;1132               width = (printf_size_t)atou_(&format);
;;;1133           } else if(*format == '*') {
;;;1134               const int w = va_arg(args, int);
;;;1135               if(w < 0) {
;;;1136                   flags |= FLAGS_LEFT; // reverse padding
;;;1137                   width = (printf_size_t)-w;
;;;1138               } else {
;;;1139                   width = (printf_size_t)w;
;;;1140               }
;;;1141               ADVANCE_IN_FORMAT_STRING(format);
;;;1142           }
;;;1143   
;;;1144           // evaluate precision field
;;;1145           printf_size_t precision = 0U;
;;;1146           if(*format == '.') {
;;;1147               flags |= FLAGS_PRECISION;
;;;1148               ADVANCE_IN_FORMAT_STRING(format);
;;;1149               if(is_digit_(*format)) {
;;;1150                   precision = (printf_size_t)atou_(&format);
;;;1151               } else if(*format == '*') {
;;;1152                   const int precision_ = va_arg(args, int);
;;;1153                   precision            = precision_ > 0 ? (printf_size_t)precision_ : 0U;
;;;1154                   ADVANCE_IN_FORMAT_STRING(format);
;;;1155               }
;;;1156           }
;;;1157   
;;;1158           // evaluate length field
;;;1159           switch(*format) {
;;;1160   #ifdef PRINTF_SUPPORT_MSVC_STYLE_INTEGER_SPECIFIERS
;;;1161           case 'I': {
;;;1162               ADVANCE_IN_FORMAT_STRING(format);
;;;1163               // Greedily parse for size in bits: 8, 16, 32 or 64
;;;1164               switch(*format) {
;;;1165               case '8':
;;;1166                   flags |= FLAGS_INT8;
;;;1167                   ADVANCE_IN_FORMAT_STRING(format);
;;;1168                   break;
;;;1169               case '1':
;;;1170                   ADVANCE_IN_FORMAT_STRING(format);
;;;1171                   if(*format == '6') {
;;;1172                       format++;
;;;1173                       flags |= FLAGS_INT16;
;;;1174                   }
;;;1175                   break;
;;;1176               case '3':
;;;1177                   ADVANCE_IN_FORMAT_STRING(format);
;;;1178                   if(*format == '2') {
;;;1179                       ADVANCE_IN_FORMAT_STRING(format);
;;;1180                       flags |= FLAGS_INT32;
;;;1181                   }
;;;1182                   break;
;;;1183               case '6':
;;;1184                   ADVANCE_IN_FORMAT_STRING(format);
;;;1185                   if(*format == '4') {
;;;1186                       ADVANCE_IN_FORMAT_STRING(format);
;;;1187                       flags |= FLAGS_INT64;
;;;1188                   }
;;;1189                   break;
;;;1190               default:
;;;1191                   break;
;;;1192               }
;;;1193               break;
;;;1194           }
;;;1195   #endif
;;;1196           case 'l':
;;;1197               flags |= FLAGS_LONG;
;;;1198               ADVANCE_IN_FORMAT_STRING(format);
;;;1199               if(*format == 'l') {
;;;1200                   flags |= FLAGS_LONG_LONG;
;;;1201                   ADVANCE_IN_FORMAT_STRING(format);
;;;1202               }
;;;1203               break;
;;;1204           case 'h':
;;;1205               flags |= FLAGS_SHORT;
;;;1206               ADVANCE_IN_FORMAT_STRING(format);
;;;1207               if(*format == 'h') {
;;;1208                   flags |= FLAGS_CHAR;
;;;1209                   ADVANCE_IN_FORMAT_STRING(format);
;;;1210               }
;;;1211               break;
;;;1212           case 't':
;;;1213               flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
;;;1214               ADVANCE_IN_FORMAT_STRING(format);
;;;1215               break;
;;;1216           case 'j':
;;;1217               flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
;;;1218               ADVANCE_IN_FORMAT_STRING(format);
;;;1219               break;
;;;1220           case 'z':
;;;1221               flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
;;;1222               ADVANCE_IN_FORMAT_STRING(format);
;;;1223               break;
;;;1224           default:
;;;1225               break;
;;;1226           }
;;;1227   
;;;1228           // evaluate specifier
;;;1229           switch(*format) {
;;;1230           case 'd':
;;;1231           case 'i':
;;;1232           case 'u':
;;;1233           case 'x':
;;;1234           case 'X':
;;;1235           case 'o':
;;;1236           case 'b': {
;;;1237               if(*format == 'd' || *format == 'i') {
;;;1238                   flags |= FLAGS_SIGNED;
;;;1239               }
;;;1240   
;;;1241               numeric_base_t base;
;;;1242               if(*format == 'x' || *format == 'X') {
;;;1243                   base = BASE_HEX;
;;;1244               } else if(*format == 'o') {
;;;1245                   base = BASE_OCTAL;
;;;1246               } else if(*format == 'b') {
;;;1247                   base = BASE_BINARY;
;;;1248               } else {
;;;1249                   base = BASE_DECIMAL;
;;;1250                   flags &= ~FLAGS_HASH; // decimal integers have no alternative presentation
;;;1251               }
;;;1252   
;;;1253               if(*format == 'X') {
;;;1254                   flags |= FLAGS_UPPERCASE;
;;;1255               }
;;;1256   
;;;1257               format++;
;;;1258               // ignore '0' flag when precision is given
;;;1259               if(flags & FLAGS_PRECISION) {
;;;1260                   flags &= ~FLAGS_ZEROPAD;
;;;1261               }
;;;1262   
;;;1263               if(flags & FLAGS_SIGNED) {
;;;1264                   // A signed specifier: d, i or possibly I + bit size if enabled
;;;1265   
;;;1266                   if(flags & FLAGS_LONG_LONG) {
;;;1267   #if PRINTF_SUPPORT_LONG_LONG
;;;1268                       const long long value = va_arg(args, long long);
;;;1269                       print_integer(
;;;1270                           output, ABS_FOR_PRINTING(value), value < 0, base, precision, width, flags);
;;;1271   #endif
;;;1272                   } else if(flags & FLAGS_LONG) {
;;;1273                       const long value = va_arg(args, long);
;;;1274                       print_integer(
;;;1275                           output, ABS_FOR_PRINTING(value), value < 0, base, precision, width, flags);
;;;1276                   } else {
;;;1277                       // We never try to interpret the argument as something potentially-smaller than int,
;;;1278                       // due to integer promotion rules: Even if the user passed a short int, short unsigned
;;;1279                       // etc. - these will come in after promotion, as int's (or unsigned for the case of
;;;1280                       // short unsigned when it has the same size as int)
;;;1281                       const int value = (flags & FLAGS_CHAR)  ? (signed char)va_arg(args, int) :
;;;1282                                         (flags & FLAGS_SHORT) ? (short int)va_arg(args, int) :
;;;1283                                                                 va_arg(args, int);
;;;1284                       print_integer(
;;;1285                           output, ABS_FOR_PRINTING(value), value < 0, base, precision, width, flags);
;;;1286                   }
;;;1287               } else {
;;;1288                   // An unsigned specifier: u, x, X, o, b
;;;1289   
;;;1290                   flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
;;;1291   
;;;1292                   if(flags & FLAGS_LONG_LONG) {
;;;1293   #if PRINTF_SUPPORT_LONG_LONG
;;;1294                       print_integer(
;;;1295                           output,
;;;1296                           (printf_unsigned_value_t)va_arg(args, unsigned long long),
;;;1297                           false,
;;;1298                           base,
;;;1299                           precision,
;;;1300                           width,
;;;1301                           flags);
;;;1302   #endif
;;;1303                   } else if(flags & FLAGS_LONG) {
;;;1304                       print_integer(
;;;1305                           output,
;;;1306                           (printf_unsigned_value_t)va_arg(args, unsigned long),
;;;1307                           false,
;;;1308                           base,
;;;1309                           precision,
;;;1310                           width,
;;;1311                           flags);
;;;1312                   } else {
;;;1313                       const unsigned int value =
;;;1314                           (flags & FLAGS_CHAR)  ? (unsigned char)va_arg(args, unsigned int) :
;;;1315                           (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(args, unsigned int) :
;;;1316                                                   va_arg(args, unsigned int);
;;;1317                       print_integer(
;;;1318                           output,
;;;1319                           (printf_unsigned_value_t)value,
;;;1320                           false,
;;;1321                           base,
;;;1322                           precision,
;;;1323                           width,
;;;1324                           flags);
;;;1325                   }
;;;1326               }
;;;1327               break;
;;;1328           }
;;;1329   #if PRINTF_SUPPORT_DECIMAL_SPECIFIERS
;;;1330           case 'f':
;;;1331           case 'F':
;;;1332               if(*format == 'F') flags |= FLAGS_UPPERCASE;
;;;1333               print_floating_point(
;;;1334                   output, va_arg(args, double), precision, width, flags, PRINTF_PREFER_DECIMAL);
;;;1335               format++;
;;;1336               break;
;;;1337   #endif
;;;1338   #if PRINTF_SUPPORT_EXPONENTIAL_SPECIFIERS
;;;1339           case 'e':
;;;1340           case 'E':
;;;1341           case 'g':
;;;1342           case 'G':
;;;1343               if((*format == 'g') || (*format == 'G')) flags |= FLAGS_ADAPT_EXP;
;;;1344               if((*format == 'E') || (*format == 'G')) flags |= FLAGS_UPPERCASE;
;;;1345               print_floating_point(
;;;1346                   output, va_arg(args, double), precision, width, flags, PRINTF_PREFER_EXPONENTIAL);
;;;1347               format++;
;;;1348               break;
;;;1349   #endif // PRINTF_SUPPORT_EXPONENTIAL_SPECIFIERS
;;;1350           case 'c': {
;;;1351               printf_size_t l = 1U;
;;;1352               // pre padding
;;;1353               if(!(flags & FLAGS_LEFT)) {
;;;1354                   while(l++ < width) {
;;;1355                       putchar_via_gadget(output, ' ');
;;;1356                   }
;;;1357               }
;;;1358               // char output
;;;1359               putchar_via_gadget(output, (char)va_arg(args, int));
;;;1360               // post padding
;;;1361               if(flags & FLAGS_LEFT) {
;;;1362                   while(l++ < width) {
;;;1363                       putchar_via_gadget(output, ' ');
;;;1364                   }
;;;1365               }
;;;1366               format++;
;;;1367               break;
;;;1368           }
;;;1369   
;;;1370           case 's': {
;;;1371               const char* p = va_arg(args, char*);
;;;1372               if(p == NULL) {
;;;1373                   out_rev_(output, ")llun(", 6, width, flags);
;;;1374               } else {
;;;1375                   printf_size_t l =
;;;1376                       strnlen_s_(p, precision ? precision : PRINTF_MAX_POSSIBLE_BUFFER_SIZE);
;;;1377                   // pre padding
;;;1378                   if(flags & FLAGS_PRECISION) {
;;;1379                       l = (l < precision ? l : precision);
;;;1380                   }
;;;1381                   if(!(flags & FLAGS_LEFT)) {
;;;1382                       while(l++ < width) {
;;;1383                           putchar_via_gadget(output, ' ');
;;;1384                       }
;;;1385                   }
;;;1386                   // string output
;;;1387                   while((*p != 0) && (!(flags & FLAGS_PRECISION) || precision)) {
;;;1388                       putchar_via_gadget(output, *(p++));
;;;1389                       --precision;
;;;1390                   }
;;;1391                   // post padding
;;;1392                   if(flags & FLAGS_LEFT) {
;;;1393                       while(l++ < width) {
;;;1394                           putchar_via_gadget(output, ' ');
;;;1395                       }
;;;1396                   }
;;;1397               }
;;;1398               format++;
;;;1399               break;
;;;1400           }
;;;1401   
;;;1402           case 'p': {
;;;1403               width = sizeof(void*) * 2U + 2; // 2 hex chars per byte + the "0x" prefix
;;;1404               flags |= FLAGS_ZEROPAD | FLAGS_POINTER;
;;;1405               uintptr_t value = (uintptr_t)va_arg(args, void*);
;;;1406               (value == (uintptr_t)NULL) ? out_rev_(output, ")lin(", 5, width, flags) :
;;;1407                                            print_integer(
;;;1408                                                output,
;;;1409                                                (printf_unsigned_value_t)value,
;;;1410                                                false,
;;;1411                                                BASE_HEX,
;;;1412                                                precision,
;;;1413                                                width,
;;;1414                                                flags);
;;;1415               format++;
;;;1416               break;
;;;1417           }
;;;1418   
;;;1419           case '%':
;;;1420               putchar_via_gadget(output, '%');
;;;1421               format++;
;;;1422               break;
;;;1423   
;;;1424               // Many people prefer to disable support for %n, as it lets the caller
;;;1425               // engineer a write to an arbitrary location, of a value the caller
;;;1426               // effectively controls - which could be a security concern in some cases.
;;;1427   #if PRINTF_SUPPORT_WRITEBACK_SPECIFIER
;;;1428           case 'n': {
;;;1429               if(flags & FLAGS_CHAR)
;;;1430                   *(va_arg(args, char*)) = (char)output->pos;
;;;1431               else if(flags & FLAGS_SHORT)
;;;1432                   *(va_arg(args, short*)) = (short)output->pos;
;;;1433               else if(flags & FLAGS_LONG)
;;;1434                   *(va_arg(args, long*)) = (long)output->pos;
;;;1435   #if PRINTF_SUPPORT_LONG_LONG
;;;1436               else if(flags & FLAGS_LONG_LONG)
;;;1437                   *(va_arg(args, long long*)) = (long long int)output->pos;
;;;1438   #endif // PRINTF_SUPPORT_LONG_LONG
;;;1439               else
;;;1440                   *(va_arg(args, int*)) = (int)output->pos;
;;;1441               format++;
;;;1442               break;
;;;1443           }
;;;1444   #endif // PRINTF_SUPPORT_WRITEBACK_SPECIFIER
;;;1445   
;;;1446           default:
;;;1447               putchar_via_gadget(output, *format);
;;;1448               format++;
;;;1449               break;
;;;1450           }
;;;1451       }
;;;1452   }
001b10  e28dd024          ADD      sp,sp,#0x24
001b14  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.6936|
001b18  e1a00000          MOV      r0,r0                 ;1125
001b1c  e28d001c          ADD      r0,sp,#0x1c           ;1127
001b20  ebfffffe          BL       parse_flags
001b24  e1a04000          MOV      r4,r0                 ;1127
001b28  e3a05000          MOV      r5,#0                 ;1130
001b2c  e59d101c          LDR      r1,[sp,#0x1c]         ;1131
001b30  e5d10000          LDRB     r0,[r1,#0]            ;1131
001b34  ebfffffe          BL       is_digit_
001b38  e3500000          CMP      r0,#0                 ;1131
001b3c  0a000003          BEQ      |L1.6992|
001b40  e28d001c          ADD      r0,sp,#0x1c           ;1132
001b44  ebfffffe          BL       atou_
001b48  e1a05000          MOV      r5,r0                 ;1132
001b4c  ea000017          B        |L1.7088|
                  |L1.6992|
001b50  e59d001c          LDR      r0,[sp,#0x1c]         ;1133
001b54  e5d00000          LDRB     r0,[r0,#0]            ;1133
001b58  e350002a          CMP      r0,#0x2a              ;1133
001b5c  1a000013          BNE      |L1.7088|
001b60  e59d1020          LDR      r1,[sp,#0x20]         ;1134
001b64  e4910004          LDR      r0,[r1],#4            ;1134
001b68  e58d1020          STR      r1,[sp,#0x20]         ;1134
001b6c  e3500000          CMP      r0,#0                 ;1135
001b70  aa000002          BGE      |L1.7040|
001b74  e3844002          ORR      r4,r4,#2              ;1136
001b78  e2605000          RSB      r5,r0,#0              ;1137
001b7c  ea000000          B        |L1.7044|
                  |L1.7040|
001b80  e1a05000          MOV      r5,r0                 ;1139
                  |L1.7044|
001b84  e1a00000          MOV      r0,r0                 ;1141
001b88  e59d101c          LDR      r1,[sp,#0x1c]         ;1141
001b8c  e2811001          ADD      r1,r1,#1              ;1141
001b90  e58d101c          STR      r1,[sp,#0x1c]         ;1141
001b94  e59d101c          LDR      r1,[sp,#0x1c]         ;1141
001b98  e5d11000          LDRB     r1,[r1,#0]            ;1141
001b9c  e3510000          CMP      r1,#0                 ;1141
001ba0  1a000000          BNE      |L1.7080|
001ba4  eaffffd9          B        |L1.6928|
                  |L1.7080|
001ba8  e1a00000          MOV      r0,r0                 ;1141
001bac  e1a00000          MOV      r0,r0                 ;1142
                  |L1.7088|
001bb0  e3a06000          MOV      r6,#0                 ;1145
001bb4  e59d001c          LDR      r0,[sp,#0x1c]         ;1146
001bb8  e5d00000          LDRB     r0,[r0,#0]            ;1146
001bbc  e350002e          CMP      r0,#0x2e              ;1146
001bc0  1a00002b          BNE      |L1.7284|
001bc4  e3844b02          ORR      r4,r4,#0x800          ;1147
001bc8  e1a00000          MOV      r0,r0                 ;1148
001bcc  e59d001c          LDR      r0,[sp,#0x1c]         ;1148
001bd0  e2800001          ADD      r0,r0,#1              ;1148
001bd4  e58d001c          STR      r0,[sp,#0x1c]         ;1148
001bd8  e59d001c          LDR      r0,[sp,#0x1c]         ;1148
001bdc  e5d00000          LDRB     r0,[r0,#0]            ;1148
001be0  e3500000          CMP      r0,#0                 ;1148
001be4  1a000000          BNE      |L1.7148|
001be8  eaffffc8          B        |L1.6928|
                  |L1.7148|
001bec  e1a00000          MOV      r0,r0                 ;1148
001bf0  e59d101c          LDR      r1,[sp,#0x1c]         ;1149
001bf4  e5d10000          LDRB     r0,[r1,#0]            ;1149
001bf8  ebfffffe          BL       is_digit_
001bfc  e3500000          CMP      r0,#0                 ;1149
001c00  0a000003          BEQ      |L1.7188|
001c04  e28d001c          ADD      r0,sp,#0x1c           ;1150
001c08  ebfffffe          BL       atou_
001c0c  e1a06000          MOV      r6,r0                 ;1150
001c10  ea000017          B        |L1.7284|
                  |L1.7188|
001c14  e59d001c          LDR      r0,[sp,#0x1c]         ;1151
001c18  e5d00000          LDRB     r0,[r0,#0]            ;1151
001c1c  e350002a          CMP      r0,#0x2a              ;1151
001c20  1a000013          BNE      |L1.7284|
001c24  e59d1020          LDR      r1,[sp,#0x20]         ;1152
001c28  e4910004          LDR      r0,[r1],#4            ;1152
001c2c  e58d1020          STR      r1,[sp,#0x20]         ;1152
001c30  e3500000          CMP      r0,#0                 ;1153
001c34  da000001          BLE      |L1.7232|
001c38  e1a01000          MOV      r1,r0                 ;1153
001c3c  ea000000          B        |L1.7236|
                  |L1.7232|
001c40  e3a01000          MOV      r1,#0                 ;1153
                  |L1.7236|
001c44  e1a06001          MOV      r6,r1                 ;1153
001c48  e1a00000          MOV      r0,r0                 ;1154
001c4c  e59d101c          LDR      r1,[sp,#0x1c]         ;1154
001c50  e2811001          ADD      r1,r1,#1              ;1154
001c54  e58d101c          STR      r1,[sp,#0x1c]         ;1154
001c58  e59d101c          LDR      r1,[sp,#0x1c]         ;1154
001c5c  e5d11000          LDRB     r1,[r1,#0]            ;1154
001c60  e3510000          CMP      r1,#0                 ;1154
001c64  1a000000          BNE      |L1.7276|
001c68  eaffffa8          B        |L1.6928|
                  |L1.7276|
001c6c  e1a00000          MOV      r0,r0                 ;1154
001c70  e1a00000          MOV      r0,r0                 ;1155
                  |L1.7284|
001c74  e59d001c          LDR      r0,[sp,#0x1c]         ;1159
001c78  e5d00000          LDRB     r0,[r0,#0]            ;1159
001c7c  e350006c          CMP      r0,#0x6c              ;1159
001c80  0a00000a          BEQ      |L1.7344|
001c84  ca000004          BGT      |L1.7324|
001c88  e3500068          CMP      r0,#0x68              ;1159
001c8c  0a000023          BEQ      |L1.7456|
001c90  e350006a          CMP      r0,#0x6a              ;1159
001c94  1a000064          BNE      |L1.7724|
001c98  ea000049          B        |L1.7620|
                  |L1.7324|
001c9c  e3500074          CMP      r0,#0x74              ;1159
001ca0  0a00003a          BEQ      |L1.7568|
001ca4  e350007a          CMP      r0,#0x7a              ;1159
001ca8  1a00005f          BNE      |L1.7724|
001cac  ea000051          B        |L1.7672|
                  |L1.7344|
001cb0  e1a00000          MOV      r0,r0                 ;1196
001cb4  e3844c02          ORR      r4,r4,#0x200          ;1197
001cb8  e1a00000          MOV      r0,r0                 ;1198
001cbc  e59d001c          LDR      r0,[sp,#0x1c]         ;1198
001cc0  e2800001          ADD      r0,r0,#1              ;1198
001cc4  e58d001c          STR      r0,[sp,#0x1c]         ;1198
001cc8  e59d001c          LDR      r0,[sp,#0x1c]         ;1198
001ccc  e5d00000          LDRB     r0,[r0,#0]            ;1198
001cd0  e3500000          CMP      r0,#0                 ;1198
001cd4  1a000000          BNE      |L1.7388|
001cd8  eaffff8c          B        |L1.6928|
                  |L1.7388|
001cdc  e1a00000          MOV      r0,r0                 ;1198
001ce0  e59d001c          LDR      r0,[sp,#0x1c]         ;1199
001ce4  e5d00000          LDRB     r0,[r0,#0]            ;1199
001ce8  e350006c          CMP      r0,#0x6c              ;1199
001cec  1a00000a          BNE      |L1.7452|
001cf0  e3844b01          ORR      r4,r4,#0x400          ;1200
001cf4  e1a00000          MOV      r0,r0                 ;1201
001cf8  e59d001c          LDR      r0,[sp,#0x1c]         ;1201
001cfc  e2800001          ADD      r0,r0,#1              ;1201
001d00  e58d001c          STR      r0,[sp,#0x1c]         ;1201
001d04  e59d001c          LDR      r0,[sp,#0x1c]         ;1201
001d08  e5d00000          LDRB     r0,[r0,#0]            ;1201
001d0c  e3500000          CMP      r0,#0                 ;1201
001d10  1a000000          BNE      |L1.7448|
001d14  eaffff7d          B        |L1.6928|
                  |L1.7448|
001d18  e1a00000          MOV      r0,r0                 ;1201
                  |L1.7452|
001d1c  ea000044          B        |L1.7732|
                  |L1.7456|
001d20  e1a00000          MOV      r0,r0                 ;1204
001d24  e3844080          ORR      r4,r4,#0x80           ;1205
001d28  e1a00000          MOV      r0,r0                 ;1206
001d2c  e59d001c          LDR      r0,[sp,#0x1c]         ;1206
001d30  e2800001          ADD      r0,r0,#1              ;1206
001d34  e58d001c          STR      r0,[sp,#0x1c]         ;1206
001d38  e59d001c          LDR      r0,[sp,#0x1c]         ;1206
001d3c  e5d00000          LDRB     r0,[r0,#0]            ;1206
001d40  e3500000          CMP      r0,#0                 ;1206
001d44  1a000000          BNE      |L1.7500|
001d48  eaffff70          B        |L1.6928|
                  |L1.7500|
001d4c  e1a00000          MOV      r0,r0                 ;1206
001d50  e59d001c          LDR      r0,[sp,#0x1c]         ;1207
001d54  e5d00000          LDRB     r0,[r0,#0]            ;1207
001d58  e3500068          CMP      r0,#0x68              ;1207
001d5c  1a00000a          BNE      |L1.7564|
001d60  e3844040          ORR      r4,r4,#0x40           ;1208
001d64  e1a00000          MOV      r0,r0                 ;1209
001d68  e59d001c          LDR      r0,[sp,#0x1c]         ;1209
001d6c  e2800001          ADD      r0,r0,#1              ;1209
001d70  e58d001c          STR      r0,[sp,#0x1c]         ;1209
001d74  e59d001c          LDR      r0,[sp,#0x1c]         ;1209
001d78  e5d00000          LDRB     r0,[r0,#0]            ;1209
001d7c  e3500000          CMP      r0,#0                 ;1209
001d80  1a000000          BNE      |L1.7560|
001d84  eaffff61          B        |L1.6928|
                  |L1.7560|
001d88  e1a00000          MOV      r0,r0                 ;1209
                  |L1.7564|
001d8c  ea000028          B        |L1.7732|
                  |L1.7568|
001d90  e1a00000          MOV      r0,r0                 ;1212
001d94  e3844c02          ORR      r4,r4,#0x200          ;1213
001d98  e1a00000          MOV      r0,r0                 ;1214
001d9c  e59d001c          LDR      r0,[sp,#0x1c]         ;1214
001da0  e2800001          ADD      r0,r0,#1              ;1214
001da4  e58d001c          STR      r0,[sp,#0x1c]         ;1214
001da8  e59d001c          LDR      r0,[sp,#0x1c]         ;1214
001dac  e5d00000          LDRB     r0,[r0,#0]            ;1214
001db0  e3500000          CMP      r0,#0                 ;1214
001db4  1a000000          BNE      |L1.7612|
001db8  eaffff54          B        |L1.6928|
                  |L1.7612|
001dbc  e1a00000          MOV      r0,r0                 ;1214
001dc0  ea00001b          B        |L1.7732|
                  |L1.7620|
001dc4  e1a00000          MOV      r0,r0                 ;1216
001dc8  e3844b01          ORR      r4,r4,#0x400          ;1217
001dcc  e1a00000          MOV      r0,r0                 ;1218
001dd0  e59d001c          LDR      r0,[sp,#0x1c]         ;1218
001dd4  e2800001          ADD      r0,r0,#1              ;1218
001dd8  e58d001c          STR      r0,[sp,#0x1c]         ;1218
001ddc  e59d001c          LDR      r0,[sp,#0x1c]         ;1218
001de0  e5d00000          LDRB     r0,[r0,#0]            ;1218
001de4  e3500000          CMP      r0,#0                 ;1218
001de8  1a000000          BNE      |L1.7664|
001dec  eaffff47          B        |L1.6928|
                  |L1.7664|
001df0  e1a00000          MOV      r0,r0                 ;1218
001df4  ea00000e          B        |L1.7732|
                  |L1.7672|
001df8  e1a00000          MOV      r0,r0                 ;1220
001dfc  e3844c02          ORR      r4,r4,#0x200          ;1221
001e00  e1a00000          MOV      r0,r0                 ;1222
001e04  e59d001c          LDR      r0,[sp,#0x1c]         ;1222
001e08  e2800001          ADD      r0,r0,#1              ;1222
001e0c  e58d001c          STR      r0,[sp,#0x1c]         ;1222
001e10  e59d001c          LDR      r0,[sp,#0x1c]         ;1222
001e14  e5d00000          LDRB     r0,[r0,#0]            ;1222
001e18  e3500000          CMP      r0,#0                 ;1222
001e1c  1a000000          BNE      |L1.7716|
001e20  eaffff3a          B        |L1.6928|
                  |L1.7716|
001e24  e1a00000          MOV      r0,r0                 ;1222
001e28  ea000001          B        |L1.7732|
                  |L1.7724|
001e2c  e1a00000          MOV      r0,r0                 ;1224
001e30  e1a00000          MOV      r0,r0                 ;1225
                  |L1.7732|
001e34  e1a00000          MOV      r0,r0                 ;1203
001e38  e59d001c          LDR      r0,[sp,#0x1c]         ;1229
001e3c  e5d00000          LDRB     r0,[r0,#0]            ;1229
001e40  e3500066          CMP      r0,#0x66              ;1229
001e44  0a00011f          BEQ      |L1.8904|
001e48  ca000014          BGT      |L1.7840|
001e4c  e3500058          CMP      r0,#0x58              ;1229
001e50  0a00002a          BEQ      |L1.7936|
001e54  ca000008          BGT      |L1.7804|
001e58  e3500025          CMP      r0,#0x25              ;1229
001e5c  0a0001f3          BEQ      |L1.9776|
001e60  e3500045          CMP      r0,#0x45              ;1229
001e64  0a000136          BEQ      |L1.9028|
001e68  e3500046          CMP      r0,#0x46              ;1229
001e6c  0a000117          BEQ      |L1.8912|
001e70  e3500047          CMP      r0,#0x47              ;1229
001e74  1a000230          BNE      |L1.10044|
001e78  ea000133          B        |L1.9036|
                  |L1.7804|
001e7c  e3500062          CMP      r0,#0x62              ;1229
001e80  0a000020          BEQ      |L1.7944|
001e84  e3500063          CMP      r0,#0x63              ;1229
001e88  0a000157          BEQ      |L1.9196|
001e8c  e3500064          CMP      r0,#0x64              ;1229
001e90  0a000015          BEQ      |L1.7916|
001e94  e3500065          CMP      r0,#0x65              ;1229
001e98  1a000227          BNE      |L1.10044|
001e9c  ea000126          B        |L1.9020|
                  |L1.7840|
001ea0  e3500070          CMP      r0,#0x70              ;1229
001ea4  0a0001c3          BEQ      |L1.9656|
001ea8  ca000008          BGT      |L1.7888|
001eac  e3500067          CMP      r0,#0x67              ;1229
001eb0  0a000124          BEQ      |L1.9032|
001eb4  e3500069          CMP      r0,#0x69              ;1229
001eb8  0a00000d          BEQ      |L1.7924|
001ebc  e350006e          CMP      r0,#0x6e              ;1229
001ec0  0a0001e2          BEQ      |L1.9808|
001ec4  e350006f          CMP      r0,#0x6f              ;1229
001ec8  1a00021b          BNE      |L1.10044|
001ecc  ea00000c          B        |L1.7940|
                  |L1.7888|
001ed0  e3500073          CMP      r0,#0x73              ;1229
001ed4  0a000167          BEQ      |L1.9336|
001ed8  e3500075          CMP      r0,#0x75              ;1229
001edc  0a000005          BEQ      |L1.7928|
001ee0  e3500078          CMP      r0,#0x78              ;1229
001ee4  1a000214          BNE      |L1.10044|
001ee8  ea000003          B        |L1.7932|
                  |L1.7916|
001eec  e1a00000          MOV      r0,r0                 ;1230
001ef0  e1a00000          MOV      r0,r0                 ;1231
                  |L1.7924|
001ef4  e1a00000          MOV      r0,r0                 ;1232
                  |L1.7928|
001ef8  e1a00000          MOV      r0,r0                 ;1233
                  |L1.7932|
001efc  e1a00000          MOV      r0,r0                 ;1234
                  |L1.7936|
001f00  e1a00000          MOV      r0,r0                 ;1235
                  |L1.7940|
001f04  e1a00000          MOV      r0,r0                 ;1236
                  |L1.7944|
001f08  e59d001c          LDR      r0,[sp,#0x1c]         ;1237
001f0c  e5d00000          LDRB     r0,[r0,#0]            ;1237
001f10  e3500064          CMP      r0,#0x64              ;1237
001f14  0a000003          BEQ      |L1.7976|
001f18  e59d001c          LDR      r0,[sp,#0x1c]         ;1237
001f1c  e5d00000          LDRB     r0,[r0,#0]            ;1237
001f20  e3500069          CMP      r0,#0x69              ;1237
001f24  1a000000          BNE      |L1.7980|
                  |L1.7976|
001f28  e3844901          ORR      r4,r4,#0x4000         ;1238
                  |L1.7980|
001f2c  e59d001c          LDR      r0,[sp,#0x1c]         ;1242
001f30  e5d00000          LDRB     r0,[r0,#0]            ;1242
001f34  e3500078          CMP      r0,#0x78              ;1242
001f38  0a000003          BEQ      |L1.8012|
001f3c  e59d001c          LDR      r0,[sp,#0x1c]         ;1242
001f40  e5d00000          LDRB     r0,[r0,#0]            ;1242
001f44  e3500058          CMP      r0,#0x58              ;1242
001f48  1a000001          BNE      |L1.8020|
                  |L1.8012|
001f4c  e3a07010          MOV      r7,#0x10              ;1243
001f50  ea00000d          B        |L1.8076|
                  |L1.8020|
001f54  e59d001c          LDR      r0,[sp,#0x1c]         ;1244
001f58  e5d00000          LDRB     r0,[r0,#0]            ;1244
001f5c  e350006f          CMP      r0,#0x6f              ;1244
001f60  1a000001          BNE      |L1.8044|
001f64  e3a07008          MOV      r7,#8                 ;1245
001f68  ea000007          B        |L1.8076|
                  |L1.8044|
001f6c  e59d001c          LDR      r0,[sp,#0x1c]         ;1246
001f70  e5d00000          LDRB     r0,[r0,#0]            ;1246
001f74  e3500062          CMP      r0,#0x62              ;1246
001f78  1a000001          BNE      |L1.8068|
001f7c  e3a07002          MOV      r7,#2                 ;1247
001f80  ea000001          B        |L1.8076|
                  |L1.8068|
001f84  e3a0700a          MOV      r7,#0xa               ;1249
001f88  e3c44010          BIC      r4,r4,#0x10           ;1250
                  |L1.8076|
001f8c  e59d001c          LDR      r0,[sp,#0x1c]         ;1253
001f90  e5d00000          LDRB     r0,[r0,#0]            ;1253
001f94  e3500058          CMP      r0,#0x58              ;1253
001f98  1a000000          BNE      |L1.8096|
001f9c  e3844020          ORR      r4,r4,#0x20           ;1254
                  |L1.8096|
001fa0  e59d001c          LDR      r0,[sp,#0x1c]         ;1257
001fa4  e2800001          ADD      r0,r0,#1              ;1257
001fa8  e58d001c          STR      r0,[sp,#0x1c]         ;1257
001fac  e2040b02          AND      r0,r4,#0x800          ;1259
001fb0  e3500000          CMP      r0,#0                 ;1259
001fb4  0a000000          BEQ      |L1.8124|
001fb8  e3c44001          BIC      r4,r4,#1              ;1260
                  |L1.8124|
001fbc  e2040901          AND      r0,r4,#0x4000         ;1263
001fc0  e3500000          CMP      r0,#0                 ;1263
001fc4  0a000071          BEQ      |L1.8592|
001fc8  e2040b01          AND      r0,r4,#0x400          ;1266
001fcc  e3500000          CMP      r0,#0                 ;1266
001fd0  0a000024          BEQ      |L1.8296|
001fd4  e59d0020          LDR      r0,[sp,#0x20]         ;1268
001fd8  e2800007          ADD      r0,r0,#7              ;1268
001fdc  e3c00007          BIC      r0,r0,#7              ;1268
001fe0  e58d0020          STR      r0,[sp,#0x20]         ;1268
001fe4  e1c080d0          LDRD     r8,r9,[r0,#0]         ;1268
001fe8  e59d2020          LDR      r2,[sp,#0x20]         ;1268
001fec  e2822008          ADD      r2,r2,#8              ;1268
001ff0  e58d2020          STR      r2,[sp,#0x20]         ;1268
001ff4  e3a01000          MOV      r1,#0                 ;1269
001ff8  e1a00001          MOV      r0,r1                 ;1269
001ffc  e0581001          SUBS     r1,r8,r1              ;1269
002000  e0d90000          SBCS     r0,r9,r0              ;1269
002004  e58d4010          STR      r4,[sp,#0x10]         ;1269
002008  e58d500c          STR      r5,[sp,#0xc]          ;1269
00200c  e58d6008          STR      r6,[sp,#8]            ;1269
002010  e58d7004          STR      r7,[sp,#4]            ;1269
002014  aa000001          BGE      |L1.8224|
002018  e3a00001          MOV      r0,#1                 ;1269
00201c  ea000000          B        |L1.8228|
                  |L1.8224|
002020  e3a00000          MOV      r0,#0                 ;1269
                  |L1.8228|
002024  e58d0000          STR      r0,[sp,#0]            ;1269
002028  e3a00000          MOV      r0,#0                 ;1269
00202c  e1a01000          MOV      r1,r0                 ;1269
002030  e0500008          SUBS     r0,r0,r8              ;1269
002034  e0d10009          SBCS     r0,r1,r9              ;1269
002038  aa000002          BGE      |L1.8264|
00203c  e1a00008          MOV      r0,r8                 ;1270
002040  e1a01009          MOV      r1,r9                 ;1270
002044  ea000001          B        |L1.8272|
                  |L1.8264|
002048  e2780000          RSBS     r0,r8,#0              ;1270
00204c  e2e91000          RSC      r1,r9,#0              ;1270
                  |L1.8272|
002050  e1a0b000          MOV      r11,r0                ;1270
002054  e1a0200b          MOV      r2,r11                ;1270
002058  e1a03001          MOV      r3,r1                 ;1270
00205c  e1a0000a          MOV      r0,r10                ;1270
002060  ebfffffe          BL       print_integer
002064  ea000096          B        |L1.8900|
                  |L1.8296|
002068  e2040c02          AND      r0,r4,#0x200          ;1272
00206c  e3500000          CMP      r0,#0                 ;1272
002070  0a000016          BEQ      |L1.8400|
002074  e59d0020          LDR      r0,[sp,#0x20]         ;1273
002078  e490b004          LDR      r11,[r0],#4           ;1273
00207c  e58d0020          STR      r0,[sp,#0x20]         ;1273
002080  e1a00fab          LSR      r0,r11,#31            ;1274
002084  e35b0000          CMP      r11,#0                ;1274
002088  e88d0081          STM      sp,{r0,r7}            ;1274
00208c  e58d4010          STR      r4,[sp,#0x10]         ;1274
002090  e58d500c          STR      r5,[sp,#0xc]          ;1274
002094  e58d6008          STR      r6,[sp,#8]            ;1274
002098  da000002          BLE      |L1.8360|
00209c  e1a01fcb          ASR      r1,r11,#31            ;1275
0020a0  e1a0000b          MOV      r0,r11                ;1275
0020a4  ea000003          B        |L1.8376|
                  |L1.8360|
0020a8  e1a00fcb          ASR      r0,r11,#31            ;1275
0020ac  e27b2000          RSBS     r2,r11,#0             ;1275
0020b0  e2e01000          RSC      r1,r0,#0              ;1275
0020b4  e1a00002          MOV      r0,r2                 ;1275
                  |L1.8376|
0020b8  e1a08000          MOV      r8,r0                 ;1275
0020bc  e1a02008          MOV      r2,r8                 ;1275
0020c0  e1a03001          MOV      r3,r1                 ;1275
0020c4  e1a0000a          MOV      r0,r10                ;1275
0020c8  ebfffffe          BL       print_integer
0020cc  ea00007c          B        |L1.8900|
                  |L1.8400|
0020d0  e2040040          AND      r0,r4,#0x40           ;1281
0020d4  e3500000          CMP      r0,#0                 ;1281
0020d8  0a000007          BEQ      |L1.8444|
0020dc  e59d0020          LDR      r0,[sp,#0x20]         ;1281
0020e0  e5d00000          LDRB     r0,[r0,#0]            ;1281
0020e4  e59d1020          LDR      r1,[sp,#0x20]         ;1281
0020e8  e2811004          ADD      r1,r1,#4              ;1281
0020ec  e1a00c00          LSL      r0,r0,#24             ;1281
0020f0  e1a00c40          ASR      r0,r0,#24             ;1281
0020f4  e58d1020          STR      r1,[sp,#0x20]         ;1281
0020f8  ea00000f          B        |L1.8508|
                  |L1.8444|
0020fc  e2040080          AND      r0,r4,#0x80           ;1282
002100  e3500000          CMP      r0,#0                 ;1282
002104  0a000007          BEQ      |L1.8488|
002108  e59d0020          LDR      r0,[sp,#0x20]         ;1282
00210c  e1d000b0          LDRH     r0,[r0,#0]            ;1282
002110  e59d1020          LDR      r1,[sp,#0x20]         ;1282
002114  e2811004          ADD      r1,r1,#4              ;1282
002118  e1a00800          LSL      r0,r0,#16             ;1282
00211c  e1a00840          ASR      r0,r0,#16             ;1282
002120  e58d1020          STR      r1,[sp,#0x20]         ;1282
002124  ea000004          B        |L1.8508|
                  |L1.8488|
002128  e59d0020          LDR      r0,[sp,#0x20]         ;1283
00212c  e5900000          LDR      r0,[r0,#0]            ;1283
002130  e59d1020          LDR      r1,[sp,#0x20]         ;1283
002134  e2811004          ADD      r1,r1,#4              ;1283
002138  e58d1020          STR      r1,[sp,#0x20]         ;1283
                  |L1.8508|
00213c  e1a0b000          MOV      r11,r0                ;1283
002140  e1a00fab          LSR      r0,r11,#31            ;1284
002144  e35b0000          CMP      r11,#0                ;1284
002148  e88d0081          STM      sp,{r0,r7}            ;1284
00214c  e58d4010          STR      r4,[sp,#0x10]         ;1284
002150  e58d500c          STR      r5,[sp,#0xc]          ;1284
002154  e58d6008          STR      r6,[sp,#8]            ;1284
002158  da000002          BLE      |L1.8552|
00215c  e1a01fcb          ASR      r1,r11,#31            ;1285
002160  e1a0000b          MOV      r0,r11                ;1285
002164  ea000003          B        |L1.8568|
                  |L1.8552|
002168  e1a00fcb          ASR      r0,r11,#31            ;1285
00216c  e27b2000          RSBS     r2,r11,#0             ;1285
002170  e2e01000          RSC      r1,r0,#0              ;1285
002174  e1a00002          MOV      r0,r2                 ;1285
                  |L1.8568|
002178  e1a08000          MOV      r8,r0                 ;1285
00217c  e1a02008          MOV      r2,r8                 ;1285
002180  e1a03001          MOV      r3,r1                 ;1285
002184  e1a0000a          MOV      r0,r10                ;1285
002188  ebfffffe          BL       print_integer
00218c  ea00004c          B        |L1.8900|
                  |L1.8592|
002190  e3c4400c          BIC      r4,r4,#0xc            ;1290
002194  e2040b01          AND      r0,r4,#0x400          ;1292
002198  e3500000          CMP      r0,#0                 ;1292
00219c  0a000012          BEQ      |L1.8684|
0021a0  e59d0020          LDR      r0,[sp,#0x20]         ;1294
0021a4  e2800007          ADD      r0,r0,#7              ;1294
0021a8  e3c00007          BIC      r0,r0,#7              ;1294
0021ac  e58d0020          STR      r0,[sp,#0x20]         ;1294
0021b0  e3a00000          MOV      r0,#0                 ;1294
0021b4  e88d0081          STM      sp,{r0,r7}            ;1294
0021b8  e58d4010          STR      r4,[sp,#0x10]         ;1294
0021bc  e58d500c          STR      r5,[sp,#0xc]          ;1294
0021c0  e58d6008          STR      r6,[sp,#8]            ;1294
0021c4  e59d0020          LDR      r0,[sp,#0x20]         ;1294
0021c8  e5903004          LDR      r3,[r0,#4]            ;1294
0021cc  e5908000          LDR      r8,[r0,#0]            ;1294
0021d0  e59d2020          LDR      r2,[sp,#0x20]         ;1294
0021d4  e2822008          ADD      r2,r2,#8              ;1294
0021d8  e58d2020          STR      r2,[sp,#0x20]         ;1294
0021dc  e1a02008          MOV      r2,r8                 ;1294
0021e0  e1a0000a          MOV      r0,r10                ;1294
0021e4  ebfffffe          BL       print_integer
0021e8  ea000035          B        |L1.8900|
                  |L1.8684|
0021ec  e2040c02          AND      r0,r4,#0x200          ;1303
0021f0  e3500000          CMP      r0,#0                 ;1303
0021f4  0a00000e          BEQ      |L1.8756|
0021f8  e3a00000          MOV      r0,#0                 ;1304
0021fc  e88d0081          STM      sp,{r0,r7}            ;1304
002200  e58d4010          STR      r4,[sp,#0x10]         ;1304
002204  e58d500c          STR      r5,[sp,#0xc]          ;1304
002208  e58d6008          STR      r6,[sp,#8]            ;1304
00220c  e59d0020          LDR      r0,[sp,#0x20]         ;1304
002210  e5901000          LDR      r1,[r0,#0]            ;1304
002214  e59d2020          LDR      r2,[sp,#0x20]         ;1304
002218  e2822004          ADD      r2,r2,#4              ;1304
00221c  e58d2020          STR      r2,[sp,#0x20]         ;1304
002220  e1a02001          MOV      r2,r1                 ;1304
002224  e3a03000          MOV      r3,#0                 ;1304
002228  e1a0000a          MOV      r0,r10                ;1304
00222c  ebfffffe          BL       print_integer
002230  ea000023          B        |L1.8900|
                  |L1.8756|
002234  e2040040          AND      r0,r4,#0x40           ;1313
002238  e3500000          CMP      r0,#0                 ;1313
00223c  0a000005          BEQ      |L1.8792|
002240  e59d0020          LDR      r0,[sp,#0x20]         ;1314
002244  e5d00000          LDRB     r0,[r0,#0]            ;1314
002248  e59d1020          LDR      r1,[sp,#0x20]         ;1314
00224c  e2811004          ADD      r1,r1,#4              ;1314
002250  e58d1020          STR      r1,[sp,#0x20]         ;1314
002254  ea00000f          B        |L1.8856|
                  |L1.8792|
002258  e2040080          AND      r0,r4,#0x80           ;1315
00225c  e3500000          CMP      r0,#0                 ;1315
002260  0a000007          BEQ      |L1.8836|
002264  e59d0020          LDR      r0,[sp,#0x20]         ;1315
002268  e1d000b0          LDRH     r0,[r0,#0]            ;1315
00226c  e59d1020          LDR      r1,[sp,#0x20]         ;1315
002270  e2811004          ADD      r1,r1,#4              ;1315
002274  e1a00800          LSL      r0,r0,#16             ;1315
002278  e1a00820          LSR      r0,r0,#16             ;1315
00227c  e58d1020          STR      r1,[sp,#0x20]         ;1315
002280  ea000004          B        |L1.8856|
                  |L1.8836|
002284  e59d0020          LDR      r0,[sp,#0x20]         ;1316
002288  e5900000          LDR      r0,[r0,#0]            ;1316
00228c  e59d1020          LDR      r1,[sp,#0x20]         ;1316
002290  e2811004          ADD      r1,r1,#4              ;1316
002294  e58d1020          STR      r1,[sp,#0x20]         ;1316
                  |L1.8856|
002298  e1a08000          MOV      r8,r0                 ;1316
00229c  e3a00000          MOV      r0,#0                 ;1317
0022a0  e1a02008          MOV      r2,r8                 ;1317
0022a4  e88d0081          STM      sp,{r0,r7}            ;1317
0022a8  e1a03000          MOV      r3,r0                 ;1317
0022ac  e1a0000a          MOV      r0,r10                ;1317
0022b0  e58d4010          STR      r4,[sp,#0x10]         ;1317
0022b4  e58d500c          STR      r5,[sp,#0xc]          ;1317
0022b8  e58d6008          STR      r6,[sp,#8]            ;1317
0022bc  ebfffffe          BL       print_integer
0022c0  e1a00000          MOV      r0,r0                 ;1325
                  |L1.8900|
0022c4  ea000125          B        |L1.10080|
                  |L1.8904|
0022c8  e1a00000          MOV      r0,r0                 ;1330
0022cc  e1a00000          MOV      r0,r0                 ;1331
                  |L1.8912|
0022d0  e59d001c          LDR      r0,[sp,#0x1c]         ;1332
0022d4  e5d00000          LDRB     r0,[r0,#0]            ;1332
0022d8  e3500046          CMP      r0,#0x46              ;1332
0022dc  1a000000          BNE      |L1.8932|
0022e0  e3844020          ORR      r4,r4,#0x20           ;1332
                  |L1.8932|
0022e4  e59d0020          LDR      r0,[sp,#0x20]         ;1333
0022e8  e2800007          ADD      r0,r0,#7              ;1333
0022ec  e3c00007          BIC      r0,r0,#7              ;1333
0022f0  e58d0020          STR      r0,[sp,#0x20]         ;1333
0022f4  e3a00000          MOV      r0,#0                 ;1333
0022f8  e58d000c          STR      r0,[sp,#0xc]          ;1333
0022fc  e58d4008          STR      r4,[sp,#8]            ;1333
002300  e58d5004          STR      r5,[sp,#4]            ;1333
002304  e58d6000          STR      r6,[sp,#0]            ;1333
002308  e59d0020          LDR      r0,[sp,#0x20]         ;1333
00230c  e5903004          LDR      r3,[r0,#4]            ;1333
002310  e5907000          LDR      r7,[r0,#0]            ;1333
002314  e59d2020          LDR      r2,[sp,#0x20]         ;1333
002318  e2822008          ADD      r2,r2,#8              ;1333
00231c  e58d2020          STR      r2,[sp,#0x20]         ;1333
002320  e1a02007          MOV      r2,r7                 ;1333
002324  e1a0000a          MOV      r0,r10                ;1333
002328  ebfffffe          BL       print_floating_point
00232c  e59d001c          LDR      r0,[sp,#0x1c]         ;1335
002330  e2800001          ADD      r0,r0,#1              ;1335
002334  e58d001c          STR      r0,[sp,#0x1c]         ;1335
002338  ea000108          B        |L1.10080|
                  |L1.9020|
00233c  e1a00000          MOV      r0,r0                 ;1339
002340  e1a00000          MOV      r0,r0                 ;1340
                  |L1.9028|
002344  e1a00000          MOV      r0,r0                 ;1341
                  |L1.9032|
002348  e1a00000          MOV      r0,r0                 ;1342
                  |L1.9036|
00234c  e59d001c          LDR      r0,[sp,#0x1c]         ;1343
002350  e5d00000          LDRB     r0,[r0,#0]            ;1343
002354  e3500067          CMP      r0,#0x67              ;1343
002358  0a000003          BEQ      |L1.9068|
00235c  e59d001c          LDR      r0,[sp,#0x1c]         ;1343
002360  e5d00000          LDRB     r0,[r0,#0]            ;1343
002364  e3500047          CMP      r0,#0x47              ;1343
002368  1a000000          BNE      |L1.9072|
                  |L1.9068|
00236c  e3844a01          ORR      r4,r4,#0x1000         ;1343
                  |L1.9072|
002370  e59d001c          LDR      r0,[sp,#0x1c]         ;1344
002374  e5d00000          LDRB     r0,[r0,#0]            ;1344
002378  e3500045          CMP      r0,#0x45              ;1344
00237c  0a000003          BEQ      |L1.9104|
002380  e59d001c          LDR      r0,[sp,#0x1c]         ;1344
002384  e5d00000          LDRB     r0,[r0,#0]            ;1344
002388  e3500047          CMP      r0,#0x47              ;1344
00238c  1a000000          BNE      |L1.9108|
                  |L1.9104|
002390  e3844020          ORR      r4,r4,#0x20           ;1344
                  |L1.9108|
002394  e59d0020          LDR      r0,[sp,#0x20]         ;1345
002398  e2800007          ADD      r0,r0,#7              ;1345
00239c  e3c00007          BIC      r0,r0,#7              ;1345
0023a0  e58d0020          STR      r0,[sp,#0x20]         ;1345
0023a4  e3a00001          MOV      r0,#1                 ;1345
0023a8  e58d000c          STR      r0,[sp,#0xc]          ;1345
0023ac  e58d4008          STR      r4,[sp,#8]            ;1345
0023b0  e58d5004          STR      r5,[sp,#4]            ;1345
0023b4  e58d6000          STR      r6,[sp,#0]            ;1345
0023b8  e59d0020          LDR      r0,[sp,#0x20]         ;1345
0023bc  e5903004          LDR      r3,[r0,#4]            ;1345
0023c0  e5907000          LDR      r7,[r0,#0]            ;1345
0023c4  e59d2020          LDR      r2,[sp,#0x20]         ;1345
0023c8  e2822008          ADD      r2,r2,#8              ;1345
0023cc  e58d2020          STR      r2,[sp,#0x20]         ;1345
0023d0  e1a02007          MOV      r2,r7                 ;1345
0023d4  e1a0000a          MOV      r0,r10                ;1345
0023d8  ebfffffe          BL       print_floating_point
0023dc  e59d001c          LDR      r0,[sp,#0x1c]         ;1347
0023e0  e2800001          ADD      r0,r0,#1              ;1347
0023e4  e58d001c          STR      r0,[sp,#0x1c]         ;1347
0023e8  ea0000dc          B        |L1.10080|
                  |L1.9196|
0023ec  e1a00000          MOV      r0,r0                 ;1350
0023f0  e3a07001          MOV      r7,#1                 ;1351
0023f4  e2040002          AND      r0,r4,#2              ;1353
0023f8  e3500000          CMP      r0,#0                 ;1353
0023fc  1a000007          BNE      |L1.9248|
002400  ea000002          B        |L1.9232|
                  |L1.9220|
002404  e3a01020          MOV      r1,#0x20              ;1355
002408  e1a0000a          MOV      r0,r10                ;1355
00240c  ebfffffe          BL       putchar_via_gadget
                  |L1.9232|
002410  e1a00007          MOV      r0,r7                 ;1354
002414  e2877001          ADD      r7,r7,#1              ;1354
002418  e1500005          CMP      r0,r5                 ;1354
00241c  3afffff8          BCC      |L1.9220|
                  |L1.9248|
002420  e59d0020          LDR      r0,[sp,#0x20]         ;1359
002424  e5d01000          LDRB     r1,[r0,#0]            ;1359
002428  e59d2020          LDR      r2,[sp,#0x20]         ;1359
00242c  e2822004          ADD      r2,r2,#4              ;1359
002430  e1a0000a          MOV      r0,r10                ;1359
002434  e58d2020          STR      r2,[sp,#0x20]         ;1359
002438  ebfffffe          BL       putchar_via_gadget
00243c  e2040002          AND      r0,r4,#2              ;1361
002440  e3500000          CMP      r0,#0                 ;1361
002444  0a000007          BEQ      |L1.9320|
002448  ea000002          B        |L1.9304|
                  |L1.9292|
00244c  e3a01020          MOV      r1,#0x20              ;1363
002450  e1a0000a          MOV      r0,r10                ;1363
002454  ebfffffe          BL       putchar_via_gadget
                  |L1.9304|
002458  e1a00007          MOV      r0,r7                 ;1362
00245c  e2877001          ADD      r7,r7,#1              ;1362
002460  e1500005          CMP      r0,r5                 ;1362
002464  3afffff8          BCC      |L1.9292|
                  |L1.9320|
002468  e59d001c          LDR      r0,[sp,#0x1c]         ;1366
00246c  e2800001          ADD      r0,r0,#1              ;1366
002470  e58d001c          STR      r0,[sp,#0x1c]         ;1366
002474  ea0000b9          B        |L1.10080|
                  |L1.9336|
002478  e1a00000          MOV      r0,r0                 ;1370
00247c  e59d0020          LDR      r0,[sp,#0x20]         ;1371
002480  e4907004          LDR      r7,[r0],#4            ;1371
002484  e58d0020          STR      r0,[sp,#0x20]         ;1371
002488  e3570000          CMP      r7,#0                 ;1372
00248c  1a000006          BNE      |L1.9388|
002490  e1a03005          MOV      r3,r5                 ;1373
002494  e3a02006          MOV      r2,#6                 ;1373
002498  e28f1e2e          ADR      r1,|L1.10112|
00249c  e1a0000a          MOV      r0,r10                ;1373
0024a0  e58d4000          STR      r4,[sp,#0]            ;1373
0024a4  ebfffffe          BL       out_rev_
0024a8  ea00003e          B        |L1.9640|
                  |L1.9388|
0024ac  e1a00007          MOV      r0,r7                 ;1375
0024b0  e3560000          CMP      r6,#0                 ;1375
0024b4  0a000001          BEQ      |L1.9408|
0024b8  e1a01006          MOV      r1,r6                 ;1376
0024bc  ea000000          B        |L1.9412|
                  |L1.9408|
0024c0  e3e01102          MVN      r1,#0x80000000        ;1376
                  |L1.9412|
0024c4  e1a02001          MOV      r2,r1                 ;1376
0024c8  e1a01000          MOV      r1,r0                 ;1376
0024cc  ea000000          B        |L1.9428|
                  |L1.9424|
0024d0  e2811001          ADD      r1,r1,#1              ;1376
                  |L1.9428|
0024d4  e5d13000          LDRB     r3,[r1,#0]            ;1376
0024d8  e3530000          CMP      r3,#0                 ;1376
0024dc  0a000002          BEQ      |L1.9452|
0024e0  e2523000          SUBS     r3,r2,#0              ;1376
0024e4  e2422001          SUB      r2,r2,#1              ;1376
0024e8  1afffff8          BNE      |L1.9424|
                  |L1.9452|
0024ec  e1a00000          MOV      r0,r0                 ;1376
0024f0  e0418000          SUB      r8,r1,r0              ;1376
0024f4  e2040b02          AND      r0,r4,#0x800          ;1378
0024f8  e3500000          CMP      r0,#0                 ;1378
0024fc  0a000005          BEQ      |L1.9496|
002500  e1580006          CMP      r8,r6                 ;1379
002504  2a000001          BCS      |L1.9488|
002508  e1a00008          MOV      r0,r8                 ;1379
00250c  ea000000          B        |L1.9492|
                  |L1.9488|
002510  e1a00006          MOV      r0,r6                 ;1379
                  |L1.9492|
002514  e1a08000          MOV      r8,r0                 ;1379
                  |L1.9496|
002518  e2040002          AND      r0,r4,#2              ;1381
00251c  e3500000          CMP      r0,#0                 ;1381
002520  1a000007          BNE      |L1.9540|
002524  ea000002          B        |L1.9524|
                  |L1.9512|
002528  e3a01020          MOV      r1,#0x20              ;1383
00252c  e1a0000a          MOV      r0,r10                ;1383
002530  ebfffffe          BL       putchar_via_gadget
                  |L1.9524|
002534  e1a00008          MOV      r0,r8                 ;1382
002538  e2888001          ADD      r8,r8,#1              ;1382
00253c  e1500005          CMP      r0,r5                 ;1382
002540  3afffff8          BCC      |L1.9512|
                  |L1.9540|
002544  ea000003          B        |L1.9560|
                  |L1.9544|
002548  e4d71001          LDRB     r1,[r7],#1            ;1388
00254c  e1a0000a          MOV      r0,r10                ;1388
002550  ebfffffe          BL       putchar_via_gadget
002554  e2466001          SUB      r6,r6,#1              ;1389
                  |L1.9560|
002558  e5d70000          LDRB     r0,[r7,#0]            ;1387
00255c  e3500000          CMP      r0,#0                 ;1387
002560  0a000004          BEQ      |L1.9592|
002564  e2040b02          AND      r0,r4,#0x800          ;1387
002568  e3500000          CMP      r0,#0                 ;1387
00256c  0afffff5          BEQ      |L1.9544|
002570  e3560000          CMP      r6,#0                 ;1387
002574  1afffff3          BNE      |L1.9544|
                  |L1.9592|
002578  e2040002          AND      r0,r4,#2              ;1392
00257c  e3500000          CMP      r0,#0                 ;1392
002580  0a000007          BEQ      |L1.9636|
002584  ea000002          B        |L1.9620|
                  |L1.9608|
002588  e3a01020          MOV      r1,#0x20              ;1394
00258c  e1a0000a          MOV      r0,r10                ;1394
002590  ebfffffe          BL       putchar_via_gadget
                  |L1.9620|
002594  e1a00008          MOV      r0,r8                 ;1393
002598  e2888001          ADD      r8,r8,#1              ;1393
00259c  e1500005          CMP      r0,r5                 ;1393
0025a0  3afffff8          BCC      |L1.9608|
                  |L1.9636|
0025a4  e1a00000          MOV      r0,r0                 ;1397
                  |L1.9640|
0025a8  e59d001c          LDR      r0,[sp,#0x1c]         ;1398
0025ac  e2800001          ADD      r0,r0,#1              ;1398
0025b0  e58d001c          STR      r0,[sp,#0x1c]         ;1398
0025b4  ea000069          B        |L1.10080|
                  |L1.9656|
0025b8  e1a00000          MOV      r0,r0                 ;1402
0025bc  e3a0500a          MOV      r5,#0xa               ;1403
0025c0  e3844a02          ORR      r4,r4,#0x2000         ;1404
0025c4  e3844001          ORR      r4,r4,#1              ;1404
0025c8  e59d0020          LDR      r0,[sp,#0x20]         ;1405
0025cc  e4907004          LDR      r7,[r0],#4            ;1405
0025d0  e58d0020          STR      r0,[sp,#0x20]         ;1405
0025d4  e3570000          CMP      r7,#0                 ;1406
0025d8  1a000006          BNE      |L1.9720|
0025dc  e1a03005          MOV      r3,r5                 ;1406
0025e0  e3a02005          MOV      r2,#5                 ;1406
0025e4  e28f1f67          ADR      r1,|L1.10120|
0025e8  e1a0000a          MOV      r0,r10                ;1406
0025ec  e58d4000          STR      r4,[sp,#0]            ;1406
0025f0  ebfffffe          BL       out_rev_
0025f4  ea000009          B        |L1.9760|
                  |L1.9720|
0025f8  e3a00010          MOV      r0,#0x10              ;1407
0025fc  e98d0041          STMIB    sp,{r0,r6}            ;1407
002600  e3a00000          MOV      r0,#0                 ;1407
002604  e1a02007          MOV      r2,r7                 ;1407
002608  e58d0000          STR      r0,[sp,#0]            ;1407
00260c  e1a03000          MOV      r3,r0                 ;1407
002610  e1a0000a          MOV      r0,r10                ;1407
002614  e58d4010          STR      r4,[sp,#0x10]         ;1407
002618  e58d500c          STR      r5,[sp,#0xc]          ;1407
00261c  ebfffffe          BL       print_integer
                  |L1.9760|
002620  e59d001c          LDR      r0,[sp,#0x1c]         ;1415
002624  e2800001          ADD      r0,r0,#1              ;1415
002628  e58d001c          STR      r0,[sp,#0x1c]         ;1415
00262c  ea00004b          B        |L1.10080|
                  |L1.9776|
002630  e1a00000          MOV      r0,r0                 ;1419
002634  e3a01025          MOV      r1,#0x25              ;1420
002638  e1a0000a          MOV      r0,r10                ;1420
00263c  ebfffffe          BL       putchar_via_gadget
002640  e59d001c          LDR      r0,[sp,#0x1c]         ;1421
002644  e2800001          ADD      r0,r0,#1              ;1421
002648  e58d001c          STR      r0,[sp,#0x1c]         ;1421
00264c  ea000043          B        |L1.10080|
                  |L1.9808|
002650  e1a00000          MOV      r0,r0                 ;1428
002654  e2040040          AND      r0,r4,#0x40           ;1429
002658  e3500000          CMP      r0,#0                 ;1429
00265c  0a000007          BEQ      |L1.9856|
002660  e5da000c          LDRB     r0,[r10,#0xc]         ;1430
002664  e59d1020          LDR      r1,[sp,#0x20]         ;1430
002668  e5911000          LDR      r1,[r1,#0]            ;1430
00266c  e5c10000          STRB     r0,[r1,#0]            ;1430
002670  e59d0020          LDR      r0,[sp,#0x20]         ;1430
002674  e2800004          ADD      r0,r0,#4              ;1430
002678  e58d0020          STR      r0,[sp,#0x20]         ;1430
00267c  ea00002a          B        |L1.10028|
                  |L1.9856|
002680  e2040080          AND      r0,r4,#0x80           ;1431
002684  e3500000          CMP      r0,#0                 ;1431
002688  0a000009          BEQ      |L1.9908|
00268c  e1da00bc          LDRH     r0,[r10,#0xc]         ;1432
002690  e1a00800          LSL      r0,r0,#16             ;1432
002694  e1a00840          ASR      r0,r0,#16             ;1432
002698  e59d1020          LDR      r1,[sp,#0x20]         ;1432
00269c  e5911000          LDR      r1,[r1,#0]            ;1432
0026a0  e1c100b0          STRH     r0,[r1,#0]            ;1432
0026a4  e59d0020          LDR      r0,[sp,#0x20]         ;1432
0026a8  e2800004          ADD      r0,r0,#4              ;1432
0026ac  e58d0020          STR      r0,[sp,#0x20]         ;1432
0026b0  ea00001d          B        |L1.10028|
                  |L1.9908|
0026b4  e2040c02          AND      r0,r4,#0x200          ;1433
0026b8  e3500000          CMP      r0,#0                 ;1433
0026bc  0a000007          BEQ      |L1.9952|
0026c0  e59a000c          LDR      r0,[r10,#0xc]         ;1434
0026c4  e59d1020          LDR      r1,[sp,#0x20]         ;1434
0026c8  e5911000          LDR      r1,[r1,#0]            ;1434
0026cc  e5810000          STR      r0,[r1,#0]            ;1434
0026d0  e59d0020          LDR      r0,[sp,#0x20]         ;1434
0026d4  e2800004          ADD      r0,r0,#4              ;1434
0026d8  e58d0020          STR      r0,[sp,#0x20]         ;1434
0026dc  ea000012          B        |L1.10028|
                  |L1.9952|
0026e0  e2040b01          AND      r0,r4,#0x400          ;1436
0026e4  e3500000          CMP      r0,#0                 ;1436
0026e8  0a000008          BEQ      |L1.10000|
0026ec  e3a01000          MOV      r1,#0                 ;1437
0026f0  e59a000c          LDR      r0,[r10,#0xc]         ;1437
0026f4  e59d2020          LDR      r2,[sp,#0x20]         ;1437
0026f8  e5922000          LDR      r2,[r2,#0]            ;1437
0026fc  e1c200f0          STRD     r0,r1,[r2,#0]         ;1437
002700  e59d0020          LDR      r0,[sp,#0x20]         ;1437
002704  e2800004          ADD      r0,r0,#4              ;1437
002708  e58d0020          STR      r0,[sp,#0x20]         ;1437
00270c  ea000006          B        |L1.10028|
                  |L1.10000|
002710  e59a000c          LDR      r0,[r10,#0xc]         ;1440
002714  e59d1020          LDR      r1,[sp,#0x20]         ;1440
002718  e5911000          LDR      r1,[r1,#0]            ;1440
00271c  e5810000          STR      r0,[r1,#0]            ;1440
002720  e59d0020          LDR      r0,[sp,#0x20]         ;1440
002724  e2800004          ADD      r0,r0,#4              ;1440
002728  e58d0020          STR      r0,[sp,#0x20]         ;1440
                  |L1.10028|
00272c  e59d001c          LDR      r0,[sp,#0x1c]         ;1441
002730  e2800001          ADD      r0,r0,#1              ;1441
002734  e58d001c          STR      r0,[sp,#0x1c]         ;1441
002738  ea000008          B        |L1.10080|
                  |L1.10044|
00273c  e1a00000          MOV      r0,r0                 ;1446
002740  e59d001c          LDR      r0,[sp,#0x1c]         ;1447
002744  e5d01000          LDRB     r1,[r0,#0]            ;1447
002748  e1a0000a          MOV      r0,r10                ;1447
00274c  ebfffffe          BL       putchar_via_gadget
002750  e59d001c          LDR      r0,[sp,#0x1c]         ;1448
002754  e2800001          ADD      r0,r0,#1              ;1448
002758  e58d001c          STR      r0,[sp,#0x1c]         ;1448
00275c  e1a00000          MOV      r0,r0                 ;1449
                  |L1.10080|
002760  e1a00000          MOV      r0,r0                 ;1327
002764  e1a00000          MOV      r0,r0                 ;1122
                  |L1.10088|
002768  e59d001c          LDR      r0,[sp,#0x1c]         ;1117
00276c  e5d00000          LDRB     r0,[r0,#0]            ;1117
002770  e3500000          CMP      r0,#0                 ;1117
002774  1afffcd1          BNE      |L1.6848|
002778  e1a00000          MOV      r0,r0
00277c  eafffce3          B        |L1.6928|
                  |L1.10112|
002780  296c6c75          DCB      ")llun(",0
002784  6e2800  
002787  00                DCB      0
                  |L1.10120|
002788  296c696e          DCB      ")lin(",0
00278c  2800    
00278e  00                DCB      0
00278f  00                DCB      0
                          ENDP

                  vsnprintf_impl PROC
;;;1454   // internal vsnprintf - used for implementing _all library functions
;;;1455   static int vsnprintf_impl(output_gadget_t* output, const char* format, va_list args) {
002790  e92d4037          PUSH     {r0-r2,r4,r5,lr}
002794  e1a04000          MOV      r4,r0
002798  e1a05001          MOV      r5,r1
;;;1456       // Note: The library only calls vsnprintf_impl() with output->pos being 0. However, it is
;;;1457       // possible to call this function with a non-zero pos value for some "remedial printing".
;;;1458       format_string_loop(output, format, args);
00279c  e1a01005          MOV      r1,r5
0027a0  e1a00004          MOV      r0,r4
0027a4  e59d2008          LDR      r2,[sp,#8]
0027a8  ebfffffe          BL       format_string_loop
;;;1459   
;;;1460       // termination
;;;1461       append_termination_with_gadget(output);
0027ac  e1a00000          MOV      r0,r0
0027b0  e5941000          LDR      r1,[r4,#0]
0027b4  e3510000          CMP      r1,#0
0027b8  1a000002          BNE      |L1.10184|
0027bc  e5941010          LDR      r1,[r4,#0x10]
0027c0  e3510000          CMP      r1,#0
0027c4  1a000000          BNE      |L1.10188|
                  |L1.10184|
0027c8  ea000010          B        |L1.10256|
                  |L1.10188|
0027cc  e5941008          LDR      r1,[r4,#8]
0027d0  e3510000          CMP      r1,#0
0027d4  1a000000          BNE      |L1.10204|
0027d8  ea00000c          B        |L1.10256|
                  |L1.10204|
0027dc  e594100c          LDR      r1,[r4,#0xc]
0027e0  e5942010          LDR      r2,[r4,#0x10]
0027e4  e1510002          CMP      r1,r2
0027e8  2a000001          BCS      |L1.10228|
0027ec  e594100c          LDR      r1,[r4,#0xc]
0027f0  ea000001          B        |L1.10236|
                  |L1.10228|
0027f4  e5941010          LDR      r1,[r4,#0x10]
0027f8  e2411001          SUB      r1,r1,#1
                  |L1.10236|
0027fc  e1a00001          MOV      r0,r1
002800  e3a01000          MOV      r1,#0
002804  e5942008          LDR      r2,[r4,#8]
002808  e7c21000          STRB     r1,[r2,r0]
00280c  e1a00000          MOV      r0,r0
                  |L1.10256|
002810  e1a00000          MOV      r0,r0
;;;1462   
;;;1463       // return written chars without terminating \0
;;;1464       return (int)output->pos;
002814  e594000c          LDR      r0,[r4,#0xc]
;;;1465   }
002818  e8bd803e          POP      {r1-r5,pc}
;;;1466   
                          ENDP

                  vprintf_ PROC
;;;1468   
;;;1469   int vprintf_(const char* format, va_list arg) {
00281c  e92d4033          PUSH     {r0,r1,r4,r5,lr}
002820  e24dd014          SUB      sp,sp,#0x14
002824  e1a04000          MOV      r4,r0
;;;1470       output_gadget_t gadget = extern_putchar_gadget();
002828  e1a00000          MOV      r0,r0
00282c  e1a0500d          MOV      r5,sp
002830  e3a02000          MOV      r2,#0
002834  e59f129c          LDR      r1,|L1.10968|
002838  e1a00005          MOV      r0,r5
00283c  ebfffffe          BL       function_gadget
002840  e1a00000          MOV      r0,r0
;;;1471       return vsnprintf_impl(&gadget, format, arg);
002844  e1a01004          MOV      r1,r4
002848  e59d2018          LDR      r2,[sp,#0x18]
00284c  e1a0000d          MOV      r0,sp
002850  ebfffffe          BL       vsnprintf_impl
002854  e28dd01c          ADD      sp,sp,#0x1c
;;;1472   }
002858  e8bd8030          POP      {r4,r5,pc}
;;;1473   
                          ENDP

                  vsnprintf_ PROC
;;;1474   int vsnprintf_(char* s, size_t n, const char* format, va_list arg) {
00285c  e92d47ff          PUSH     {r0-r10,lr}
002860  e24dd028          SUB      sp,sp,#0x28
002864  e1a06000          MOV      r6,r0
002868  e1a04001          MOV      r4,r1
00286c  e1a07002          MOV      r7,r2
;;;1475       output_gadget_t gadget = buffer_gadget(s, n);
002870  e1a00000          MOV      r0,r0
002874  e28d8014          ADD      r8,sp,#0x14
002878  e1a05006          MOV      r5,r6
00287c  e1a09004          MOV      r9,r4
002880  e3790106          CMN      r9,#0x80000001
002884  9a000001          BLS      |L1.10384|
002888  e3e00102          MVN      r0,#0x80000000
00288c  ea000000          B        |L1.10388|
                  |L1.10384|
002890  e1a00009          MOV      r0,r9
                  |L1.10388|
002894  e1a0a000          MOV      r10,r0
002898  e1a0000d          MOV      r0,sp
00289c  ebfffffe          BL       discarding_gadget
0028a0  e3550000          CMP      r5,#0
0028a4  0a000001          BEQ      |L1.10416|
0028a8  e58d5008          STR      r5,[sp,#8]
0028ac  e58da010          STR      r10,[sp,#0x10]
                  |L1.10416|
0028b0  e1a00000          MOV      r0,r0
0028b4  e3a02014          MOV      r2,#0x14
0028b8  e1a0100d          MOV      r1,sp
0028bc  e1a00008          MOV      r0,r8
0028c0  ebfffffe          BL       __aeabi_memcpy4
0028c4  e1a00000          MOV      r0,r0
;;;1476       return vsnprintf_impl(&gadget, format, arg);
0028c8  e1a01007          MOV      r1,r7
0028cc  e59d2034          LDR      r2,[sp,#0x34]
0028d0  e28d0014          ADD      r0,sp,#0x14
0028d4  ebfffffe          BL       vsnprintf_impl
0028d8  e28dd038          ADD      sp,sp,#0x38
;;;1477   }
0028dc  e8bd87f0          POP      {r4-r10,pc}
;;;1478   
                          ENDP

                  vsprintf_ PROC
;;;1479   int vsprintf_(char* s, const char* format, va_list arg) {
0028e0  e92d4037          PUSH     {r0-r2,r4,r5,lr}
0028e4  e1a05000          MOV      r5,r0
0028e8  e1a04001          MOV      r4,r1
;;;1480       return vsnprintf_(s, PRINTF_MAX_POSSIBLE_BUFFER_SIZE, format, arg);
0028ec  e1a02004          MOV      r2,r4
0028f0  e3e01102          MVN      r1,#0x80000000
0028f4  e1a00005          MOV      r0,r5
0028f8  e59d3008          LDR      r3,[sp,#8]
0028fc  ebfffffe          BL       vsnprintf_
;;;1481   }
002900  e8bd803e          POP      {r1-r5,pc}
;;;1482   
                          ENDP

                  vfctprintf PROC
;;;1483   int vfctprintf(
002904  e92d407f          PUSH     {r0-r6,lr}
;;;1484       void (*out)(char c, void* extra_arg),
;;;1485       void* extra_arg,
;;;1486       const char* format,
;;;1487       va_list arg) {
002908  e24dd018          SUB      sp,sp,#0x18
00290c  e1a04000          MOV      r4,r0
002910  e1a05001          MOV      r5,r1
002914  e1a06002          MOV      r6,r2
;;;1488       output_gadget_t gadget = function_gadget(out, extra_arg);
002918  e1a02005          MOV      r2,r5
00291c  e1a01004          MOV      r1,r4
002920  e28d0004          ADD      r0,sp,#4
002924  ebfffffe          BL       function_gadget
;;;1489       return vsnprintf_impl(&gadget, format, arg);
002928  e1a01006          MOV      r1,r6
00292c  e59d2024          LDR      r2,[sp,#0x24]
002930  e28d0004          ADD      r0,sp,#4
002934  ebfffffe          BL       vsnprintf_impl
002938  e28dd028          ADD      sp,sp,#0x28
;;;1490   }
00293c  e8bd8070          POP      {r4-r6,pc}
;;;1491   
                          ENDP

                  printf_ PROC
;;;1492   int printf_(const char* format, ...) {
002940  e92d000f          PUSH     {r0-r3}
002944  e92d4038          PUSH     {r3-r5,lr}
;;;1493       va_list args;
;;;1494       va_start(args, format);
002948  e28d0014          ADD      r0,sp,#0x14
00294c  e58d0000          STR      r0,[sp,#0]
;;;1495       const int ret = vprintf_(format, args);
002950  e59d0010          LDR      r0,[sp,#0x10]
002954  e59d1000          LDR      r1,[sp,#0]
002958  ebfffffe          BL       vprintf_
00295c  e1a04000          MOV      r4,r0
;;;1496       va_end(args);
002960  e3a00000          MOV      r0,#0
002964  e58d0000          STR      r0,[sp,#0]
;;;1497       return ret;
002968  e1a00004          MOV      r0,r4
00296c  e8bd0038          POP      {r3-r5}
;;;1498   }
002970  e49df014          LDR      pc,[sp],#0x14
;;;1499   
                          ENDP

                  sprintf_ PROC
;;;1500   int sprintf_(char* s, const char* format, ...) {
002974  e92d000f          PUSH     {r0-r3}
002978  e92d4038          PUSH     {r3-r5,lr}
00297c  e1a04000          MOV      r4,r0
;;;1501       va_list args;
;;;1502       va_start(args, format);
002980  e28d0018          ADD      r0,sp,#0x18
002984  e58d0000          STR      r0,[sp,#0]
;;;1503       const int ret = vsprintf_(s, format, args);
002988  e1a00004          MOV      r0,r4
00298c  e59d1014          LDR      r1,[sp,#0x14]
002990  e59d2000          LDR      r2,[sp,#0]
002994  ebfffffe          BL       vsprintf_
002998  e1a05000          MOV      r5,r0
;;;1504       va_end(args);
00299c  e3a00000          MOV      r0,#0
0029a0  e58d0000          STR      r0,[sp,#0]
;;;1505       return ret;
0029a4  e1a00005          MOV      r0,r5
0029a8  e8bd0038          POP      {r3-r5}
;;;1506   }
0029ac  e49df014          LDR      pc,[sp],#0x14
;;;1507   
                          ENDP

                  snprintf_ PROC
;;;1508   int snprintf_(char* s, size_t n, const char* format, ...) {
0029b0  e92d000f          PUSH     {r0-r3}
0029b4  e92d40f8          PUSH     {r3-r7,lr}
0029b8  e1a04000          MOV      r4,r0
0029bc  e1a05001          MOV      r5,r1
;;;1509       va_list args;
;;;1510       va_start(args, format);
0029c0  e28d0024          ADD      r0,sp,#0x24
0029c4  e58d0000          STR      r0,[sp,#0]
;;;1511       const int ret = vsnprintf_(s, n, format, args);
0029c8  e1a01005          MOV      r1,r5
0029cc  e1a00004          MOV      r0,r4
0029d0  e59d2020          LDR      r2,[sp,#0x20]
0029d4  e59d3000          LDR      r3,[sp,#0]
0029d8  ebfffffe          BL       vsnprintf_
0029dc  e1a06000          MOV      r6,r0
;;;1512       va_end(args);
0029e0  e3a00000          MOV      r0,#0
0029e4  e58d0000          STR      r0,[sp,#0]
;;;1513       return ret;
0029e8  e1a00006          MOV      r0,r6
0029ec  e8bd00f8          POP      {r3-r7}
;;;1514   }
0029f0  e49df014          LDR      pc,[sp],#0x14
;;;1515   
                          ENDP

                  fctprintf PROC
;;;1516   int fctprintf(void (*out)(char c, void* extra_arg), void* extra_arg, const char* format, ...) {
0029f4  e92d000f          PUSH     {r0-r3}
0029f8  e92d40f8          PUSH     {r3-r7,lr}
0029fc  e1a04000          MOV      r4,r0
002a00  e1a05001          MOV      r5,r1
;;;1517       va_list args;
;;;1518       va_start(args, format);
002a04  e28d0024          ADD      r0,sp,#0x24
002a08  e58d0000          STR      r0,[sp,#0]
;;;1519       const int ret = vfctprintf(out, extra_arg, format, args);
002a0c  e1a01005          MOV      r1,r5
002a10  e1a00004          MOV      r0,r4
002a14  e59d2020          LDR      r2,[sp,#0x20]
002a18  e59d3000          LDR      r3,[sp,#0]
002a1c  ebfffffe          BL       vfctprintf
002a20  e1a06000          MOV      r6,r0
;;;1520       va_end(args);
002a24  e3a00000          MOV      r0,#0
002a28  e58d0000          STR      r0,[sp,#0]
;;;1521       return ret;
002a2c  e1a00006          MOV      r0,r6
002a30  e8bd00f8          POP      {r3-r7}
;;;1522   }
002a34  e49df014          LDR      pc,[sp],#0x14
                          ENDP

                  get_bit_access PROC
;;;269    // 3. If you try to use it as C++, only C++20 supports compound literals
;;;270    static inline double_with_bit_access get_bit_access(double x) {
002a38  e92d401c          PUSH     {r2-r4,lr}
;;;271        double_with_bit_access dwba;
;;;272        dwba.F = x;
002a3c  e1cd20f0          STRD     r2,r3,[sp,#0]
;;;273        return dwba;
002a40  e89d1002          LDM      sp,{r1,r12}
002a44  e8801002          STM      r0,{r1,r12}
;;;274    }
002a48  e8bd801c          POP      {r2-r4,pc}
;;;275    
                          ENDP

                  get_sign_bit PROC
;;;276    static inline int get_sign_bit(double x) {
002a4c  e92d407f          PUSH     {r0-r6,lr}
002a50  e1a04000          MOV      r4,r0
002a54  e1a05001          MOV      r5,r1
;;;277        // The sign is stored in the highest bit
;;;278        return (int)(get_bit_access(x).U >> (DOUBLE_SIZE_IN_BITS - 1));
002a58  e1a02004          MOV      r2,r4
002a5c  e1a03005          MOV      r3,r5
002a60  e1a0000d          MOV      r0,sp
002a64  ebfffffe          BL       get_bit_access
002a68  e1cd00d0          LDRD     r0,r1,[sp,#0]
002a6c  e1cd00f8          STRD     r0,r1,[sp,#8]
002a70  e1a00fa1          LSR      r0,r1,#31
002a74  e28dd010          ADD      sp,sp,#0x10
;;;279    }
002a78  e8bd8070          POP      {r4-r6,pc}
;;;280    
                          ENDP

                  get_exp2 PROC
;;;281    static inline int get_exp2(double_with_bit_access x) {
002a7c  e92d4013          PUSH     {r0,r1,r4,lr}
;;;282        // The exponent in an IEEE-754 floating-point number occupies a contiguous
;;;283        // sequence of bits (e.g. 52..62 for 64-bit doubles), but with a non-trivial representation: An
;;;284        // unsigned offset from some negative value (with the extremal offset values reserved for
;;;285        // special use).
;;;286        return (int)((x.U >> DOUBLE_STORED_MANTISSA_BITS) & DOUBLE_EXPONENT_MASK) -
002a80  e59d0004          LDR      r0,[sp,#4]
002a84  e1a01a20          LSR      r1,r0,#20
002a88  e59f004c          LDR      r0,|L1.10972|
002a8c  e0000001          AND      r0,r0,r1
002a90  e2400c03          SUB      r0,r0,#0x300
002a94  e24000ff          SUB      r0,r0,#0xff
;;;287               DOUBLE_BASE_EXPONENT;
;;;288    }
002a98  e8bd801c          POP      {r2-r4,pc}
;;;289    #define PRINTF_ABS(_x) ((_x) > 0 ? (_x) : -(_x))
                          ENDP

                  putchar_wrapper PROC
;;;350    // only takes pointers to functions with an extra argument
;;;351    static inline void putchar_wrapper(char c, void* unused) {
002a9c  e92d4070          PUSH     {r4-r6,lr}
002aa0  e1a04000          MOV      r4,r0
002aa4  e1a05001          MOV      r5,r1
;;;352        (void)unused;
;;;353        putchar_(c);
002aa8  e1a00004          MOV      r0,r4
002aac  ebfffffe          BL       sys_uart_putc
;;;354    }
002ab0  e8bd8070          POP      {r4-r6,pc}
;;;355    
                          ENDP

                  is_digit_ PROC
;;;402    // @return true if char is a digit
;;;403    static inline bool is_digit_(char ch) {
002ab4  e1a01000          MOV      r1,r0
;;;404        return (ch >= '0') && (ch <= '9');
002ab8  e3510030          CMP      r1,#0x30
002abc  ba000003          BLT      |L1.10960|
002ac0  e3510039          CMP      r1,#0x39
002ac4  ca000001          BGT      |L1.10960|
002ac8  e3a00001          MOV      r0,#1
                  |L1.10956|
;;;405    }
002acc  e12fff1e          BX       lr
                  |L1.10960|
002ad0  e3a00000          MOV      r0,#0                 ;404
002ad4  eafffffc          B        |L1.10956|
;;;406    
                          ENDP

                  |L1.10968|
                          DCD      putchar_wrapper
                  |L1.10972|
                          DCD      0x000007ff

                          AREA ||.constdata||, DATA, READONLY, ALIGN=3

                  powers_of_10
000000  00000000          DCFD     0x3ff0000000000000 ; 1
000004  3ff00000
000008  00000000          DCFD     0x4024000000000000 ; 10
00000c  40240000
000010  00000000          DCFD     0x4059000000000000 ; 100
000014  40590000
000018  00000000          DCFD     0x408f400000000000 ; 1000
00001c  408f4000
000020  00000000          DCFD     0x40c3880000000000 ; 10000
000024  40c38800
000028  00000000          DCFD     0x40f86a0000000000 ; 100000
00002c  40f86a00
000030  00000000          DCFD     0x412e848000000000 ; 1000000
000034  412e8480
000038  00000000          DCFD     0x416312d000000000 ; 10000000
00003c  416312d0
000040  00000000          DCFD     0x4197d78400000000 ; 100000000
000044  4197d784
000048  00000000          DCFD     0x41cdcd6500000000 ; 1000000000
00004c  41cdcd65
000050  20000000          DCFD     0x4202a05f20000000 ; 10000000000
000054  4202a05f
000058  e8000000          DCFD     0x42374876e8000000 ; 100000000000
00005c  42374876
000060  a2000000          DCFD     0x426d1a94a2000000 ; 1000000000000
000064  426d1a94
000068  e5400000          DCFD     0x42a2309ce5400000 ; 10000000000000
00006c  42a2309c
000070  1e900000          DCFD     0x42d6bcc41e900000 ; 100000000000000
000074  42d6bcc4
000078  26340000          DCFD     0x430c6bf526340000 ; 1000000000000000
00007c  430c6bf5
000080  37e08000          DCFD     0x4341c37937e08000 ; 10000000000000000
000084  4341c379
000088  85d8a000          DCFD     0x4376345785d8a000 ; 100000000000000000
00008c  43763457
