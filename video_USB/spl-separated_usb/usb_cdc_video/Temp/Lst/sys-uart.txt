; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave --gnu -o.\temp\obj\sys-uart.o --asm_dir=.\Temp\Lst\ --list_dir=.\Temp\Lst\ --depend=.\temp\obj\sys-uart.d --cpu=ARM9E --apcs=interwork -O0 -Otime --diag_suppress=9931 -I.\users\include -I.\..\machine\include -I.\..\periph\include -I.\..\include -I.\..\emwin\Include -I.\..\tinyusb\src -I.\..\tinyusb\hw -I.\..\display -I.\..\lib\display_gfx -I.\..\lib\printf -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Atmel\SAM9260 -D__RTX -D__UVISION_VERSION=536 -DPCB_TINY200V1 -DCFG_TUSB_MCU=OPT_MCU_F1C100S -DCFG_TUSB_OS=OPT_OS_RTX4 --omf_browse=.\temp\obj\sys-uart.crf ..\machine\sys-uart.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  sys_uart_init PROC
;;;91     
;;;92     void sys_uart_init(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;93     {
;;;94       uint32_t addr;
;;;95       uint32_t val;
;;;96     
;;;97       /* UART管脚配置PE0&PE1 */
;;;98       addr = PIO_REG_BASE + PE_OFFSET + 0x00;
000004  e59f4140          LDR      r4,|L1.332|
;;;99       val = read32(addr);
000008  e1a00004          MOV      r0,r4
00000c  ebfffffe          BL       read32
000010  e1a05000          MOV      r5,r0
;;;100      val &= ~((0x7 << 4) | (0x7 << 0));
000014  e3c55077          BIC      r5,r5,#0x77
;;;101      val |= ((0x5 << 4) | (0x5 << 0));
000018  e3855055          ORR      r5,r5,#0x55
;;;102      write32(addr, val);
00001c  e1a01005          MOV      r1,r5
000020  e1a00004          MOV      r0,r4
000024  ebfffffe          BL       write32
;;;103    
;;;104      /* 打开UART时钟源 */
;;;105      addr = F1C100S_CCU_BASE + CCU_BUS_CLK_GATE2;
000028  e59f4120          LDR      r4,|L1.336|
;;;106      val = read32(addr);
00002c  e1a00004          MOV      r0,r4
000030  ebfffffe          BL       read32
000034  e1a05000          MOV      r5,r0
;;;107      val |= (1 << 20);
000038  e3855601          ORR      r5,r5,#0x100000
;;;108      write32(addr, val);
00003c  e1a01005          MOV      r1,r5
000040  e1a00004          MOV      r0,r4
000044  ebfffffe          BL       write32
;;;109    
;;;110      /* 撤销UART总线复位 */
;;;111      addr = F1C100S_CCU_BASE + CCU_BUS_SOFT_RST2;
000048  e2844f9a          ADD      r4,r4,#0x268
;;;112      val = read32(addr);
00004c  e1a00004          MOV      r0,r4
000050  ebfffffe          BL       read32
000054  e1a05000          MOV      r5,r0
;;;113      val |= (1 << 20);
000058  e3855601          ORR      r5,r5,#0x100000
;;;114      write32(addr, val);
00005c  e1a01005          MOV      r1,r5
000060  e1a00004          MOV      r0,r4
000064  ebfffffe          BL       write32
;;;115    
;;;116      /* 配置UART参数115200-8-1-0 */
;;;117      addr = UART0_REG_BASE;
000068  e59f40e4          LDR      r4,|L1.340|
;;;118      write32(addr + UART_IER_REG, 0x0);
00006c  e3a01000          MOV      r1,#0
000070  e2840004          ADD      r0,r4,#4
000074  ebfffffe          BL       write32
;;;119      write32(addr + UART_FCR_REG, 0xf7);
000078  e3a010f7          MOV      r1,#0xf7
00007c  e2840008          ADD      r0,r4,#8
000080  ebfffffe          BL       write32
;;;120      write32(addr + UART_MCR_REG, 0x0);
000084  e3a01000          MOV      r1,#0
000088  e2840010          ADD      r0,r4,#0x10
00008c  ebfffffe          BL       write32
;;;121      val = read32(addr + UART_LCR_REG);
000090  e284000c          ADD      r0,r4,#0xc
000094  ebfffffe          BL       read32
000098  e1a05000          MOV      r5,r0
;;;122      val |= (1 << 7);
00009c  e3855080          ORR      r5,r5,#0x80
;;;123      write32(addr + UART_LCR_REG, val);
0000a0  e1a01005          MOV      r1,r5
0000a4  e284000c          ADD      r0,r4,#0xc
0000a8  ebfffffe          BL       write32
;;;124      write32(addr + UART_DLL_REG, (54 & 0xff));        // APB=100Mhz时div=54，则baud=115200
0000ac  e3a01036          MOV      r1,#0x36
0000b0  e1a00004          MOV      r0,r4
0000b4  ebfffffe          BL       write32
;;;125      write32(addr + UART_DLH_REG, ((54 >> 8) & 0xff));
0000b8  e3a01000          MOV      r1,#0
0000bc  e2840004          ADD      r0,r4,#4
0000c0  ebfffffe          BL       write32
;;;126      val = read32(addr + UART_LCR_REG);
0000c4  e284000c          ADD      r0,r4,#0xc
0000c8  ebfffffe          BL       read32
0000cc  e1a05000          MOV      r5,r0
;;;127      val &= ~(1 << 7);
0000d0  e3c55080          BIC      r5,r5,#0x80
;;;128      write32(addr + UART_LCR_REG, val);
0000d4  e1a01005          MOV      r1,r5
0000d8  e284000c          ADD      r0,r4,#0xc
0000dc  ebfffffe          BL       write32
;;;129      val = read32(addr + UART_LCR_REG);
0000e0  e284000c          ADD      r0,r4,#0xc
0000e4  ebfffffe          BL       read32
0000e8  e1a05000          MOV      r5,r0
;;;130      val &= ~0x3f;
0000ec  e3c5503f          BIC      r5,r5,#0x3f
;;;131      val |= ((0x3 << 0) | (0 << 2) | (0x0 << 3));
0000f0  e3855003          ORR      r5,r5,#3
;;;132      write32(addr + UART_LCR_REG, val);
0000f4  e1a01005          MOV      r1,r5
0000f8  e284000c          ADD      r0,r4,#0xc
0000fc  ebfffffe          BL       write32
;;;133    }
000100  e8bd8070          POP      {r4-r6,pc}
;;;134    
                          ENDP

                  sys_uart_putc PROC
;;;135    void sys_uart_putc(char c)
000104  e92d4070          PUSH     {r4-r6,lr}
;;;136    {
000108  e1a04000          MOV      r4,r0
;;;137      uint32_t addr = UART0_REG_BASE;
00010c  e59f5040          LDR      r5,|L1.340|
;;;138      // Wait for transmit FIFO Not Full!
;;;139      while ((read32(addr + UART_USR_REG) & (1 << 1)) == 0);
000110  e1a00000          MOV      r0,r0
                  |L1.276|
000114  e285007c          ADD      r0,r5,#0x7c
000118  ebfffffe          BL       read32
00011c  e2000002          AND      r0,r0,#2
000120  e3500000          CMP      r0,#0
000124  0afffffa          BEQ      |L1.276|
;;;140      write32(addr + UART_THR_REG, c);
000128  e1a01004          MOV      r1,r4
00012c  e1a00005          MOV      r0,r5
000130  ebfffffe          BL       write32
;;;141    }
000134  e8bd8070          POP      {r4-r6,pc}
;;;142    
                          ENDP

                  read32 PROC
;;;19     
;;;20     static __inline uint32_t read32(uint32_t addr)
000138  e1a01000          MOV      r1,r0
;;;21     {
;;;22       return (*((volatile uint32_t*)(addr)));
00013c  e5910000          LDR      r0,[r1,#0]
;;;23     }
000140  e12fff1e          BX       lr
;;;24     
                          ENDP

                  write32 PROC
;;;39     
;;;40     static __inline void write32(uint32_t addr, uint32_t value)
000144  e5801000          STR      r1,[r0,#0]
;;;41     {
;;;42       *((volatile uint32_t*)(addr)) = value;
;;;43     }
000148  e12fff1e          BX       lr
;;;44     
                          ENDP

                  |L1.332|
                          DCD      0x01c20890
                  |L1.336|
                          DCD      0x01c20068
                  |L1.340|
                          DCD      0x01c25000
