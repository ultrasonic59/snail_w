; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave --gnu -o.\temp\obj\usbd.o --asm_dir=.\Temp\Lst\ --list_dir=.\Temp\Lst\ --depend=.\temp\obj\usbd.d --cpu=ARM9E --apcs=interwork -O0 -Otime --diag_suppress=9931 -I.\users\include -I.\..\machine\include -I.\..\periph\include -I.\..\include -I.\..\emwin\Include -I.\..\tinyusb\src -I.\..\tinyusb\hw -I.\..\display -I.\..\lib\display_gfx -I.\..\lib\printf -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Atmel\SAM9260 -D__RTX -D__UVISION_VERSION=536 -DPCB_TINY200V1 -DCFG_TUSB_MCU=OPT_MCU_F1C100S -DCFG_TUSB_OS=OPT_OS_RTX4 --omf_browse=.\temp\obj\usbd.crf ..\tinyusb\src\device\usbd.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  get_driver PROC
;;;245    // Application is positioned first to allow overwriting built-in ones.
;;;246    static inline usbd_class_driver_t const * get_driver(uint8_t drvid)
000000  e1a01000          MOV      r1,r0
;;;247    {
;;;248      // Application drivers
;;;249      if ( usbd_app_driver_get_cb )
000004  e59f03e4          LDR      r0,|L1.1008|
000008  e3500000          CMP      r0,#0
00000c  0a00000c          BEQ      |L1.68|
;;;250      {
;;;251        if ( drvid < _app_driver_count ) return &_app_driver[drvid];
000010  e59f03dc          LDR      r0,|L1.1012|
000014  e5d00000          LDRB     r0,[r0,#0]  ; _app_driver_count
000018  e1510000          CMP      r1,r0
00001c  aa000004          BGE      |L1.52|
000020  e0810081          ADD      r0,r1,r1,LSL #1
000024  e59f23cc          LDR      r2,|L1.1016|
000028  e5922000          LDR      r2,[r2,#0]  ; _app_driver
00002c  e0820180          ADD      r0,r2,r0,LSL #3
                  |L1.48|
;;;252        drvid -= _app_driver_count;
;;;253      }
;;;254    
;;;255      // when there is no built-in drivers BUILTIN_DRIVER_COUNT = 0 will cause -Wtype-limits warning
;;;256    #ifdef __GNUC__
;;;257    #pragma GCC diagnostic push
;;;258    #pragma GCC diagnostic ignored "-Wtype-limits"
;;;259    #endif
;;;260    
;;;261      // Built-in drivers
;;;262      if (drvid < BUILTIN_DRIVER_COUNT) return &_usbd_driver[drvid];
;;;263    
;;;264    #ifdef __GNUC__
;;;265    #pragma GCC diagnostic pop
;;;266    #endif
;;;267    
;;;268      return NULL;
;;;269    }
000030  e12fff1e          BX       lr
                  |L1.52|
000034  e59f03b8          LDR      r0,|L1.1012|
000038  e5d00000          LDRB     r0,[r0,#0]            ;252  ; _app_driver_count
00003c  e0410000          SUB      r0,r1,r0              ;252
000040  e20010ff          AND      r1,r0,#0xff           ;252
                  |L1.68|
000044  e3510001          CMP      r1,#1                 ;262
000048  aa000003          BGE      |L1.92|
00004c  e0810081          ADD      r0,r1,r1,LSL #1       ;262
000050  e59f23a4          LDR      r2,|L1.1020|
000054  e0820180          ADD      r0,r2,r0,LSL #3       ;262
000058  eafffff4          B        |L1.48|
                  |L1.92|
00005c  e3a00000          MOV      r0,#0                 ;268
000060  eafffff2          B        |L1.48|
;;;270    
                          ENDP

                  tud_speed_get PROC
;;;343    //--------------------------------------------------------------------+
;;;344    tusb_speed_t tud_speed_get(void)
000064  e59f0394          LDR      r0,|L1.1024|
;;;345    {
;;;346      return (tusb_speed_t) _usbd_dev.speed;
000068  e5d00002          LDRB     r0,[r0,#2]  ; _usbd_dev
;;;347    }
00006c  e12fff1e          BX       lr
;;;348    
                          ENDP

                  tud_connected PROC
;;;349    bool tud_connected(void)
000070  e59f0388          LDR      r0,|L1.1024|
;;;350    {
;;;351      return _usbd_dev.connected;
000074  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_dev
000078  e2000001          AND      r0,r0,#1
;;;352    }
00007c  e12fff1e          BX       lr
;;;353    
                          ENDP

                  tud_mounted PROC
;;;354    bool tud_mounted(void)
000080  e59f0378          LDR      r0,|L1.1024|
;;;355    {
;;;356      return _usbd_dev.cfg_num ? true : false;
000084  e5d00001          LDRB     r0,[r0,#1]  ; _usbd_dev
000088  e3500000          CMP      r0,#0
00008c  0a000001          BEQ      |L1.152|
000090  e3a00001          MOV      r0,#1
                  |L1.148|
;;;357    }
000094  e12fff1e          BX       lr
                  |L1.152|
000098  e3a00000          MOV      r0,#0                 ;356
00009c  eafffffc          B        |L1.148|
;;;358    
                          ENDP

                  tud_suspended PROC
;;;359    bool tud_suspended(void)
0000a0  e59f0358          LDR      r0,|L1.1024|
;;;360    {
;;;361      return _usbd_dev.suspended;
0000a4  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_dev
0000a8  e1a00e80          LSL      r0,r0,#29
0000ac  e1a00fa0          LSR      r0,r0,#31
;;;362    }
0000b0  e12fff1e          BX       lr
;;;363    
                          ENDP

                  tud_remote_wakeup PROC
;;;364    bool tud_remote_wakeup(void)
0000b4  e92d4010          PUSH     {r4,lr}
;;;365    {
;;;366      // only wake up host if this feature is supported and enabled and we are suspended
;;;367      TU_VERIFY (_usbd_dev.suspended && _usbd_dev.remote_wakeup_support && _usbd_dev.remote_wakeup_en );
0000b8  e1a00000          MOV      r0,r0
0000bc  e59f033c          LDR      r0,|L1.1024|
0000c0  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_dev
0000c4  e1a00e80          LSL      r0,r0,#29
0000c8  e1a00fa0          LSR      r0,r0,#31
0000cc  e3500000          CMP      r0,#0
0000d0  0a00000b          BEQ      |L1.260|
0000d4  e59f0324          LDR      r0,|L1.1024|
0000d8  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_dev
0000dc  e1a00d80          LSL      r0,r0,#27
0000e0  e1a00fa0          LSR      r0,r0,#31
0000e4  e3500000          CMP      r0,#0
0000e8  0a000005          BEQ      |L1.260|
0000ec  e59f030c          LDR      r0,|L1.1024|
0000f0  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_dev
0000f4  e1a00e00          LSL      r0,r0,#28
0000f8  e1a00fa0          LSR      r0,r0,#31
0000fc  e3500000          CMP      r0,#0
000100  1a000001          BNE      |L1.268|
                  |L1.260|
000104  e3a00000          MOV      r0,#0
                  |L1.264|
;;;368      dcd_remote_wakeup(_usbd_rhport);
;;;369      return true;
;;;370    }
000108  e8bd8010          POP      {r4,pc}
                  |L1.268|
00010c  e1a00000          MOV      r0,r0                 ;367
000110  e59f02ec          LDR      r0,|L1.1028|
000114  e5d00000          LDRB     r0,[r0,#0]            ;368  ; _usbd_rhport
000118  ebfffffe          BL       dcd_remote_wakeup
00011c  e3a00001          MOV      r0,#1                 ;369
000120  eafffff8          B        |L1.264|
;;;371    
                          ENDP

                  tud_disconnect PROC
;;;372    bool tud_disconnect(void)
000124  e92d4010          PUSH     {r4,lr}
;;;373    {
;;;374      TU_VERIFY(dcd_disconnect);
000128  e1a00000          MOV      r0,r0
00012c  e59f02d4          LDR      r0,|L1.1032|
000130  e3500000          CMP      r0,#0
000134  1a000001          BNE      |L1.320|
000138  e3a00000          MOV      r0,#0
                  |L1.316|
;;;375      dcd_disconnect(_usbd_rhport);
;;;376      return true;
;;;377    }
00013c  e8bd8010          POP      {r4,pc}
                  |L1.320|
000140  e1a00000          MOV      r0,r0                 ;374
000144  e59f02b8          LDR      r0,|L1.1028|
000148  e5d00000          LDRB     r0,[r0,#0]            ;375  ; _usbd_rhport
00014c  ebfffffe          BL       dcd_disconnect
000150  e3a00001          MOV      r0,#1                 ;376
000154  eafffff8          B        |L1.316|
;;;378    
                          ENDP

                  tud_connect PROC
;;;379    bool tud_connect(void)
000158  e92d4010          PUSH     {r4,lr}
;;;380    {
;;;381      TU_VERIFY(dcd_connect);
00015c  e1a00000          MOV      r0,r0
000160  e59f02a4          LDR      r0,|L1.1036|
000164  e3500000          CMP      r0,#0
000168  1a000001          BNE      |L1.372|
00016c  e3a00000          MOV      r0,#0
                  |L1.368|
;;;382      dcd_connect(_usbd_rhport);
;;;383      return true;
;;;384    }
000170  e8bd8010          POP      {r4,pc}
                  |L1.372|
000174  e1a00000          MOV      r0,r0                 ;381
000178  e59f0284          LDR      r0,|L1.1028|
00017c  e5d00000          LDRB     r0,[r0,#0]            ;382  ; _usbd_rhport
000180  ebfffffe          BL       dcd_connect
000184  e3a00001          MOV      r0,#1                 ;383
000188  eafffff8          B        |L1.368|
;;;385    
                          ENDP

                  tud_inited PROC
;;;388    //--------------------------------------------------------------------+
;;;389    bool tud_inited(void)
00018c  e59f0270          LDR      r0,|L1.1028|
;;;390    {
;;;391      return _usbd_rhport != RHPORT_INVALID;
000190  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_rhport
000194  e35000ff          CMP      r0,#0xff
000198  0a000001          BEQ      |L1.420|
00019c  e3a00001          MOV      r0,#1
                  |L1.416|
;;;392    }
0001a0  e12fff1e          BX       lr
                  |L1.420|
0001a4  e3a00000          MOV      r0,#0                 ;391
0001a8  eafffffc          B        |L1.416|
;;;393    
                          ENDP

                  tud_init PROC
;;;394    bool tud_init (uint8_t rhport)
0001ac  e92d4070          PUSH     {r4-r6,lr}
;;;395    {
0001b0  e1a05000          MOV      r5,r0
;;;396      // skip if already initialized
;;;397      if ( tud_inited() ) return true;
0001b4  ebfffffe          BL       tud_inited
0001b8  e3500000          CMP      r0,#0
0001bc  0a000001          BEQ      |L1.456|
0001c0  e3a00001          MOV      r0,#1
                  |L1.452|
;;;398    
;;;399      TU_LOG(USBD_DBG, "USBD init on controller %u\r\n", rhport);
;;;400      TU_LOG_INT(USBD_DBG, sizeof(usbd_device_t));
;;;401      TU_LOG_INT(USBD_DBG, sizeof(tu_fifo_t));
;;;402      TU_LOG_INT(USBD_DBG, sizeof(tu_edpt_stream_t));
;;;403    
;;;404      tu_varclr(&_usbd_dev);
;;;405    
;;;406    #if OSAL_MUTEX_REQUIRED
;;;407      // Init device mutex
;;;408      _usbd_mutex = osal_mutex_create(&_ubsd_mutexdef);
;;;409      TU_ASSERT(_usbd_mutex);
;;;410    #endif
;;;411    
;;;412      // Init device queue & task
;;;413      _usbd_q = osal_queue_create(&_usbd_qdef);
;;;414      TU_ASSERT(_usbd_q);
;;;415    
;;;416      // Get application driver if available
;;;417      if ( usbd_app_driver_get_cb )
;;;418      {
;;;419        _app_driver = usbd_app_driver_get_cb(&_app_driver_count);
;;;420      }
;;;421    
;;;422      // Init class drivers
;;;423      for (uint8_t i = 0; i < TOTAL_DRIVER_COUNT; i++)
;;;424      {
;;;425        usbd_class_driver_t const * driver = get_driver(i);
;;;426        TU_ASSERT(driver);
;;;427        TU_LOG(USBD_DBG, "%s init\r\n", driver->name);
;;;428        driver->init();
;;;429      }
;;;430    
;;;431      _usbd_rhport = rhport;
;;;432    
;;;433      // Init device controller driver
;;;434      dcd_init(rhport);
;;;435      dcd_int_enable(rhport);
;;;436    
;;;437      return true;
;;;438    }
0001c4  e8bd8070          POP      {r4-r6,pc}
                  |L1.456|
0001c8  e3a01023          MOV      r1,#0x23              ;404
0001cc  e59f022c          LDR      r0,|L1.1024|
0001d0  ebfffffe          BL       __aeabi_memclr4
0001d4  e59f4234          LDR      r4,|L1.1040|
0001d8  e1a00004          MOV      r0,r4                 ;408
0001dc  ebfffffe          BL       os_mut_init
0001e0  e1a00000          MOV      r0,r0                 ;408
0001e4  e59f0228          LDR      r0,|L1.1044|
0001e8  e5804000          STR      r4,[r0,#0]            ;408  ; _usbd_mutex
0001ec  e1a00000          MOV      r0,r0                 ;409
0001f0  e5900000          LDR      r0,[r0,#0]            ;409  ; _usbd_mutex
0001f4  e3500000          CMP      r0,#0                 ;409
0001f8  1a000007          BNE      |L1.540|
0001fc  e59f2214          LDR      r2,|L1.1048|
000200  e59f1214          LDR      r1,|L1.1052|
000204  e28f0f85          ADR      r0,|L1.1056|
000208  ebfffffe          BL       __2printf
00020c  e1a00000          MOV      r0,r0                 ;409
000210  e1a00000          MOV      r0,r0                 ;409
000214  e3a00000          MOV      r0,#0                 ;409
000218  eaffffe9          B        |L1.452|
                  |L1.540|
00021c  e1a00000          MOV      r0,r0                 ;409
000220  e59f4210          LDR      r4,|L1.1080|
000224  e1d420b0          LDRH     r2,[r4,#0]            ;413
000228  e2822004          ADD      r2,r2,#4              ;413
00022c  e59f3208          LDR      r3,|L1.1084|
000230  e0031102          AND      r1,r3,r2,LSL #2       ;413
000234  e5940008          LDR      r0,[r4,#8]            ;413
000238  ebfffffe          BL       os_mbx_init
00023c  e1d430b2          LDRH     r3,[r4,#2]            ;413
000240  e2836003          ADD      r6,r3,#3              ;413
000244  e1a03fc6          ASR      r3,r6,#31             ;413
000248  e0863f23          ADD      r3,r6,r3,LSR #30      ;413
00024c  e1a03143          ASR      r3,r3,#2              ;413
000250  e1d4c0b0          LDRH     r12,[r4,#0]           ;413
000254  e003039c          MUL      r3,r12,r3             ;413
000258  e2831003          ADD      r1,r3,#3              ;413
00025c  e1d420b2          LDRH     r2,[r4,#2]            ;413
000260  e5940004          LDR      r0,[r4,#4]            ;413
000264  ebfffffe          BL       _init_box
000268  e1a00000          MOV      r0,r0                 ;413
00026c  e59f01cc          LDR      r0,|L1.1088|
000270  e5804000          STR      r4,[r0,#0]            ;413  ; _usbd_q
000274  e1a00000          MOV      r0,r0                 ;414
000278  e5900000          LDR      r0,[r0,#0]            ;414  ; _usbd_q
00027c  e3500000          CMP      r0,#0                 ;414
000280  1a000007          BNE      |L1.676|
000284  e59f21b8          LDR      r2,|L1.1092|
000288  e59f118c          LDR      r1,|L1.1052|
00028c  e28f0f63          ADR      r0,|L1.1056|
000290  ebfffffe          BL       __2printf
000294  e1a00000          MOV      r0,r0                 ;414
000298  e1a00000          MOV      r0,r0                 ;414
00029c  e3a00000          MOV      r0,#0                 ;414
0002a0  eaffffc7          B        |L1.452|
                  |L1.676|
0002a4  e1a00000          MOV      r0,r0                 ;414
0002a8  e59f0140          LDR      r0,|L1.1008|
0002ac  e3500000          CMP      r0,#0                 ;417
0002b0  0a000003          BEQ      |L1.708|
0002b4  e59f0138          LDR      r0,|L1.1012|
0002b8  ebfffffe          BL       usbd_app_driver_get_cb
0002bc  e59f1134          LDR      r1,|L1.1016|
0002c0  e5810000          STR      r0,[r1,#0]            ;419  ; _app_driver
                  |L1.708|
0002c4  e3a04000          MOV      r4,#0                 ;423
0002c8  ea000012          B        |L1.792|
                  |L1.716|
0002cc  e1a00004          MOV      r0,r4                 ;425
0002d0  ebfffffe          BL       get_driver
0002d4  e1a06000          MOV      r6,r0                 ;425
0002d8  e1a00000          MOV      r0,r0                 ;426
0002dc  e3560000          CMP      r6,#0                 ;426
0002e0  1a000007          BNE      |L1.772|
0002e4  e59f215c          LDR      r2,|L1.1096|
0002e8  e59f112c          LDR      r1,|L1.1052|
0002ec  e28f0f4b          ADR      r0,|L1.1056|
0002f0  ebfffffe          BL       __2printf
0002f4  e1a00000          MOV      r0,r0                 ;426
0002f8  e1a00000          MOV      r0,r0                 ;426
0002fc  e3a00000          MOV      r0,#0                 ;426
000300  eaffffaf          B        |L1.452|
                  |L1.772|
000304  e1a00000          MOV      r0,r0                 ;426
000308  e5960000          LDR      r0,[r6,#0]            ;428
00030c  e12fff30          BLX      r0                    ;428
000310  e2840001          ADD      r0,r4,#1              ;423
000314  e20040ff          AND      r4,r0,#0xff           ;423
                  |L1.792|
000318  e59f00d4          LDR      r0,|L1.1012|
00031c  e5d00000          LDRB     r0,[r0,#0]            ;423  ; _app_driver_count
000320  e2800001          ADD      r0,r0,#1              ;423
000324  e1540000          CMP      r4,r0                 ;423
000328  baffffe7          BLT      |L1.716|
00032c  e59f00d0          LDR      r0,|L1.1028|
000330  e5c05000          STRB     r5,[r0,#0]            ;431  ; _usbd_rhport
000334  e1a00005          MOV      r0,r5                 ;434
000338  ebfffffe          BL       dcd_init
00033c  e1a00005          MOV      r0,r5                 ;435
000340  ebfffffe          BL       dcd_int_enable
000344  e3a00001          MOV      r0,#1                 ;437
000348  eaffff9d          B        |L1.452|
;;;439    
                          ENDP

                  configuration_reset PROC
;;;440    static void configuration_reset(uint8_t rhport)
00034c  e92d4070          PUSH     {r4-r6,lr}
;;;441    {
000350  e1a06000          MOV      r6,r0
;;;442      for ( uint8_t i = 0; i < TOTAL_DRIVER_COUNT; i++ )
000354  e3a04000          MOV      r4,#0
000358  ea000012          B        |L1.936|
                  |L1.860|
;;;443      {
;;;444        usbd_class_driver_t const * driver = get_driver(i);
00035c  e1a00004          MOV      r0,r4
000360  ebfffffe          BL       get_driver
000364  e1a05000          MOV      r5,r0
;;;445        TU_ASSERT(driver, );
000368  e1a00000          MOV      r0,r0
00036c  e3550000          CMP      r5,#0
000370  1a000006          BNE      |L1.912|
000374  e59f20d0          LDR      r2,|L1.1100|
000378  e59f10d0          LDR      r1,|L1.1104|
00037c  e28f009c          ADR      r0,|L1.1056|
000380  ebfffffe          BL       __2printf
000384  e1a00000          MOV      r0,r0
000388  e1a00000          MOV      r0,r0
                  |L1.908|
;;;446        driver->reset(rhport);
;;;447      }
;;;448    
;;;449      tu_varclr(&_usbd_dev);
;;;450      memset(_usbd_dev.itf2drv, DRVID_INVALID, sizeof(_usbd_dev.itf2drv)); // invalid mapping
;;;451      memset(_usbd_dev.ep2drv , DRVID_INVALID, sizeof(_usbd_dev.ep2drv )); // invalid mapping
;;;452    }
00038c  e8bd8070          POP      {r4-r6,pc}
                  |L1.912|
000390  e1a00000          MOV      r0,r0                 ;445
000394  e1a00006          MOV      r0,r6                 ;446
000398  e5951004          LDR      r1,[r5,#4]            ;446
00039c  e12fff31          BLX      r1                    ;446
0003a0  e2840001          ADD      r0,r4,#1              ;442
0003a4  e20040ff          AND      r4,r0,#0xff           ;442
                  |L1.936|
0003a8  e59f0044          LDR      r0,|L1.1012|
0003ac  e5d00000          LDRB     r0,[r0,#0]            ;442  ; _app_driver_count
0003b0  e2800001          ADD      r0,r0,#1              ;442
0003b4  e1540000          CMP      r4,r0                 ;442
0003b8  baffffe7          BLT      |L1.860|
0003bc  e3a01023          MOV      r1,#0x23              ;449
0003c0  e59f0038          LDR      r0,|L1.1024|
0003c4  ebfffffe          BL       __aeabi_memclr4
0003c8  e3a020ff          MOV      r2,#0xff              ;450
0003cc  e3a01010          MOV      r1,#0x10              ;450
0003d0  e59f007c          LDR      r0,|L1.1108|
0003d4  ebfffffe          BL       __aeabi_memset
0003d8  e3a020ff          MOV      r2,#0xff              ;451
0003dc  e3a01008          MOV      r1,#8                 ;451
0003e0  e59f0070          LDR      r0,|L1.1112|
0003e4  ebfffffe          BL       __aeabi_memset
0003e8  e1a00000          MOV      r0,r0
0003ec  eaffffe6          B        |L1.908|
                  |L1.1008|
                          DCD      usbd_app_driver_get_cb
                  |L1.1012|
                          DCD      _app_driver_count
                  |L1.1016|
                          DCD      _app_driver
                  |L1.1020|
                          DCD      _usbd_driver
                  |L1.1024|
                          DCD      _usbd_dev
                  |L1.1028|
                          DCD      _usbd_rhport
                  |L1.1032|
                          DCD      dcd_disconnect
                  |L1.1036|
                          DCD      dcd_connect
                  |L1.1040|
                          DCD      _ubsd_mutexdef
                  |L1.1044|
                          DCD      _usbd_mutex
                  |L1.1048|
                          DCD      0x00000199
                  |L1.1052|
                          DCD      __func__
                  |L1.1056|
000420  25732025          DCB      "%s %d: ASSERT FAILED\r\n",0
000424  643a2041
000428  53534552
00042c  54204641
000430  494c4544
000434  0d0a00  
000437  00                DCB      0
                  |L1.1080|
                          DCD      _usbd_qdef
                  |L1.1084|
                          DCD      0x0000ffff
                  |L1.1088|
                          DCD      _usbd_q
                  |L1.1092|
                          DCD      0x0000019e
                  |L1.1096|
                          DCD      0x000001aa
                  |L1.1100|
                          DCD      0x000001bd
                  |L1.1104|
                          DCD      |symbol_number.17|
                  |L1.1108|
                          DCD      _usbd_dev+0x3
                  |L1.1112|
                          DCD      _usbd_dev+0x13
                          ENDP

                  usbd_reset PROC
;;;453    
;;;454    static void usbd_reset(uint8_t rhport)
00045c  e92d4010          PUSH     {r4,lr}
;;;455    {
000460  e1a04000          MOV      r4,r0
;;;456      configuration_reset(rhport);
000464  e1a00004          MOV      r0,r4
000468  ebfffffe          BL       configuration_reset
;;;457      usbd_control_reset();
00046c  ebfffffe          BL       usbd_control_reset
;;;458    }
000470  e8bd8010          POP      {r4,pc}
;;;459    
                          ENDP

                  tud_task_event_ready PROC
;;;460    bool tud_task_event_ready(void)
000474  e92d4010          PUSH     {r4,lr}
;;;461    {
;;;462      // Skip if stack is not initialized
;;;463      if ( !tud_inited() ) return false;
000478  ebfffffe          BL       tud_inited
00047c  e3500000          CMP      r0,#0
000480  1a000001          BNE      |L1.1164|
000484  e3a00000          MOV      r0,#0
                  |L1.1160|
;;;464    
;;;465      return !osal_queue_empty(_usbd_q);
;;;466    }
000488  e8bd8010          POP      {r4,pc}
                  |L1.1164|
00048c  e51f0054          LDR      r0,|L1.1088|
000490  e5904000          LDR      r4,[r0,#0]            ;465  ; _usbd_q
000494  e5940008          LDR      r0,[r4,#8]            ;465
000498  ebfffffe          BL       os_mbx_check
00049c  e1d410b0          LDRH     r1,[r4,#0]            ;465
0004a0  e1500001          CMP      r0,r1                 ;465
0004a4  1a000001          BNE      |L1.1200|
0004a8  e3a00001          MOV      r0,#1                 ;465
0004ac  ea000000          B        |L1.1204|
                  |L1.1200|
0004b0  e3a00000          MOV      r0,#0                 ;465
                  |L1.1204|
0004b4  e2200001          EOR      r0,r0,#1              ;465
0004b8  eafffff2          B        |L1.1160|
;;;467    
                          ENDP

                  invoke_class_control PROC
;;;627    // Helper to invoke class driver control request handler
;;;628    static bool invoke_class_control(uint8_t rhport, usbd_class_driver_t const * driver, tusb_control_request_t const * request)
0004bc  e92d4070          PUSH     {r4-r6,lr}
;;;629    {
0004c0  e1a05000          MOV      r5,r0
0004c4  e1a04001          MOV      r4,r1
0004c8  e1a06002          MOV      r6,r2
;;;630      usbd_control_set_complete_callback(driver->control_xfer_cb);
0004cc  e594000c          LDR      r0,[r4,#0xc]
0004d0  ebfffffe          BL       usbd_control_set_complete_callback
;;;631      TU_LOG(USBD_DBG, "  %s control request\r\n", driver->name);
;;;632      return driver->control_xfer_cb(rhport, CONTROL_STAGE_SETUP, request);
0004d4  e1a02006          MOV      r2,r6
0004d8  e3a01001          MOV      r1,#1
0004dc  e1a00005          MOV      r0,r5
0004e0  e594300c          LDR      r3,[r4,#0xc]
0004e4  e12fff33          BLX      r3
;;;633    }
0004e8  e8bd8070          POP      {r4-r6,pc}
;;;634    
                          ENDP

                  usbd_edpt_stall PROC
;;;1326   
;;;1327   void usbd_edpt_stall(uint8_t rhport, uint8_t ep_addr)
0004ec  e92d41f0          PUSH     {r4-r8,lr}
;;;1328   {
0004f0  e1a07000          MOV      r7,r0
0004f4  e1a04001          MOV      r4,r1
;;;1329     rhport = _usbd_rhport;
0004f8  e51f00fc          LDR      r0,|L1.1028|
0004fc  e5d07000          LDRB     r7,[r0,#0]  ; _usbd_rhport
;;;1330   
;;;1331     uint8_t const epnum = tu_edpt_number(ep_addr);
000500  e1a00000          MOV      r0,r0
000504  e3c40080          BIC      r0,r4,#0x80
000508  e1a05000          MOV      r5,r0
;;;1332     uint8_t const dir   = tu_edpt_dir(ep_addr);
00050c  e1a00000          MOV      r0,r0
000510  e2040080          AND      r0,r4,#0x80
000514  e1a003a0          LSR      r0,r0,#7
000518  e1a06000          MOV      r6,r0
;;;1333   
;;;1334     // only stalled if currently cleared
;;;1335     if ( !_usbd_dev.ep_status[epnum][dir].stalled )
00051c  e59f0ed4          LDR      r0,|L1.5112|
000520  e0800085          ADD      r0,r0,r5,LSL #1
000524  e7d00006          LDRB     r0,[r0,r6]
000528  e1a00f00          LSL      r0,r0,#30
00052c  e1a00fa0          LSR      r0,r0,#31
000530  e3500000          CMP      r0,#0
000534  1a000010          BNE      |L1.1404|
;;;1336     {
;;;1337       TU_LOG(USBD_DBG, "    Stall EP %02X\r\n", ep_addr);
;;;1338       dcd_edpt_stall(rhport, ep_addr);
000538  e1a01004          MOV      r1,r4
00053c  e1a00007          MOV      r0,r7
000540  ebfffffe          BL       dcd_edpt_stall
;;;1339       _usbd_dev.ep_status[epnum][dir].stalled = 1;
000544  e59f0eac          LDR      r0,|L1.5112|
000548  e0800085          ADD      r0,r0,r5,LSL #1
00054c  e7d00006          LDRB     r0,[r0,r6]
000550  e3800002          ORR      r0,r0,#2
000554  e59f1e9c          LDR      r1,|L1.5112|
000558  e0811085          ADD      r1,r1,r5,LSL #1
00055c  e7c10006          STRB     r0,[r1,r6]
;;;1340       _usbd_dev.ep_status[epnum][dir].busy = 1;
000560  e59f0e90          LDR      r0,|L1.5112|
000564  e0800085          ADD      r0,r0,r5,LSL #1
000568  e7d00006          LDRB     r0,[r0,r6]
00056c  e3800001          ORR      r0,r0,#1
000570  e59f1e80          LDR      r1,|L1.5112|
000574  e0811085          ADD      r1,r1,r5,LSL #1
000578  e7c10006          STRB     r0,[r1,r6]
                  |L1.1404|
;;;1341     }
;;;1342   }
00057c  e8bd81f0          POP      {r4-r8,pc}
;;;1343   
                          ENDP

                  usbd_edpt_clear_stall PROC
;;;1344   void usbd_edpt_clear_stall(uint8_t rhport, uint8_t ep_addr)
000580  e92d41f0          PUSH     {r4-r8,lr}
;;;1345   {
000584  e1a07000          MOV      r7,r0
000588  e1a04001          MOV      r4,r1
;;;1346     rhport = _usbd_rhport;
00058c  e51f0190          LDR      r0,|L1.1028|
000590  e5d07000          LDRB     r7,[r0,#0]  ; _usbd_rhport
;;;1347   
;;;1348     uint8_t const epnum = tu_edpt_number(ep_addr);
000594  e1a00000          MOV      r0,r0
000598  e3c40080          BIC      r0,r4,#0x80
00059c  e1a05000          MOV      r5,r0
;;;1349     uint8_t const dir   = tu_edpt_dir(ep_addr);
0005a0  e1a00000          MOV      r0,r0
0005a4  e2040080          AND      r0,r4,#0x80
0005a8  e1a003a0          LSR      r0,r0,#7
0005ac  e1a06000          MOV      r6,r0
;;;1350   
;;;1351     // only clear if currently stalled
;;;1352     if ( _usbd_dev.ep_status[epnum][dir].stalled )
0005b0  e59f0e40          LDR      r0,|L1.5112|
0005b4  e0800085          ADD      r0,r0,r5,LSL #1
0005b8  e7d00006          LDRB     r0,[r0,r6]
0005bc  e1a00f00          LSL      r0,r0,#30
0005c0  e1a00fa0          LSR      r0,r0,#31
0005c4  e3500000          CMP      r0,#0
0005c8  0a000010          BEQ      |L1.1552|
;;;1353     {
;;;1354       TU_LOG(USBD_DBG, "    Clear Stall EP %02X\r\n", ep_addr);
;;;1355       dcd_edpt_clear_stall(rhport, ep_addr);
0005cc  e1a01004          MOV      r1,r4
0005d0  e1a00007          MOV      r0,r7
0005d4  ebfffffe          BL       dcd_edpt_clear_stall
;;;1356       _usbd_dev.ep_status[epnum][dir].stalled = 0;
0005d8  e59f0e18          LDR      r0,|L1.5112|
0005dc  e0800085          ADD      r0,r0,r5,LSL #1
0005e0  e7d00006          LDRB     r0,[r0,r6]
0005e4  e3c00002          BIC      r0,r0,#2
0005e8  e59f1e08          LDR      r1,|L1.5112|
0005ec  e0811085          ADD      r1,r1,r5,LSL #1
0005f0  e7c10006          STRB     r0,[r1,r6]
;;;1357       _usbd_dev.ep_status[epnum][dir].busy = 0;
0005f4  e59f0dfc          LDR      r0,|L1.5112|
0005f8  e0800085          ADD      r0,r0,r5,LSL #1
0005fc  e7d00006          LDRB     r0,[r0,r6]
000600  e3c00001          BIC      r0,r0,#1
000604  e59f1dec          LDR      r1,|L1.5112|
000608  e0811085          ADD      r1,r1,r5,LSL #1
00060c  e7c10006          STRB     r0,[r1,r6]
                  |L1.1552|
;;;1358     }
;;;1359   }
000610  e8bd81f0          POP      {r4-r8,pc}
;;;1360   
                          ENDP

                  usbd_edpt_stalled PROC
;;;1361   bool usbd_edpt_stalled(uint8_t rhport, uint8_t ep_addr)
000614  e1a0c000          MOV      r12,r0
;;;1362   {
;;;1363     (void) rhport;
;;;1364   
;;;1365     uint8_t const epnum = tu_edpt_number(ep_addr);
000618  e1a00000          MOV      r0,r0
00061c  e3c10080          BIC      r0,r1,#0x80
000620  e1a02000          MOV      r2,r0
;;;1366     uint8_t const dir   = tu_edpt_dir(ep_addr);
000624  e1a00000          MOV      r0,r0
000628  e2010080          AND      r0,r1,#0x80
00062c  e1a003a0          LSR      r0,r0,#7
000630  e1a03000          MOV      r3,r0
;;;1367   
;;;1368     return _usbd_dev.ep_status[epnum][dir].stalled;
000634  e59f0dbc          LDR      r0,|L1.5112|
000638  e0800082          ADD      r0,r0,r2,LSL #1
00063c  e7d00003          LDRB     r0,[r0,r3]
000640  e1a00f00          LSL      r0,r0,#30
000644  e1a00fa0          LSR      r0,r0,#31
;;;1369   }
000648  e12fff1e          BX       lr
;;;1370   
                          ENDP

                  process_get_descriptor PROC
;;;984    // return descriptor's buffer and update desc_len
;;;985    static bool process_get_descriptor(uint8_t rhport, tusb_control_request_t const * p_request)
00064c  e92d47f0          PUSH     {r4-r10,lr}
;;;986    {
000650  e1a08000          MOV      r8,r0
000654  e1a05001          MOV      r5,r1
;;;987      tusb_desc_type_t const desc_type = (tusb_desc_type_t) tu_u16_high(p_request->wValue);
000658  e5d51003          LDRB     r1,[r5,#3]
00065c  e5d52002          LDRB     r2,[r5,#2]
000660  e1820401          ORR      r0,r2,r1,LSL #8
000664  e1a01440          ASR      r1,r0,#8
000668  e1a07001          MOV      r7,r1
;;;988      uint8_t const desc_index = tu_u16_low( p_request->wValue );
00066c  e5d51003          LDRB     r1,[r5,#3]
000670  e5d52002          LDRB     r2,[r5,#2]
000674  e1820401          ORR      r0,r2,r1,LSL #8
000678  e20010ff          AND      r1,r0,#0xff
00067c  e1a09001          MOV      r9,r1
;;;989    
;;;990      switch(desc_type)
000680  e3570006          CMP      r7,#6
000684  0a000076          BEQ      |L1.2148|
000688  ca000006          BGT      |L1.1704|
00068c  e3570001          CMP      r7,#1
000690  0a000009          BEQ      |L1.1724|
000694  e3570002          CMP      r7,#2
000698  0a000031          BEQ      |L1.1892|
00069c  e3570003          CMP      r7,#3
0006a0  1a000088          BNE      |L1.2248|
0006a4  ea000058          B        |L1.2060|
                  |L1.1704|
0006a8  e3570007          CMP      r7,#7
0006ac  0a00002e          BEQ      |L1.1900|
0006b0  e357000f          CMP      r7,#0xf
0006b4  1a000083          BNE      |L1.2248|
0006b8  ea000009          B        |L1.1764|
                  |L1.1724|
;;;991      {
;;;992        case TUSB_DESC_DEVICE:
0006bc  e1a00000          MOV      r0,r0
;;;993        {
;;;994          TU_LOG(USBD_DBG, " Device\r\n");
;;;995    
;;;996          void* desc_device = (void*) (uintptr_t) tud_descriptor_device_cb();
0006c0  ebfffffe          BL       tud_descriptor_device_cb
0006c4  e1a04000          MOV      r4,r0
;;;997    
;;;998          // Only response with exactly 1 Packet if: not addressed and host requested more data than device descriptor has.
;;;999          // This only happens with the very first get device descriptor and EP0 size = 8 or 16.
;;;1000         if ((CFG_TUD_ENDPOINT0_SIZE < sizeof(tusb_desc_device_t)) && !_usbd_dev.addressed &&
0006c8  e1a00000          MOV      r0,r0
;;;1001             ((tusb_control_request_t const*) p_request)->wLength > sizeof(tusb_desc_device_t))
;;;1002         {
;;;1003           // Hack here: we modify the request length to prevent usbd_control response with zlp
;;;1004           // since we are responding with 1 packet & less data than wLength.
;;;1005           tusb_control_request_t mod_request = *p_request;
;;;1006           mod_request.wLength = CFG_TUD_ENDPOINT0_SIZE;
;;;1007   
;;;1008           return tud_control_xfer(rhport, &mod_request, desc_device, CFG_TUD_ENDPOINT0_SIZE);
;;;1009         }else
;;;1010         {
;;;1011           return tud_control_xfer(rhport, p_request, desc_device, sizeof(tusb_desc_device_t));
0006cc  e3a03012          MOV      r3,#0x12
0006d0  e1a02004          MOV      r2,r4
0006d4  e1a01005          MOV      r1,r5
0006d8  e1a00008          MOV      r0,r8
0006dc  ebfffffe          BL       tud_control_xfer
                  |L1.1760|
;;;1012         }
;;;1013       }
;;;1014       // break; // unreachable
;;;1015   
;;;1016       case TUSB_DESC_BOS:
;;;1017       {
;;;1018         TU_LOG(USBD_DBG, " BOS\r\n");
;;;1019   
;;;1020         // requested by host if USB > 2.0 ( i.e 2.1 or 3.x )
;;;1021         if (!tud_descriptor_bos_cb) return false;
;;;1022   
;;;1023         uintptr_t desc_bos = (uintptr_t) tud_descriptor_bos_cb();
;;;1024         TU_ASSERT(desc_bos);
;;;1025   
;;;1026         // Use offsetof to avoid pointer to the odd/misaligned address
;;;1027         uint16_t const total_len = tu_le16toh( tu_unaligned_read16((const void*) (desc_bos + offsetof(tusb_desc_bos_t, wTotalLength))) );
;;;1028   
;;;1029         return tud_control_xfer(rhport, p_request, (void*) desc_bos, total_len);
;;;1030       }
;;;1031       // break; // unreachable
;;;1032   
;;;1033       case TUSB_DESC_CONFIGURATION:
;;;1034       case TUSB_DESC_OTHER_SPEED_CONFIG:
;;;1035       {
;;;1036         uintptr_t desc_config;
;;;1037   
;;;1038         if ( desc_type == TUSB_DESC_CONFIGURATION )
;;;1039         {
;;;1040           TU_LOG(USBD_DBG, " Configuration[%u]\r\n", desc_index);
;;;1041           desc_config = (uintptr_t) tud_descriptor_configuration_cb(desc_index);
;;;1042         }else
;;;1043         {
;;;1044           // Host only request this after getting Device Qualifier descriptor
;;;1045           TU_LOG(USBD_DBG, " Other Speed Configuration\r\n");
;;;1046           TU_VERIFY( tud_descriptor_other_speed_configuration_cb );
;;;1047           desc_config = (uintptr_t) tud_descriptor_other_speed_configuration_cb(desc_index);
;;;1048         }
;;;1049   
;;;1050         TU_ASSERT(desc_config);
;;;1051   
;;;1052         // Use offsetof to avoid pointer to the odd/misaligned address
;;;1053         uint16_t const total_len = tu_le16toh( tu_unaligned_read16((const void*) (desc_config + offsetof(tusb_desc_configuration_t, wTotalLength))) );
;;;1054   
;;;1055         return tud_control_xfer(rhport, p_request, (void*) desc_config, total_len);
;;;1056       }
;;;1057       // break; // unreachable
;;;1058   
;;;1059       case TUSB_DESC_STRING:
;;;1060       {
;;;1061         TU_LOG(USBD_DBG, " String[%u]\r\n", desc_index);
;;;1062   
;;;1063         // String Descriptor always uses the desc set from user
;;;1064         uint8_t const* desc_str = (uint8_t const*) tud_descriptor_string_cb(desc_index, tu_le16toh(p_request->wIndex));
;;;1065         TU_VERIFY(desc_str);
;;;1066   
;;;1067         // first byte of descriptor is its size
;;;1068         return tud_control_xfer(rhport, p_request, (void*) (uintptr_t) desc_str, tu_desc_len(desc_str));
;;;1069       }
;;;1070       // break; // unreachable
;;;1071   
;;;1072       case TUSB_DESC_DEVICE_QUALIFIER:
;;;1073       {
;;;1074         TU_LOG(USBD_DBG, " Device Qualifier\r\n");
;;;1075   
;;;1076         TU_VERIFY( tud_descriptor_device_qualifier_cb );
;;;1077   
;;;1078         uint8_t const* desc_qualifier = tud_descriptor_device_qualifier_cb();
;;;1079         TU_VERIFY(desc_qualifier);
;;;1080   
;;;1081         // first byte of descriptor is its size
;;;1082         return tud_control_xfer(rhport, p_request, (void*) (uintptr_t) desc_qualifier, tu_desc_len(desc_qualifier));
;;;1083       }
;;;1084       // break; // unreachable
;;;1085   
;;;1086       default: return false;
;;;1087     }
;;;1088   }
0006e0  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1764|
0006e4  e1a00000          MOV      r0,r0                 ;1016
0006e8  e59f0d0c          LDR      r0,|L1.5116|
0006ec  e3500000          CMP      r0,#0                 ;1021
0006f0  1a000001          BNE      |L1.1788|
0006f4  e3a00000          MOV      r0,#0                 ;1021
0006f8  eafffff8          B        |L1.1760|
                  |L1.1788|
0006fc  ebfffffe          BL       tud_descriptor_bos_cb
000700  e1a04000          MOV      r4,r0                 ;1023
000704  e1a00000          MOV      r0,r0                 ;1024
000708  e3540000          CMP      r4,#0                 ;1024
00070c  1a000007          BNE      |L1.1840|
000710  e3a02b01          MOV      r2,#0x400             ;1024
000714  e59f1ce4          LDR      r1,|L1.5120|
000718  e24f0c03          ADR      r0,|L1.1056|
00071c  ebfffffe          BL       __2printf
000720  e1a00000          MOV      r0,r0                 ;1024
000724  e1a00000          MOV      r0,r0                 ;1024
000728  e3a00000          MOV      r0,#0                 ;1024
00072c  eaffffeb          B        |L1.1760|
                  |L1.1840|
000730  e1a00000          MOV      r0,r0                 ;1024
000734  e2840002          ADD      r0,r4,#2              ;1027
000738  e1a01000          MOV      r1,r0                 ;1027
00073c  e5d12001          LDRB     r2,[r1,#1]            ;1027
000740  e5d13000          LDRB     r3,[r1,#0]            ;1027
000744  e1836402          ORR      r6,r3,r2,LSL #8       ;1027
000748  e1a00000          MOV      r0,r0                 ;1027
00074c  e1a03006          MOV      r3,r6                 ;1029
000750  e1a02004          MOV      r2,r4                 ;1029
000754  e1a01005          MOV      r1,r5                 ;1029
000758  e1a00008          MOV      r0,r8                 ;1029
00075c  ebfffffe          BL       tud_control_xfer
000760  eaffffde          B        |L1.1760|
                  |L1.1892|
000764  e1a00000          MOV      r0,r0                 ;1033
000768  e1a00000          MOV      r0,r0                 ;1034
                  |L1.1900|
00076c  e3570002          CMP      r7,#2                 ;1038
000770  1a000003          BNE      |L1.1924|
000774  e1a00009          MOV      r0,r9                 ;1041
000778  ebfffffe          BL       tud_descriptor_configuration_cb
00077c  e1a04000          MOV      r4,r0                 ;1041
000780  ea000009          B        |L1.1964|
                  |L1.1924|
000784  e1a00000          MOV      r0,r0                 ;1046
000788  e59f0c74          LDR      r0,|L1.5124|
00078c  e3500000          CMP      r0,#0                 ;1046
000790  1a000001          BNE      |L1.1948|
000794  e3a00000          MOV      r0,#0                 ;1046
000798  eaffffd0          B        |L1.1760|
                  |L1.1948|
00079c  e1a00000          MOV      r0,r0                 ;1046
0007a0  e1a00009          MOV      r0,r9                 ;1047
0007a4  ebfffffe          BL       tud_descriptor_other_speed_configuration_cb
0007a8  e1a04000          MOV      r4,r0                 ;1047
                  |L1.1964|
0007ac  e1a00000          MOV      r0,r0                 ;1050
0007b0  e3540000          CMP      r4,#0                 ;1050
0007b4  1a000007          BNE      |L1.2008|
0007b8  e59f2c48          LDR      r2,|L1.5128|
0007bc  e59f1c3c          LDR      r1,|L1.5120|
0007c0  e24f0fea          ADR      r0,|L1.1056|
0007c4  ebfffffe          BL       __2printf
0007c8  e1a00000          MOV      r0,r0                 ;1050
0007cc  e1a00000          MOV      r0,r0                 ;1050
0007d0  e3a00000          MOV      r0,#0                 ;1050
0007d4  eaffffc1          B        |L1.1760|
                  |L1.2008|
0007d8  e1a00000          MOV      r0,r0                 ;1050
0007dc  e2840002          ADD      r0,r4,#2              ;1053
0007e0  e1a01000          MOV      r1,r0                 ;1053
0007e4  e5d12001          LDRB     r2,[r1,#1]            ;1053
0007e8  e5d13000          LDRB     r3,[r1,#0]            ;1053
0007ec  e1836402          ORR      r6,r3,r2,LSL #8       ;1053
0007f0  e1a00000          MOV      r0,r0                 ;1053
0007f4  e1a03006          MOV      r3,r6                 ;1055
0007f8  e1a02004          MOV      r2,r4                 ;1055
0007fc  e1a01005          MOV      r1,r5                 ;1055
000800  e1a00008          MOV      r0,r8                 ;1055
000804  ebfffffe          BL       tud_control_xfer
000808  eaffffb4          B        |L1.1760|
                  |L1.2060|
00080c  e1a00000          MOV      r0,r0                 ;1059
000810  e5d50005          LDRB     r0,[r5,#5]            ;1064
000814  e5d52004          LDRB     r2,[r5,#4]            ;1064
000818  e1821400          ORR      r1,r2,r0,LSL #8       ;1064
00081c  e1a00009          MOV      r0,r9                 ;1064
000820  ebfffffe          BL       tud_descriptor_string_cb
000824  e1a04000          MOV      r4,r0                 ;1064
000828  e1a00000          MOV      r0,r0                 ;1065
00082c  e3540000          CMP      r4,#0                 ;1065
000830  1a000001          BNE      |L1.2108|
000834  e3a00000          MOV      r0,#0                 ;1065
000838  eaffffa8          B        |L1.1760|
                  |L1.2108|
00083c  e1a00000          MOV      r0,r0                 ;1065
000840  e1a00000          MOV      r0,r0                 ;1068
000844  e5d40000          LDRB     r0,[r4,#0]            ;1068
000848  e1a06000          MOV      r6,r0                 ;1068
00084c  e1a03006          MOV      r3,r6                 ;1068
000850  e1a02004          MOV      r2,r4                 ;1068
000854  e1a01005          MOV      r1,r5                 ;1068
000858  e1a00008          MOV      r0,r8                 ;1068
00085c  ebfffffe          BL       tud_control_xfer
000860  eaffff9e          B        |L1.1760|
                  |L1.2148|
000864  e1a00000          MOV      r0,r0                 ;1072
000868  e1a00000          MOV      r0,r0                 ;1076
00086c  e59f0b98          LDR      r0,|L1.5132|
000870  e3500000          CMP      r0,#0                 ;1076
000874  1a000001          BNE      |L1.2176|
000878  e3a00000          MOV      r0,#0                 ;1076
00087c  eaffff97          B        |L1.1760|
                  |L1.2176|
000880  e1a00000          MOV      r0,r0                 ;1076
000884  ebfffffe          BL       tud_descriptor_device_qualifier_cb
000888  e1a04000          MOV      r4,r0                 ;1078
00088c  e1a00000          MOV      r0,r0                 ;1079
000890  e3540000          CMP      r4,#0                 ;1079
000894  1a000001          BNE      |L1.2208|
000898  e3a00000          MOV      r0,#0                 ;1079
00089c  eaffff8f          B        |L1.1760|
                  |L1.2208|
0008a0  e1a00000          MOV      r0,r0                 ;1079
0008a4  e1a00000          MOV      r0,r0                 ;1082
0008a8  e5d40000          LDRB     r0,[r4,#0]            ;1082
0008ac  e1a06000          MOV      r6,r0                 ;1082
0008b0  e1a03006          MOV      r3,r6                 ;1082
0008b4  e1a02004          MOV      r2,r4                 ;1082
0008b8  e1a01005          MOV      r1,r5                 ;1082
0008bc  e1a00008          MOV      r0,r8                 ;1082
0008c0  ebfffffe          BL       tud_control_xfer
0008c4  eaffff85          B        |L1.1760|
                  |L1.2248|
0008c8  e1a00000          MOV      r0,r0                 ;1086
0008cc  e3a00000          MOV      r0,#0                 ;1086
0008d0  eaffff82          B        |L1.1760|
;;;1089   
                          ENDP

                  process_set_config PROC
;;;888    // This function parse configuration descriptor & open drivers accordingly
;;;889    static bool process_set_config(uint8_t rhport, uint8_t cfg_num)
0008d4  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;890    {
0008d8  e24dd00c          SUB      sp,sp,#0xc
;;;891      // index is cfg_num-1
;;;892      tusb_desc_configuration_t const * desc_cfg = (tusb_desc_configuration_t const *) tud_descriptor_configuration_cb(cfg_num-1);
0008dc  e59d1010          LDR      r1,[sp,#0x10]
0008e0  e2411001          SUB      r1,r1,#1
0008e4  e20100ff          AND      r0,r1,#0xff
0008e8  ebfffffe          BL       tud_descriptor_configuration_cb
0008ec  e1a05000          MOV      r5,r0
;;;893      TU_ASSERT(desc_cfg != NULL && desc_cfg->bDescriptorType == TUSB_DESC_CONFIGURATION);
0008f0  e1a00000          MOV      r0,r0
0008f4  e3550000          CMP      r5,#0
0008f8  0a000002          BEQ      |L1.2312|
0008fc  e5d50001          LDRB     r0,[r5,#1]
000900  e3500002          CMP      r0,#2
000904  0a000008          BEQ      |L1.2348|
                  |L1.2312|
000908  e59f2b00          LDR      r2,|L1.5136|
00090c  e59f1b00          LDR      r1,|L1.5140|
000910  e59f0b00          LDR      r0,|L1.5144|
000914  ebfffffe          BL       __2printf
000918  e1a00000          MOV      r0,r0
00091c  e1a00000          MOV      r0,r0
000920  e3a00000          MOV      r0,#0
                  |L1.2340|
000924  e28dd014          ADD      sp,sp,#0x14
;;;894    
;;;895      // Parse configuration descriptor
;;;896      _usbd_dev.remote_wakeup_support = (desc_cfg->bmAttributes & TUSB_DESC_CONFIG_ATT_REMOTE_WAKEUP) ? 1u : 0u;
;;;897      _usbd_dev.self_powered          = (desc_cfg->bmAttributes & TUSB_DESC_CONFIG_ATT_SELF_POWERED ) ? 1u : 0u;
;;;898    
;;;899      // Parse interface descriptor
;;;900      uint8_t const * p_desc   = ((uint8_t const*) desc_cfg) + sizeof(tusb_desc_configuration_t);
;;;901      uint8_t const * desc_end = ((uint8_t const*) desc_cfg) + tu_le16toh(desc_cfg->wTotalLength);
;;;902    
;;;903      while( p_desc < desc_end )
;;;904      {
;;;905        uint8_t assoc_itf_count = 1;
;;;906    
;;;907        // Class will always starts with Interface Association (if any) and then Interface descriptor
;;;908        if ( TUSB_DESC_INTERFACE_ASSOCIATION == tu_desc_type(p_desc) )
;;;909        {
;;;910          tusb_desc_interface_assoc_t const * desc_iad = (tusb_desc_interface_assoc_t const *) p_desc;
;;;911          assoc_itf_count = desc_iad->bInterfaceCount;
;;;912    
;;;913          p_desc = tu_desc_next(p_desc); // next to Interface
;;;914    
;;;915          // IAD's first interface number and class should match with opened interface
;;;916          //TU_ASSERT(desc_iad->bFirstInterface == desc_itf->bInterfaceNumber &&
;;;917          //          desc_iad->bFunctionClass  == desc_itf->bInterfaceClass);
;;;918        }
;;;919    
;;;920        TU_ASSERT( TUSB_DESC_INTERFACE == tu_desc_type(p_desc) );
;;;921        tusb_desc_interface_t const * desc_itf = (tusb_desc_interface_t const*) p_desc;
;;;922    
;;;923        // Find driver for this interface
;;;924        uint16_t const remaining_len = (uint16_t) (desc_end-p_desc);
;;;925        uint8_t drv_id;
;;;926        for (drv_id = 0; drv_id < TOTAL_DRIVER_COUNT; drv_id++)
;;;927        {
;;;928          usbd_class_driver_t const *driver = get_driver(drv_id);
;;;929          TU_ASSERT(driver);
;;;930          uint16_t const drv_len = driver->open(rhport, desc_itf, remaining_len);
;;;931    
;;;932          if ( (sizeof(tusb_desc_interface_t) <= drv_len)  && (drv_len <= remaining_len) )
;;;933          {
;;;934            // Open successfully
;;;935            TU_LOG(USBD_DBG, "  %s opened\r\n", driver->name);
;;;936    
;;;937            // Some drivers use 2 or more interfaces but may not have IAD e.g MIDI (always) or
;;;938            // BTH (even CDC) with class in device descriptor (single interface)
;;;939            if ( assoc_itf_count == 1)
;;;940            {
;;;941              #if CFG_TUD_CDC
;;;942              if ( driver->open == cdcd_open ) assoc_itf_count = 2;
;;;943              #endif
;;;944    
;;;945              #if CFG_TUD_MIDI
;;;946              if ( driver->open == midid_open ) assoc_itf_count = 2;
;;;947              #endif
;;;948    
;;;949              #if CFG_TUD_BTH && CFG_TUD_BTH_ISO_ALT_COUNT
;;;950              if ( driver->open == btd_open ) assoc_itf_count = 2;
;;;951              #endif
;;;952            }
;;;953    
;;;954            // bind (associated) interfaces to found driver
;;;955            for(uint8_t i=0; i<assoc_itf_count; i++)
;;;956            {
;;;957              uint8_t const itf_num = desc_itf->bInterfaceNumber+i;
;;;958    
;;;959              // Interface number must not be used already
;;;960              TU_ASSERT(DRVID_INVALID == _usbd_dev.itf2drv[itf_num]);
;;;961              _usbd_dev.itf2drv[itf_num] = drv_id;
;;;962            }
;;;963    
;;;964            // bind all endpoints to found driver
;;;965            tu_edpt_bind_driver(_usbd_dev.ep2drv, desc_itf, drv_len, drv_id);
;;;966    
;;;967            // next Interface
;;;968            p_desc += drv_len;
;;;969    
;;;970            break; // exit driver find loop
;;;971          }
;;;972        }
;;;973    
;;;974        // Failed if there is no supported drivers
;;;975        TU_ASSERT(drv_id < TOTAL_DRIVER_COUNT);
;;;976      }
;;;977    
;;;978      // invoke callback
;;;979      if (tud_mount_cb) tud_mount_cb();
;;;980    
;;;981      return true;
;;;982    }
000928  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.2348|
00092c  e1a00000          MOV      r0,r0                 ;893
000930  e51f0538          LDR      r0,|L1.1024|
000934  e5d00000          LDRB     r0,[r0,#0]            ;896  ; _usbd_dev
000938  e3c00010          BIC      r0,r0,#0x10           ;896
00093c  e5d51007          LDRB     r1,[r5,#7]            ;896
000940  e2011020          AND      r1,r1,#0x20           ;896
000944  e1a012a1          LSR      r1,r1,#5              ;896
000948  e3a02010          MOV      r2,#0x10              ;896
00094c  e0021201          AND      r1,r2,r1,LSL #4       ;896
000950  e1800001          ORR      r0,r0,r1              ;896
000954  e51f155c          LDR      r1,|L1.1024|
000958  e5c10000          STRB     r0,[r1,#0]            ;896  ; _usbd_dev
00095c  e2810000          ADD      r0,r1,#0              ;897
000960  e5d00000          LDRB     r0,[r0,#0]            ;897  ; _usbd_dev
000964  e3c00020          BIC      r0,r0,#0x20           ;897
000968  e5d51007          LDRB     r1,[r5,#7]            ;897
00096c  e2011040          AND      r1,r1,#0x40           ;897
000970  e1a01321          LSR      r1,r1,#6              ;897
000974  e3a02020          MOV      r2,#0x20              ;897
000978  e0021281          AND      r1,r2,r1,LSL #5       ;897
00097c  e1800001          ORR      r0,r0,r1              ;897
000980  e51f1588          LDR      r1,|L1.1024|
000984  e5c10000          STRB     r0,[r1,#0]            ;897  ; _usbd_dev
000988  e2854009          ADD      r4,r5,#9              ;900
00098c  e5d50003          LDRB     r0,[r5,#3]            ;901
000990  e5d51002          LDRB     r1,[r5,#2]            ;901
000994  e1810400          ORR      r0,r1,r0,LSL #8       ;901
000998  e0809005          ADD      r9,r0,r5              ;901
00099c  ea000079          B        |L1.2952|
                  |L1.2464|
0009a0  e3a00001          MOV      r0,#1                 ;905
0009a4  e58d0008          STR      r0,[sp,#8]            ;905
0009a8  e1a00000          MOV      r0,r0                 ;908
0009ac  e5d40001          LDRB     r0,[r4,#1]            ;908
0009b0  e350000b          CMP      r0,#0xb               ;908
0009b4  1a000008          BNE      |L1.2524|
0009b8  e1a00004          MOV      r0,r4                 ;910
0009bc  e5d01003          LDRB     r1,[r0,#3]            ;911
0009c0  e58d1008          STR      r1,[sp,#8]            ;911
0009c4  e1a01004          MOV      r1,r4                 ;913
0009c8  e1a02001          MOV      r2,r1                 ;913
0009cc  e5d23000          LDRB     r3,[r2,#0]            ;913
0009d0  e0833002          ADD      r3,r3,r2              ;913
0009d4  e1a04003          MOV      r4,r3                 ;913
0009d8  e1a00000          MOV      r0,r0                 ;918
                  |L1.2524|
0009dc  e1a00000          MOV      r0,r0                 ;920
0009e0  e1a00000          MOV      r0,r0                 ;920
0009e4  e5d40001          LDRB     r0,[r4,#1]            ;920
0009e8  e3500004          CMP      r0,#4                 ;920
0009ec  0a000007          BEQ      |L1.2576|
0009f0  e3a02fe6          MOV      r2,#0x398             ;920
0009f4  e59f1a18          LDR      r1,|L1.5140|
0009f8  e59f0a18          LDR      r0,|L1.5144|
0009fc  ebfffffe          BL       __2printf
000a00  e1a00000          MOV      r0,r0                 ;920
000a04  e1a00000          MOV      r0,r0                 ;920
000a08  e3a00000          MOV      r0,#0                 ;920
000a0c  eaffffc4          B        |L1.2340|
                  |L1.2576|
000a10  e1a00000          MOV      r0,r0                 ;920
000a14  e1a08004          MOV      r8,r4                 ;921
000a18  e0490004          SUB      r0,r9,r4              ;924
000a1c  e1a0a800          LSL      r10,r0,#16            ;924
000a20  e1a0a82a          LSR      r10,r10,#16           ;924
000a24  e3a06000          MOV      r6,#0                 ;926
000a28  ea000040          B        |L1.2864|
                  |L1.2604|
000a2c  e1a00006          MOV      r0,r6                 ;928
000a30  ebfffffe          BL       get_driver
000a34  e58d0004          STR      r0,[sp,#4]            ;928
000a38  e1a00000          MOV      r0,r0                 ;929
000a3c  e59d0004          LDR      r0,[sp,#4]            ;929
000a40  e3500000          CMP      r0,#0                 ;929
000a44  1a000007          BNE      |L1.2664|
000a48  e59f29cc          LDR      r2,|L1.5148|
000a4c  e59f19c0          LDR      r1,|L1.5140|
000a50  e59f09c0          LDR      r0,|L1.5144|
000a54  ebfffffe          BL       __2printf
000a58  e1a00000          MOV      r0,r0                 ;929
000a5c  e1a00000          MOV      r0,r0                 ;929
000a60  e3a00000          MOV      r0,#0                 ;929
000a64  eaffffae          B        |L1.2340|
                  |L1.2664|
000a68  e1a00000          MOV      r0,r0                 ;929
000a6c  e59d0004          LDR      r0,[sp,#4]            ;930
000a70  e1a0200a          MOV      r2,r10                ;930
000a74  e1a01008          MOV      r1,r8                 ;930
000a78  e5903008          LDR      r3,[r0,#8]            ;930
000a7c  e59d000c          LDR      r0,[sp,#0xc]          ;930
000a80  e12fff33          BLX      r3                    ;930
000a84  e1a07000          MOV      r7,r0                 ;930
000a88  e3570009          CMP      r7,#9                 ;932
000a8c  3a000025          BCC      |L1.2856|
000a90  e157000a          CMP      r7,r10                ;932
000a94  ca000023          BGT      |L1.2856|
000a98  e3a0b000          MOV      r11,#0                ;955
000a9c  ea000017          B        |L1.2816|
                  |L1.2720|
000aa0  e5d80002          LDRB     r0,[r8,#2]            ;957
000aa4  e080000b          ADD      r0,r0,r11             ;957
000aa8  e20000ff          AND      r0,r0,#0xff           ;957
000aac  e58d0000          STR      r0,[sp,#0]            ;957
000ab0  e1a00000          MOV      r0,r0                 ;960
000ab4  e51f1668          LDR      r1,|L1.1108|
000ab8  e59d0000          LDR      r0,[sp,#0]            ;960
000abc  e7d10000          LDRB     r0,[r1,r0]            ;960
000ac0  e35000ff          CMP      r0,#0xff              ;960
000ac4  0a000007          BEQ      |L1.2792|
000ac8  e3a02d0f          MOV      r2,#0x3c0             ;960
000acc  e59f1940          LDR      r1,|L1.5140|
000ad0  e59f0940          LDR      r0,|L1.5144|
000ad4  ebfffffe          BL       __2printf
000ad8  e1a00000          MOV      r0,r0                 ;960
000adc  e1a00000          MOV      r0,r0                 ;960
000ae0  e3a00000          MOV      r0,#0                 ;960
000ae4  eaffff8e          B        |L1.2340|
                  |L1.2792|
000ae8  e1a00000          MOV      r0,r0                 ;960
000aec  e51f16a0          LDR      r1,|L1.1108|
000af0  e59d0000          LDR      r0,[sp,#0]            ;961
000af4  e7c16000          STRB     r6,[r1,r0]            ;961
000af8  e28b0001          ADD      r0,r11,#1             ;955
000afc  e200b0ff          AND      r11,r0,#0xff          ;955
                  |L1.2816|
000b00  e59d0008          LDR      r0,[sp,#8]            ;955
000b04  e15b0000          CMP      r11,r0                ;955
000b08  baffffe4          BLT      |L1.2720|
000b0c  e1a03006          MOV      r3,r6                 ;965
000b10  e1a02007          MOV      r2,r7                 ;965
000b14  e1a01008          MOV      r1,r8                 ;965
000b18  e51f06c8          LDR      r0,|L1.1112|
000b1c  ebfffffe          BL       tu_edpt_bind_driver
000b20  e0844007          ADD      r4,r4,r7              ;968
000b24  ea000006          B        |L1.2884|
                  |L1.2856|
000b28  e2860001          ADD      r0,r6,#1              ;926
000b2c  e20060ff          AND      r6,r0,#0xff           ;926
                  |L1.2864|
000b30  e51f0744          LDR      r0,|L1.1012|
000b34  e5d00000          LDRB     r0,[r0,#0]            ;926  ; _app_driver_count
000b38  e2800001          ADD      r0,r0,#1              ;926
000b3c  e1560000          CMP      r6,r0                 ;926
000b40  baffffb9          BLT      |L1.2604|
                  |L1.2884|
000b44  e1a00000          MOV      r0,r0                 ;970
000b48  e1a00000          MOV      r0,r0                 ;975
000b4c  e51f0760          LDR      r0,|L1.1012|
000b50  e5d00000          LDRB     r0,[r0,#0]            ;975  ; _app_driver_count
000b54  e2800001          ADD      r0,r0,#1              ;975
000b58  e1560000          CMP      r6,r0                 ;975
000b5c  ba000007          BLT      |L1.2944|
000b60  e59f28b8          LDR      r2,|L1.5152|
000b64  e59f18a8          LDR      r1,|L1.5140|
000b68  e59f08a8          LDR      r0,|L1.5144|
000b6c  ebfffffe          BL       __2printf
000b70  e1a00000          MOV      r0,r0                 ;975
000b74  e1a00000          MOV      r0,r0                 ;975
000b78  e3a00000          MOV      r0,#0                 ;975
000b7c  eaffff68          B        |L1.2340|
                  |L1.2944|
000b80  e1a00000          MOV      r0,r0                 ;975
000b84  e1a00000          MOV      r0,r0                 ;976
                  |L1.2952|
000b88  e1540009          CMP      r4,r9                 ;903
000b8c  3affff83          BCC      |L1.2464|
000b90  e59f088c          LDR      r0,|L1.5156|
000b94  e3500000          CMP      r0,#0                 ;979
000b98  0a000000          BEQ      |L1.2976|
000b9c  ebfffffe          BL       tud_mount_cb
                  |L1.2976|
000ba0  e3a00001          MOV      r0,#1                 ;981
000ba4  eaffff5e          B        |L1.2340|
;;;983    
                          ENDP

                  process_control_request PROC
;;;636    // return false will cause its caller to stall control endpoint
;;;637    static bool process_control_request(uint8_t rhport, tusb_control_request_t const * p_request)
000ba8  e92d43f8          PUSH     {r3-r9,lr}
;;;638    {
000bac  e1a07000          MOV      r7,r0
000bb0  e1a04001          MOV      r4,r1
;;;639      usbd_control_set_complete_callback(NULL);
000bb4  e3a00000          MOV      r0,#0
000bb8  ebfffffe          BL       usbd_control_set_complete_callback
;;;640    
;;;641      TU_ASSERT(p_request->bmRequestType_bit.type < TUSB_REQ_TYPE_INVALID);
000bbc  e1a00000          MOV      r0,r0
000bc0  e5d40000          LDRB     r0,[r4,#0]
000bc4  e1a00c80          LSL      r0,r0,#25
000bc8  e3a01003          MOV      r1,#3
000bcc  e1510f20          CMP      r1,r0,LSR #30
000bd0  ca000007          BGT      |L1.3060|
000bd4  e59f284c          LDR      r2,|L1.5160|
000bd8  e59f184c          LDR      r1,|L1.5164|
000bdc  e59f0834          LDR      r0,|L1.5144|
000be0  ebfffffe          BL       __2printf
000be4  e1a00000          MOV      r0,r0
000be8  e1a00000          MOV      r0,r0
000bec  e3a00000          MOV      r0,#0
                  |L1.3056|
;;;642    
;;;643      // Vendor request
;;;644      if ( p_request->bmRequestType_bit.type == TUSB_REQ_TYPE_VENDOR )
;;;645      {
;;;646        TU_VERIFY(tud_vendor_control_xfer_cb);
;;;647    
;;;648        usbd_control_set_complete_callback(tud_vendor_control_xfer_cb);
;;;649        return tud_vendor_control_xfer_cb(rhport, CONTROL_STAGE_SETUP, p_request);
;;;650      }
;;;651    
;;;652    #if CFG_TUSB_DEBUG >= 2
;;;653      if (TUSB_REQ_TYPE_STANDARD == p_request->bmRequestType_bit.type && p_request->bRequest <= TUSB_REQ_SYNCH_FRAME)
;;;654      {
;;;655        TU_LOG(USBD_DBG, "  %s", tu_str_std_request[p_request->bRequest]);
;;;656        if (TUSB_REQ_GET_DESCRIPTOR != p_request->bRequest) TU_LOG(USBD_DBG, "\r\n");
;;;657      }
;;;658    #endif
;;;659    
;;;660      switch ( p_request->bmRequestType_bit.recipient )
;;;661      {
;;;662        //------------- Device Requests e.g in enumeration -------------//
;;;663        case TUSB_REQ_RCPT_DEVICE:
;;;664          if ( TUSB_REQ_TYPE_CLASS == p_request->bmRequestType_bit.type )
;;;665          {
;;;666            uint8_t const itf = tu_u16_low(p_request->wIndex);
;;;667            TU_VERIFY(itf < TU_ARRAY_SIZE(_usbd_dev.itf2drv));
;;;668    
;;;669            usbd_class_driver_t const * driver = get_driver(_usbd_dev.itf2drv[itf]);
;;;670            TU_VERIFY(driver);
;;;671    
;;;672            // forward to class driver: "non-STD request to Interface"
;;;673            return invoke_class_control(rhport, driver, p_request);
;;;674          }
;;;675    
;;;676          if ( TUSB_REQ_TYPE_STANDARD != p_request->bmRequestType_bit.type )
;;;677          {
;;;678            // Non standard request is not supported
;;;679            TU_BREAKPOINT();
;;;680            return false;
;;;681          }
;;;682    
;;;683          switch ( p_request->bRequest )
;;;684          {
;;;685            case TUSB_REQ_SET_ADDRESS:
;;;686              // Depending on mcu, status phase could be sent either before or after changing device address,
;;;687              // or even require stack to not response with status at all
;;;688              // Therefore DCD must take full responsibility to response and include zlp status packet if needed.
;;;689              usbd_control_set_request(p_request); // set request since DCD has no access to tud_control_status() API
;;;690              dcd_set_address(rhport, (uint8_t) p_request->wValue);
;;;691              // skip tud_control_status()
;;;692              _usbd_dev.addressed = 1;
;;;693            break;
;;;694    
;;;695            case TUSB_REQ_GET_CONFIGURATION:
;;;696            {
;;;697              uint8_t cfg_num = _usbd_dev.cfg_num;
;;;698              tud_control_xfer(rhport, p_request, &cfg_num, 1);
;;;699            }
;;;700            break;
;;;701    
;;;702            case TUSB_REQ_SET_CONFIGURATION:
;;;703            {
;;;704              uint8_t const cfg_num = (uint8_t) p_request->wValue;
;;;705    
;;;706              // Only process if new configure is different
;;;707              if (_usbd_dev.cfg_num != cfg_num)
;;;708              {
;;;709                if ( _usbd_dev.cfg_num )
;;;710                {
;;;711                  // already configured: need to clear all endpoints and driver first
;;;712                  TU_LOG(USBD_DBG, "  Clear current Configuration (%u) before switching\r\n", _usbd_dev.cfg_num);
;;;713    
;;;714                  // close all non-control endpoints, cancel all pending transfers if any
;;;715                  dcd_edpt_close_all(rhport);
;;;716    
;;;717                  // close all drivers and current configured state except bus speed
;;;718                  uint8_t const speed = _usbd_dev.speed;
;;;719                  configuration_reset(rhport);
;;;720    
;;;721                  _usbd_dev.speed = speed; // restore speed
;;;722                }
;;;723    
;;;724                // switch to new configuration if not zero
;;;725                if ( cfg_num ) TU_ASSERT( process_set_config(rhport, cfg_num) );
;;;726              }
;;;727    
;;;728              _usbd_dev.cfg_num = cfg_num;
;;;729              tud_control_status(rhport, p_request);
;;;730            }
;;;731            break;
;;;732    
;;;733            case TUSB_REQ_GET_DESCRIPTOR:
;;;734              TU_VERIFY( process_get_descriptor(rhport, p_request) );
;;;735            break;
;;;736    
;;;737            case TUSB_REQ_SET_FEATURE:
;;;738              // Only support remote wakeup for device feature
;;;739              TU_VERIFY(TUSB_REQ_FEATURE_REMOTE_WAKEUP == p_request->wValue);
;;;740    
;;;741              TU_LOG(USBD_DBG, "    Enable Remote Wakeup\r\n");
;;;742    
;;;743              // Host may enable remote wake up before suspending especially HID device
;;;744              _usbd_dev.remote_wakeup_en = true;
;;;745              tud_control_status(rhport, p_request);
;;;746            break;
;;;747    
;;;748            case TUSB_REQ_CLEAR_FEATURE:
;;;749              // Only support remote wakeup for device feature
;;;750              TU_VERIFY(TUSB_REQ_FEATURE_REMOTE_WAKEUP == p_request->wValue);
;;;751    
;;;752              TU_LOG(USBD_DBG, "    Disable Remote Wakeup\r\n");
;;;753    
;;;754              // Host may disable remote wake up after resuming
;;;755              _usbd_dev.remote_wakeup_en = false;
;;;756              tud_control_status(rhport, p_request);
;;;757            break;
;;;758    
;;;759            case TUSB_REQ_GET_STATUS:
;;;760            {
;;;761              // Device status bit mask
;;;762              // - Bit 0: Self Powered
;;;763              // - Bit 1: Remote Wakeup enabled
;;;764              uint16_t status = (uint16_t) ((_usbd_dev.self_powered ? 1u : 0u) | (_usbd_dev.remote_wakeup_en ? 2u : 0u));
;;;765              tud_control_xfer(rhport, p_request, &status, 2);
;;;766            }
;;;767            break;
;;;768    
;;;769            // Unknown/Unsupported request
;;;770            default: TU_BREAKPOINT(); return false;
;;;771          }
;;;772        break;
;;;773    
;;;774        //------------- Class/Interface Specific Request -------------//
;;;775        case TUSB_REQ_RCPT_INTERFACE:
;;;776        {
;;;777          uint8_t const itf = tu_u16_low(p_request->wIndex);
;;;778          TU_VERIFY(itf < TU_ARRAY_SIZE(_usbd_dev.itf2drv));
;;;779    
;;;780          usbd_class_driver_t const * driver = get_driver(_usbd_dev.itf2drv[itf]);
;;;781          TU_VERIFY(driver);
;;;782    
;;;783          // all requests to Interface (STD or Class) is forwarded to class driver.
;;;784          // notable requests are: GET HID REPORT DESCRIPTOR, SET_INTERFACE, GET_INTERFACE
;;;785          if ( !invoke_class_control(rhport, driver, p_request) )
;;;786          {
;;;787            // For GET_INTERFACE and SET_INTERFACE, it is mandatory to respond even if the class
;;;788            // driver doesn't use alternate settings or implement this
;;;789            TU_VERIFY(TUSB_REQ_TYPE_STANDARD == p_request->bmRequestType_bit.type);
;;;790    
;;;791            switch(p_request->bRequest)
;;;792            {
;;;793              case TUSB_REQ_GET_INTERFACE:
;;;794              case TUSB_REQ_SET_INTERFACE:
;;;795                // Clear complete callback if driver set since it can also stall the request.
;;;796                usbd_control_set_complete_callback(NULL);
;;;797    
;;;798                if (TUSB_REQ_GET_INTERFACE == p_request->bRequest)
;;;799                {
;;;800                  uint8_t alternate = 0;
;;;801                  tud_control_xfer(rhport, p_request, &alternate, 1);
;;;802                }else
;;;803                {
;;;804                  tud_control_status(rhport, p_request);
;;;805                }
;;;806              break;
;;;807    
;;;808              default: return false;
;;;809            }
;;;810          }
;;;811        }
;;;812        break;
;;;813    
;;;814        //------------- Endpoint Request -------------//
;;;815        case TUSB_REQ_RCPT_ENDPOINT:
;;;816        {
;;;817          uint8_t const ep_addr = tu_u16_low(p_request->wIndex);
;;;818          uint8_t const ep_num  = tu_edpt_number(ep_addr);
;;;819          uint8_t const ep_dir  = tu_edpt_dir(ep_addr);
;;;820    
;;;821          TU_ASSERT(ep_num < TU_ARRAY_SIZE(_usbd_dev.ep2drv) );
;;;822    
;;;823          usbd_class_driver_t const * driver = get_driver(_usbd_dev.ep2drv[ep_num][ep_dir]);
;;;824    
;;;825          if ( TUSB_REQ_TYPE_STANDARD != p_request->bmRequestType_bit.type )
;;;826          {
;;;827            // Forward class request to its driver
;;;828            TU_VERIFY(driver);
;;;829            return invoke_class_control(rhport, driver, p_request);
;;;830          }
;;;831          else
;;;832          {
;;;833            // Handle STD request to endpoint
;;;834            switch ( p_request->bRequest )
;;;835            {
;;;836              case TUSB_REQ_GET_STATUS:
;;;837              {
;;;838                uint16_t status = usbd_edpt_stalled(rhport, ep_addr) ? 0x0001 : 0x0000;
;;;839                tud_control_xfer(rhport, p_request, &status, 2);
;;;840              }
;;;841              break;
;;;842    
;;;843              case TUSB_REQ_CLEAR_FEATURE:
;;;844              case TUSB_REQ_SET_FEATURE:
;;;845              {
;;;846                if ( TUSB_REQ_FEATURE_EDPT_HALT == p_request->wValue )
;;;847                {
;;;848                  if ( TUSB_REQ_CLEAR_FEATURE ==  p_request->bRequest )
;;;849                  {
;;;850                    usbd_edpt_clear_stall(rhport, ep_addr);
;;;851                  }else
;;;852                  {
;;;853                    usbd_edpt_stall(rhport, ep_addr);
;;;854                  }
;;;855                }
;;;856    
;;;857                if (driver)
;;;858                {
;;;859                  // Some classes such as USBTMC needs to clear/re-init its buffer when receiving CLEAR_FEATURE request
;;;860                  // We will also forward std request targeted endpoint to class drivers as well
;;;861    
;;;862                  // STD request must always be ACKed regardless of driver returned value
;;;863                  // Also clear complete callback if driver set since it can also stall the request.
;;;864                  (void) invoke_class_control(rhport, driver, p_request);
;;;865                  usbd_control_set_complete_callback(NULL);
;;;866    
;;;867                  // skip ZLP status if driver already did that
;;;868                  if ( !_usbd_dev.ep_status[0][TUSB_DIR_IN].busy ) tud_control_status(rhport, p_request);
;;;869                }
;;;870              }
;;;871              break;
;;;872    
;;;873              // Unknown/Unsupported request
;;;874              default: TU_BREAKPOINT(); return false;
;;;875            }
;;;876          }
;;;877        }
;;;878        break;
;;;879    
;;;880        // Unknown recipient
;;;881        default: TU_BREAKPOINT(); return false;
;;;882      }
;;;883    
;;;884      return true;
;;;885    }
000bf0  e8bd83f8          POP      {r3-r9,pc}
                  |L1.3060|
000bf4  e1a00000          MOV      r0,r0                 ;641
000bf8  e5d40000          LDRB     r0,[r4,#0]            ;644
000bfc  e2000060          AND      r0,r0,#0x60           ;644
000c00  e3500040          CMP      r0,#0x40              ;644
000c04  1a00000d          BNE      |L1.3136|
000c08  e1a00000          MOV      r0,r0                 ;646
000c0c  e59f081c          LDR      r0,|L1.5168|
000c10  e3500000          CMP      r0,#0                 ;646
000c14  1a000001          BNE      |L1.3104|
000c18  e3a00000          MOV      r0,#0                 ;646
000c1c  eafffff3          B        |L1.3056|
                  |L1.3104|
000c20  e1a00000          MOV      r0,r0                 ;646
000c24  e59f0804          LDR      r0,|L1.5168|
000c28  ebfffffe          BL       usbd_control_set_complete_callback
000c2c  e1a02004          MOV      r2,r4                 ;649
000c30  e3a01001          MOV      r1,#1                 ;649
000c34  e1a00007          MOV      r0,r7                 ;649
000c38  ebfffffe          BL       tud_vendor_control_xfer_cb
000c3c  eaffffeb          B        |L1.3056|
                  |L1.3136|
000c40  e5d40000          LDRB     r0,[r4,#0]            ;660
000c44  e200001f          AND      r0,r0,#0x1f           ;660
000c48  e3500000          CMP      r0,#0                 ;660
000c4c  0a000004          BEQ      |L1.3172|
000c50  e3500001          CMP      r0,#1                 ;660
000c54  0a0000cc          BEQ      |L1.3980|
000c58  e3500002          CMP      r0,#2                 ;660
000c5c  1a000177          BNE      |L1.4672|
000c60  ea00010c          B        |L1.4248|
                  |L1.3172|
000c64  e1a00000          MOV      r0,r0                 ;663
000c68  e5d40000          LDRB     r0,[r4,#0]            ;664
000c6c  e2000060          AND      r0,r0,#0x60           ;664
000c70  e3500020          CMP      r0,#0x20              ;664
000c74  1a000019          BNE      |L1.3296|
000c78  e5d41005          LDRB     r1,[r4,#5]            ;666
000c7c  e5d42004          LDRB     r2,[r4,#4]            ;666
000c80  e1820401          ORR      r0,r2,r1,LSL #8       ;666
000c84  e20010ff          AND      r1,r0,#0xff           ;666
000c88  e1a06001          MOV      r6,r1                 ;666
000c8c  e1a00000          MOV      r0,r0                 ;667
000c90  e3560010          CMP      r6,#0x10              ;667
000c94  3a000001          BCC      |L1.3232|
000c98  e3a00000          MOV      r0,#0                 ;667
000c9c  eaffffd3          B        |L1.3056|
                  |L1.3232|
000ca0  e1a00000          MOV      r0,r0                 ;667
000ca4  e51f1858          LDR      r1,|L1.1108|
000ca8  e7d10006          LDRB     r0,[r1,r6]            ;669
000cac  ebfffffe          BL       get_driver
000cb0  e1a05000          MOV      r5,r0                 ;669
000cb4  e1a00000          MOV      r0,r0                 ;670
000cb8  e3550000          CMP      r5,#0                 ;670
000cbc  1a000001          BNE      |L1.3272|
000cc0  e3a00000          MOV      r0,#0                 ;670
000cc4  eaffffc9          B        |L1.3056|
                  |L1.3272|
000cc8  e1a00000          MOV      r0,r0                 ;670
000ccc  e1a02004          MOV      r2,r4                 ;673
000cd0  e1a01005          MOV      r1,r5                 ;673
000cd4  e1a00007          MOV      r0,r7                 ;673
000cd8  ebfffffe          BL       invoke_class_control
000cdc  eaffffc3          B        |L1.3056|
                  |L1.3296|
000ce0  e1a00000          MOV      r0,r0                 ;674
000ce4  e5d40000          LDRB     r0,[r4,#0]            ;676
000ce8  e1a00c80          LSL      r0,r0,#25             ;676
000cec  e1a00f20          LSR      r0,r0,#30             ;676
000cf0  e3500000          CMP      r0,#0                 ;676
000cf4  0a000003          BEQ      |L1.3336|
000cf8  e1a00000          MOV      r0,r0                 ;679
000cfc  e1a00000          MOV      r0,r0                 ;679
000d00  e3a00000          MOV      r0,#0                 ;680
000d04  eaffffb9          B        |L1.3056|
                  |L1.3336|
000d08  e5d40001          LDRB     r0,[r4,#1]            ;683
000d0c  e350000a          CMP      r0,#0xa               ;683
000d10  308ff100          ADDCC    pc,pc,r0,LSL #2       ;683
000d14  ea000095          B        |L1.3952|
000d18  ea00007f          B        |L1.3868|
000d1c  ea00006b          B        |L1.3792|
000d20  ea000092          B        |L1.3952|
000d24  ea000056          B        |L1.3716|
000d28  ea000090          B        |L1.3952|
000d2c  ea000003          B        |L1.3392|
000d30  ea000048          B        |L1.3672|
000d34  ea00008d          B        |L1.3952|
000d38  ea00000f          B        |L1.3452|
000d3c  ea000018          B        |L1.3492|
                  |L1.3392|
000d40  e1a00000          MOV      r0,r0                 ;685
000d44  e1a00004          MOV      r0,r4                 ;689
000d48  ebfffffe          BL       usbd_control_set_request
000d4c  e5d40003          LDRB     r0,[r4,#3]            ;690
000d50  e5d42002          LDRB     r2,[r4,#2]            ;690
000d54  e1820400          ORR      r0,r2,r0,LSL #8       ;690
000d58  e20010ff          AND      r1,r0,#0xff           ;690
000d5c  e1a00007          MOV      r0,r7                 ;690
000d60  ebfffffe          BL       dcd_set_address
000d64  e51f096c          LDR      r0,|L1.1024|
000d68  e5d00000          LDRB     r0,[r0,#0]            ;692  ; _usbd_dev
000d6c  e3800002          ORR      r0,r0,#2              ;692
000d70  e51f1978          LDR      r1,|L1.1024|
000d74  e5c10000          STRB     r0,[r1,#0]            ;692  ; _usbd_dev
000d78  ea000081          B        |L1.3972|
                  |L1.3452|
000d7c  e1a00000          MOV      r0,r0                 ;695
000d80  e51f0988          LDR      r0,|L1.1024|
000d84  e5d00001          LDRB     r0,[r0,#1]            ;697  ; _usbd_dev
000d88  e58d0000          STR      r0,[sp,#0]            ;697
000d8c  e3a03001          MOV      r3,#1                 ;698
000d90  e1a0200d          MOV      r2,sp                 ;698
000d94  e1a01004          MOV      r1,r4                 ;698
000d98  e1a00007          MOV      r0,r7                 ;698
000d9c  ebfffffe          BL       tud_control_xfer
000da0  ea000077          B        |L1.3972|
                  |L1.3492|
000da4  e1a00000          MOV      r0,r0                 ;702
000da8  e5d40003          LDRB     r0,[r4,#3]            ;704
000dac  e5d41002          LDRB     r1,[r4,#2]            ;704
000db0  e1810400          ORR      r0,r1,r0,LSL #8       ;704
000db4  e20050ff          AND      r5,r0,#0xff           ;704
000db8  e51f09c0          LDR      r0,|L1.1024|
000dbc  e5d00001          LDRB     r0,[r0,#1]            ;707  ; _usbd_dev
000dc0  e1500005          CMP      r0,r5                 ;707
000dc4  0a00001d          BEQ      |L1.3648|
000dc8  e51f09d0          LDR      r0,|L1.1024|
000dcc  e5d00001          LDRB     r0,[r0,#1]            ;709  ; _usbd_dev
000dd0  e3500000          CMP      r0,#0                 ;709
000dd4  0a000008          BEQ      |L1.3580|
000dd8  e1a00007          MOV      r0,r7                 ;715
000ddc  ebfffffe          BL       dcd_edpt_close_all
000de0  e51f09e8          LDR      r0,|L1.1024|
000de4  e5d06002          LDRB     r6,[r0,#2]            ;718  ; _usbd_dev
000de8  e1a00007          MOV      r0,r7                 ;719
000dec  ebfffffe          BL       configuration_reset
000df0  e51f09f8          LDR      r0,|L1.1024|
000df4  e5c06002          STRB     r6,[r0,#2]            ;721  ; _usbd_dev
000df8  e1a00000          MOV      r0,r0                 ;722
                  |L1.3580|
000dfc  e3550000          CMP      r5,#0                 ;725
000e00  0a00000e          BEQ      |L1.3648|
000e04  e1a00000          MOV      r0,r0                 ;725
000e08  e1a01005          MOV      r1,r5                 ;725
000e0c  e1a00007          MOV      r0,r7                 ;725
000e10  ebfffffe          BL       process_set_config
000e14  e3500000          CMP      r0,#0                 ;725
000e18  1a000007          BNE      |L1.3644|
000e1c  e59f2610          LDR      r2,|L1.5172|
000e20  e59f1604          LDR      r1,|L1.5164|
000e24  e59f05ec          LDR      r0,|L1.5144|
000e28  ebfffffe          BL       __2printf
000e2c  e1a00000          MOV      r0,r0                 ;725
000e30  e1a00000          MOV      r0,r0                 ;725
000e34  e3a00000          MOV      r0,#0                 ;725
000e38  eaffff6c          B        |L1.3056|
                  |L1.3644|
000e3c  e1a00000          MOV      r0,r0                 ;725
                  |L1.3648|
000e40  e51f0a48          LDR      r0,|L1.1024|
000e44  e5c05001          STRB     r5,[r0,#1]            ;728  ; _usbd_dev
000e48  e1a01004          MOV      r1,r4                 ;729
000e4c  e1a00007          MOV      r0,r7                 ;729
000e50  ebfffffe          BL       tud_control_status
000e54  ea00004a          B        |L1.3972|
                  |L1.3672|
000e58  e1a00000          MOV      r0,r0                 ;733
000e5c  e1a00000          MOV      r0,r0                 ;734
000e60  e1a01004          MOV      r1,r4                 ;734
000e64  e1a00007          MOV      r0,r7                 ;734
000e68  ebfffffe          BL       process_get_descriptor
000e6c  e3500000          CMP      r0,#0                 ;734
000e70  1a000001          BNE      |L1.3708|
000e74  e3a00000          MOV      r0,#0                 ;734
000e78  eaffff5c          B        |L1.3056|
                  |L1.3708|
000e7c  e1a00000          MOV      r0,r0                 ;734
000e80  ea00003f          B        |L1.3972|
                  |L1.3716|
000e84  e1a00000          MOV      r0,r0                 ;737
000e88  e1a00000          MOV      r0,r0                 ;739
000e8c  e5d40003          LDRB     r0,[r4,#3]            ;739
000e90  e5d41002          LDRB     r1,[r4,#2]            ;739
000e94  e1810400          ORR      r0,r1,r0,LSL #8       ;739
000e98  e3500001          CMP      r0,#1                 ;739
000e9c  0a000001          BEQ      |L1.3752|
000ea0  e3a00000          MOV      r0,#0                 ;739
000ea4  eaffff51          B        |L1.3056|
                  |L1.3752|
000ea8  e1a00000          MOV      r0,r0                 ;739
000eac  e51f0ab4          LDR      r0,|L1.1024|
000eb0  e5d00000          LDRB     r0,[r0,#0]            ;744  ; _usbd_dev
000eb4  e3800008          ORR      r0,r0,#8              ;744
000eb8  e51f1ac0          LDR      r1,|L1.1024|
000ebc  e5c10000          STRB     r0,[r1,#0]            ;744  ; _usbd_dev
000ec0  e1a01004          MOV      r1,r4                 ;745
000ec4  e1a00007          MOV      r0,r7                 ;745
000ec8  ebfffffe          BL       tud_control_status
000ecc  ea00002c          B        |L1.3972|
                  |L1.3792|
000ed0  e1a00000          MOV      r0,r0                 ;748
000ed4  e1a00000          MOV      r0,r0                 ;750
000ed8  e5d40003          LDRB     r0,[r4,#3]            ;750
000edc  e5d41002          LDRB     r1,[r4,#2]            ;750
000ee0  e1810400          ORR      r0,r1,r0,LSL #8       ;750
000ee4  e3500001          CMP      r0,#1                 ;750
000ee8  0a000001          BEQ      |L1.3828|
000eec  e3a00000          MOV      r0,#0                 ;750
000ef0  eaffff3e          B        |L1.3056|
                  |L1.3828|
000ef4  e1a00000          MOV      r0,r0                 ;750
000ef8  e51f0b00          LDR      r0,|L1.1024|
000efc  e5d00000          LDRB     r0,[r0,#0]            ;755  ; _usbd_dev
000f00  e3c00008          BIC      r0,r0,#8              ;755
000f04  e51f1b0c          LDR      r1,|L1.1024|
000f08  e5c10000          STRB     r0,[r1,#0]            ;755  ; _usbd_dev
000f0c  e1a01004          MOV      r1,r4                 ;756
000f10  e1a00007          MOV      r0,r7                 ;756
000f14  ebfffffe          BL       tud_control_status
000f18  ea000019          B        |L1.3972|
                  |L1.3868|
000f1c  e1a00000          MOV      r0,r0                 ;759
000f20  e51f0b28          LDR      r0,|L1.1024|
000f24  e5d00000          LDRB     r0,[r0,#0]            ;764  ; _usbd_dev
000f28  e1a00e00          LSL      r0,r0,#28             ;764
000f2c  e1a00fa0          LSR      r0,r0,#31             ;764
000f30  e3500000          CMP      r0,#0                 ;764
000f34  0a000001          BEQ      |L1.3904|
000f38  e3a00002          MOV      r0,#2                 ;764
000f3c  ea000000          B        |L1.3908|
                  |L1.3904|
000f40  e3a00000          MOV      r0,#0                 ;764
                  |L1.3908|
000f44  e51f1b4c          LDR      r1,|L1.1024|
000f48  e5d11000          LDRB     r1,[r1,#0]            ;764  ; _usbd_dev
000f4c  e1a01d01          LSL      r1,r1,#26             ;764
000f50  e1800fa1          ORR      r0,r0,r1,LSR #31      ;764
000f54  e58d0000          STR      r0,[sp,#0]            ;764
000f58  e3a03002          MOV      r3,#2                 ;765
000f5c  e1a0200d          MOV      r2,sp                 ;765
000f60  e1a01004          MOV      r1,r4                 ;765
000f64  e1a00007          MOV      r0,r7                 ;765
000f68  ebfffffe          BL       tud_control_xfer
000f6c  ea000004          B        |L1.3972|
                  |L1.3952|
000f70  e1a00000          MOV      r0,r0                 ;770
000f74  e1a00000          MOV      r0,r0                 ;770
000f78  e1a00000          MOV      r0,r0                 ;770
000f7c  e3a00000          MOV      r0,#0                 ;770
000f80  eaffff1a          B        |L1.3056|
                  |L1.3972|
000f84  e1a00000          MOV      r0,r0                 ;693
000f88  ea0000b1          B        |L1.4692|
                  |L1.3980|
000f8c  e1a00000          MOV      r0,r0                 ;775
000f90  e5d41005          LDRB     r1,[r4,#5]            ;777
000f94  e5d42004          LDRB     r2,[r4,#4]            ;777
000f98  e1820401          ORR      r0,r2,r1,LSL #8       ;777
000f9c  e20010ff          AND      r1,r0,#0xff           ;777
000fa0  e1a06001          MOV      r6,r1                 ;777
000fa4  e1a00000          MOV      r0,r0                 ;778
000fa8  e3560010          CMP      r6,#0x10              ;778
000fac  3a000001          BCC      |L1.4024|
000fb0  e3a00000          MOV      r0,#0                 ;778
000fb4  eaffff0d          B        |L1.3056|
                  |L1.4024|
000fb8  e1a00000          MOV      r0,r0                 ;778
000fbc  e51f1b70          LDR      r1,|L1.1108|
000fc0  e7d10006          LDRB     r0,[r1,r6]            ;780
000fc4  ebfffffe          BL       get_driver
000fc8  e1a05000          MOV      r5,r0                 ;780
000fcc  e1a00000          MOV      r0,r0                 ;781
000fd0  e3550000          CMP      r5,#0                 ;781
000fd4  1a000001          BNE      |L1.4064|
000fd8  e3a00000          MOV      r0,#0                 ;781
000fdc  eaffff03          B        |L1.3056|
                  |L1.4064|
000fe0  e1a00000          MOV      r0,r0                 ;781
000fe4  e1a02004          MOV      r2,r4                 ;785
000fe8  e1a01005          MOV      r1,r5                 ;785
000fec  e1a00007          MOV      r0,r7                 ;785
000ff0  ebfffffe          BL       invoke_class_control
000ff4  e3500000          CMP      r0,#0                 ;785
000ff8  1a000025          BNE      |L1.4244|
000ffc  e1a00000          MOV      r0,r0                 ;789
001000  e5d40000          LDRB     r0,[r4,#0]            ;789
001004  e1a00c80          LSL      r0,r0,#25             ;789
001008  e1a00f20          LSR      r0,r0,#30             ;789
00100c  e3500000          CMP      r0,#0                 ;789
001010  0a000001          BEQ      |L1.4124|
001014  e3a00000          MOV      r0,#0                 ;789
001018  eafffef4          B        |L1.3056|
                  |L1.4124|
00101c  e1a00000          MOV      r0,r0                 ;789
001020  e5d40001          LDRB     r0,[r4,#1]            ;791
001024  e350000a          CMP      r0,#0xa               ;791
001028  0a000002          BEQ      |L1.4152|
00102c  e350000b          CMP      r0,#0xb               ;791
001030  1a000013          BNE      |L1.4228|
001034  ea000001          B        |L1.4160|
                  |L1.4152|
001038  e1a00000          MOV      r0,r0                 ;793
00103c  e1a00000          MOV      r0,r0                 ;794
                  |L1.4160|
001040  e3a00000          MOV      r0,#0                 ;796
001044  ebfffffe          BL       usbd_control_set_complete_callback
001048  e5d40001          LDRB     r0,[r4,#1]            ;798
00104c  e350000a          CMP      r0,#0xa               ;798
001050  1a000007          BNE      |L1.4212|
001054  e3a00000          MOV      r0,#0                 ;800
001058  e58d0000          STR      r0,[sp,#0]            ;800
00105c  e3a03001          MOV      r3,#1                 ;801
001060  e1a0200d          MOV      r2,sp                 ;801
001064  e1a01004          MOV      r1,r4                 ;801
001068  e1a00007          MOV      r0,r7                 ;801
00106c  ebfffffe          BL       tud_control_xfer
001070  ea000002          B        |L1.4224|
                  |L1.4212|
001074  e1a01004          MOV      r1,r4                 ;804
001078  e1a00007          MOV      r0,r7                 ;804
00107c  ebfffffe          BL       tud_control_status
                  |L1.4224|
001080  ea000002          B        |L1.4240|
                  |L1.4228|
001084  e1a00000          MOV      r0,r0                 ;808
001088  e3a00000          MOV      r0,#0                 ;808
00108c  eafffed7          B        |L1.3056|
                  |L1.4240|
001090  e1a00000          MOV      r0,r0                 ;806
                  |L1.4244|
001094  ea00006e          B        |L1.4692|
                  |L1.4248|
001098  e1a00000          MOV      r0,r0                 ;815
00109c  e5d41005          LDRB     r1,[r4,#5]            ;817
0010a0  e5d42004          LDRB     r2,[r4,#4]            ;817
0010a4  e1820401          ORR      r0,r2,r1,LSL #8       ;817
0010a8  e20010ff          AND      r1,r0,#0xff           ;817
0010ac  e1a05001          MOV      r5,r1                 ;817
0010b0  e1a00000          MOV      r0,r0                 ;818
0010b4  e3c50080          BIC      r0,r5,#0x80           ;818
0010b8  e1a08000          MOV      r8,r0                 ;818
0010bc  e1a00000          MOV      r0,r0                 ;819
0010c0  e2050080          AND      r0,r5,#0x80           ;819
0010c4  e1a003a0          LSR      r0,r0,#7              ;819
0010c8  e1a09000          MOV      r9,r0                 ;819
0010cc  e1a00000          MOV      r0,r0                 ;821
0010d0  e3580004          CMP      r8,#4                 ;821
0010d4  3a000007          BCC      |L1.4344|
0010d8  e59f2358          LDR      r2,|L1.5176|
0010dc  e59f1348          LDR      r1,|L1.5164|
0010e0  e59f0330          LDR      r0,|L1.5144|
0010e4  ebfffffe          BL       __2printf
0010e8  e1a00000          MOV      r0,r0                 ;821
0010ec  e1a00000          MOV      r0,r0                 ;821
0010f0  e3a00000          MOV      r0,#0                 ;821
0010f4  eafffebd          B        |L1.3056|
                  |L1.4344|
0010f8  e1a00000          MOV      r0,r0                 ;821
0010fc  e51f1cac          LDR      r1,|L1.1112|
001100  e0811088          ADD      r1,r1,r8,LSL #1       ;823
001104  e7d10009          LDRB     r0,[r1,r9]            ;823
001108  ebfffffe          BL       get_driver
00110c  e1a06000          MOV      r6,r0                 ;823
001110  e5d40000          LDRB     r0,[r4,#0]            ;825
001114  e1a00c80          LSL      r0,r0,#25             ;825
001118  e1a00f20          LSR      r0,r0,#30             ;825
00111c  e3500000          CMP      r0,#0                 ;825
001120  0a00000a          BEQ      |L1.4432|
001124  e1a00000          MOV      r0,r0                 ;828
001128  e3560000          CMP      r6,#0                 ;828
00112c  1a000001          BNE      |L1.4408|
001130  e3a00000          MOV      r0,#0                 ;828
001134  eafffead          B        |L1.3056|
                  |L1.4408|
001138  e1a00000          MOV      r0,r0                 ;828
00113c  e1a02004          MOV      r2,r4                 ;829
001140  e1a01006          MOV      r1,r6                 ;829
001144  e1a00007          MOV      r0,r7                 ;829
001148  ebfffffe          BL       invoke_class_control
00114c  eafffea7          B        |L1.3056|
                  |L1.4432|
001150  e5d40001          LDRB     r0,[r4,#1]            ;834
001154  e3500000          CMP      r0,#0                 ;834
001158  0a000004          BEQ      |L1.4464|
00115c  e3500001          CMP      r0,#1                 ;834
001160  0a00000d          BEQ      |L1.4508|
001164  e3500003          CMP      r0,#3                 ;834
001168  1a00002d          BNE      |L1.4644|
00116c  ea00000c          B        |L1.4516|
                  |L1.4464|
001170  e1a00000          MOV      r0,r0                 ;836
001174  e1a01005          MOV      r1,r5                 ;838
001178  e1a00007          MOV      r0,r7                 ;838
00117c  ebfffffe          BL       usbd_edpt_stalled
001180  e58d0000          STR      r0,[sp,#0]            ;838
001184  e3a03002          MOV      r3,#2                 ;839
001188  e1a0200d          MOV      r2,sp                 ;839
00118c  e1a01004          MOV      r1,r4                 ;839
001190  e1a00007          MOV      r0,r7                 ;839
001194  ebfffffe          BL       tud_control_xfer
001198  ea000026          B        |L1.4664|
                  |L1.4508|
00119c  e1a00000          MOV      r0,r0                 ;843
0011a0  e1a00000          MOV      r0,r0                 ;844
                  |L1.4516|
0011a4  e5d40003          LDRB     r0,[r4,#3]            ;846
0011a8  e5d41002          LDRB     r1,[r4,#2]            ;846
0011ac  e1810400          ORR      r0,r1,r0,LSL #8       ;846
0011b0  e3500000          CMP      r0,#0                 ;846
0011b4  1a000009          BNE      |L1.4576|
0011b8  e5d40001          LDRB     r0,[r4,#1]            ;848
0011bc  e3500001          CMP      r0,#1                 ;848
0011c0  1a000003          BNE      |L1.4564|
0011c4  e1a01005          MOV      r1,r5                 ;850
0011c8  e1a00007          MOV      r0,r7                 ;850
0011cc  ebfffffe          BL       usbd_edpt_clear_stall
0011d0  ea000002          B        |L1.4576|
                  |L1.4564|
0011d4  e1a01005          MOV      r1,r5                 ;853
0011d8  e1a00007          MOV      r0,r7                 ;853
0011dc  ebfffffe          BL       usbd_edpt_stall
                  |L1.4576|
0011e0  e3560000          CMP      r6,#0                 ;857
0011e4  0a00000d          BEQ      |L1.4640|
0011e8  e1a02004          MOV      r2,r4                 ;864
0011ec  e1a01006          MOV      r1,r6                 ;864
0011f0  e1a00007          MOV      r0,r7                 ;864
0011f4  ebfffffe          BL       invoke_class_control
0011f8  e3a00000          MOV      r0,#0                 ;865
0011fc  ebfffffe          BL       usbd_control_set_complete_callback
001200  e51f0e08          LDR      r0,|L1.1024|
001204  e5d0001c          LDRB     r0,[r0,#0x1c]         ;868
001208  e2000001          AND      r0,r0,#1              ;868
00120c  e3500000          CMP      r0,#0                 ;868
001210  1a000002          BNE      |L1.4640|
001214  e1a01004          MOV      r1,r4                 ;868
001218  e1a00007          MOV      r0,r7                 ;868
00121c  ebfffffe          BL       tud_control_status
                  |L1.4640|
001220  ea000004          B        |L1.4664|
                  |L1.4644|
001224  e1a00000          MOV      r0,r0                 ;874
001228  e1a00000          MOV      r0,r0                 ;874
00122c  e1a00000          MOV      r0,r0                 ;874
001230  e3a00000          MOV      r0,#0                 ;874
001234  eafffe6d          B        |L1.3056|
                  |L1.4664|
001238  e1a00000          MOV      r0,r0                 ;841
00123c  ea000004          B        |L1.4692|
                  |L1.4672|
001240  e1a00000          MOV      r0,r0                 ;881
001244  e1a00000          MOV      r0,r0                 ;881
001248  e1a00000          MOV      r0,r0                 ;881
00124c  e3a00000          MOV      r0,#0                 ;881
001250  eafffe66          B        |L1.3056|
                  |L1.4692|
001254  e1a00000          MOV      r0,r0                 ;772
001258  e3a00001          MOV      r0,#1                 ;884
00125c  eafffe63          B        |L1.3056|
;;;886    
                          ENDP

                  tud_task_ext PROC
;;;485     */
;;;486    void tud_task_ext(uint32_t timeout_ms, bool in_isr)
001260  e92d47ff          PUSH     {r0-r10,lr}
;;;487    {
001264  e1a07000          MOV      r7,r0
001268  e1a08001          MOV      r8,r1
;;;488      (void) in_isr; // not implemented yet
;;;489    ////TU_LOG(USBD_DBG,"\r\n======tud_task_ext=============");
;;;490      // Skip if stack is not initialized
;;;491      if ( !tud_inited() ) 
00126c  ebfffffe          BL       tud_inited
001270  e3500000          CMP      r0,#0
001274  1a000000          BNE      |L1.4732|
                  |L1.4728|
;;;492    		return;
;;;493    /////TU_LOG(USBD_DBG,"\r\n======tud_task_ext1=============");
;;;494    
;;;495      // Loop until there is no more events in the queue
;;;496      while (1)
;;;497      {
;;;498        dcd_event_t event;
;;;499        if ( !osal_queue_receive(_usbd_q, &event, timeout_ms) ) 
;;;500    			{
;;;501    			TU_LOG(USBD_DBG,"\r\n======tud_task_ext exit=============");
;;;502    		
;;;503    			return;
;;;504    			}
;;;505    #if CFG_TUSB_DEBUG >= 2
;;;506        if (event.event_id == DCD_EVENT_SETUP_RECEIVED) TU_LOG(USBD_DBG, "\r\n"); // extra line for setup
;;;507        TU_LOG(USBD_DBG, "USBD_ %s ", event.event_id < DCD_EVENT_COUNT ? _usbd_event_str[event.event_id] : "CORRUPTED");
;;;508    #endif
;;;509    
;;;510        switch ( event.event_id )
;;;511        {
;;;512          case DCD_EVENT_BUS_RESET:
;;;513            TU_LOG(USBD_DBG, ": %s Speed\r\n", tu_str_speed[event.bus_reset.speed]);
;;;514            usbd_reset(event.rhport);
;;;515            _usbd_dev.speed = event.bus_reset.speed;
;;;516          break;
;;;517    
;;;518          case DCD_EVENT_UNPLUGGED:
;;;519            TU_LOG(USBD_DBG, "EVENT_UNPLUGGED \r\n");
;;;520            usbd_reset(event.rhport);
;;;521    
;;;522            // invoke callback
;;;523            if (tud_umount_cb) tud_umount_cb();
;;;524          break;
;;;525    
;;;526          case DCD_EVENT_SETUP_RECEIVED:
;;;527            TU_LOG_PTR(USBD_DBG, &event.setup_received);
;;;528            TU_LOG(USBD_DBG, "\r\n");
;;;529    
;;;530            // Mark as connected after receiving 1st setup packet.
;;;531            // But it is easier to set it every time instead of wasting time to check then set
;;;532            _usbd_dev.connected = 1;
;;;533    
;;;534            // mark both in & out control as free
;;;535            _usbd_dev.ep_status[0][TUSB_DIR_OUT].busy = 0;
;;;536            _usbd_dev.ep_status[0][TUSB_DIR_OUT].claimed = 0;
;;;537            _usbd_dev.ep_status[0][TUSB_DIR_IN ].busy = 0;
;;;538            _usbd_dev.ep_status[0][TUSB_DIR_IN ].claimed = 0;
;;;539    
;;;540            // Process control request
;;;541            if ( !process_control_request(event.rhport, &event.setup_received) )
;;;542            {
;;;543              TU_LOG(USBD_DBG, "  Stall EP0\r\n");
;;;544              // Failed -> stall both control endpoint IN and OUT
;;;545              dcd_edpt_stall(event.rhport, 0);
;;;546              dcd_edpt_stall(event.rhport, 0 | TUSB_DIR_IN_MASK);
;;;547            }
;;;548          break;
;;;549    
;;;550          case DCD_EVENT_XFER_COMPLETE:
;;;551          {
;;;552            // Invoke the class callback associated with the endpoint address
;;;553            uint8_t const ep_addr = event.xfer_complete.ep_addr;
;;;554            uint8_t const epnum   = tu_edpt_number(ep_addr);
;;;555            uint8_t const ep_dir  = tu_edpt_dir(ep_addr);
;;;556    
;;;557            TU_LOG(USBD_DBG, "on EP %02X with %u bytes\r\n", ep_addr
;;;558    									, (unsigned int) event.xfer_complete.len);
;;;559    
;;;560            _usbd_dev.ep_status[epnum][ep_dir].busy = 0;
;;;561            _usbd_dev.ep_status[epnum][ep_dir].claimed = 0;
;;;562    
;;;563            if ( 0 == epnum )
;;;564            {
;;;565              usbd_control_xfer_cb(event.rhport, ep_addr, (xfer_result_t) event.xfer_complete.result, event.xfer_complete
;;;566              .len);
;;;567            }
;;;568            else
;;;569            {
;;;570              usbd_class_driver_t const * driver = get_driver( _usbd_dev.ep2drv[epnum][ep_dir] );
;;;571              TU_ASSERT(driver, );
;;;572    
;;;573              TU_LOG(USBD_DBG, "  %s xfer callback\r\n", driver->name);
;;;574              driver->xfer_cb(event.rhport, ep_addr, (xfer_result_t) event.xfer_complete.result, event.xfer_complete.len);
;;;575            }
;;;576          }
;;;577          break;
;;;578    
;;;579          case DCD_EVENT_SUSPEND:
;;;580            // NOTE: When plugging/unplugging device, the D+/D- state are unstable and
;;;581            // can accidentally meet the SUSPEND condition ( Bus Idle for 3ms ), which result in a series of event
;;;582            // e.g suspend -> resume -> unplug/plug. Skip suspend/resume if not connected
;;;583            if ( _usbd_dev.connected )
;;;584            {
;;;585              TU_LOG(USBD_DBG, ": Remote Wakeup = %u\r\n", _usbd_dev.remote_wakeup_en);
;;;586              if (tud_suspend_cb) tud_suspend_cb(_usbd_dev.remote_wakeup_en);
;;;587            }else
;;;588            {
;;;589              TU_LOG(USBD_DBG, " Skipped\r\n");
;;;590            }
;;;591          break;
;;;592    
;;;593          case DCD_EVENT_RESUME:
;;;594            if ( _usbd_dev.connected )
;;;595            {
;;;596              TU_LOG(USBD_DBG, "\r\n");
;;;597              if (tud_resume_cb) tud_resume_cb();
;;;598            }else
;;;599            {
;;;600              TU_LOG(USBD_DBG, " Skipped\r\n");
;;;601            }
;;;602          break;
;;;603    
;;;604          case USBD_EVENT_FUNC_CALL:
;;;605            TU_LOG(USBD_DBG, "EVENT_FUNC_CALL\r\n");
;;;606            if ( event.func_call.func ) 
;;;607    					event.func_call.func(event.func_call.param);
;;;608          break;
;;;609    
;;;610          case DCD_EVENT_SOF:
;;;611          default:
;;;612            TU_BREAKPOINT();
;;;613          break;
;;;614        }
;;;615    
;;;616    #if CFG_TUSB_OS != OPT_OS_NONE && CFG_TUSB_OS != OPT_OS_PICO
;;;617        // return if there is no more events, for application to run other background
;;;618        if (osal_queue_empty(_usbd_q)) return;
;;;619    #endif
;;;620      }
;;;621    }
001278  e8bd87ff          POP      {r0-r10,pc}
                  |L1.4732|
00127c  ea0000dd          B        |L1.5624|
                  |L1.4736|
001280  e51f0e48          LDR      r0,|L1.1088|
001284  e28d6004          ADD      r6,sp,#4              ;499
001288  e1a05007          MOV      r5,r7                 ;499
00128c  e5904000          LDR      r4,[r0,#0]            ;499  ; _usbd_q
001290  e1a00005          MOV      r0,r5                 ;499
001294  e3700001          CMN      r0,#1                 ;499
001298  1a000001          BNE      |L1.4772|
00129c  e51f1e68          LDR      r1,|L1.1084|
0012a0  ea000005          B        |L1.4796|
                  |L1.4772|
0012a4  e59f1190          LDR      r1,|L1.5180|
0012a8  e1500001          CMP      r0,r1                 ;499
0012ac  3a000000          BCC      |L1.4788|
0012b0  ea000001          B        |L1.4796|
                  |L1.4788|
0012b4  e1a01800          LSL      r1,r0,#16             ;499
0012b8  e1a01821          LSR      r1,r1,#16             ;499
                  |L1.4796|
0012bc  e1a00000          MOV      r0,r0                 ;499
0012c0  e1a09001          MOV      r9,r1                 ;499
0012c4  e1a02009          MOV      r2,r9                 ;499
0012c8  e1a0100d          MOV      r1,sp                 ;499
0012cc  e5940008          LDR      r0,[r4,#8]            ;499
0012d0  ebfffffe          BL       os_mbx_wait
0012d4  e1d420b2          LDRH     r2,[r4,#2]            ;499
0012d8  e1a00006          MOV      r0,r6                 ;499
0012dc  e59d1000          LDR      r1,[sp,#0]            ;499
0012e0  ebfffffe          BL       __aeabi_memcpy
0012e4  e5940004          LDR      r0,[r4,#4]            ;499
0012e8  e59d1000          LDR      r1,[sp,#0]            ;499
0012ec  ef000002          SVC      #0x2                  ;499
0012f0  e3a00001          MOV      r0,#1                 ;499
0012f4  e3500000          CMP      r0,#0                 ;499
0012f8  1a000000          BNE      |L1.4864|
0012fc  eaffffdd          B        |L1.4728|
                  |L1.4864|
001300  e5dd0005          LDRB     r0,[sp,#5]            ;510
001304  e3500009          CMP      r0,#9                 ;510
001308  308ff100          ADDCC    pc,pc,r0,LSL #2       ;510
00130c  ea0000a5          B        |L1.5544|
001310  ea0000a4          B        |L1.5544|
001314  ea000006          B        |L1.4916|
001318  ea00000c          B        |L1.4944|
00131c  ea0000a3          B        |L1.5552|
001320  ea00007e          B        |L1.5408|
001324  ea00008c          B        |L1.5468|
001328  ea000010          B        |L1.4976|
00132c  ea000044          B        |L1.5188|
001330  ea000094          B        |L1.5512|
                  |L1.4916|
001334  e1a00000          MOV      r0,r0                 ;512
001338  e5dd0004          LDRB     r0,[sp,#4]            ;514
00133c  ebfffffe          BL       usbd_reset
001340  e5dd0008          LDRB     r0,[sp,#8]            ;515
001344  e51f1f4c          LDR      r1,|L1.1024|
001348  e5c10002          STRB     r0,[r1,#2]            ;515  ; _usbd_dev
00134c  ea00009a          B        |L1.5564|
                  |L1.4944|
001350  e1a00000          MOV      r0,r0                 ;518
001354  e5dd0004          LDRB     r0,[sp,#4]            ;520
001358  ebfffffe          BL       usbd_reset
00135c  e59f00dc          LDR      r0,|L1.5184|
001360  e3500000          CMP      r0,#0                 ;523
001364  0a000000          BEQ      |L1.4972|
001368  ebfffffe          BL       tud_umount_cb
                  |L1.4972|
00136c  ea000092          B        |L1.5564|
                  |L1.4976|
001370  e1a00000          MOV      r0,r0                 ;526
001374  e51f0f7c          LDR      r0,|L1.1024|
001378  e5d00000          LDRB     r0,[r0,#0]            ;532  ; _usbd_dev
00137c  e3800001          ORR      r0,r0,#1              ;532
001380  e51f1f88          LDR      r1,|L1.1024|
001384  e5c10000          STRB     r0,[r1,#0]            ;532  ; _usbd_dev
001388  e2810000          ADD      r0,r1,#0              ;535
00138c  e5d0001b          LDRB     r0,[r0,#0x1b]         ;535  ; _usbd_dev
001390  e3c00001          BIC      r0,r0,#1              ;535
001394  e5c1001b          STRB     r0,[r1,#0x1b]         ;535  ; _usbd_dev
001398  e2810000          ADD      r0,r1,#0              ;536
00139c  e5d0001b          LDRB     r0,[r0,#0x1b]         ;536  ; _usbd_dev
0013a0  e3c00004          BIC      r0,r0,#4              ;536
0013a4  e5c1001b          STRB     r0,[r1,#0x1b]         ;536  ; _usbd_dev
0013a8  e2810000          ADD      r0,r1,#0              ;537
0013ac  e5d0001c          LDRB     r0,[r0,#0x1c]         ;537
0013b0  e3c00001          BIC      r0,r0,#1              ;537
0013b4  e5c1001c          STRB     r0,[r1,#0x1c]         ;537
0013b8  e2810000          ADD      r0,r1,#0              ;538
0013bc  e5d0001c          LDRB     r0,[r0,#0x1c]         ;538
0013c0  e3c00004          BIC      r0,r0,#4              ;538
0013c4  e5c1001c          STRB     r0,[r1,#0x1c]         ;538
0013c8  e5dd0004          LDRB     r0,[sp,#4]            ;541
0013cc  e28d1008          ADD      r1,sp,#8              ;541
0013d0  ebfffffe          BL       process_control_request
0013d4  e3500000          CMP      r0,#0                 ;541
0013d8  1a000005          BNE      |L1.5108|
0013dc  e5dd0004          LDRB     r0,[sp,#4]            ;545
0013e0  e3a01000          MOV      r1,#0                 ;545
0013e4  ebfffffe          BL       dcd_edpt_stall
0013e8  e5dd0004          LDRB     r0,[sp,#4]            ;546
0013ec  e3a01080          MOV      r1,#0x80              ;546
0013f0  ebfffffe          BL       dcd_edpt_stall
                  |L1.5108|
0013f4  ea000070          B        |L1.5564|
                  |L1.5112|
                          DCD      _usbd_dev+0x1b
                  |L1.5116|
                          DCD      tud_descriptor_bos_cb
                  |L1.5120|
                          DCD      |symbol_number.21|
                  |L1.5124|
                          DCD      tud_descriptor_other_speed_configuration_cb
                  |L1.5128|
                          DCD      0x0000041a
                  |L1.5132|
                          DCD      tud_descriptor_device_qualifier_cb
                  |L1.5136|
                          DCD      0x0000037d
                  |L1.5140|
                          DCD      |symbol_number.20|
                  |L1.5144|
                          DCD      ||.text||+0x420
                  |L1.5148|
                          DCD      0x000003a1
                  |L1.5152|
                          DCD      0x000003cf
                  |L1.5156|
                          DCD      tud_mount_cb
                  |L1.5160|
                          DCD      0x00000281
                  |L1.5164|
                          DCD      |symbol_number.19|
                  |L1.5168|
                          DCD      tud_vendor_control_xfer_cb
                  |L1.5172|
                          DCD      0x000002d5
                  |L1.5176|
                          DCD      0x00000335
                  |L1.5180|
                          DCD      0x0000fffe
                  |L1.5184|
                          DCD      tud_umount_cb
                  |L1.5188|
001444  e1a00000          MOV      r0,r0                 ;550
001448  e5dd5008          LDRB     r5,[sp,#8]            ;553
00144c  e1a00005          MOV      r0,r5                 ;554
001450  e3c01080          BIC      r1,r0,#0x80           ;554
001454  e1a04001          MOV      r4,r1                 ;554
001458  e1a00005          MOV      r0,r5                 ;555
00145c  e2001080          AND      r1,r0,#0x80           ;555
001460  e1a013a1          LSR      r1,r1,#7              ;555
001464  e1a06001          MOV      r6,r1                 ;555
001468  e51f0078          LDR      r0,|L1.5112|
00146c  e0800084          ADD      r0,r0,r4,LSL #1       ;560
001470  e7d00006          LDRB     r0,[r0,r6]            ;560
001474  e3c00001          BIC      r0,r0,#1              ;560
001478  e51f1088          LDR      r1,|L1.5112|
00147c  e0811084          ADD      r1,r1,r4,LSL #1       ;560
001480  e7c10006          STRB     r0,[r1,r6]            ;560
001484  e51f0094          LDR      r0,|L1.5112|
001488  e0800084          ADD      r0,r0,r4,LSL #1       ;561
00148c  e7d00006          LDRB     r0,[r0,r6]            ;561
001490  e3c00004          BIC      r0,r0,#4              ;561
001494  e51f10a4          LDR      r1,|L1.5112|
001498  e0811084          ADD      r1,r1,r4,LSL #1       ;561
00149c  e7c10006          STRB     r0,[r1,r6]            ;561
0014a0  e3540000          CMP      r4,#0                 ;563
0014a4  1a000005          BNE      |L1.5312|
0014a8  e59d300c          LDR      r3,[sp,#0xc]          ;565
0014ac  e5dd2009          LDRB     r2,[sp,#9]            ;565
0014b0  e5dd0004          LDRB     r0,[sp,#4]            ;565
0014b4  e1a01005          MOV      r1,r5                 ;565
0014b8  ebfffffe          BL       usbd_control_xfer_cb
0014bc  ea000016          B        |L1.5404|
                  |L1.5312|
0014c0  e59f1c04          LDR      r1,|L1.8396|
0014c4  e0811084          ADD      r1,r1,r4,LSL #1       ;570
0014c8  e7d10006          LDRB     r0,[r1,r6]            ;570
0014cc  ebfffffe          BL       get_driver
0014d0  e1a09000          MOV      r9,r0                 ;570
0014d4  e1a00000          MOV      r0,r0                 ;571
0014d8  e3590000          CMP      r9,#0                 ;571
0014dc  1a000006          BNE      |L1.5372|
0014e0  e59f2be8          LDR      r2,|L1.8400|
0014e4  e59f1be8          LDR      r1,|L1.8404|
0014e8  e51f00d8          LDR      r0,|L1.5144|
0014ec  ebfffffe          BL       __2printf
0014f0  e1a00000          MOV      r0,r0                 ;571
0014f4  e1a00000          MOV      r0,r0                 ;571
0014f8  eaffff5e          B        |L1.4728|
                  |L1.5372|
0014fc  e1a00000          MOV      r0,r0                 ;571
001500  e59d300c          LDR      r3,[sp,#0xc]          ;574
001504  e5dd2009          LDRB     r2,[sp,#9]            ;574
001508  e5dd0004          LDRB     r0,[sp,#4]            ;574
00150c  e1a01005          MOV      r1,r5                 ;574
001510  e599c010          LDR      r12,[r9,#0x10]        ;574
001514  e12fff3c          BLX      r12                   ;574
001518  e1a00000          MOV      r0,r0                 ;575
                  |L1.5404|
00151c  ea000026          B        |L1.5564|
                  |L1.5408|
001520  e1a00000          MOV      r0,r0                 ;579
001524  e59f0bac          LDR      r0,|L1.8408|
001528  e5d00000          LDRB     r0,[r0,#0]            ;583  ; _usbd_dev
00152c  e2000001          AND      r0,r0,#1              ;583
001530  e3500000          CMP      r0,#0                 ;583
001534  0a000007          BEQ      |L1.5464|
001538  e59f0b9c          LDR      r0,|L1.8412|
00153c  e3500000          CMP      r0,#0                 ;586
001540  0a000004          BEQ      |L1.5464|
001544  e59f1b8c          LDR      r1,|L1.8408|
001548  e5d11000          LDRB     r1,[r1,#0]            ;586  ; _usbd_dev
00154c  e1a01e01          LSL      r1,r1,#28             ;586
001550  e1a00fa1          LSR      r0,r1,#31             ;586
001554  ebfffffe          BL       tud_suspend_cb
                  |L1.5464|
001558  ea000017          B        |L1.5564|
                  |L1.5468|
00155c  e1a00000          MOV      r0,r0                 ;593
001560  e59f0b70          LDR      r0,|L1.8408|
001564  e5d00000          LDRB     r0,[r0,#0]            ;594  ; _usbd_dev
001568  e2000001          AND      r0,r0,#1              ;594
00156c  e3500000          CMP      r0,#0                 ;594
001570  0a000003          BEQ      |L1.5508|
001574  e59f0b64          LDR      r0,|L1.8416|
001578  e3500000          CMP      r0,#0                 ;597
00157c  0a000000          BEQ      |L1.5508|
001580  ebfffffe          BL       tud_resume_cb
                  |L1.5508|
001584  ea00000c          B        |L1.5564|
                  |L1.5512|
001588  e1a00000          MOV      r0,r0                 ;604
00158c  e59d0008          LDR      r0,[sp,#8]            ;606
001590  e3500000          CMP      r0,#0                 ;606
001594  0a000002          BEQ      |L1.5540|
001598  e59d000c          LDR      r0,[sp,#0xc]          ;607
00159c  e59d1008          LDR      r1,[sp,#8]            ;607
0015a0  e12fff31          BLX      r1                    ;607
                  |L1.5540|
0015a4  ea000004          B        |L1.5564|
                  |L1.5544|
0015a8  e1a00000          MOV      r0,r0                 ;610
0015ac  e1a00000          MOV      r0,r0                 ;610
                  |L1.5552|
0015b0  e1a00000          MOV      r0,r0                 ;612
0015b4  e1a00000          MOV      r0,r0                 ;612
0015b8  e1a00000          MOV      r0,r0                 ;613
                  |L1.5564|
0015bc  e1a00000          MOV      r0,r0                 ;516
0015c0  e59f0b1c          LDR      r0,|L1.8420|
0015c4  e5904000          LDR      r4,[r0,#0]            ;618  ; _usbd_q
0015c8  e5940008          LDR      r0,[r4,#8]            ;618
0015cc  ebfffffe          BL       os_mbx_check
0015d0  e1d410b0          LDRH     r1,[r4,#0]            ;618
0015d4  e1500001          CMP      r0,r1                 ;618
0015d8  1a000001          BNE      |L1.5604|
0015dc  e3a00001          MOV      r0,#1                 ;618
0015e0  ea000000          B        |L1.5608|
                  |L1.5604|
0015e4  e3a00000          MOV      r0,#0                 ;618
                  |L1.5608|
0015e8  e3500000          CMP      r0,#0                 ;618
0015ec  0a000000          BEQ      |L1.5620|
0015f0  eaffff20          B        |L1.4728|
                  |L1.5620|
0015f4  e1a00000          MOV      r0,r0                 ;620
                  |L1.5624|
0015f8  eaffff20          B        |L1.4736|
;;;622    
                          ENDP

                  dcd_event_handler PROC
;;;1092   //--------------------------------------------------------------------+
;;;1093   TU_ATTR_FAST_FUNC void dcd_event_handler(dcd_event_t const * event, bool in_isr)
0015fc  e92d43fe          PUSH     {r1-r9,lr}
;;;1094   {
001600  e1a05000          MOV      r5,r0
001604  e1a04001          MOV      r4,r1
;;;1095     switch (event->event_id)
001608  e5d50001          LDRB     r0,[r5,#1]
00160c  e3500002          CMP      r0,#2
001610  0a000006          BEQ      |L1.5680|
001614  e3500003          CMP      r0,#3
001618  0a000074          BEQ      |L1.6128|
00161c  e3500004          CMP      r0,#4
001620  0a00002a          BEQ      |L1.5840|
001624  e3500005          CMP      r0,#5
001628  1a0000af          BNE      |L1.6380|
00162c  ea00004b          B        |L1.5984|
                  |L1.5680|
;;;1096     {
;;;1097       case DCD_EVENT_UNPLUGGED:
001630  e1a00000          MOV      r0,r0
;;;1098         _usbd_dev.connected  = 0;
001634  e59f0a9c          LDR      r0,|L1.8408|
001638  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_dev
00163c  e3c00001          BIC      r0,r0,#1
001640  e59f1a90          LDR      r1,|L1.8408|
001644  e5c10000          STRB     r0,[r1,#0]  ; _usbd_dev
;;;1099         _usbd_dev.addressed  = 0;
001648  e2810000          ADD      r0,r1,#0
00164c  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_dev
001650  e3c00002          BIC      r0,r0,#2
001654  e5c10000          STRB     r0,[r1,#0]  ; _usbd_dev
;;;1100         _usbd_dev.cfg_num    = 0;
001658  e3a00000          MOV      r0,#0
00165c  e5c10001          STRB     r0,[r1,#1]  ; _usbd_dev
;;;1101         _usbd_dev.suspended  = 0;
001660  e2810000          ADD      r0,r1,#0
001664  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_dev
001668  e3c00004          BIC      r0,r0,#4
00166c  e5c10000          STRB     r0,[r1,#0]  ; _usbd_dev
;;;1102         osal_queue_send(_usbd_q, event, in_isr);
001670  e59f0a6c          LDR      r0,|L1.8420|
001674  e1a07005          MOV      r7,r5
001678  e1a08004          MOV      r8,r4
00167c  e5906000          LDR      r6,[r0,#0]  ; _usbd_q
001680  e5960004          LDR      r0,[r6,#4]
001684  ef000001          SVC      #0x1
001688  e1a09000          MOV      r9,r0
00168c  e1d620b2          LDRH     r2,[r6,#2]
001690  e1a01007          MOV      r1,r7
001694  e1a00009          MOV      r0,r9
001698  ebfffffe          BL       __aeabi_memcpy
00169c  e3580000          CMP      r8,#0
0016a0  1a000004          BNE      |L1.5816|
0016a4  e5960008          LDR      r0,[r6,#8]
0016a8  e59f2a38          LDR      r2,|L1.8424|
0016ac  e1a01009          MOV      r1,r9
0016b0  ebfffffe          BL       os_mbx_send
0016b4  ea000002          B        |L1.5828|
                  |L1.5816|
0016b8  e1a01009          MOV      r1,r9
0016bc  e5960008          LDR      r0,[r6,#8]
0016c0  ebfffffe          BL       isr_mbx_send
                  |L1.5828|
0016c4  e1a00000          MOV      r0,r0
0016c8  e1a00000          MOV      r0,r0
;;;1103       break;
0016cc  ea00009f          B        |L1.6480|
                  |L1.5840|
;;;1104   
;;;1105       case DCD_EVENT_SUSPEND:
0016d0  e1a00000          MOV      r0,r0
;;;1106         // NOTE: When plugging/unplugging device, the D+/D- state are unstable and
;;;1107         // can accidentally meet the SUSPEND condition ( Bus Idle for 3ms ).
;;;1108         // In addition, some MCUs such as SAMD or boards that haven no VBUS detection cannot distinguish
;;;1109         // suspended vs disconnected. We will skip handling SUSPEND/RESUME event if not currently connected
;;;1110         if ( _usbd_dev.connected )
0016d4  e59f09fc          LDR      r0,|L1.8408|
0016d8  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_dev
0016dc  e2000001          AND      r0,r0,#1
0016e0  e3500000          CMP      r0,#0
0016e4  0a00001c          BEQ      |L1.5980|
;;;1111         {
;;;1112           _usbd_dev.suspended = 1;
0016e8  e59f09e8          LDR      r0,|L1.8408|
0016ec  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_dev
0016f0  e3800004          ORR      r0,r0,#4
0016f4  e59f19dc          LDR      r1,|L1.8408|
0016f8  e5c10000          STRB     r0,[r1,#0]  ; _usbd_dev
;;;1113           osal_queue_send(_usbd_q, event, in_isr);
0016fc  e59f09e0          LDR      r0,|L1.8420|
001700  e1a07005          MOV      r7,r5
001704  e1a08004          MOV      r8,r4
001708  e5906000          LDR      r6,[r0,#0]  ; _usbd_q
00170c  e5960004          LDR      r0,[r6,#4]
001710  ef000001          SVC      #0x1
001714  e1a09000          MOV      r9,r0
001718  e1d620b2          LDRH     r2,[r6,#2]
00171c  e1a01007          MOV      r1,r7
001720  e1a00009          MOV      r0,r9
001724  ebfffffe          BL       __aeabi_memcpy
001728  e3580000          CMP      r8,#0
00172c  1a000004          BNE      |L1.5956|
001730  e5960008          LDR      r0,[r6,#8]
001734  e59f29ac          LDR      r2,|L1.8424|
001738  e1a01009          MOV      r1,r9
00173c  ebfffffe          BL       os_mbx_send
001740  ea000002          B        |L1.5968|
                  |L1.5956|
001744  e1a01009          MOV      r1,r9
001748  e5960008          LDR      r0,[r6,#8]
00174c  ebfffffe          BL       isr_mbx_send
                  |L1.5968|
001750  e1a00000          MOV      r0,r0
001754  e1a00000          MOV      r0,r0
001758  e1a00000          MOV      r0,r0
                  |L1.5980|
;;;1114         }
;;;1115       break;
00175c  ea00007b          B        |L1.6480|
                  |L1.5984|
;;;1116   
;;;1117       case DCD_EVENT_RESUME:
001760  e1a00000          MOV      r0,r0
;;;1118         // skip event if not connected (especially required for SAMD)
;;;1119         if ( _usbd_dev.connected )
001764  e59f096c          LDR      r0,|L1.8408|
001768  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_dev
00176c  e2000001          AND      r0,r0,#1
001770  e3500000          CMP      r0,#0
001774  0a00001c          BEQ      |L1.6124|
;;;1120         {
;;;1121           _usbd_dev.suspended = 0;
001778  e59f0958          LDR      r0,|L1.8408|
00177c  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_dev
001780  e3c00004          BIC      r0,r0,#4
001784  e59f194c          LDR      r1,|L1.8408|
001788  e5c10000          STRB     r0,[r1,#0]  ; _usbd_dev
;;;1122           osal_queue_send(_usbd_q, event, in_isr);
00178c  e59f0950          LDR      r0,|L1.8420|
001790  e1a07005          MOV      r7,r5
001794  e1a08004          MOV      r8,r4
001798  e5906000          LDR      r6,[r0,#0]  ; _usbd_q
00179c  e5960004          LDR      r0,[r6,#4]
0017a0  ef000001          SVC      #0x1
0017a4  e1a09000          MOV      r9,r0
0017a8  e1d620b2          LDRH     r2,[r6,#2]
0017ac  e1a01007          MOV      r1,r7
0017b0  e1a00009          MOV      r0,r9
0017b4  ebfffffe          BL       __aeabi_memcpy
0017b8  e3580000          CMP      r8,#0
0017bc  1a000004          BNE      |L1.6100|
0017c0  e5960008          LDR      r0,[r6,#8]
0017c4  e59f291c          LDR      r2,|L1.8424|
0017c8  e1a01009          MOV      r1,r9
0017cc  ebfffffe          BL       os_mbx_send
0017d0  ea000002          B        |L1.6112|
                  |L1.6100|
0017d4  e1a01009          MOV      r1,r9
0017d8  e5960008          LDR      r0,[r6,#8]
0017dc  ebfffffe          BL       isr_mbx_send
                  |L1.6112|
0017e0  e1a00000          MOV      r0,r0
0017e4  e1a00000          MOV      r0,r0
0017e8  e1a00000          MOV      r0,r0
                  |L1.6124|
;;;1123         }
;;;1124       break;
0017ec  ea000057          B        |L1.6480|
                  |L1.6128|
;;;1125   
;;;1126       case DCD_EVENT_SOF:
0017f0  e1a00000          MOV      r0,r0
;;;1127         // SOF driver handler in ISR context
;;;1128         for (uint8_t i = 0; i < TOTAL_DRIVER_COUNT; i++)
0017f4  e3a06000          MOV      r6,#0
0017f8  ea00000d          B        |L1.6196|
                  |L1.6140|
;;;1129         {
;;;1130           usbd_class_driver_t const * driver = get_driver(i);
0017fc  e1a00006          MOV      r0,r6
001800  ebfffffe          BL       get_driver
001804  e1a07000          MOV      r7,r0
;;;1131           if (driver && driver->sof)
001808  e3570000          CMP      r7,#0
00180c  0a000006          BEQ      |L1.6188|
001810  e5970014          LDR      r0,[r7,#0x14]
001814  e3500000          CMP      r0,#0
001818  0a000003          BEQ      |L1.6188|
;;;1132           {
;;;1133             driver->sof(event->rhport, event->sof.frame_count);
00181c  e5951004          LDR      r1,[r5,#4]
001820  e5d50000          LDRB     r0,[r5,#0]
001824  e5972014          LDR      r2,[r7,#0x14]
001828  e12fff32          BLX      r2
                  |L1.6188|
00182c  e2860001          ADD      r0,r6,#1              ;1128
001830  e20060ff          AND      r6,r0,#0xff           ;1128
                  |L1.6196|
001834  e59f08b0          LDR      r0,|L1.8428|
001838  e5d00000          LDRB     r0,[r0,#0]            ;1128  ; _app_driver_count
00183c  e2800001          ADD      r0,r0,#1              ;1128
001840  e1560000          CMP      r6,r0                 ;1128
001844  baffffec          BLT      |L1.6140|
;;;1134           }
;;;1135         }
;;;1136   
;;;1137         // Some MCUs after running dcd_remote_wakeup() does not have way to detect the end of remote wakeup
;;;1138         // which last 1-15 ms. DCD can use SOF as a clear indicator that bus is back to operational
;;;1139         if ( _usbd_dev.suspended )
001848  e59f0888          LDR      r0,|L1.8408|
00184c  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_dev
001850  e1a00e80          LSL      r0,r0,#29
001854  e1a00fa0          LSR      r0,r0,#31
001858  e3500000          CMP      r0,#0
00185c  0a000021          BEQ      |L1.6376|
;;;1140         {
;;;1141           _usbd_dev.suspended = 0;
001860  e59f0870          LDR      r0,|L1.8408|
001864  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_dev
001868  e3c00004          BIC      r0,r0,#4
00186c  e59f1864          LDR      r1,|L1.8408|
001870  e5c10000          STRB     r0,[r1,#0]  ; _usbd_dev
;;;1142   
;;;1143           dcd_event_t const event_resume = { .rhport = event->rhport, .event_id = DCD_EVENT_RESUME };
001874  e59f2874          LDR      r2,|L1.8432|
001878  e8920007          LDM      r2,{r0-r2}  ; <Data8>, <Data8>, <Data8>
00187c  e88d0007          STM      sp,{r0-r2}
001880  e5d50000          LDRB     r0,[r5,#0]
001884  e5cd0000          STRB     r0,[sp,#0]
;;;1144           osal_queue_send(_usbd_q, &event_resume, in_isr);
001888  e59f0854          LDR      r0,|L1.8420|
00188c  e1a0700d          MOV      r7,sp
001890  e1a08004          MOV      r8,r4
001894  e5906000          LDR      r6,[r0,#0]  ; _usbd_q
001898  e5960004          LDR      r0,[r6,#4]
00189c  ef000001          SVC      #0x1
0018a0  e1a09000          MOV      r9,r0
0018a4  e1d620b2          LDRH     r2,[r6,#2]
0018a8  e1a01007          MOV      r1,r7
0018ac  e1a00009          MOV      r0,r9
0018b0  ebfffffe          BL       __aeabi_memcpy
0018b4  e3580000          CMP      r8,#0
0018b8  1a000004          BNE      |L1.6352|
0018bc  e5960008          LDR      r0,[r6,#8]
0018c0  e59f2820          LDR      r2,|L1.8424|
0018c4  e1a01009          MOV      r1,r9
0018c8  ebfffffe          BL       os_mbx_send
0018cc  ea000002          B        |L1.6364|
                  |L1.6352|
0018d0  e1a01009          MOV      r1,r9
0018d4  e5960008          LDR      r0,[r6,#8]
0018d8  ebfffffe          BL       isr_mbx_send
                  |L1.6364|
0018dc  e1a00000          MOV      r0,r0
0018e0  e1a00000          MOV      r0,r0
;;;1145         }
0018e4  e1a00000          MOV      r0,r0
                  |L1.6376|
;;;1146   
;;;1147         // skip osal queue for SOF in usbd task
;;;1148       break;
0018e8  ea000018          B        |L1.6480|
                  |L1.6380|
;;;1149   
;;;1150       default:
0018ec  e1a00000          MOV      r0,r0
;;;1151         osal_queue_send(_usbd_q, event, in_isr);
0018f0  e59f07ec          LDR      r0,|L1.8420|
0018f4  e1a07005          MOV      r7,r5
0018f8  e1a08004          MOV      r8,r4
0018fc  e5906000          LDR      r6,[r0,#0]  ; _usbd_q
001900  e5960004          LDR      r0,[r6,#4]
001904  ef000001          SVC      #0x1
001908  e1a09000          MOV      r9,r0
00190c  e1d620b2          LDRH     r2,[r6,#2]
001910  e1a01007          MOV      r1,r7
001914  e1a00009          MOV      r0,r9
001918  ebfffffe          BL       __aeabi_memcpy
00191c  e3580000          CMP      r8,#0
001920  1a000004          BNE      |L1.6456|
001924  e5960008          LDR      r0,[r6,#8]
001928  e59f27b8          LDR      r2,|L1.8424|
00192c  e1a01009          MOV      r1,r9
001930  ebfffffe          BL       os_mbx_send
001934  ea000002          B        |L1.6468|
                  |L1.6456|
001938  e1a01009          MOV      r1,r9
00193c  e5960008          LDR      r0,[r6,#8]
001940  ebfffffe          BL       isr_mbx_send
                  |L1.6468|
001944  e1a00000          MOV      r0,r0
001948  e1a00000          MOV      r0,r0
;;;1152       break;
00194c  e1a00000          MOV      r0,r0
                  |L1.6480|
001950  e1a00000          MOV      r0,r0                 ;1103
;;;1153     }
;;;1154   }
001954  e8bd83fe          POP      {r1-r9,pc}
;;;1155   
                          ENDP

                  usbd_int_set PROC
;;;1159   
;;;1160   void usbd_int_set(bool enabled)
001958  e92d4010          PUSH     {r4,lr}
;;;1161   {
00195c  e1a04000          MOV      r4,r0
;;;1162     if (enabled)
001960  e3540000          CMP      r4,#0
001964  0a000003          BEQ      |L1.6520|
;;;1163     {
;;;1164       dcd_int_enable(_usbd_rhport);
001968  e59f0784          LDR      r0,|L1.8436|
00196c  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_rhport
001970  ebfffffe          BL       dcd_int_enable
001974  ea000002          B        |L1.6532|
                  |L1.6520|
;;;1165     }else
;;;1166     {
;;;1167       dcd_int_disable(_usbd_rhport);
001978  e59f0774          LDR      r0,|L1.8436|
00197c  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_rhport
001980  ebfffffe          BL       dcd_int_disable
                  |L1.6532|
;;;1168     }
;;;1169   }
001984  e8bd8010          POP      {r4,pc}
;;;1170   
                          ENDP

                  usbd_edpt_open PROC
;;;1213   
;;;1214   bool usbd_edpt_open(uint8_t rhport, tusb_desc_endpoint_t const * desc_ep)
001988  e92d4070          PUSH     {r4-r6,lr}
;;;1215   {
00198c  e1a05000          MOV      r5,r0
001990  e1a04001          MOV      r4,r1
;;;1216     rhport = _usbd_rhport;
001994  e59f0758          LDR      r0,|L1.8436|
001998  e5d05000          LDRB     r5,[r0,#0]  ; _usbd_rhport
;;;1217   
;;;1218     TU_ASSERT(tu_edpt_number(desc_ep->bEndpointAddress) < CFG_TUD_ENDPPOINT_MAX);
00199c  e1a00000          MOV      r0,r0
0019a0  e5d40002          LDRB     r0,[r4,#2]
0019a4  e3c01080          BIC      r1,r0,#0x80
0019a8  e3510004          CMP      r1,#4
0019ac  ba000007          BLT      |L1.6608|
0019b0  e59f2740          LDR      r2,|L1.8440|
0019b4  e59f1740          LDR      r1,|L1.8444|
0019b8  e51f05a8          LDR      r0,|L1.5144|
0019bc  ebfffffe          BL       __2printf
0019c0  e1a00000          MOV      r0,r0
0019c4  e1a00000          MOV      r0,r0
0019c8  e3a00000          MOV      r0,#0
                  |L1.6604|
;;;1219     TU_ASSERT(tu_edpt_validate(desc_ep, (tusb_speed_t) _usbd_dev.speed));
;;;1220   
;;;1221     return dcd_edpt_open(rhport, desc_ep);
;;;1222   }
0019cc  e8bd8070          POP      {r4-r6,pc}
                  |L1.6608|
0019d0  e1a00000          MOV      r0,r0                 ;1218
0019d4  e1a00000          MOV      r0,r0                 ;1219
0019d8  e59f06f8          LDR      r0,|L1.8408|
0019dc  e5d01002          LDRB     r1,[r0,#2]            ;1219  ; _usbd_dev
0019e0  e1a00004          MOV      r0,r4                 ;1219
0019e4  ebfffffe          BL       tu_edpt_validate
0019e8  e3500000          CMP      r0,#0                 ;1219
0019ec  1a000007          BNE      |L1.6672|
0019f0  e59f2708          LDR      r2,|L1.8448|
0019f4  e59f1700          LDR      r1,|L1.8444|
0019f8  e51f05e8          LDR      r0,|L1.5144|
0019fc  ebfffffe          BL       __2printf
001a00  e1a00000          MOV      r0,r0                 ;1219
001a04  e1a00000          MOV      r0,r0                 ;1219
001a08  e3a00000          MOV      r0,#0                 ;1219
001a0c  eaffffee          B        |L1.6604|
                  |L1.6672|
001a10  e1a00000          MOV      r0,r0                 ;1219
001a14  e1a01004          MOV      r1,r4                 ;1221
001a18  e1a00005          MOV      r0,r5                 ;1221
001a1c  ebfffffe          BL       dcd_edpt_open
001a20  eaffffe9          B        |L1.6604|
;;;1223   
                          ENDP

                  usbd_open_edpt_pair PROC
;;;1171   // Parse consecutive endpoint descriptors (IN & OUT)
;;;1172   bool usbd_open_edpt_pair(uint8_t rhport, uint8_t const* p_desc, uint8_t ep_count, uint8_t xfer_type, uint8_t* ep_out, uint8_t* ep_in)
001a24  e92d5ff0          PUSH     {r4-r12,lr}
;;;1173   {
001a28  e1a09000          MOV      r9,r0
001a2c  e1a04001          MOV      r4,r1
001a30  e1a06002          MOV      r6,r2
001a34  e1a07003          MOV      r7,r3
001a38  e1cda2d8          LDRD     r10,r11,[sp,#0x28]
;;;1174     for(int i=0; i<ep_count; i++)
001a3c  e3a08000          MOV      r8,#0
001a40  ea000030          B        |L1.6920|
                  |L1.6724|
;;;1175     {
;;;1176       tusb_desc_endpoint_t const * desc_ep = (tusb_desc_endpoint_t const *) p_desc;
001a44  e1a05004          MOV      r5,r4
;;;1177   
;;;1178       TU_ASSERT(TUSB_DESC_ENDPOINT == desc_ep->bDescriptorType && xfer_type == desc_ep->bmAttributes.xfer);
001a48  e1a00000          MOV      r0,r0
001a4c  e5d50001          LDRB     r0,[r5,#1]
001a50  e3500005          CMP      r0,#5
001a54  1a000003          BNE      |L1.6760|
001a58  e5d50003          LDRB     r0,[r5,#3]
001a5c  e2000003          AND      r0,r0,#3
001a60  e1500007          CMP      r0,r7
001a64  0a000007          BEQ      |L1.6792|
                  |L1.6760|
001a68  e59f2694          LDR      r2,|L1.8452|
001a6c  e59f1694          LDR      r1,|L1.8456|
001a70  e51f0660          LDR      r0,|L1.5144|
001a74  ebfffffe          BL       __2printf
001a78  e1a00000          MOV      r0,r0
001a7c  e1a00000          MOV      r0,r0
001a80  e3a00000          MOV      r0,#0
                  |L1.6788|
;;;1179       TU_ASSERT(usbd_edpt_open(rhport, desc_ep));
;;;1180   
;;;1181       if ( tu_edpt_dir(desc_ep->bEndpointAddress) == TUSB_DIR_IN )
;;;1182       {
;;;1183         (*ep_in) = desc_ep->bEndpointAddress;
;;;1184       }else
;;;1185       {
;;;1186         (*ep_out) = desc_ep->bEndpointAddress;
;;;1187       }
;;;1188   
;;;1189       p_desc = tu_desc_next(p_desc);
;;;1190     }
;;;1191   
;;;1192     return true;
;;;1193   }
001a84  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.6792|
001a88  e1a00000          MOV      r0,r0                 ;1178
001a8c  e1a00000          MOV      r0,r0                 ;1179
001a90  e1a01005          MOV      r1,r5                 ;1179
001a94  e1a00009          MOV      r0,r9                 ;1179
001a98  ebfffffe          BL       usbd_edpt_open
001a9c  e3500000          CMP      r0,#0                 ;1179
001aa0  1a000007          BNE      |L1.6852|
001aa4  e59f2660          LDR      r2,|L1.8460|
001aa8  e59f1658          LDR      r1,|L1.8456|
001aac  e51f069c          LDR      r0,|L1.5144|
001ab0  ebfffffe          BL       __2printf
001ab4  e1a00000          MOV      r0,r0                 ;1179
001ab8  e1a00000          MOV      r0,r0                 ;1179
001abc  e3a00000          MOV      r0,#0                 ;1179
001ac0  eaffffef          B        |L1.6788|
                  |L1.6852|
001ac4  e1a00000          MOV      r0,r0                 ;1179
001ac8  e5d50002          LDRB     r0,[r5,#2]            ;1181
001acc  e2001080          AND      r1,r0,#0x80           ;1181
001ad0  e1a013a1          LSR      r1,r1,#7              ;1181
001ad4  e3510000          CMP      r1,#0                 ;1181
001ad8  0a000002          BEQ      |L1.6888|
001adc  e5d50002          LDRB     r0,[r5,#2]            ;1183
001ae0  e5cb0000          STRB     r0,[r11,#0]           ;1183
001ae4  ea000001          B        |L1.6896|
                  |L1.6888|
001ae8  e5d50002          LDRB     r0,[r5,#2]            ;1186
001aec  e5ca0000          STRB     r0,[r10,#0]           ;1186
                  |L1.6896|
001af0  e1a00004          MOV      r0,r4                 ;1189
001af4  e1a01000          MOV      r1,r0                 ;1189
001af8  e5d12000          LDRB     r2,[r1,#0]            ;1189
001afc  e0822001          ADD      r2,r2,r1              ;1189
001b00  e1a04002          MOV      r4,r2                 ;1189
001b04  e2888001          ADD      r8,r8,#1              ;1174
                  |L1.6920|
001b08  e1580006          CMP      r8,r6                 ;1174
001b0c  baffffcc          BLT      |L1.6724|
001b10  e3a00001          MOV      r0,#1                 ;1192
001b14  eaffffda          B        |L1.6788|
;;;1194   
                          ENDP

                  usbd_defer_func PROC
;;;1195   // Helper to defer an isr function
;;;1196   void usbd_defer_func(osal_task_func_t func, void* param, bool in_isr)
001b18  e92d40fe          PUSH     {r1-r7,lr}
;;;1197   {
001b1c  e1a06000          MOV      r6,r0
001b20  e1a04001          MOV      r4,r1
001b24  e1a05002          MOV      r5,r2
;;;1198     dcd_event_t event =
001b28  e59f25e0          LDR      r2,|L1.8464|
001b2c  e8920007          LDM      r2,{r0-r2}  ; <Data9>, <Data9>, <Data9>
001b30  e88d0007          STM      sp,{r0-r2}
;;;1199     {
;;;1200         .rhport   = 0,
;;;1201         .event_id = USBD_EVENT_FUNC_CALL,
;;;1202     };
;;;1203   
;;;1204     event.func_call.func  = func;
001b34  e58d6004          STR      r6,[sp,#4]
;;;1205     event.func_call.param = param;
001b38  e58d4008          STR      r4,[sp,#8]
;;;1206   
;;;1207     dcd_event_handler(&event, in_isr);
001b3c  e1a01005          MOV      r1,r5
001b40  e1a0000d          MOV      r0,sp
001b44  ebfffffe          BL       dcd_event_handler
;;;1208   }
001b48  e8bd80fe          POP      {r1-r7,pc}
;;;1209   
                          ENDP

                  usbd_edpt_claim PROC
;;;1223   
;;;1224   bool usbd_edpt_claim(uint8_t rhport, uint8_t ep_addr)
001b4c  e92d41f0          PUSH     {r4-r8,lr}
;;;1225   {
001b50  e1a08000          MOV      r8,r0
001b54  e1a04001          MOV      r4,r1
;;;1226     (void) rhport;
;;;1227   
;;;1228     // TODO add this check later, also make sure we don't starve an out endpoint while suspending
;;;1229     // TU_VERIFY(tud_ready());
;;;1230   
;;;1231     uint8_t const epnum       = tu_edpt_number(ep_addr);
001b58  e1a00000          MOV      r0,r0
001b5c  e3c40080          BIC      r0,r4,#0x80
001b60  e1a05000          MOV      r5,r0
;;;1232     uint8_t const dir         = tu_edpt_dir(ep_addr);
001b64  e1a00000          MOV      r0,r0
001b68  e2040080          AND      r0,r4,#0x80
001b6c  e1a003a0          LSR      r0,r0,#7
001b70  e1a06000          MOV      r6,r0
;;;1233     tu_edpt_state_t* ep_state = &_usbd_dev.ep_status[epnum][dir];
001b74  e51f0784          LDR      r0,|L1.5112|
001b78  e0800085          ADD      r0,r0,r5,LSL #1
001b7c  e0807006          ADD      r7,r0,r6
;;;1234   
;;;1235     return tu_edpt_claim(ep_state, _usbd_mutex);
001b80  e59f058c          LDR      r0,|L1.8468|
001b84  e5901000          LDR      r1,[r0,#0]  ; _usbd_mutex
001b88  e1a00007          MOV      r0,r7
001b8c  ebfffffe          BL       tu_edpt_claim
;;;1236   }
001b90  e8bd81f0          POP      {r4-r8,pc}
;;;1237   
                          ENDP

                  usbd_edpt_release PROC
;;;1238   bool usbd_edpt_release(uint8_t rhport, uint8_t ep_addr)
001b94  e92d41f0          PUSH     {r4-r8,lr}
;;;1239   {
001b98  e1a08000          MOV      r8,r0
001b9c  e1a04001          MOV      r4,r1
;;;1240     (void) rhport;
;;;1241   
;;;1242     uint8_t const epnum       = tu_edpt_number(ep_addr);
001ba0  e1a00000          MOV      r0,r0
001ba4  e3c40080          BIC      r0,r4,#0x80
001ba8  e1a05000          MOV      r5,r0
;;;1243     uint8_t const dir         = tu_edpt_dir(ep_addr);
001bac  e1a00000          MOV      r0,r0
001bb0  e2040080          AND      r0,r4,#0x80
001bb4  e1a003a0          LSR      r0,r0,#7
001bb8  e1a06000          MOV      r6,r0
;;;1244     tu_edpt_state_t* ep_state = &_usbd_dev.ep_status[epnum][dir];
001bbc  e51f07cc          LDR      r0,|L1.5112|
001bc0  e0800085          ADD      r0,r0,r5,LSL #1
001bc4  e0807006          ADD      r7,r0,r6
;;;1245   
;;;1246     return tu_edpt_release(ep_state, _usbd_mutex);
001bc8  e59f0544          LDR      r0,|L1.8468|
001bcc  e5901000          LDR      r1,[r0,#0]  ; _usbd_mutex
001bd0  e1a00007          MOV      r0,r7
001bd4  ebfffffe          BL       tu_edpt_release
;;;1247   }
001bd8  e8bd81f0          POP      {r4-r8,pc}
;;;1248   
                          ENDP

                  usbd_edpt_xfer PROC
;;;1249   bool usbd_edpt_xfer(uint8_t rhport, uint8_t ep_addr, uint8_t * buffer, uint16_t total_bytes)
001bdc  e92d47f0          PUSH     {r4-r10,lr}
;;;1250   {
001be0  e1a07000          MOV      r7,r0
001be4  e1a06001          MOV      r6,r1
001be8  e1a08002          MOV      r8,r2
001bec  e1a09003          MOV      r9,r3
;;;1251     rhport = _usbd_rhport;
001bf0  e59f04fc          LDR      r0,|L1.8436|
001bf4  e5d07000          LDRB     r7,[r0,#0]  ; _usbd_rhport
;;;1252   
;;;1253     uint8_t const epnum = tu_edpt_number(ep_addr);
001bf8  e1a00000          MOV      r0,r0
001bfc  e3c60080          BIC      r0,r6,#0x80
001c00  e1a04000          MOV      r4,r0
;;;1254     uint8_t const dir   = tu_edpt_dir(ep_addr);
001c04  e1a00000          MOV      r0,r0
001c08  e2060080          AND      r0,r6,#0x80
001c0c  e1a003a0          LSR      r0,r0,#7
001c10  e1a05000          MOV      r5,r0
;;;1255   
;;;1256     // TODO skip ready() check for now since enumeration also use this API
;;;1257     // TU_VERIFY(tud_ready());
;;;1258   
;;;1259     TU_LOG(USBD_DBG, "  Queue EP %02X with %u bytes ...\r\n", ep_addr, total_bytes);
;;;1260   
;;;1261     // Attempt to transfer on a busy endpoint, sound like an race condition !
;;;1262     TU_ASSERT(_usbd_dev.ep_status[epnum][dir].busy == 0);
001c14  e1a00000          MOV      r0,r0
001c18  e51f0828          LDR      r0,|L1.5112|
001c1c  e0800084          ADD      r0,r0,r4,LSL #1
001c20  e7d00005          LDRB     r0,[r0,r5]
001c24  e2000001          AND      r0,r0,#1
001c28  e3500000          CMP      r0,#0
001c2c  0a000007          BEQ      |L1.7248|
001c30  e59f24e0          LDR      r2,|L1.8472|
001c34  e59f14e0          LDR      r1,|L1.8476|
001c38  e51f0828          LDR      r0,|L1.5144|
001c3c  ebfffffe          BL       __2printf
001c40  e1a00000          MOV      r0,r0
001c44  e1a00000          MOV      r0,r0
001c48  e3a00000          MOV      r0,#0
                  |L1.7244|
;;;1263   
;;;1264     // Set busy first since the actual transfer can be complete before dcd_edpt_xfer()
;;;1265     // could return and USBD task can preempt and clear the busy
;;;1266     _usbd_dev.ep_status[epnum][dir].busy = 1;
;;;1267   
;;;1268     if ( dcd_edpt_xfer(rhport, ep_addr, buffer, total_bytes) )
;;;1269     {
;;;1270       return true;
;;;1271     }else
;;;1272     {
;;;1273       // DCD error, mark endpoint as ready to allow next transfer
;;;1274       _usbd_dev.ep_status[epnum][dir].busy = 0;
;;;1275       _usbd_dev.ep_status[epnum][dir].claimed = 0;
;;;1276       TU_LOG(USBD_DBG, "FAILED\r\n");
;;;1277       TU_BREAKPOINT();
;;;1278       return false;
;;;1279     }
;;;1280   }
001c4c  e8bd87f0          POP      {r4-r10,pc}
                  |L1.7248|
001c50  e1a00000          MOV      r0,r0                 ;1262
001c54  e51f0864          LDR      r0,|L1.5112|
001c58  e0800084          ADD      r0,r0,r4,LSL #1       ;1266
001c5c  e7d00005          LDRB     r0,[r0,r5]            ;1266
001c60  e3800001          ORR      r0,r0,#1              ;1266
001c64  e51f1874          LDR      r1,|L1.5112|
001c68  e0811084          ADD      r1,r1,r4,LSL #1       ;1266
001c6c  e7c10005          STRB     r0,[r1,r5]            ;1266
001c70  e1a03009          MOV      r3,r9                 ;1268
001c74  e1a02008          MOV      r2,r8                 ;1268
001c78  e1a01006          MOV      r1,r6                 ;1268
001c7c  e1a00007          MOV      r0,r7                 ;1268
001c80  ebfffffe          BL       dcd_edpt_xfer
001c84  e3500000          CMP      r0,#0                 ;1268
001c88  0a000001          BEQ      |L1.7316|
001c8c  e3a00001          MOV      r0,#1                 ;1270
001c90  eaffffed          B        |L1.7244|
                  |L1.7316|
001c94  e51f08a4          LDR      r0,|L1.5112|
001c98  e0800084          ADD      r0,r0,r4,LSL #1       ;1274
001c9c  e7d00005          LDRB     r0,[r0,r5]            ;1274
001ca0  e3c00001          BIC      r0,r0,#1              ;1274
001ca4  e51f18b4          LDR      r1,|L1.5112|
001ca8  e0811084          ADD      r1,r1,r4,LSL #1       ;1274
001cac  e7c10005          STRB     r0,[r1,r5]            ;1274
001cb0  e51f08c0          LDR      r0,|L1.5112|
001cb4  e0800084          ADD      r0,r0,r4,LSL #1       ;1275
001cb8  e7d00005          LDRB     r0,[r0,r5]            ;1275
001cbc  e3c00004          BIC      r0,r0,#4              ;1275
001cc0  e51f18d0          LDR      r1,|L1.5112|
001cc4  e0811084          ADD      r1,r1,r4,LSL #1       ;1275
001cc8  e7c10005          STRB     r0,[r1,r5]            ;1275
001ccc  e1a00000          MOV      r0,r0                 ;1277
001cd0  e1a00000          MOV      r0,r0                 ;1277
001cd4  e3a00000          MOV      r0,#0                 ;1278
001cd8  eaffffdb          B        |L1.7244|
;;;1281   
                          ENDP

                  usbd_edpt_xfer_fifo PROC
;;;1285   // into the USB buffer!
;;;1286   bool usbd_edpt_xfer_fifo(uint8_t rhport, uint8_t ep_addr, tu_fifo_t * ff, uint16_t total_bytes)
001cdc  e92d47f0          PUSH     {r4-r10,lr}
;;;1287   {
001ce0  e1a07000          MOV      r7,r0
001ce4  e1a06001          MOV      r6,r1
001ce8  e1a08002          MOV      r8,r2
001cec  e1a09003          MOV      r9,r3
;;;1288     rhport = _usbd_rhport;
001cf0  e59f03fc          LDR      r0,|L1.8436|
001cf4  e5d07000          LDRB     r7,[r0,#0]  ; _usbd_rhport
;;;1289   
;;;1290     uint8_t const epnum = tu_edpt_number(ep_addr);
001cf8  e1a00000          MOV      r0,r0
001cfc  e3c60080          BIC      r0,r6,#0x80
001d00  e1a04000          MOV      r4,r0
;;;1291     uint8_t const dir   = tu_edpt_dir(ep_addr);
001d04  e1a00000          MOV      r0,r0
001d08  e2060080          AND      r0,r6,#0x80
001d0c  e1a003a0          LSR      r0,r0,#7
001d10  e1a05000          MOV      r5,r0
;;;1292   
;;;1293     TU_LOG(USBD_DBG, "  Queue ISO EP %02X with %u bytes ... ", ep_addr, total_bytes);
;;;1294   
;;;1295     // Attempt to transfer on a busy endpoint, sound like an race condition !
;;;1296     TU_ASSERT(_usbd_dev.ep_status[epnum][dir].busy == 0);
001d14  e1a00000          MOV      r0,r0
001d18  e51f0928          LDR      r0,|L1.5112|
001d1c  e0800084          ADD      r0,r0,r4,LSL #1
001d20  e7d00005          LDRB     r0,[r0,r5]
001d24  e2000001          AND      r0,r0,#1
001d28  e3500000          CMP      r0,#0
001d2c  0a000007          BEQ      |L1.7504|
001d30  e3a02e51          MOV      r2,#0x510
001d34  e59f13e4          LDR      r1,|L1.8480|
001d38  e51f0928          LDR      r0,|L1.5144|
001d3c  ebfffffe          BL       __2printf
001d40  e1a00000          MOV      r0,r0
001d44  e1a00000          MOV      r0,r0
001d48  e3a00000          MOV      r0,#0
                  |L1.7500|
;;;1297   
;;;1298     // Set busy first since the actual transfer can be complete before dcd_edpt_xfer() could return
;;;1299     // and usbd task can preempt and clear the busy
;;;1300     _usbd_dev.ep_status[epnum][dir].busy = 1;
;;;1301   
;;;1302     if (dcd_edpt_xfer_fifo(rhport, ep_addr, ff, total_bytes))
;;;1303     {
;;;1304       TU_LOG(USBD_DBG, "OK\r\n");
;;;1305       return true;
;;;1306     }else
;;;1307     {
;;;1308       // DCD error, mark endpoint as ready to allow next transfer
;;;1309       _usbd_dev.ep_status[epnum][dir].busy = 0;
;;;1310       _usbd_dev.ep_status[epnum][dir].claimed = 0;
;;;1311       TU_LOG(USBD_DBG, "failed\r\n");
;;;1312       TU_BREAKPOINT();
;;;1313       return false;
;;;1314     }
;;;1315   }
001d4c  e8bd87f0          POP      {r4-r10,pc}
                  |L1.7504|
001d50  e1a00000          MOV      r0,r0                 ;1296
001d54  e51f0964          LDR      r0,|L1.5112|
001d58  e0800084          ADD      r0,r0,r4,LSL #1       ;1300
001d5c  e7d00005          LDRB     r0,[r0,r5]            ;1300
001d60  e3800001          ORR      r0,r0,#1              ;1300
001d64  e51f1974          LDR      r1,|L1.5112|
001d68  e0811084          ADD      r1,r1,r4,LSL #1       ;1300
001d6c  e7c10005          STRB     r0,[r1,r5]            ;1300
001d70  e1a03009          MOV      r3,r9                 ;1302
001d74  e1a02008          MOV      r2,r8                 ;1302
001d78  e1a01006          MOV      r1,r6                 ;1302
001d7c  e1a00007          MOV      r0,r7                 ;1302
001d80  ebfffffe          BL       dcd_edpt_xfer_fifo
001d84  e3500000          CMP      r0,#0                 ;1302
001d88  0a000001          BEQ      |L1.7572|
001d8c  e3a00001          MOV      r0,#1                 ;1305
001d90  eaffffed          B        |L1.7500|
                  |L1.7572|
001d94  e51f09a4          LDR      r0,|L1.5112|
001d98  e0800084          ADD      r0,r0,r4,LSL #1       ;1309
001d9c  e7d00005          LDRB     r0,[r0,r5]            ;1309
001da0  e3c00001          BIC      r0,r0,#1              ;1309
001da4  e51f19b4          LDR      r1,|L1.5112|
001da8  e0811084          ADD      r1,r1,r4,LSL #1       ;1309
001dac  e7c10005          STRB     r0,[r1,r5]            ;1309
001db0  e51f09c0          LDR      r0,|L1.5112|
001db4  e0800084          ADD      r0,r0,r4,LSL #1       ;1310
001db8  e7d00005          LDRB     r0,[r0,r5]            ;1310
001dbc  e3c00004          BIC      r0,r0,#4              ;1310
001dc0  e51f19d0          LDR      r1,|L1.5112|
001dc4  e0811084          ADD      r1,r1,r4,LSL #1       ;1310
001dc8  e7c10005          STRB     r0,[r1,r5]            ;1310
001dcc  e1a00000          MOV      r0,r0                 ;1312
001dd0  e1a00000          MOV      r0,r0                 ;1312
001dd4  e3a00000          MOV      r0,#0                 ;1313
001dd8  eaffffdb          B        |L1.7500|
;;;1316   
                          ENDP

                  usbd_edpt_busy PROC
;;;1317   bool usbd_edpt_busy(uint8_t rhport, uint8_t ep_addr)
001ddc  e1a0c000          MOV      r12,r0
;;;1318   {
;;;1319     (void) rhport;
;;;1320   
;;;1321     uint8_t const epnum = tu_edpt_number(ep_addr);
001de0  e1a00000          MOV      r0,r0
001de4  e3c10080          BIC      r0,r1,#0x80
001de8  e1a02000          MOV      r2,r0
;;;1322     uint8_t const dir   = tu_edpt_dir(ep_addr);
001dec  e1a00000          MOV      r0,r0
001df0  e2010080          AND      r0,r1,#0x80
001df4  e1a003a0          LSR      r0,r0,#7
001df8  e1a03000          MOV      r3,r0
;;;1323   
;;;1324     return _usbd_dev.ep_status[epnum][dir].busy;
001dfc  e51f0a0c          LDR      r0,|L1.5112|
001e00  e0800082          ADD      r0,r0,r2,LSL #1
001e04  e7d00003          LDRB     r0,[r0,r3]
001e08  e2000001          AND      r0,r0,#1
;;;1325   }
001e0c  e12fff1e          BX       lr
;;;1326   
                          ENDP

                  usbd_edpt_close PROC
;;;1376    */
;;;1377   void usbd_edpt_close(uint8_t rhport, uint8_t ep_addr)
001e10  e92d41f0          PUSH     {r4-r8,lr}
;;;1378   {
001e14  e1a07000          MOV      r7,r0
001e18  e1a06001          MOV      r6,r1
;;;1379     rhport = _usbd_rhport;
001e1c  e59f02d0          LDR      r0,|L1.8436|
001e20  e5d07000          LDRB     r7,[r0,#0]  ; _usbd_rhport
;;;1380   
;;;1381     TU_ASSERT(dcd_edpt_close, /**/);
001e24  e1a00000          MOV      r0,r0
001e28  e59f02f4          LDR      r0,|L1.8484|
001e2c  e3500000          CMP      r0,#0
001e30  1a000006          BNE      |L1.7760|
001e34  e59f22ec          LDR      r2,|L1.8488|
001e38  e59f12ec          LDR      r1,|L1.8492|
001e3c  e51f0a2c          LDR      r0,|L1.5144|
001e40  ebfffffe          BL       __2printf
001e44  e1a00000          MOV      r0,r0
001e48  e1a00000          MOV      r0,r0
                  |L1.7756|
;;;1382     TU_LOG(USBD_DBG, "  CLOSING Endpoint: 0x%02X\r\n", ep_addr);
;;;1383   
;;;1384     uint8_t const epnum = tu_edpt_number(ep_addr);
;;;1385     uint8_t const dir   = tu_edpt_dir(ep_addr);
;;;1386   
;;;1387     dcd_edpt_close(rhport, ep_addr);
;;;1388     _usbd_dev.ep_status[epnum][dir].stalled = 0;
;;;1389     _usbd_dev.ep_status[epnum][dir].busy = 0;
;;;1390     _usbd_dev.ep_status[epnum][dir].claimed = 0;
;;;1391   
;;;1392     return;
;;;1393   }
001e4c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.7760|
001e50  e1a00000          MOV      r0,r0                 ;1381
001e54  e1a00000          MOV      r0,r0                 ;1384
001e58  e3c64080          BIC      r4,r6,#0x80           ;1384
001e5c  e1a00000          MOV      r0,r0                 ;1384
001e60  e1a00000          MOV      r0,r0                 ;1385
001e64  e2060080          AND      r0,r6,#0x80           ;1385
001e68  e1a053a0          LSR      r5,r0,#7              ;1385
001e6c  e1a00000          MOV      r0,r0                 ;1385
001e70  e1a01006          MOV      r1,r6                 ;1387
001e74  e1a00007          MOV      r0,r7                 ;1387
001e78  ebfffffe          BL       dcd_edpt_close
001e7c  e51f0a8c          LDR      r0,|L1.5112|
001e80  e0800084          ADD      r0,r0,r4,LSL #1       ;1388
001e84  e7d00005          LDRB     r0,[r0,r5]            ;1388
001e88  e3c00002          BIC      r0,r0,#2              ;1388
001e8c  e51f1a9c          LDR      r1,|L1.5112|
001e90  e0811084          ADD      r1,r1,r4,LSL #1       ;1388
001e94  e7c10005          STRB     r0,[r1,r5]            ;1388
001e98  e51f0aa8          LDR      r0,|L1.5112|
001e9c  e0800084          ADD      r0,r0,r4,LSL #1       ;1389
001ea0  e7d00005          LDRB     r0,[r0,r5]            ;1389
001ea4  e3c00001          BIC      r0,r0,#1              ;1389
001ea8  e51f1ab8          LDR      r1,|L1.5112|
001eac  e0811084          ADD      r1,r1,r4,LSL #1       ;1389
001eb0  e7c10005          STRB     r0,[r1,r5]            ;1389
001eb4  e51f0ac4          LDR      r0,|L1.5112|
001eb8  e0800084          ADD      r0,r0,r4,LSL #1       ;1390
001ebc  e7d00005          LDRB     r0,[r0,r5]            ;1390
001ec0  e3c00004          BIC      r0,r0,#4              ;1390
001ec4  e51f1ad4          LDR      r1,|L1.5112|
001ec8  e0811084          ADD      r1,r1,r4,LSL #1       ;1390
001ecc  e7c10005          STRB     r0,[r1,r5]            ;1390
001ed0  e1a00000          MOV      r0,r0                 ;1392
001ed4  eaffffdc          B        |L1.7756|
;;;1394   
                          ENDP

                  usbd_sof_enable PROC
;;;1395   void usbd_sof_enable(uint8_t rhport, bool en)
001ed8  e92d4070          PUSH     {r4-r6,lr}
;;;1396   {
001edc  e1a04000          MOV      r4,r0
001ee0  e1a05001          MOV      r5,r1
;;;1397     rhport = _usbd_rhport;
001ee4  e59f0208          LDR      r0,|L1.8436|
001ee8  e5d04000          LDRB     r4,[r0,#0]  ; _usbd_rhport
;;;1398   
;;;1399     // TODO: Check needed if all drivers including the user sof_cb does not need an active SOF ISR any more.
;;;1400     // Only if all drivers switched off SOF calls the SOF interrupt may be disabled
;;;1401     dcd_sof_enable(rhport, en);
001eec  e1a01005          MOV      r1,r5
001ef0  e1a00004          MOV      r0,r4
001ef4  ebfffffe          BL       dcd_sof_enable
;;;1402   }
001ef8  e8bd8070          POP      {r4-r6,pc}
;;;1403   
                          ENDP

                  usbd_edpt_iso_alloc PROC
;;;1404   bool usbd_edpt_iso_alloc(uint8_t rhport, uint8_t ep_addr, uint16_t largest_packet_size)
001efc  e92d4070          PUSH     {r4-r6,lr}
;;;1405   {
001f00  e1a05000          MOV      r5,r0
001f04  e1a04001          MOV      r4,r1
001f08  e1a06002          MOV      r6,r2
;;;1406     rhport = _usbd_rhport;
001f0c  e59f01e0          LDR      r0,|L1.8436|
001f10  e5d05000          LDRB     r5,[r0,#0]  ; _usbd_rhport
;;;1407   
;;;1408     TU_ASSERT(dcd_edpt_iso_alloc);
001f14  e1a00000          MOV      r0,r0
001f18  e59f0210          LDR      r0,|L1.8496|
001f1c  e3500000          CMP      r0,#0
001f20  1a000007          BNE      |L1.8004|
001f24  e3a02d16          MOV      r2,#0x580
001f28  e59f1204          LDR      r1,|L1.8500|
001f2c  e51f0b1c          LDR      r0,|L1.5144|
001f30  ebfffffe          BL       __2printf
001f34  e1a00000          MOV      r0,r0
001f38  e1a00000          MOV      r0,r0
001f3c  e3a00000          MOV      r0,#0
                  |L1.8000|
;;;1409     TU_ASSERT(tu_edpt_number(ep_addr) < CFG_TUD_ENDPPOINT_MAX);
;;;1410   
;;;1411     return dcd_edpt_iso_alloc(rhport, ep_addr, largest_packet_size);
;;;1412   }
001f40  e8bd8070          POP      {r4-r6,pc}
                  |L1.8004|
001f44  e1a00000          MOV      r0,r0                 ;1408
001f48  e1a00000          MOV      r0,r0                 ;1409
001f4c  e1a00000          MOV      r0,r0                 ;1409
001f50  e3c40080          BIC      r0,r4,#0x80           ;1409
001f54  e3500004          CMP      r0,#4                 ;1409
001f58  ba000007          BLT      |L1.8060|
001f5c  e59f21d4          LDR      r2,|L1.8504|
001f60  e59f11cc          LDR      r1,|L1.8500|
001f64  e51f0b54          LDR      r0,|L1.5144|
001f68  ebfffffe          BL       __2printf
001f6c  e1a00000          MOV      r0,r0                 ;1409
001f70  e1a00000          MOV      r0,r0                 ;1409
001f74  e3a00000          MOV      r0,#0                 ;1409
001f78  eafffff0          B        |L1.8000|
                  |L1.8060|
001f7c  e1a00000          MOV      r0,r0                 ;1409
001f80  e1a02006          MOV      r2,r6                 ;1411
001f84  e1a01004          MOV      r1,r4                 ;1411
001f88  e1a00005          MOV      r0,r5                 ;1411
001f8c  ebfffffe          BL       dcd_edpt_iso_alloc
001f90  eaffffea          B        |L1.8000|
;;;1413   
                          ENDP

                  usbd_edpt_iso_activate PROC
;;;1414   bool usbd_edpt_iso_activate(uint8_t rhport, tusb_desc_endpoint_t const * desc_ep)
001f94  e92d41f0          PUSH     {r4-r8,lr}
;;;1415   {
001f98  e1a07000          MOV      r7,r0
001f9c  e1a06001          MOV      r6,r1
;;;1416     rhport = _usbd_rhport;
001fa0  e59f014c          LDR      r0,|L1.8436|
001fa4  e5d07000          LDRB     r7,[r0,#0]  ; _usbd_rhport
;;;1417   
;;;1418     uint8_t const epnum = tu_edpt_number(desc_ep->bEndpointAddress);
001fa8  e5d60002          LDRB     r0,[r6,#2]
001fac  e3c01080          BIC      r1,r0,#0x80
001fb0  e1a04001          MOV      r4,r1
;;;1419     uint8_t const dir   = tu_edpt_dir(desc_ep->bEndpointAddress);
001fb4  e5d60002          LDRB     r0,[r6,#2]
001fb8  e2001080          AND      r1,r0,#0x80
001fbc  e1a013a1          LSR      r1,r1,#7
001fc0  e1a05001          MOV      r5,r1
;;;1420   
;;;1421     TU_ASSERT(dcd_edpt_iso_activate);
001fc4  e1a00000          MOV      r0,r0
001fc8  e59f016c          LDR      r0,|L1.8508|
001fcc  e3500000          CMP      r0,#0
001fd0  1a000007          BNE      |L1.8180|
001fd4  e59f2164          LDR      r2,|L1.8512|
001fd8  e59f1164          LDR      r1,|L1.8516|
001fdc  e51f0bcc          LDR      r0,|L1.5144|
001fe0  ebfffffe          BL       __2printf
001fe4  e1a00000          MOV      r0,r0
001fe8  e1a00000          MOV      r0,r0
001fec  e3a00000          MOV      r0,#0
                  |L1.8176|
;;;1422     TU_ASSERT(epnum < CFG_TUD_ENDPPOINT_MAX);
;;;1423     TU_ASSERT(tu_edpt_validate(desc_ep, (tusb_speed_t) _usbd_dev.speed));
;;;1424   
;;;1425     _usbd_dev.ep_status[epnum][dir].stalled = 0;
;;;1426     _usbd_dev.ep_status[epnum][dir].busy = 0;
;;;1427     _usbd_dev.ep_status[epnum][dir].claimed = 0;
;;;1428     return dcd_edpt_iso_activate(rhport, desc_ep);
;;;1429   }
001ff0  e8bd81f0          POP      {r4-r8,pc}
                  |L1.8180|
001ff4  e1a00000          MOV      r0,r0                 ;1421
001ff8  e1a00000          MOV      r0,r0                 ;1422
001ffc  e3540004          CMP      r4,#4                 ;1422
002000  ba000007          BLT      |L1.8228|
002004  e59f213c          LDR      r2,|L1.8520|
002008  e59f1134          LDR      r1,|L1.8516|
00200c  e51f0bfc          LDR      r0,|L1.5144|
002010  ebfffffe          BL       __2printf
002014  e1a00000          MOV      r0,r0                 ;1422
002018  e1a00000          MOV      r0,r0                 ;1422
00201c  e3a00000          MOV      r0,#0                 ;1422
002020  eafffff2          B        |L1.8176|
                  |L1.8228|
002024  e1a00000          MOV      r0,r0                 ;1422
002028  e1a00000          MOV      r0,r0                 ;1423
00202c  e59f00a4          LDR      r0,|L1.8408|
002030  e5d01002          LDRB     r1,[r0,#2]            ;1423  ; _usbd_dev
002034  e1a00006          MOV      r0,r6                 ;1423
002038  ebfffffe          BL       tu_edpt_validate
00203c  e3500000          CMP      r0,#0                 ;1423
002040  1a000007          BNE      |L1.8292|
002044  e59f2100          LDR      r2,|L1.8524|
002048  e59f10f4          LDR      r1,|L1.8516|
00204c  e51f0c3c          LDR      r0,|L1.5144|
002050  ebfffffe          BL       __2printf
002054  e1a00000          MOV      r0,r0                 ;1423
002058  e1a00000          MOV      r0,r0                 ;1423
00205c  e3a00000          MOV      r0,#0                 ;1423
002060  eaffffe2          B        |L1.8176|
                  |L1.8292|
002064  e1a00000          MOV      r0,r0                 ;1423
002068  e51f0c78          LDR      r0,|L1.5112|
00206c  e0800084          ADD      r0,r0,r4,LSL #1       ;1425
002070  e7d00005          LDRB     r0,[r0,r5]            ;1425
002074  e3c00002          BIC      r0,r0,#2              ;1425
002078  e51f1c88          LDR      r1,|L1.5112|
00207c  e0811084          ADD      r1,r1,r4,LSL #1       ;1425
002080  e7c10005          STRB     r0,[r1,r5]            ;1425
002084  e51f0c94          LDR      r0,|L1.5112|
002088  e0800084          ADD      r0,r0,r4,LSL #1       ;1426
00208c  e7d00005          LDRB     r0,[r0,r5]            ;1426
002090  e3c00001          BIC      r0,r0,#1              ;1426
002094  e51f1ca4          LDR      r1,|L1.5112|
002098  e0811084          ADD      r1,r1,r4,LSL #1       ;1426
00209c  e7c10005          STRB     r0,[r1,r5]            ;1426
0020a0  e51f0cb0          LDR      r0,|L1.5112|
0020a4  e0800084          ADD      r0,r0,r4,LSL #1       ;1427
0020a8  e7d00005          LDRB     r0,[r0,r5]            ;1427
0020ac  e3c00004          BIC      r0,r0,#4              ;1427
0020b0  e51f1cc0          LDR      r1,|L1.5112|
0020b4  e0811084          ADD      r1,r1,r4,LSL #1       ;1427
0020b8  e7c10005          STRB     r0,[r1,r5]            ;1427
0020bc  e1a01006          MOV      r1,r6                 ;1428
0020c0  e1a00007          MOV      r0,r7                 ;1428
0020c4  ebfffffe          BL       dcd_edpt_iso_activate
0020c8  eaffffc8          B        |L1.8176|
;;;1430   
                          ENDP

                  |L1.8396|
                          DCD      _usbd_dev+0x13
                  |L1.8400|
                          DCD      0x0000023b
                  |L1.8404|
                          DCD      |symbol_number.18|
                  |L1.8408|
                          DCD      _usbd_dev
                  |L1.8412|
                          DCD      tud_suspend_cb
                  |L1.8416|
                          DCD      tud_resume_cb
                  |L1.8420|
                          DCD      _usbd_q
                  |L1.8424|
                          DCD      0x0000ffff
                  |L1.8428|
                          DCD      _app_driver_count
                  |L1.8432|
                          DCD      ||.constdata||+0x84
                  |L1.8436|
                          DCD      _usbd_rhport
                  |L1.8440|
                          DCD      0x000004c2
                  |L1.8444|
                          DCD      |symbol_number.23|
                  |L1.8448|
                          DCD      0x000004c3
                  |L1.8452|
                          DCD      0x0000049a
                  |L1.8456|
                          DCD      |symbol_number.22|
                  |L1.8460|
                          DCD      0x0000049b
                  |L1.8464|
                          DCD      ||.constdata||+0xa4
                  |L1.8468|
                          DCD      _usbd_mutex
                  |L1.8472|
                          DCD      0x000004ee
                  |L1.8476|
                          DCD      |symbol_number.24|
                  |L1.8480|
                          DCD      |symbol_number.25|
                  |L1.8484|
                          DCD      dcd_edpt_close
                  |L1.8488|
                          DCD      0x00000565
                  |L1.8492|
                          DCD      |symbol_number.26|
                  |L1.8496|
                          DCD      dcd_edpt_iso_alloc
                  |L1.8500|
                          DCD      |symbol_number.27|
                  |L1.8504|
                          DCD      0x00000581
                  |L1.8508|
                          DCD      dcd_edpt_iso_activate
                  |L1.8512|
                          DCD      0x0000058d
                  |L1.8516|
                          DCD      |symbol_number.28|
                  |L1.8520|
                          DCD      0x0000058e
                  |L1.8524|
                          DCD      0x0000058f

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  _usbd_dev
                          %        36
                  _usbd_qdef__mbox
                          %        80
                  _usbd_qdef__pool
                          %        204
                  _ubsd_mutexdef
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  _usbd_driver
                          DCD      videod_init
                          DCD      videod_reset
                          DCD      videod_open
                          DCD      videod_control_xfer_cb
                          DCD      videod_xfer_cb
                          DCD      0x00000000
                  __func__
000018  7475645f          DCB      0x74,0x75,0x64,0x5f
00001c  696e6974          DCB      0x69,0x6e,0x69,0x74
000020  00                DCB      0x00
                  |symbol_number.17|
000021  636f6e            DCB      0x63,0x6f,0x6e
000024  66696775          DCB      0x66,0x69,0x67,0x75
000028  72617469          DCB      0x72,0x61,0x74,0x69
00002c  6f6e5f72          DCB      0x6f,0x6e,0x5f,0x72
000030  65736574          DCB      0x65,0x73,0x65,0x74
000034  00                DCB      0x00
                  |symbol_number.18|
000035  747564            DCB      0x74,0x75,0x64
000038  5f746173          DCB      0x5f,0x74,0x61,0x73
00003c  6b5f6578          DCB      0x6b,0x5f,0x65,0x78
000040  7400              DCB      0x74,0x00
                  |symbol_number.19|
000042  7072              DCB      0x70,0x72
000044  6f636573          DCB      0x6f,0x63,0x65,0x73
000048  735f636f          DCB      0x73,0x5f,0x63,0x6f
00004c  6e74726f          DCB      0x6e,0x74,0x72,0x6f
000050  6c5f7265          DCB      0x6c,0x5f,0x72,0x65
000054  71756573          DCB      0x71,0x75,0x65,0x73
000058  7400              DCB      0x74,0x00
                  |symbol_number.20|
00005a  7072              DCB      0x70,0x72
00005c  6f636573          DCB      0x6f,0x63,0x65,0x73
000060  735f7365          DCB      0x73,0x5f,0x73,0x65
000064  745f636f          DCB      0x74,0x5f,0x63,0x6f
000068  6e666967          DCB      0x6e,0x66,0x69,0x67
00006c  00                DCB      0x00
                  |symbol_number.21|
00006d  70726f            DCB      0x70,0x72,0x6f
000070  63657373          DCB      0x63,0x65,0x73,0x73
000074  5f676574          DCB      0x5f,0x67,0x65,0x74
000078  5f646573          DCB      0x5f,0x64,0x65,0x73
00007c  63726970          DCB      0x63,0x72,0x69,0x70
000080  746f7200          DCB      0x74,0x6f,0x72,0x00
000084  00050000          DCB      0x00,0x05,0x00,0x00
                          %        8
                  |symbol_number.22|
000090  75736264          DCB      0x75,0x73,0x62,0x64
000094  5f6f7065          DCB      0x5f,0x6f,0x70,0x65
000098  6e5f6564          DCB      0x6e,0x5f,0x65,0x64
00009c  70745f70          DCB      0x70,0x74,0x5f,0x70
0000a0  61697200          DCB      0x61,0x69,0x72,0x00
0000a4  00080000          DCB      0x00,0x08,0x00,0x00
                          %        8
                  |symbol_number.23|
0000b0  75736264          DCB      0x75,0x73,0x62,0x64
0000b4  5f656470          DCB      0x5f,0x65,0x64,0x70
0000b8  745f6f70          DCB      0x74,0x5f,0x6f,0x70
0000bc  656e00            DCB      0x65,0x6e,0x00
                  |symbol_number.24|
0000bf  75                DCB      0x75
0000c0  7362645f          DCB      0x73,0x62,0x64,0x5f
0000c4  65647074          DCB      0x65,0x64,0x70,0x74
0000c8  5f786665          DCB      0x5f,0x78,0x66,0x65
0000cc  7200              DCB      0x72,0x00
                  |symbol_number.25|
0000ce  7573              DCB      0x75,0x73
0000d0  62645f65          DCB      0x62,0x64,0x5f,0x65
0000d4  6470745f          DCB      0x64,0x70,0x74,0x5f
0000d8  78666572          DCB      0x78,0x66,0x65,0x72
0000dc  5f666966          DCB      0x5f,0x66,0x69,0x66
0000e0  6f00              DCB      0x6f,0x00
                  |symbol_number.26|
0000e2  7573              DCB      0x75,0x73
0000e4  62645f65          DCB      0x62,0x64,0x5f,0x65
0000e8  6470745f          DCB      0x64,0x70,0x74,0x5f
0000ec  636c6f73          DCB      0x63,0x6c,0x6f,0x73
0000f0  6500              DCB      0x65,0x00
                  |symbol_number.27|
0000f2  7573              DCB      0x75,0x73
0000f4  62645f65          DCB      0x62,0x64,0x5f,0x65
0000f8  6470745f          DCB      0x64,0x70,0x74,0x5f
0000fc  69736f5f          DCB      0x69,0x73,0x6f,0x5f
000100  616c6c6f          DCB      0x61,0x6c,0x6c,0x6f
000104  6300              DCB      0x63,0x00
                  |symbol_number.28|
000106  7573              DCB      0x75,0x73
000108  62645f65          DCB      0x62,0x64,0x5f,0x65
00010c  6470745f          DCB      0x64,0x70,0x74,0x5f
000110  69736f5f          DCB      0x69,0x73,0x6f,0x5f
000114  61637469          DCB      0x61,0x63,0x74,0x69
000118  76617465          DCB      0x76,0x61,0x74,0x65
00011c  00                DCB      0x00

                          AREA ||.data||, DATA, ALIGN=2

                  _app_driver
                          DCD      0x00000000
                  _app_driver_count
000004  00                DCB      0x00
                  _usbd_rhport
000005  ff0000            DCB      0xff,0x00,0x00
                  _usbd_qdef
000008  0010000c          DCW      0x0010,0x000c
                          DCD      _usbd_qdef__pool
                          DCD      _usbd_qdef__mbox
                  _usbd_q
                          DCD      0x00000000
                  _usbd_mutex
                          DCD      0x00000000
