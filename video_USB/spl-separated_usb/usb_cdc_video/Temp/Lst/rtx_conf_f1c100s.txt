; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave --gnu -o.\temp\obj\rtx_conf_f1c100s.o --asm_dir=.\Temp\Lst\ --list_dir=.\Temp\Lst\ --depend=.\temp\obj\rtx_conf_f1c100s.d --cpu=ARM9E --apcs=interwork -O0 -Otime --diag_suppress=9931 -I.\users\include -I.\..\machine\include -I.\..\periph\include -I.\..\include -I.\..\emwin\Include -I.\..\tinyusb\src -I.\..\tinyusb\hw -I.\..\display -I.\..\lib\display_gfx -I.\..\lib\printf -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Atmel\SAM9260 -D__RTX -D__UVISION_VERSION=536 -DPCB_TINY200V1 -DCFG_TUSB_MCU=OPT_MCU_F1C100S -DCFG_TUSB_OS=OPT_OS_RTX4 --omf_browse=.\temp\obj\rtx_conf_f1c100s.crf ..\system\RTX_Conf_F1C100s.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  timer0_irq PROC
;;;163    
;;;164    static void timer0_irq(void)
000000  e92d4010          PUSH     {r4,lr}
;;;165    {
;;;166      if (read32(TIMER_REG_BASE + 0x04) & (1 << 0)) {
000004  e59f0430          LDR      r0,|L1.1084|
000008  ebfffffe          BL       read32
00000c  e2000001          AND      r0,r0,#1
000010  e3500000          CMP      r0,#0
000014  0a000002          BEQ      |L1.36|
;;;167        write32(TIMER_REG_BASE + 0x04, (1 << 0));
000018  e3a01001          MOV      r1,#1
00001c  e59f0418          LDR      r0,|L1.1084|
000020  ebfffffe          BL       write32
                  |L1.36|
;;;168      }
;;;169    }
000024  e8bd8010          POP      {r4,pc}
;;;170    
                          ENDP

                  os_def_interrupt PROC
                  ||__tagsym$$used||
;;;252    
;;;253    __irq void os_def_interrupt(void)
000028  e92d503f          PUSH     {r0-r5,r12,lr}
;;;254    {
;;;255      U8 nIRQ = backup_nirq;
00002c  e59f040c          LDR      r0,|L1.1088|
000030  e5d04000          LDRB     r4,[r0,#0]  ; backup_nirq
;;;256      f1c100s_intc_dispatch(nIRQ);
000034  e1a00004          MOV      r0,r4
000038  ebfffffe          BL       f1c100s_intc_dispatch
;;;257      f1c100s_intc_clear_pend(nIRQ);
00003c  e1a00004          MOV      r0,r4
000040  ebfffffe          BL       f1c100s_intc_clear_pend
;;;258    }
000044  e8bd503f          POP      {r0-r5,r12,lr}
000048  e25ef004          SUBS     pc,lr,#4
;;;259    
                          ENDP

                  os_idle_demon PROC
;;;262    
;;;263    __task void os_idle_demon(void)
00004c  e1a00000          MOV      r0,r0
                  |L1.80|
;;;264    {
;;;265      /* The idle demon is a system task, running when no other task is ready */
;;;266      /* to run. The 'os_xxx' function calls are not allowed from this task.  */
;;;267      for (;;) {
000050  eafffffe          B        |L1.80|
;;;268        /* HERE: include optional user code to be executed when no task runs.*/
;;;269        _idle_();
;;;270      }
;;;271    }
;;;272    
                          ENDP

                  os_error PROC
;;;291    
;;;292    void os_error(U32 err_code)
000054  e92d4010          PUSH     {r4,lr}
;;;293    {
000058  e1a04000          MOV      r4,r0
;;;294      /* This function is called when a runtime error is detected. */
;;;295      OS_TID err_task;
;;;296    
;;;297      switch (err_code) {
00005c  e3540001          CMP      r4,#1
000060  0a000004          BEQ      |L1.120|
000064  e3540002          CMP      r4,#2
000068  0a000005          BEQ      |L1.132|
00006c  e3540003          CMP      r4,#3
000070  1a000007          BNE      |L1.148|
000074  ea000004          B        |L1.140|
                  |L1.120|
;;;298        case OS_ERR_STK_OVF:
000078  e1a00000          MOV      r0,r0
;;;299          /* Identify the task with stack overflow. */
;;;300          err_task = isr_tsk_get();
00007c  ebfffffe          BL       os_tsk_self
;;;301          DBG_PRINT("\nOS_ERR_STK_OVF(%u)\n", err_task);
;;;302          break;
000080  ea000003          B        |L1.148|
                  |L1.132|
;;;303        case OS_ERR_FIFO_OVF:
000084  e1a00000          MOV      r0,r0
;;;304          (void)err_task;
;;;305          break;
000088  ea000001          B        |L1.148|
                  |L1.140|
;;;306        case OS_ERR_MBX_OVF:
00008c  e1a00000          MOV      r0,r0
;;;307          (void)err_task;
;;;308          break;
000090  e1a00000          MOV      r0,r0
                  |L1.148|
000094  e1a00000          MOV      r0,r0                 ;302
;;;309      }
;;;310      /* End-less loop */
;;;311      DBG_PRINT("\nos_error(%u)\n", err_code);
;;;312      //for (;;);
;;;313    }
000098  e8bd8010          POP      {r4,pc}
;;;314    
                          ENDP

                  UFX_PostTaskTimer PROC
;;;413    /* 在RTX的os_tmr_call()中调用即可 */
;;;414    void UFX_PostTaskTimer(U16 info)
00009c  e92d4070          PUSH     {r4-r6,lr}
;;;415    {
0000a0  e1a04000          MOV      r4,r0
;;;416      int nfree;
;;;417      CPU_SR_DECL;
;;;418    
;;;419      if (info > 0) {
0000a4  e3540000          CMP      r4,#0
0000a8  da000014          BLE      |L1.256|
;;;420        nfree = isr_mbx_check(&mb_tsktmr);
0000ac  e59f0390          LDR      r0,|L1.1092|
0000b0  ebfffffe          BL       os_mbx_check
0000b4  e1a05000          MOV      r5,r0
;;;421        if (nfree > 0) {
0000b8  e3550000          CMP      r5,#0
0000bc  da000003          BLE      |L1.208|
;;;422          // 发送定时器事件到定时器专用线程。
;;;423          isr_mbx_send(&mb_tsktmr, (void*)((1UL << 31) | info));
0000c0  e3841102          ORR      r1,r4,#0x80000000
0000c4  e59f0378          LDR      r0,|L1.1092|
0000c8  ebfffffe          BL       isr_mbx_send
0000cc  ea00000b          B        |L1.256|
                  |L1.208|
;;;424        } else {
;;;425          // 邮箱已满，只能丢弃该定时器事件。
;;;426          CPU_ENTER_CRITICAL();
0000d0  e1a00000          MOV      r0,r0
0000d4  ebfffffe          BL       __fast_enter_critical
0000d8  e1a06000          MOV      r6,r0
0000dc  e1a00000          MOV      r0,r0
;;;427          __hdl_free(info);
0000e0  e20400ff          AND      r0,r4,#0xff
0000e4  ebfffffe          BL       __hdl_free
;;;428          CPU_EXIT_CRITICAL();
0000e8  e1a00000          MOV      r0,r0
0000ec  e1a00006          MOV      r0,r6
0000f0  ebfffffe          BL       __fast_exit_critical
0000f4  e1a00000          MOV      r0,r0
;;;429          os_error(OS_ERR_MBX_OVF);
0000f8  e3a00003          MOV      r0,#3
0000fc  ebfffffe          BL       os_error
                  |L1.256|
;;;430        }
;;;431      }
;;;432    }
000100  e8bd8070          POP      {r4-r6,pc}
;;;433    
                          ENDP

                  os_tmr_call PROC
;;;277    #endif
;;;278    void os_tmr_call(U16 info)
000104  e92d4010          PUSH     {r4,lr}
;;;279    {
000108  e1a04000          MOV      r4,r0
;;;280      /* This function is called when the user timer has expired. Parameter   */
;;;281      /* 'info' holds the value, defined when the timer was created.          */
;;;282    
;;;283      /* HERE: include optional user code to be executed on timeout. */
;;;284    #if OS_TIMERCNT > 0
;;;285      UFX_PostTaskTimer(info);
00010c  e1a00004          MOV      r0,r4
000110  ebfffffe          BL       UFX_PostTaskTimer
;;;286    #endif
;;;287    }
000114  e8bd8010          POP      {r4,pc}
;;;288    
                          ENDP

                  __ThreadTimerWaiter PROC
;;;333    
;;;334    static __task void __ThreadTimerWaiter(void)
000118  e92d4008          PUSH     {r3,lr}
;;;335    {
;;;336      CPU_SR_DECL;
;;;337      void (*pfn)(void*);
;;;338      void* parg;
;;;339      U32 uival;
;;;340      U16 info;
;;;341      void* msg;
;;;342    
;;;343      for (;;) {
00011c  e1a00000          MOV      r0,r0
                  |L1.288|
;;;344        if (os_mbx_wait(&mb_tsktmr, &msg, TWAIT_FOREVER) != OS_R_TMO) {
000120  e59f2320          LDR      r2,|L1.1096|
000124  e1a0100d          MOV      r1,sp
000128  e59f0314          LDR      r0,|L1.1092|
00012c  ebfffffe          BL       os_mbx_wait
000130  e3500001          CMP      r0,#1
000134  0afffff9          BEQ      |L1.288|
;;;345          uival = (U32)msg;
000138  e59d6000          LDR      r6,[sp,#0]
;;;346          if (uival & (1UL << 31)) {
00013c  e2060102          AND      r0,r6,#0x80000000
000140  e3500000          CMP      r0,#0
000144  0afffff5          BEQ      |L1.288|
;;;347            info = (U16)uival;
000148  e1a04806          LSL      r4,r6,#16
00014c  e1a04824          LSR      r4,r4,#16
;;;348            if (info > 0) {
000150  e3540000          CMP      r4,#0
000154  dafffff1          BLE      |L1.288|
;;;349              parg = tsktmr_pool[info - 1].parg;
000158  e2440001          SUB      r0,r4,#1
00015c  e59f12e8          LDR      r1,|L1.1100|
000160  e7917180          LDR      r7,[r1,r0,LSL #3]
;;;350              pfn = tsktmr_pool[info - 1].pfn;
000164  e2440001          SUB      r0,r4,#1
000168  e0810180          ADD      r0,r1,r0,LSL #3
00016c  e5905004          LDR      r5,[r0,#4]
;;;351              CPU_ENTER_CRITICAL();
000170  e1a00000          MOV      r0,r0
000174  ebfffffe          BL       __fast_enter_critical
000178  e1a08000          MOV      r8,r0
00017c  e1a00000          MOV      r0,r0
;;;352              __hdl_free(info);
000180  e20400ff          AND      r0,r4,#0xff
000184  ebfffffe          BL       __hdl_free
;;;353              CPU_EXIT_CRITICAL();
000188  e1a00000          MOV      r0,r0
00018c  e1a00008          MOV      r0,r8
000190  ebfffffe          BL       __fast_exit_critical
000194  e1a00000          MOV      r0,r0
;;;354              if (pfn) {
000198  e3550000          CMP      r5,#0
00019c  0affffdf          BEQ      |L1.288|
;;;355                pfn(parg);
0001a0  e1a00007          MOV      r0,r7
0001a4  e12fff35          BLX      r5
0001a8  eaffffdc          B        |L1.288|
;;;356              }
;;;357            }
;;;358          }
;;;359        }
;;;360      }
;;;361    }
;;;362    
                          ENDP

                  UFX_SetupTaskTimer PROC
;;;363    /* 建立线程定时器的基础设施，该函数仅供BSP调用一次 */
;;;364    void UFX_SetupTaskTimer(void)
0001ac  e92d4070          PUSH     {r4-r6,lr}
;;;365    {
;;;366      static U64 __StackTimerWaiter[1024 / 8] MEM_PI_STACK;
;;;367      CPU_SR_DECL;
;;;368      OS_TID task_id;
;;;369    
;;;370      CPU_ENTER_CRITICAL();
0001b0  e1a00000          MOV      r0,r0
0001b4  ebfffffe          BL       __fast_enter_critical
0001b8  e1a05000          MOV      r5,r0
0001bc  e1a00000          MOV      r0,r0
;;;371      __hdl_pool_init();
0001c0  e1a00000          MOV      r0,r0
0001c4  e3a00000          MOV      r0,#0
0001c8  ea000003          B        |L1.476|
                  |L1.460|
0001cc  e2801001          ADD      r1,r0,#1
0001d0  e59f2278          LDR      r2,|L1.1104|
0001d4  e7c21000          STRB     r1,[r2,r0]
0001d8  e2800001          ADD      r0,r0,#1
                  |L1.476|
0001dc  e3500050          CMP      r0,#0x50
0001e0  3afffff9          BCC      |L1.460|
0001e4  e3a01000          MOV      r1,#0
0001e8  e59f2260          LDR      r2,|L1.1104|
0001ec  e7c21000          STRB     r1,[r2,r0]
0001f0  e1a00000          MOV      r0,r0
;;;372      CPU_EXIT_CRITICAL();
0001f4  e1a00000          MOV      r0,r0
0001f8  e1a00005          MOV      r0,r5
0001fc  ebfffffe          BL       __fast_exit_critical
000200  e1a00000          MOV      r0,r0
;;;373    
;;;374      os_mbx_init(&mb_tsktmr, sizeof(mb_tsktmr));
000204  e3a01e15          MOV      r1,#0x150
000208  e59f0234          LDR      r0,|L1.1092|
00020c  ebfffffe          BL       os_mbx_init
;;;375    
;;;376      task_id = os_tsk_create_user(
000210  e3a03000          MOV      r3,#0
000214  e59f2238          LDR      r2,|L1.1108|
000218  e59f1238          LDR      r1,|L1.1112|
00021c  e59f0238          LDR      r0,|L1.1116|
000220  ebfffffe          BL       os_tsk_create0
000224  e1a04000          MOV      r4,r0
;;;377                    __ThreadTimerWaiter,
;;;378                    TSK_PRIO_HIGHEST,
;;;379                    __StackTimerWaiter,
;;;380                    sizeof(__StackTimerWaiter));
;;;381    
;;;382      if (task_id == 0) {
000228  e3540000          CMP      r4,#0
00022c  1a000004          BNE      |L1.580|
;;;383        sys_suspend();
000230  e1a00000          MOV      r0,r0
000234  e59f020c          LDR      r0,|L1.1096|
000238  ebfffffe          BL       os_dly_wait
00023c  e1a00000          MOV      r0,r0
                  |L1.576|
;;;384        return;
;;;385      }
;;;386    }
000240  e8bd8070          POP      {r4-r6,pc}
                  |L1.580|
000244  e1a00000          MOV      r0,r0
000248  eafffffc          B        |L1.576|
;;;387    
                          ENDP

                  UFX_AddTaskTimer PROC
;;;388    /* 启动一个线程定时器 */
;;;389    bool_t UFX_AddTaskTimer(U16 dly, void (*pfn)(void*), void* parg)
00024c  e92d47f0          PUSH     {r4-r10,lr}
;;;390    {
000250  e1a08000          MOV      r8,r0
000254  e1a05001          MOV      r5,r1
000258  e1a06002          MOV      r6,r2
;;;391      CPU_SR_DECL;
;;;392      OS_ID tmr_id = 0;
00025c  e3a09000          MOV      r9,#0
;;;393      U16 info = 0;
000260  e3a04000          MOV      r4,#0
;;;394    
;;;395      CPU_ENTER_CRITICAL();
000264  e1a00000          MOV      r0,r0
000268  ebfffffe          BL       __fast_enter_critical
00026c  e1a07000          MOV      r7,r0
000270  e1a00000          MOV      r0,r0
;;;396      info = __hdl_alloc();
000274  e1a00000          MOV      r0,r0
000278  e59f11d0          LDR      r1,|L1.1104|
00027c  e5d10000          LDRB     r0,[r1,#0]  ; hdlpool
000280  e3500000          CMP      r0,#0
000284  1a000001          BNE      |L1.656|
000288  e3a01000          MOV      r1,#0
00028c  ea000004          B        |L1.676|
                  |L1.656|
000290  e59f11b8          LDR      r1,|L1.1104|
000294  e7d11000          LDRB     r1,[r1,r0]
000298  e59f21b0          LDR      r2,|L1.1104|
00029c  e5c21000          STRB     r1,[r2,#0]  ; hdlpool
0002a0  e1a01000          MOV      r1,r0
                  |L1.676|
0002a4  e1a00000          MOV      r0,r0
0002a8  e1a04001          MOV      r4,r1
;;;397      CPU_EXIT_CRITICAL();
0002ac  e1a00000          MOV      r0,r0
0002b0  e1a00007          MOV      r0,r7
0002b4  ebfffffe          BL       __fast_exit_critical
0002b8  e1a00000          MOV      r0,r0
;;;398      if (info == 0) {
0002bc  e3540000          CMP      r4,#0
0002c0  1a000001          BNE      |L1.716|
;;;399        return false;
0002c4  e3a00000          MOV      r0,#0
                  |L1.712|
;;;400      }
;;;401      tsktmr_pool[info - 1].parg = parg;
;;;402      tsktmr_pool[info - 1].pfn = pfn;
;;;403      tmr_id = os_tmr_create(dly, info);
;;;404      if (tmr_id == NULL) {
;;;405        CPU_ENTER_CRITICAL();
;;;406        __hdl_free(info);
;;;407        CPU_EXIT_CRITICAL();
;;;408        return false;
;;;409      }
;;;410      return true;
;;;411    }
0002c8  e8bd87f0          POP      {r4-r10,pc}
                  |L1.716|
0002cc  e2440001          SUB      r0,r4,#1              ;401
0002d0  e59f1174          LDR      r1,|L1.1100|
0002d4  e7816180          STR      r6,[r1,r0,LSL #3]     ;401
0002d8  e2440001          SUB      r0,r4,#1              ;402
0002dc  e0810180          ADD      r0,r1,r0,LSL #3       ;402
0002e0  e5805004          STR      r5,[r0,#4]            ;402
0002e4  e1a01004          MOV      r1,r4                 ;403
0002e8  e1a00008          MOV      r0,r8                 ;403
0002ec  ebfffffe          BL       os_tmr_create
0002f0  e1a09000          MOV      r9,r0                 ;403
0002f4  e3590000          CMP      r9,#0                 ;404
0002f8  1a00000b          BNE      |L1.812|
0002fc  e1a00000          MOV      r0,r0                 ;405
000300  ebfffffe          BL       __fast_enter_critical
000304  e1a07000          MOV      r7,r0                 ;405
000308  e1a00000          MOV      r0,r0                 ;405
00030c  e20400ff          AND      r0,r4,#0xff           ;406
000310  ebfffffe          BL       __hdl_free
000314  e1a00000          MOV      r0,r0                 ;407
000318  e1a00007          MOV      r0,r7                 ;407
00031c  ebfffffe          BL       __fast_exit_critical
000320  e1a00000          MOV      r0,r0                 ;407
000324  e3a00000          MOV      r0,#0                 ;408
000328  eaffffe6          B        |L1.712|
                  |L1.812|
00032c  e3a00001          MOV      r0,#1                 ;410
000330  eaffffe4          B        |L1.712|
;;;412    
                          ENDP

                  __fast_enter_critical PROC
;;;52     #define CPU_ENTER_CRITICAL()  do{cpu_sr = __fast_enter_critical();}while(0)
;;;53     static inline ubase_t __fast_enter_critical(void)
000334  e10f0000          MRS      r0,APSR ; formerly CPSR
;;;54     {
;;;55       ubase_t cpu_sr, tmp_sr;
;;;56       __asm volatile {
;;;57         MRS cpu_sr, CPSR
;;;58         ORR tmp_sr, cpu_sr, #0xC0
000338  e38010c0          ORR      r1,r0,#0xc0
;;;59         MSR CPSR_c, tmp_sr
00033c  e121f001          MSR      CPSR_c,r1
;;;60       }
;;;61       return cpu_sr;
;;;62     }
000340  e12fff1e          BX       lr
;;;63     #endif
                          ENDP

                  __fast_exit_critical PROC
;;;68     #define CPU_EXIT_CRITICAL()   do{__fast_exit_critical(cpu_sr);}while(0)
;;;69     static inline void __fast_exit_critical(ubase_t cpu_sr)
000344  e121f000          MSR      CPSR_c,r0
;;;70     {
;;;71       __asm volatile {
;;;72         MSR CPSR_c, cpu_sr
;;;73       }
;;;74     }
000348  e12fff1e          BX       lr
;;;75     #endif
                          ENDP

                  read32 PROC
;;;19     
;;;20     static __inline uint32_t read32(uint32_t addr)
00034c  e1a01000          MOV      r1,r0
;;;21     {
;;;22       return (*((volatile uint32_t*)(addr)));
000350  e5910000          LDR      r0,[r1,#0]
;;;23     }
000354  e12fff1e          BX       lr
;;;24     
                          ENDP

                  write32 PROC
;;;39     
;;;40     static __inline void write32(uint32_t addr, uint32_t value)
000358  e5801000          STR      r1,[r0,#0]
;;;41     {
;;;42       *((volatile uint32_t*)(addr)) = value;
;;;43     }
00035c  e12fff1e          BX       lr
;;;44     
                          ENDP

                  OS_TIACK PROC
;;;153    to release the timer interrupt logic.  */
;;;154    static inline void OS_TIACK(void)
000360  e92d4010          PUSH     {r4,lr}
;;;155    {
;;;156      U8 nIRQ = F1C100S_IRQ_TIMER0;
000364  e3a0400d          MOV      r4,#0xd
;;;157      // 清除TIMER0模块的IRQ状态标志
;;;158      write32(TIMER_REG_BASE + 0x04, (1 << 0));
000368  e3a01001          MOV      r1,#1
00036c  e59f00c8          LDR      r0,|L1.1084|
000370  ebfffffe          BL       write32
;;;159      f1c100s_intc_clear_pend(nIRQ);
000374  e1a00004          MOV      r0,r4
000378  ebfffffe          BL       f1c100s_intc_clear_pend
;;;160    }
00037c  e8bd8010          POP      {r4,pc}
;;;161    
                          ENDP

                  OS_TINIT PROC
;;;174    This code is executed from the os_sys_init() function.  */
;;;175    static inline void OS_TINIT(void)
000380  e92d4010          PUSH     {r4,lr}
;;;176    {
;;;177      f1c100s_intc_set_isr(F1C100S_IRQ_TIMER0, timer0_irq);
000384  e59f10d4          LDR      r1,|L1.1120|
000388  e3a0000d          MOV      r0,#0xd
00038c  ebfffffe          BL       f1c100s_intc_set_isr
;;;178      write32(TIMER_REG_BASE + 0x14, OS_TRV);
000390  e59f10cc          LDR      r1,|L1.1124|
000394  e59f00cc          LDR      r0,|L1.1128|
000398  ebfffffe          BL       write32
;;;179      write32(TIMER_REG_BASE + 0x10, 0x04);
00039c  e3a01004          MOV      r1,#4
0003a0  e59f00c4          LDR      r0,|L1.1132|
0003a4  ebfffffe          BL       write32
;;;180      write32(TIMER_REG_BASE + 0x10, read32(TIMER_REG_BASE + 0x10) | (1 << 1));
0003a8  e59f00bc          LDR      r0,|L1.1132|
0003ac  ebfffffe          BL       read32
0003b0  e3804002          ORR      r4,r0,#2
0003b4  e1a01004          MOV      r1,r4
0003b8  e59f00ac          LDR      r0,|L1.1132|
0003bc  ebfffffe          BL       write32
;;;181      while (read32(TIMER_REG_BASE + 0x10) & (1 << 1));
0003c0  e1a00000          MOV      r0,r0
                  |L1.964|
0003c4  e59f00a0          LDR      r0,|L1.1132|
0003c8  ebfffffe          BL       read32
0003cc  e2000002          AND      r0,r0,#2
0003d0  e3500000          CMP      r0,#0
0003d4  1afffffa          BNE      |L1.964|
;;;182      write32(TIMER_REG_BASE + 0x10, read32(TIMER_REG_BASE + 0x10) | (1 << 0));
0003d8  e59f008c          LDR      r0,|L1.1132|
0003dc  ebfffffe          BL       read32
0003e0  e3804001          ORR      r4,r0,#1
0003e4  e1a01004          MOV      r1,r4
0003e8  e59f007c          LDR      r0,|L1.1132|
0003ec  ebfffffe          BL       write32
;;;183      write32(TIMER_REG_BASE + 0x00, (1 << 0));
0003f0  e3a01001          MOV      r1,#1
0003f4  e59f0074          LDR      r0,|L1.1136|
0003f8  ebfffffe          BL       write32
;;;184    }
0003fc  e8bd8010          POP      {r4,pc}
;;;185    
                          ENDP

                  OS_LOCK PROC
;;;190    This code is executed from the tsk_lock() function.  */
;;;191    static inline void OS_LOCK(void)
000400  e92d4010          PUSH     {r4,lr}
;;;192    {
;;;193      f1c100s_intc_disable_irq(F1C100S_IRQ_TIMER0);
000404  e3a0000d          MOV      r0,#0xd
000408  ebfffffe          BL       f1c100s_intc_disable_irq
;;;194    }
00040c  e8bd8010          POP      {r4,pc}
;;;195    
                          ENDP

                  OS_UNLOCK PROC
;;;198    and the forced interrupts. This code is executed from tsk_unlock() function.  */
;;;199    static inline void OS_UNLOCK(void)
000410  e92d4010          PUSH     {r4,lr}
;;;200    {
;;;201      f1c100s_intc_enable_irq(F1C100S_IRQ_TIMER0);
000414  e3a0000d          MOV      r0,#0xd
000418  ebfffffe          BL       f1c100s_intc_enable_irq
;;;202    }
00041c  e8bd8010          POP      {r4,pc}
;;;203    
                          ENDP

                  __hdl_free PROC
;;;81     ////////////////////////////////////////////////////////////////////////////////
;;;82     static __INLINE void __hdl_free(HANDLE_T hdl)
000420  e59f1028          LDR      r1,|L1.1104|
;;;83     {
;;;84       hdlpool[hdl] = hdlpool[0];
000424  e5d11000          LDRB     r1,[r1,#0]  ; hdlpool
000428  e59f2020          LDR      r2,|L1.1104|
00042c  e7c21000          STRB     r1,[r2,r0]
;;;85       hdlpool[0] = hdl;
000430  e2821000          ADD      r1,r2,#0
000434  e5c10000          STRB     r0,[r1,#0]  ; hdlpool
;;;86     }
000438  e12fff1e          BX       lr
;;;87     
                          ENDP

                  |L1.1084|
                          DCD      0x01c20c04
                  |L1.1088|
                          DCD      backup_nirq
                  |L1.1092|
                          DCD      mb_tsktmr
                  |L1.1096|
                          DCD      0x0000ffff
                  |L1.1100|
                          DCD      tsktmr_pool
                  |L1.1104|
                          DCD      hdlpool
                  |L1.1108|
                          DCD      __StackTimerWaiter
                  |L1.1112|
                          DCD      0x00040032
                  |L1.1116|
                          DCD      __ThreadTimerWaiter
                  |L1.1120|
                          DCD      timer0_irq
                  |L1.1124|
                          DCD      0x00005dbf
                  |L1.1128|
                          DCD      0x01c20c14
                  |L1.1132|
                          DCD      0x01c20c10
                  |L1.1136|
                          DCD      0x01c20c00

                          AREA ||area_number.2||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.2||, ||.text||
                          THUMB
                  os_tmr_init PROC
;;;106    #ifndef __OS_TMR_INIT
;;;107    void os_tmr_init (void) {
000000  b510              PUSH     {r4,lr}
;;;108      /* Initialize hardware timer as system tick timer. */
;;;109      OS_TINIT();
000002  f7fffffe          BL       OS_TINIT
;;;110    }
000006  bd10              POP      {r4,pc}
;;;111    #endif
                          ENDP

                  os_tmr_force_irq PROC
;;;124    #ifndef __OS_TMR_FORCE_IRQ
;;;125    void os_tmr_force_irq (void) {
000008  b510              PUSH     {r4,lr}
;;;126      /* Force a timer interrupt. */
;;;127      OS_TFIRQ();
00000a  200d              MOVS     r0,#0xd
00000c  f7fffffe          BL       f1c100s_intc_force_irq
;;;128    }
000010  bd10              POP      {r4,pc}
;;;129    #endif
                          ENDP

000012  46c0              MOV      r8,r8
                  os_tmr_inspect_cnt PROC
;;;133    #ifndef __OS_TMR_INSPECT_CNT
;;;134    U32 os_tmr_inspect_cnt (void) {
000014  b510              PUSH     {r4,lr}
;;;135      /* Inspect current value of rtx timer. */
;;;136      return (OS_TVAL);
000016  482b              LDR      r0,|L2.196|
000018  f7fffffe          BL       read32
00001c  492a              LDR      r1,|L2.200|
00001e  1a08              SUBS     r0,r1,r0
;;;137    }
000020  bd10              POP      {r4,pc}
;;;138    #endif
                          ENDP

000022  46c0              MOV      r8,r8
                  os_tmr_inspect_ovf PROC
;;;142    #ifndef __OS_TMR_INSPECT_OVF
;;;143    BOOL os_tmr_inspect_ovf (void) {
000024  b510              PUSH     {r4,lr}
;;;144      /* Inspect current state of timer overflow flag. */
;;;145      return (OS_TOVF);
000026  4827              LDR      r0,|L2.196|
000028  3814              SUBS     r0,r0,#0x14
00002a  f7fffffe          BL       read32
00002e  07c0              LSLS     r0,r0,#31
000030  0fc0              LSRS     r0,r0,#31
;;;146    }
000032  bd10              POP      {r4,pc}
;;;147    #endif
                          ENDP

                  os_irq_ack_lock PROC
;;;151    #ifndef __OS_IRQ_ACK_LOCK
;;;152    void os_irq_ack_lock (void) {
000034  b510              PUSH     {r4,lr}
;;;153      /* Acknowledge and disable a timer interrupt. */
;;;154      OS_TIACK();
000036  f7fffffe          BL       OS_TIACK
;;;155      OS_LOCK();
00003a  f7fffffe          BL       OS_LOCK
;;;156    }
00003e  bd10              POP      {r4,pc}
;;;157    #endif
                          ENDP

                  __SWI_5 PROC
;;;162    void __swi(5) tsk_lock (void);
;;;163    void __SWI_5           (void) {
000040  b510              PUSH     {r4,lr}
;;;164      /* Disable RTX System Tick Timer interrupts. */
;;;165      OS_LOCK();
000042  f7fffffe          BL       OS_LOCK
;;;166    }
000046  bd10              POP      {r4,pc}
;;;167    #endif
                          ENDP

                  tsk_unlock PROC
;;;171    #ifndef __TSK_UNLOCK
;;;172    void tsk_unlock (void) {
000048  b510              PUSH     {r4,lr}
;;;173      /* Enable RTX System Tick Timer Interrupts. */
;;;174      OS_UNLOCK();
00004a  f7fffffe          BL       OS_UNLOCK
;;;175    }
00004e  bd10              POP      {r4,pc}
;;;176    #endif
                          ENDP

                  os_stk_check PROC
;;;355    #if (__ARM__ || __CR__) && OS_STKCHECK == 0
;;;356     void os_stk_check  (U32 stk) {;}
000050  4770              BX       lr
;;;357    #endif
                          ENDP

000052  46c0              MOV      r8,r8
                  __user_perthread_libspace PROC
;;;376    
;;;377    void *__user_perthread_libspace (void) {
000054  b510              PUSH     {r4,lr}
;;;378      /* Provide a separate libspace for each task. */
;;;379      U32 idx;
;;;380    
;;;381      idx = runtask_id ();
000056  f7fffffe          BL       os_tsk_self
;;;382      if (idx == 0) {
00005a  2800              CMP      r0,#0
00005c  d005              BEQ      |L2.106|
;;;383        /* RTX not running yet. */
;;;384        return (&__libspace_start);
;;;385      }
;;;386      return ((void *)&std_libspace[idx-1]);
00005e  2160              MOVS     r1,#0x60
000060  4348              MULS     r0,r1,r0
000062  491a              LDR      r1,|L2.204|
000064  1840              ADDS     r0,r0,r1
000066  3860              SUBS     r0,r0,#0x60
;;;387    }
000068  bd10              POP      {r4,pc}
                  |L2.106|
00006a  4819              LDR      r0,|L2.208|
00006c  bd10              POP      {r4,pc}
;;;388    
                          ENDP

00006e  46c0              MOV      r8,r8
                  _mutex_initialize PROC
;;;390    
;;;391    int _mutex_initialize (OS_ID *mutex) {
000070  b510              PUSH     {r4,lr}
000072  0003              MOVS     r3,r0
;;;392      /* Allocate and initialize a system mutex. */
;;;393    
;;;394      if (nr_mutex >= OS_MUTEXCNT) {
000074  4a17              LDR      r2,|L2.212|
000076  6891              LDR      r1,[r2,#8]  ; nr_mutex
000078  2910              CMP      r1,#0x10
00007a  d300              BCC      |L2.126|
                  |L2.124|
;;;395        /* If you are here, you need to increase the number OS_MUTEXCNT. */
;;;396        for (;;);
00007c  e7fe              B        |L2.124|
                  |L2.126|
00007e  0108              LSLS     r0,r1,#4
;;;397      }
;;;398      *mutex = &std_libmutex[nr_mutex++];
000080  4c15              LDR      r4,|L2.216|
000082  1900              ADDS     r0,r0,r4
000084  1c49              ADDS     r1,r1,#1
000086  6018              STR      r0,[r3,#0]
;;;399      mutex_init (*mutex);
000088  6091              STR      r1,[r2,#8]  ; nr_mutex
00008a  f7fffffe          BL       os_mut_init
;;;400      return (1);
00008e  2001              MOVS     r0,#1
;;;401    }
000090  bd10              POP      {r4,pc}
;;;402    
                          ENDP

000092  46c0              MOV      r8,r8
                  _mutex_acquire PROC
                  |symbol_number.38|
;;;405    
;;;406    __used void _mutex_acquire (OS_ID *mutex) {
000094  b510              PUSH     {r4,lr}
000096  0004              MOVS     r4,r0
;;;407      /* Acquire a system mutex, lock stdlib resources. */
;;;408      if (runtask_id ()) {
000098  f7fffffe          BL       os_tsk_self
00009c  2800              CMP      r0,#0
00009e  d003              BEQ      |L2.168|
;;;409        /* RTX running, acquire a mutex. */
;;;410        mutex_wait (*mutex);
0000a0  490e              LDR      r1,|L2.220|
0000a2  6820              LDR      r0,[r4,#0]
0000a4  f7fffffe          BL       os_mut_wait
                  |L2.168|
;;;411      }
;;;412    }
0000a8  bd10              POP      {r4,pc}
;;;413    
                          ENDP

0000aa  46c0              MOV      r8,r8
                  _mutex_release PROC
                  |symbol_number.40|
;;;416    
;;;417    __used void _mutex_release (OS_ID *mutex) {
0000ac  b510              PUSH     {r4,lr}
0000ae  0004              MOVS     r4,r0
;;;418      /* Release a system mutex, unlock stdlib resources. */
;;;419      if (runtask_id ()) {
0000b0  f7fffffe          BL       os_tsk_self
0000b4  2800              CMP      r0,#0
0000b6  d002              BEQ      |L2.190|
;;;420        /* RTX runnning, release a mutex. */
;;;421        mutex_rel (*mutex);
0000b8  6820              LDR      r0,[r4,#0]
0000ba  f7fffffe          BL       os_mut_release
                  |L2.190|
;;;422      }
;;;423    }
0000be  bd10              POP      {r4,pc}
;;;424    
                          ENDP

                  PrintExceptionMessage PROC
;;;462    
;;;463    void PrintExceptionMessage(ExceptionFrameType* frame, uint32_t cpsr)
0000c0  4770              BX       lr
;;;464    {
;;;465      DBG_PRINT("R0   = %08X\n", frame->R0);
;;;466      DBG_PRINT("R1   = %08X\n", frame->R1);
;;;467      DBG_PRINT("R2   = %08X\n", frame->R2);
;;;468      DBG_PRINT("R3   = %08X\n", frame->R3);
;;;469      DBG_PRINT("R4   = %08X\n", frame->R4);
;;;470      DBG_PRINT("R5   = %08X\n", frame->R5);
;;;471      DBG_PRINT("R6   = %08X\n", frame->R6);
;;;472      DBG_PRINT("R7   = %08X\n", frame->R7);
;;;473      DBG_PRINT("R8   = %08X\n", frame->R8);
;;;474      DBG_PRINT("R9   = %08X\n", frame->R9);
;;;475      DBG_PRINT("R10  = %08X\n", frame->R10);
;;;476      DBG_PRINT("R11  = %08X\n", frame->R11);
;;;477      DBG_PRINT("R12  = %08X\n", frame->R12);
;;;478      DBG_PRINT("SP   = %08X\n", (uint32_t)frame);
;;;479      DBG_PRINT("LR   = %08X\n", frame->LR);
;;;480      DBG_PRINT("SPSR = %08X\n", frame->SPSR);
;;;481      DBG_PRINT("PC   = %08X\n", frame->PC);
;;;482      DBG_PRINT("CPSR = %08X\n", cpsr);
;;;483    }
;;;484    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L2.196|
                          DCD      0x01c20c18
                  |L2.200|
                          DCD      0x00005dbf
                  |L2.204|
                          DCD      ||.bss||+0x1b30
                  |L2.208|
                          DCD      __libspace_start
                  |L2.212|
                          DCD      ||.data||
                  |L2.216|
                          DCD      ||.bss||+0x2a30
                  |L2.220|
                          DCD      0x0000ffff

                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  tsktmr_pool
                          %        640
                  mb_tsktmr
                          %        336
                  hdlpool
                          %        84
                  mp_tcb
                          %        2252
                  mp_stk
                          %        2064
                  os_fifo
                          %        772
                  os_active_TCB
                          %        160
                  mp_tmr
                          %        652
                  std_libspace
                          %        3840
                  std_libmutex
                          %        256

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  os_maxtaskrun
000000  0028              DCW      0x0028
000002  0000              DCB      0x00,0x00
                  os_stackinfo
                          DCD      0x00280800
                  os_rrobin
                          DCD      0x00010005
                  os_clockrate
                  |symbol_number.18|
                          DCD      0x000003e8
                  os_timernum
                  |symbol_number.19|
                          DCD      0x00000050
                  mp_tcb_size
000014  08cc              DCW      0x08cc
000016  0000              DCB      0x00,0x00
                  mp_stk_size
                          DCD      0x00000810
                  os_fifo_size
00001c  6000              DCB      0x60,0x00
                  mp_tmr_size
00001e  028c              DCW      0x028c

                          AREA ||.data||, DATA, ALIGN=2

                  backup_nirq
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  m_tmr
                          DCD      mp_tmr
                  nr_mutex
                          DCD      0x00000000

                          AREA STACK, DATA, NOINIT, ALIGN=3

                  __StackTimerWaiter
                          %        1024

;*** Start embedded assembler ***

#line 1 "..\\system\\RTX_Conf_F1C100s.c"
	AREA ||.emb_text||, CODE
	ARM
	EXPORT |IRQ_Handler|
	IMPORT |os_clock_interrupt|
#line 212
|IRQ_Handler| PROC
#line 213

 
 PRESERVE8
 ARM

 
 PUSH {R0-R3,R12,LR}

 
 LDR R1, =0x01C20400 
 LDR R0, [R1, #0x00] 
 LSL R0, R0, #24
 LSR R0, R0, #26
 LDR R2, = |backup_nirq|
 STRB R0, [R2] 

 
 LSR R2, R0, #5
 LSL R2, R2, #2
 ADD R1, R1, R2
 LDR R2, [R1, #0x50] 
 MOV R12, #1
 AND R3, R0, #0x1F
 BIC R3, R2, R12, LSL R3
 STR R3, [R1, #0x50] 

 
 CMP R0, #(13)
 POP {R0-R3,R12,LR}

 
 LDRNE PC, = |os_def_interrupt|

 
 LDR PC, = |os_clock_interrupt|

 
 B .
	ENDP

;*** End   embedded assembler ***
