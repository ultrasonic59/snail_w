; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave --gnu -o.\temp\obj\gpio-f1c100s.o --asm_dir=.\Temp\Lst\ --list_dir=.\Temp\Lst\ --depend=.\temp\obj\gpio-f1c100s.d --cpu=ARM9E --apcs=interwork -O0 -Otime --diag_suppress=9931 -I.\users\include -I.\..\machine\include -I.\..\periph\include -I.\..\include -I.\..\emwin\Include -I.\..\tinyusb\src -I.\..\tinyusb\hw -I.\..\display -I.\..\lib\display_gfx -I.\..\lib\printf -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Atmel\SAM9260 -D__RTX -D__UVISION_VERSION=536 -DPCB_TINY200V1 -DCFG_TUSB_MCU=OPT_MCU_F1C100S -DCFG_TUSB_OS=OPT_OS_RTX4 --omf_browse=.\temp\obj\gpio-f1c100s.crf ..\periph\gpio-f1c100s.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  gpio_f1c100s_set_cfg PROC
;;;81     
;;;82     void gpio_f1c100s_set_cfg(const gpio_port_t* port, int32_t pin, int32_t cfg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;83     {
000004  e1a05000          MOV      r5,r0
000008  e1a04001          MOV      r4,r1
00000c  e1a07002          MOV      r7,r2
;;;84       uint32_t addr;
;;;85       uint32_t val;
;;;86     
;;;87       if (pin >= port->ngpio)
000010  e5950008          LDR      r0,[r5,#8]
000014  e1500004          CMP      r0,r4
000018  ca000000          BGT      |L1.32|
                  |L1.28|
;;;88         return;
;;;89     
;;;90       addr = port->virt + GPIO_CFG0 + ((pin >> 3) << 2);
;;;91       val = read32(addr);
;;;92       val &= ~(0xf << ((pin & 0x7) << 2));
;;;93       val |= ((cfg & 0x7) << ((pin & 0x7) << 2));
;;;94       write32(addr, val);
;;;95     }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.32|
000020  e1a011c4          ASR      r1,r4,#3              ;90
000024  e5950000          LDR      r0,[r5,#0]            ;90
000028  e0808101          ADD      r8,r0,r1,LSL #2       ;90
00002c  e1a00008          MOV      r0,r8                 ;91
000030  ebfffffe          BL       read32
000034  e1a06000          MOV      r6,r0                 ;91
000038  e1a00e84          LSL      r0,r4,#29             ;92
00003c  e1a00da0          LSR      r0,r0,#27             ;92
000040  e3a0100f          MOV      r1,#0xf               ;92
000044  e1c66011          BIC      r6,r6,r1,LSL r0       ;92
000048  e2070007          AND      r0,r7,#7              ;93
00004c  e1a01e84          LSL      r1,r4,#29             ;93
000050  e1a01da1          LSR      r1,r1,#27             ;93
000054  e1866110          ORR      r6,r6,r0,LSL r1       ;93
000058  e1a01006          MOV      r1,r6                 ;94
00005c  e1a00008          MOV      r0,r8                 ;94
000060  ebfffffe          BL       write32
000064  e1a00000          MOV      r0,r0
000068  eaffffeb          B        |L1.28|
;;;96     
                          ENDP

                  gpio_f1c100s_get_cfg PROC
;;;97     int32_t gpio_f1c100s_get_cfg(const gpio_port_t* port, int32_t pin)
00006c  e92d41f0          PUSH     {r4-r8,lr}
;;;98     {
000070  e1a05000          MOV      r5,r0
000074  e1a04001          MOV      r4,r1
;;;99       uint32_t addr;
;;;100      uint32_t val;
;;;101    
;;;102      if (pin >= port->ngpio)
000078  e5950008          LDR      r0,[r5,#8]
00007c  e1500004          CMP      r0,r4
000080  ca000001          BGT      |L1.140|
;;;103        return 0;
000084  e3a00000          MOV      r0,#0
                  |L1.136|
;;;104    
;;;105      addr = port->virt + GPIO_CFG0 + ((pin >> 3) << 2);
;;;106      val = (read32(addr) >> ((pin & 0x7) << 2)) & 0x7;
;;;107      return val;
;;;108    }
000088  e8bd81f0          POP      {r4-r8,pc}
                  |L1.140|
00008c  e1a011c4          ASR      r1,r4,#3              ;105
000090  e5950000          LDR      r0,[r5,#0]            ;105
000094  e0806101          ADD      r6,r0,r1,LSL #2       ;105
000098  e1a00006          MOV      r0,r6                 ;106
00009c  ebfffffe          BL       read32
0000a0  e1a01e84          LSL      r1,r4,#29             ;106
0000a4  e1a01da1          LSR      r1,r1,#27             ;106
0000a8  e1a00130          LSR      r0,r0,r1              ;106
0000ac  e2007007          AND      r7,r0,#7              ;106
0000b0  e1a00007          MOV      r0,r7                 ;107
0000b4  eafffff3          B        |L1.136|
;;;109    
                          ENDP

                  gpio_f1c100s_set_pull PROC
;;;110    void gpio_f1c100s_set_pull(const gpio_port_t* port, int32_t pin, gpio_pull_t pull)
0000b8  e92d47f0          PUSH     {r4-r10,lr}
;;;111    {
0000bc  e1a06000          MOV      r6,r0
0000c0  e1a05001          MOV      r5,r1
0000c4  e1a08002          MOV      r8,r2
;;;112      uint32_t addr;
;;;113      uint32_t val, v;
;;;114    
;;;115      if (pin >= port->ngpio)
0000c8  e5960008          LDR      r0,[r6,#8]
0000cc  e1500005          CMP      r0,r5
0000d0  ca000000          BGT      |L1.216|
                  |L1.212|
;;;116        return;
;;;117    
;;;118      switch (pull) {
;;;119        case GPIO_PULL_UP:
;;;120          v = 0x1;
;;;121          break;
;;;122    
;;;123        case GPIO_PULL_DOWN:
;;;124          v = 0x2;
;;;125          break;
;;;126    
;;;127        case GPIO_PULL_NONE:
;;;128          v = 0x0;
;;;129          break;
;;;130    
;;;131        default:
;;;132          v = 0x0;
;;;133          break;
;;;134      }
;;;135    
;;;136      addr = port->virt + GPIO_PUL0 + ((pin >> 4) << 2);
;;;137      val = read32(addr);
;;;138      val &= ~(v << ((pin & 0xf) << 1));
;;;139      val |= (v << ((pin & 0xf) << 1));
;;;140      write32(addr, val);
;;;141    }
0000d4  e8bd87f0          POP      {r4-r10,pc}
                  |L1.216|
0000d8  e3580000          CMP      r8,#0                 ;118
0000dc  0a000004          BEQ      |L1.244|
0000e0  e3580001          CMP      r8,#1                 ;118
0000e4  0a000005          BEQ      |L1.256|
0000e8  e3580002          CMP      r8,#2                 ;118
0000ec  1a000009          BNE      |L1.280|
0000f0  ea000005          B        |L1.268|
                  |L1.244|
0000f4  e1a00000          MOV      r0,r0                 ;119
0000f8  e3a04001          MOV      r4,#1                 ;120
0000fc  ea000008          B        |L1.292|
                  |L1.256|
000100  e1a00000          MOV      r0,r0                 ;123
000104  e3a04002          MOV      r4,#2                 ;124
000108  ea000005          B        |L1.292|
                  |L1.268|
00010c  e1a00000          MOV      r0,r0                 ;127
000110  e3a04000          MOV      r4,#0                 ;128
000114  ea000002          B        |L1.292|
                  |L1.280|
000118  e1a00000          MOV      r0,r0                 ;131
00011c  e3a04000          MOV      r4,#0                 ;132
000120  e1a00000          MOV      r0,r0                 ;133
                  |L1.292|
000124  e1a00000          MOV      r0,r0                 ;121
000128  e5960000          LDR      r0,[r6,#0]            ;136
00012c  e280001c          ADD      r0,r0,#0x1c           ;136
000130  e1a01245          ASR      r1,r5,#4              ;136
000134  e0809101          ADD      r9,r0,r1,LSL #2       ;136
000138  e1a00009          MOV      r0,r9                 ;137
00013c  ebfffffe          BL       read32
000140  e1a07000          MOV      r7,r0                 ;137
000144  e1a00e05          LSL      r0,r5,#28             ;138
000148  e1a00da0          LSR      r0,r0,#27             ;138
00014c  e1c77014          BIC      r7,r7,r4,LSL r0       ;138
000150  e1a00e05          LSL      r0,r5,#28             ;139
000154  e1a00da0          LSR      r0,r0,#27             ;139
000158  e1877014          ORR      r7,r7,r4,LSL r0       ;139
00015c  e1a01007          MOV      r1,r7                 ;140
000160  e1a00009          MOV      r0,r9                 ;140
000164  ebfffffe          BL       write32
000168  e1a00000          MOV      r0,r0
00016c  eaffffd8          B        |L1.212|
;;;142    
                          ENDP

                  gpio_f1c100s_get_pull PROC
;;;143    gpio_pull_t gpio_f1c100s_get_pull(const gpio_port_t* port, int32_t pin)
000170  e92d41f0          PUSH     {r4-r8,lr}
;;;144    {
000174  e1a05000          MOV      r5,r0
000178  e1a04001          MOV      r4,r1
;;;145      uint32_t addr;
;;;146      uint32_t v = 0;
00017c  e3a07000          MOV      r7,#0
;;;147    
;;;148      if (pin >= port->ngpio)
000180  e5950008          LDR      r0,[r5,#8]
000184  e1500004          CMP      r0,r4
000188  ca000001          BGT      |L1.404|
;;;149        return GPIO_PULL_NONE;
00018c  e3a00002          MOV      r0,#2
                  |L1.400|
;;;150    
;;;151      addr = port->virt + GPIO_PUL0 + ((pin >> 4) << 2);
;;;152      v = (read32(addr) >> ((pin & 0xf) << 1)) & 0x3;
;;;153    
;;;154      switch (v) {
;;;155        case 0:
;;;156          return GPIO_PULL_NONE;
;;;157        case 1:
;;;158          return GPIO_PULL_UP;
;;;159        case 2:
;;;160          return GPIO_PULL_DOWN;
;;;161        default:
;;;162          break;
;;;163      }
;;;164      return GPIO_PULL_NONE;
;;;165    }
000190  e8bd81f0          POP      {r4-r8,pc}
                  |L1.404|
000194  e5950000          LDR      r0,[r5,#0]            ;151
000198  e280001c          ADD      r0,r0,#0x1c           ;151
00019c  e1a01244          ASR      r1,r4,#4              ;151
0001a0  e0806101          ADD      r6,r0,r1,LSL #2       ;151
0001a4  e1a00006          MOV      r0,r6                 ;152
0001a8  ebfffffe          BL       read32
0001ac  e1a01e04          LSL      r1,r4,#28             ;152
0001b0  e1a01da1          LSR      r1,r1,#27             ;152
0001b4  e1a00130          LSR      r0,r0,r1              ;152
0001b8  e2007003          AND      r7,r0,#3              ;152
0001bc  e3570000          CMP      r7,#0                 ;154
0001c0  0a000004          BEQ      |L1.472|
0001c4  e3570001          CMP      r7,#1                 ;154
0001c8  0a000005          BEQ      |L1.484|
0001cc  e3570002          CMP      r7,#2                 ;154
0001d0  1a000009          BNE      |L1.508|
0001d4  ea000005          B        |L1.496|
                  |L1.472|
0001d8  e1a00000          MOV      r0,r0                 ;155
0001dc  e3a00002          MOV      r0,#2                 ;156
0001e0  eaffffea          B        |L1.400|
                  |L1.484|
0001e4  e1a00000          MOV      r0,r0                 ;157
0001e8  e3a00000          MOV      r0,#0                 ;158
0001ec  eaffffe7          B        |L1.400|
                  |L1.496|
0001f0  e1a00000          MOV      r0,r0                 ;159
0001f4  e3a00001          MOV      r0,#1                 ;160
0001f8  eaffffe4          B        |L1.400|
                  |L1.508|
0001fc  e1a00000          MOV      r0,r0                 ;161
000200  e1a00000          MOV      r0,r0                 ;162
000204  e1a00000          MOV      r0,r0                 ;162
000208  e3a00002          MOV      r0,#2                 ;164
00020c  eaffffdf          B        |L1.400|
;;;166    
                          ENDP

                  gpio_f1c100s_set_drv PROC
;;;167    void gpio_f1c100s_set_drv(const gpio_port_t* port, int32_t pin, gpio_drv_t drv)
000210  e92d47f0          PUSH     {r4-r10,lr}
;;;168    {
000214  e1a06000          MOV      r6,r0
000218  e1a05001          MOV      r5,r1
00021c  e1a08002          MOV      r8,r2
;;;169      uint32_t addr;
;;;170      uint32_t val, v;
;;;171    
;;;172      if (pin >= port->ngpio)
000220  e5960008          LDR      r0,[r6,#8]
000224  e1500005          CMP      r0,r5
000228  ca000000          BGT      |L1.560|
                  |L1.556|
;;;173        return;
;;;174    
;;;175      switch (drv) {
;;;176        case GPIO_DRV_WEAK:
;;;177          v = 0x0;
;;;178          break;
;;;179    
;;;180        case GPIO_DRV_WEAKER:
;;;181          v = 0x1;
;;;182          break;
;;;183    
;;;184        case GPIO_DRV_STRONGER:
;;;185          v = 0x2;
;;;186          break;
;;;187    
;;;188        case GPIO_DRV_STRONG:
;;;189          v = 0x3;
;;;190          break;
;;;191    
;;;192        default:
;;;193          v = 0x0;
;;;194          break;
;;;195      }
;;;196    
;;;197      addr = port->virt + GPIO_DRV0 + ((pin >> 4) << 2);
;;;198      val = read32(addr);
;;;199      val &= ~(v << ((pin & 0xf) << 1));
;;;200      val |= (v << ((pin & 0xf) << 1));
;;;201      write32(addr, val);
;;;202    }
00022c  e8bd87f0          POP      {r4-r10,pc}
                  |L1.560|
000230  e3580000          CMP      r8,#0                 ;175
000234  0a000006          BEQ      |L1.596|
000238  e3580001          CMP      r8,#1                 ;175
00023c  0a000007          BEQ      |L1.608|
000240  e3580002          CMP      r8,#2                 ;175
000244  0a000008          BEQ      |L1.620|
000248  e3580003          CMP      r8,#3                 ;175
00024c  1a00000c          BNE      |L1.644|
000250  ea000008          B        |L1.632|
                  |L1.596|
000254  e1a00000          MOV      r0,r0                 ;176
000258  e3a04000          MOV      r4,#0                 ;177
00025c  ea00000b          B        |L1.656|
                  |L1.608|
000260  e1a00000          MOV      r0,r0                 ;180
000264  e3a04001          MOV      r4,#1                 ;181
000268  ea000008          B        |L1.656|
                  |L1.620|
00026c  e1a00000          MOV      r0,r0                 ;184
000270  e3a04002          MOV      r4,#2                 ;185
000274  ea000005          B        |L1.656|
                  |L1.632|
000278  e1a00000          MOV      r0,r0                 ;188
00027c  e3a04003          MOV      r4,#3                 ;189
000280  ea000002          B        |L1.656|
                  |L1.644|
000284  e1a00000          MOV      r0,r0                 ;192
000288  e3a04000          MOV      r4,#0                 ;193
00028c  e1a00000          MOV      r0,r0                 ;194
                  |L1.656|
000290  e1a00000          MOV      r0,r0                 ;178
000294  e5960000          LDR      r0,[r6,#0]            ;197
000298  e2800014          ADD      r0,r0,#0x14           ;197
00029c  e1a01245          ASR      r1,r5,#4              ;197
0002a0  e0809101          ADD      r9,r0,r1,LSL #2       ;197
0002a4  e1a00009          MOV      r0,r9                 ;198
0002a8  ebfffffe          BL       read32
0002ac  e1a07000          MOV      r7,r0                 ;198
0002b0  e1a00e05          LSL      r0,r5,#28             ;199
0002b4  e1a00da0          LSR      r0,r0,#27             ;199
0002b8  e1c77014          BIC      r7,r7,r4,LSL r0       ;199
0002bc  e1a00e05          LSL      r0,r5,#28             ;200
0002c0  e1a00da0          LSR      r0,r0,#27             ;200
0002c4  e1877014          ORR      r7,r7,r4,LSL r0       ;200
0002c8  e1a01007          MOV      r1,r7                 ;201
0002cc  e1a00009          MOV      r0,r9                 ;201
0002d0  ebfffffe          BL       write32
0002d4  e1a00000          MOV      r0,r0
0002d8  eaffffd3          B        |L1.556|
;;;203    
                          ENDP

                  gpio_f1c100s_get_drv PROC
;;;204    gpio_drv_t gpio_f1c100s_get_drv(const gpio_port_t* port, int32_t pin)
0002dc  e92d41f0          PUSH     {r4-r8,lr}
;;;205    {
0002e0  e1a05000          MOV      r5,r0
0002e4  e1a04001          MOV      r4,r1
;;;206      uint32_t addr;
;;;207      uint32_t v = 0;
0002e8  e3a07000          MOV      r7,#0
;;;208    
;;;209      if (pin >= port->ngpio)
0002ec  e5950008          LDR      r0,[r5,#8]
0002f0  e1500004          CMP      r0,r4
0002f4  ca000001          BGT      |L1.768|
;;;210        return GPIO_DRV_WEAK;
0002f8  e3a00000          MOV      r0,#0
                  |L1.764|
;;;211    
;;;212      addr = port->virt + GPIO_DRV0 + ((pin >> 4) << 2);
;;;213      v = (read32(addr) >> ((pin & 0xf) << 1)) & 0x3;
;;;214    
;;;215      switch (v) {
;;;216        case 0:
;;;217          return GPIO_DRV_WEAK;
;;;218        case 1:
;;;219          return GPIO_DRV_WEAKER;
;;;220        case 2:
;;;221          return GPIO_DRV_STRONGER;
;;;222        case 3:
;;;223          return GPIO_DRV_STRONG;
;;;224        default:
;;;225          break;
;;;226      }
;;;227      return GPIO_DRV_WEAK;
;;;228    }
0002fc  e8bd81f0          POP      {r4-r8,pc}
                  |L1.768|
000300  e5950000          LDR      r0,[r5,#0]            ;212
000304  e2800014          ADD      r0,r0,#0x14           ;212
000308  e1a01244          ASR      r1,r4,#4              ;212
00030c  e0806101          ADD      r6,r0,r1,LSL #2       ;212
000310  e1a00006          MOV      r0,r6                 ;213
000314  ebfffffe          BL       read32
000318  e1a01e04          LSL      r1,r4,#28             ;213
00031c  e1a01da1          LSR      r1,r1,#27             ;213
000320  e1a00130          LSR      r0,r0,r1              ;213
000324  e2007003          AND      r7,r0,#3              ;213
000328  e3570000          CMP      r7,#0                 ;215
00032c  0a000006          BEQ      |L1.844|
000330  e3570001          CMP      r7,#1                 ;215
000334  0a000007          BEQ      |L1.856|
000338  e3570002          CMP      r7,#2                 ;215
00033c  0a000008          BEQ      |L1.868|
000340  e3570003          CMP      r7,#3                 ;215
000344  1a00000c          BNE      |L1.892|
000348  ea000008          B        |L1.880|
                  |L1.844|
00034c  e1a00000          MOV      r0,r0                 ;216
000350  e3a00000          MOV      r0,#0                 ;217
000354  eaffffe8          B        |L1.764|
                  |L1.856|
000358  e1a00000          MOV      r0,r0                 ;218
00035c  e3a00001          MOV      r0,#1                 ;219
000360  eaffffe5          B        |L1.764|
                  |L1.868|
000364  e1a00000          MOV      r0,r0                 ;220
000368  e3a00002          MOV      r0,#2                 ;221
00036c  eaffffe2          B        |L1.764|
                  |L1.880|
000370  e1a00000          MOV      r0,r0                 ;222
000374  e3a00003          MOV      r0,#3                 ;223
000378  eaffffdf          B        |L1.764|
                  |L1.892|
00037c  e1a00000          MOV      r0,r0                 ;224
000380  e1a00000          MOV      r0,r0                 ;225
000384  e1a00000          MOV      r0,r0                 ;225
000388  e3a00000          MOV      r0,#0                 ;227
00038c  eaffffda          B        |L1.764|
;;;229    
                          ENDP

                  gpio_f1c100s_set_rate PROC
;;;230    void gpio_f1c100s_set_rate(const gpio_port_t* port, int32_t pin, gpio_rate_t rate)
000390  e12fff1e          BX       lr
;;;231    {
;;;232    }
;;;233    
                          ENDP

                  gpio_f1c100s_get_rate PROC
;;;234    gpio_rate_t gpio_f1c100s_get_rate(const gpio_port_t* port, int32_t pin)
000394  e1a02000          MOV      r2,r0
;;;235    {
;;;236      return GPIO_RATE_SLOW;
000398  e3a00000          MOV      r0,#0
;;;237    }
00039c  e12fff1e          BX       lr
;;;238    
                          ENDP

                  gpio_f1c100s_set_dir PROC
;;;239    void gpio_f1c100s_set_dir(const gpio_port_t* port, int32_t pin, gpio_direction_t dir)
0003a0  e92d4070          PUSH     {r4-r6,lr}
;;;240    {
0003a4  e1a06000          MOV      r6,r0
0003a8  e1a04001          MOV      r4,r1
0003ac  e1a05002          MOV      r5,r2
;;;241      if (pin >= port->ngpio)
0003b0  e5960008          LDR      r0,[r6,#8]
0003b4  e1500004          CMP      r0,r4
0003b8  ca000000          BGT      |L1.960|
                  |L1.956|
;;;242        return;
;;;243    
;;;244      switch (dir) {
;;;245        case GPIO_DIRECTION_INPUT:
;;;246          gpio_f1c100s_set_cfg(port, pin, 0);
;;;247          break;
;;;248    
;;;249        case GPIO_DIRECTION_OUTPUT:
;;;250          gpio_f1c100s_set_cfg(port, pin, 1);
;;;251          break;
;;;252    
;;;253        default:
;;;254          break;
;;;255      }
;;;256    }
0003bc  e8bd8070          POP      {r4-r6,pc}
                  |L1.960|
0003c0  e3550000          CMP      r5,#0                 ;244
0003c4  0a000002          BEQ      |L1.980|
0003c8  e3550001          CMP      r5,#1                 ;244
0003cc  1a00000c          BNE      |L1.1028|
0003d0  ea000005          B        |L1.1004|
                  |L1.980|
0003d4  e1a00000          MOV      r0,r0                 ;245
0003d8  e3a02000          MOV      r2,#0                 ;246
0003dc  e1a01004          MOV      r1,r4                 ;246
0003e0  e1a00006          MOV      r0,r6                 ;246
0003e4  ebfffffe          BL       gpio_f1c100s_set_cfg
0003e8  ea000007          B        |L1.1036|
                  |L1.1004|
0003ec  e1a00000          MOV      r0,r0                 ;249
0003f0  e3a02001          MOV      r2,#1                 ;250
0003f4  e1a01004          MOV      r1,r4                 ;250
0003f8  e1a00006          MOV      r0,r6                 ;250
0003fc  ebfffffe          BL       gpio_f1c100s_set_cfg
000400  ea000001          B        |L1.1036|
                  |L1.1028|
000404  e1a00000          MOV      r0,r0                 ;253
000408  e1a00000          MOV      r0,r0                 ;254
                  |L1.1036|
00040c  e1a00000          MOV      r0,r0                 ;247
000410  e1a00000          MOV      r0,r0
000414  eaffffe8          B        |L1.956|
;;;257    
                          ENDP

                  gpio_f1c100s_get_dir PROC
;;;258    gpio_direction_t gpio_f1c100s_get_dir(const gpio_port_t* port, int32_t pin)
000418  e92d4070          PUSH     {r4-r6,lr}
;;;259    {
00041c  e1a04000          MOV      r4,r0
000420  e1a05001          MOV      r5,r1
;;;260      if (pin >= port->ngpio)
000424  e5940008          LDR      r0,[r4,#8]
000428  e1500005          CMP      r0,r5
00042c  ca000001          BGT      |L1.1080|
;;;261        return GPIO_DIRECTION_INPUT;
000430  e3a00000          MOV      r0,#0
                  |L1.1076|
;;;262    
;;;263      switch (gpio_f1c100s_get_cfg(port, pin)) {
;;;264        case 0:
;;;265          return GPIO_DIRECTION_INPUT;
;;;266        case 1:
;;;267          return GPIO_DIRECTION_OUTPUT;
;;;268        default:
;;;269          break;
;;;270      }
;;;271      return GPIO_DIRECTION_INPUT;
;;;272    }
000434  e8bd8070          POP      {r4-r6,pc}
                  |L1.1080|
000438  e1a01005          MOV      r1,r5                 ;263
00043c  e1a00004          MOV      r0,r4                 ;263
000440  ebfffffe          BL       gpio_f1c100s_get_cfg
000444  e3500000          CMP      r0,#0                 ;263
000448  0a000002          BEQ      |L1.1112|
00044c  e3500001          CMP      r0,#1                 ;263
000450  1a000006          BNE      |L1.1136|
000454  ea000002          B        |L1.1124|
                  |L1.1112|
000458  e1a00000          MOV      r0,r0                 ;264
00045c  e3a00000          MOV      r0,#0                 ;265
000460  eafffff3          B        |L1.1076|
                  |L1.1124|
000464  e1a00000          MOV      r0,r0                 ;266
000468  e3a00001          MOV      r0,#1                 ;267
00046c  eafffff0          B        |L1.1076|
                  |L1.1136|
000470  e1a00000          MOV      r0,r0                 ;268
000474  e1a00000          MOV      r0,r0                 ;269
000478  e1a00000          MOV      r0,r0                 ;269
00047c  e3a00000          MOV      r0,#0                 ;271
000480  eaffffeb          B        |L1.1076|
;;;273    
                          ENDP

                  gpio_f1c100s_set_value PROC
;;;274    void gpio_f1c100s_set_value(const gpio_port_t* port, int32_t pin, int32_t value)
000484  e92d41f0          PUSH     {r4-r8,lr}
;;;275    {
000488  e1a04000          MOV      r4,r0
00048c  e1a05001          MOV      r5,r1
000490  e1a07002          MOV      r7,r2
;;;276      uint32_t val;
;;;277    
;;;278      if (pin >= port->ngpio)
000494  e5940008          LDR      r0,[r4,#8]
000498  e1500005          CMP      r0,r5
00049c  ca000000          BGT      |L1.1188|
                  |L1.1184|
;;;279        return;
;;;280    
;;;281      val = read32(port->virt + GPIO_DAT);
;;;282      val &= ~(1 << pin);
;;;283      val |= (!!value) << pin;
;;;284      write32(port->virt + GPIO_DAT, val);
;;;285    }
0004a0  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1188|
0004a4  e5941000          LDR      r1,[r4,#0]            ;281
0004a8  e2810010          ADD      r0,r1,#0x10           ;281
0004ac  ebfffffe          BL       read32
0004b0  e1a06000          MOV      r6,r0                 ;281
0004b4  e3a00001          MOV      r0,#1                 ;282
0004b8  e1c66510          BIC      r6,r6,r0,LSL r5       ;282
0004bc  e3570000          CMP      r7,#0                 ;283
0004c0  0a000000          BEQ      |L1.1224|
0004c4  ea000000          B        |L1.1228|
                  |L1.1224|
0004c8  e3a00000          MOV      r0,#0                 ;283
                  |L1.1228|
0004cc  e1866510          ORR      r6,r6,r0,LSL r5       ;283
0004d0  e5941000          LDR      r1,[r4,#0]            ;284
0004d4  e2810010          ADD      r0,r1,#0x10           ;284
0004d8  e1a01006          MOV      r1,r6                 ;284
0004dc  ebfffffe          BL       write32
0004e0  e1a00000          MOV      r0,r0
0004e4  eaffffed          B        |L1.1184|
;;;286    
                          ENDP

                  gpio_f1c100s_get_value PROC
;;;287    int32_t gpio_f1c100s_get_value(const gpio_port_t* port, int32_t pin)
0004e8  e92d4070          PUSH     {r4-r6,lr}
;;;288    {
0004ec  e1a04000          MOV      r4,r0
0004f0  e1a05001          MOV      r5,r1
;;;289      uint32_t val;
;;;290    
;;;291      if (pin >= port->ngpio)
0004f4  e5940008          LDR      r0,[r4,#8]
0004f8  e1500005          CMP      r0,r5
0004fc  ca000001          BGT      |L1.1288|
;;;292        return 0;
000500  e3a00000          MOV      r0,#0
                  |L1.1284|
;;;293    
;;;294      val = read32(port->virt + GPIO_DAT);
;;;295      return !!(val & (1 << pin));
;;;296    }
000504  e8bd8070          POP      {r4-r6,pc}
                  |L1.1288|
000508  e5941000          LDR      r1,[r4,#0]            ;294
00050c  e2810010          ADD      r0,r1,#0x10           ;294
000510  ebfffffe          BL       read32
000514  e1a06000          MOV      r6,r0                 ;294
000518  e3a00001          MOV      r0,#1                 ;295
00051c  e0060510          AND      r0,r6,r0,LSL r5       ;295
000520  e3500000          CMP      r0,#0                 ;295
000524  0a000001          BEQ      |L1.1328|
000528  e3a00001          MOV      r0,#1                 ;295
00052c  eafffff4          B        |L1.1284|
                  |L1.1328|
000530  e3a00000          MOV      r0,#0                 ;295
000534  eafffff2          B        |L1.1284|
;;;297    
                          ENDP

                  gpio_f1c100s_to_irq PROC
;;;298    int32_t gpio_f1c100s_to_irq(const gpio_port_t* port, int32_t pin)
000538  e1a02000          MOV      r2,r0
;;;299    {
;;;300    
;;;301      if ((pin >= port->ngpio) || (port->oirq < 0))
00053c  e5920008          LDR      r0,[r2,#8]
000540  e1500001          CMP      r0,r1
000544  da000002          BLE      |L1.1364|
000548  e592000c          LDR      r0,[r2,#0xc]
00054c  e3500000          CMP      r0,#0
000550  aa000001          BGE      |L1.1372|
                  |L1.1364|
;;;302        return -1;
000554  e3e00000          MVN      r0,#0
                  |L1.1368|
;;;303      return port->oirq + pin;
;;;304    }
000558  e12fff1e          BX       lr
                  |L1.1372|
00055c  e592000c          LDR      r0,[r2,#0xc]          ;303
000560  e0800001          ADD      r0,r0,r1              ;303
000564  eafffffb          B        |L1.1368|
                          ENDP

                  read32 PROC
;;;19     
;;;20     static __inline uint32_t read32(uint32_t addr)
000568  e1a01000          MOV      r1,r0
;;;21     {
;;;22       return (*((volatile uint32_t*)(addr)));
00056c  e5910000          LDR      r0,[r1,#0]
;;;23     }
000570  e12fff1e          BX       lr
;;;24     
                          ENDP

                  write32 PROC
;;;39     
;;;40     static __inline void write32(uint32_t addr, uint32_t value)
000574  e5801000          STR      r1,[r0,#0]
;;;41     {
;;;42       *((volatile uint32_t*)(addr)) = value;
;;;43     }
000578  e12fff1e          BX       lr
;;;44     
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  GPIO_PA
                          DCD      0x01c20800
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000000
                  GPIO_PB
                          DCD      0x01c20824
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000000
                  GPIO_PC
                          DCD      0x01c20848
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000000
                  GPIO_PD
                          DCD      0x01c2086c
                          DCD      0x00000000
                          DCD      0x00000016
                          DCD      0x00000000
                  GPIO_PE
                          DCD      0x01c20890
                          DCD      0x00000000
                          DCD      0x0000000d
                          DCD      0x00000000
                  GPIO_PF
                          DCD      0x01c208b4
                          DCD      0x00000000
                          DCD      0x00000006
                          DCD      0x00000000
