; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave --gnu -o.\temp\obj\usbd.o --asm_dir=.\Temp\Lst\ --list_dir=.\Temp\Lst\ --depend=.\temp\obj\usbd.d --cpu=ARM9E --apcs=interwork -O3 -Otime --diag_suppress=9931 -I.\users\include -I.\..\machine\include -I.\..\periph\include -I.\..\include -I.\..\emwin\Include -I.\..\tinyusb\src -I.\..\tinyusb\hw -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Atmel\SAM9260 -D__RTX -D__UVISION_VERSION=536 -DPCB_TINY200V2 -DCFG_TUSB_MCU=OPT_MCU_F1C100S -DCFG_TUSB_OS=OPT_OS_RTX4 --omf_browse=.\temp\obj\usbd.crf ..\tinyusb\src\device\usbd.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  tud_speed_get PROC
;;;343    //--------------------------------------------------------------------+
;;;344    tusb_speed_t tud_speed_get(void)
000000  e59f0ed0          LDR      r0,|L1.3800|
;;;345    {
;;;346      return (tusb_speed_t) _usbd_dev.speed;
000004  e5d00002          LDRB     r0,[r0,#2]  ; _usbd_dev
;;;347    }
000008  e12fff1e          BX       lr
;;;348    
                          ENDP

                  tud_connected PROC
;;;349    bool tud_connected(void)
00000c  e59f0ec4          LDR      r0,|L1.3800|
;;;350    {
;;;351      return _usbd_dev.connected;
000010  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_dev
000014  e2000001          AND      r0,r0,#1
;;;352    }
000018  e12fff1e          BX       lr
;;;353    
                          ENDP

                  tud_mounted PROC
;;;354    bool tud_mounted(void)
00001c  e59f0eb4          LDR      r0,|L1.3800|
;;;355    {
;;;356      return _usbd_dev.cfg_num ? true : false;
000020  e5d00001          LDRB     r0,[r0,#1]  ; _usbd_dev
000024  e3500000          CMP      r0,#0
000028  13a00001          MOVNE    r0,#1
;;;357    }
00002c  e12fff1e          BX       lr
;;;358    
                          ENDP

                  tud_suspended PROC
;;;359    bool tud_suspended(void)
000030  e59f0ea0          LDR      r0,|L1.3800|
;;;360    {
;;;361      return _usbd_dev.suspended;
000034  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_dev
000038  e2000004          AND      r0,r0,#4
00003c  e1a00120          LSR      r0,r0,#2
;;;362    }
000040  e12fff1e          BX       lr
;;;363    
                          ENDP

                  tud_remote_wakeup PROC
;;;364    bool tud_remote_wakeup(void)
000044  e59f0e8c          LDR      r0,|L1.3800|
;;;365    {
;;;366      // only wake up host if this feature is supported and enabled and we are suspended
;;;367      TU_VERIFY (_usbd_dev.suspended && _usbd_dev.remote_wakeup_support && _usbd_dev.remote_wakeup_en );
000048  e5d01000          LDRB     r1,[r0,#0]  ; _usbd_dev
00004c  e3110004          TST      r1,#4
000050  15d00000          LDRBNE   r0,[r0,#0]  ; _usbd_dev
000054  13100010          TSTNE    r0,#0x10
000058  13100008          TSTNE    r0,#8
00005c  03a00000          MOVEQ    r0,#0
;;;368      dcd_remote_wakeup(_usbd_rhport);
;;;369      return true;
;;;370    }
000060  012fff1e          BXEQ     lr
000064  e92d4010          PUSH     {r4,lr}               ;365
000068  e59f0e6c          LDR      r0,|L1.3804|
00006c  e5d00001          LDRB     r0,[r0,#1]            ;368  ; _usbd_rhport
000070  ebfffffe          BL       dcd_remote_wakeup
000074  e3a00001          MOV      r0,#1                 ;369
000078  e8bd8010          POP      {r4,pc}
;;;371    
                          ENDP

                  tud_disconnect PROC
;;;372    bool tud_disconnect(void)
00007c  e59f0e5c          LDR      r0,|L1.3808|
;;;373    {
;;;374      TU_VERIFY(dcd_disconnect);
000080  e3500000          CMP      r0,#0
;;;375      dcd_disconnect(_usbd_rhport);
;;;376      return true;
;;;377    }
000084  012fff1e          BXEQ     lr
000088  e92d4010          PUSH     {r4,lr}               ;373
00008c  e59f0e48          LDR      r0,|L1.3804|
000090  e5d00001          LDRB     r0,[r0,#1]            ;375  ; _usbd_rhport
000094  ebfffffe          BL       dcd_disconnect
000098  e3a00001          MOV      r0,#1                 ;376
00009c  e8bd8010          POP      {r4,pc}
;;;378    
                          ENDP

                  tud_connect PROC
;;;379    bool tud_connect(void)
0000a0  e59f0e3c          LDR      r0,|L1.3812|
;;;380    {
;;;381      TU_VERIFY(dcd_connect);
0000a4  e3500000          CMP      r0,#0
;;;382      dcd_connect(_usbd_rhport);
;;;383      return true;
;;;384    }
0000a8  012fff1e          BXEQ     lr
0000ac  e92d4010          PUSH     {r4,lr}               ;380
0000b0  e59f0e24          LDR      r0,|L1.3804|
0000b4  e5d00001          LDRB     r0,[r0,#1]            ;382  ; _usbd_rhport
0000b8  ebfffffe          BL       dcd_connect
0000bc  e3a00001          MOV      r0,#1                 ;383
0000c0  e8bd8010          POP      {r4,pc}
;;;385    
                          ENDP

                  tud_inited PROC
;;;388    //--------------------------------------------------------------------+
;;;389    bool tud_inited(void)
0000c4  e59f0e10          LDR      r0,|L1.3804|
;;;390    {
;;;391      return _usbd_rhport != RHPORT_INVALID;
0000c8  e5d00001          LDRB     r0,[r0,#1]  ; _usbd_rhport
0000cc  e35000ff          CMP      r0,#0xff
0000d0  13a00001          MOVNE    r0,#1
0000d4  03a00000          MOVEQ    r0,#0
;;;392    }
0000d8  e12fff1e          BX       lr
;;;393    
                          ENDP

                  tud_init PROC
;;;394    bool tud_init (uint8_t rhport)
0000dc  e92d47f0          PUSH     {r4-r10,lr}
;;;395    {
0000e0  e59f6df4          LDR      r6,|L1.3804|
0000e4  e1a08000          MOV      r8,r0
0000e8  e5d60001          LDRB     r0,[r6,#1]  ; _usbd_rhport
0000ec  e35000ff          CMP      r0,#0xff
;;;396      // skip if already initialized
;;;397      if ( tud_inited() ) return true;
0000f0  13a00001          MOVNE    r0,#1
;;;398    
;;;399      TU_LOG(USBD_DBG, "USBD init on controller %u\r\n", rhport);
;;;400      TU_LOG_INT(USBD_DBG, sizeof(usbd_device_t));
;;;401      TU_LOG_INT(USBD_DBG, sizeof(tu_fifo_t));
;;;402      TU_LOG_INT(USBD_DBG, sizeof(tu_edpt_stream_t));
;;;403    
;;;404      tu_varclr(&_usbd_dev);
;;;405    
;;;406    #if OSAL_MUTEX_REQUIRED
;;;407      // Init device mutex
;;;408      _usbd_mutex = osal_mutex_create(&_ubsd_mutexdef);
;;;409      TU_ASSERT(_usbd_mutex);
;;;410    #endif
;;;411    
;;;412      // Init device queue & task
;;;413      _usbd_q = osal_queue_create(&_usbd_qdef);
;;;414      TU_ASSERT(_usbd_q);
;;;415    
;;;416      // Get application driver if available
;;;417      if ( usbd_app_driver_get_cb )
;;;418      {
;;;419        _app_driver = usbd_app_driver_get_cb(&_app_driver_count);
;;;420      }
;;;421    
;;;422      // Init class drivers
;;;423      for (uint8_t i = 0; i < TOTAL_DRIVER_COUNT; i++)
;;;424      {
;;;425        usbd_class_driver_t const * driver = get_driver(i);
;;;426        TU_ASSERT(driver);
;;;427        TU_LOG(USBD_DBG, "%s init\r\n", driver->name);
;;;428        driver->init();
;;;429      }
;;;430    
;;;431      _usbd_rhport = rhport;
;;;432    
;;;433      // Init device controller driver
;;;434      dcd_init(rhport);
;;;435      dcd_int_enable(rhport);
;;;436    
;;;437      return true;
;;;438    }
0000f4  18bd87f0          POPNE    {r4-r10,pc}
0000f8  e3a01023          MOV      r1,#0x23              ;404
0000fc  e59f0dd4          LDR      r0,|L1.3800|
000100  ebfffffe          BL       __aeabi_memclr4
000104  e59f4ddc          LDR      r4,|L1.3816|
000108  e1a00004          MOV      r0,r4                 ;408
00010c  ebfffffe          BL       os_mut_init
000110  e586400c          STR      r4,[r6,#0xc]          ;408  ; _usbd_mutex
000114  e59f4dd0          LDR      r4,|L1.3820|
000118  e1d400b0          LDRH     r0,[r4,#0]            ;413
00011c  e1a01100          LSL      r1,r0,#2              ;413
000120  e2811010          ADD      r1,r1,#0x10           ;413
000124  e5940008          LDR      r0,[r4,#8]            ;413
000128  e3c11807          BIC      r1,r1,#0x70000        ;413
00012c  ebfffffe          BL       os_mbx_init
000130  e1d420b2          LDRH     r2,[r4,#2]            ;413
000134  e1d410b0          LDRH     r1,[r4,#0]            ;413
000138  e5940004          LDR      r0,[r4,#4]            ;413
00013c  e2823003          ADD      r3,r2,#3              ;413
000140  e1a03123          LSR      r3,r3,#2              ;413
000144  e0010193          MUL      r1,r3,r1              ;413
000148  e2811003          ADD      r1,r1,#3              ;413
00014c  ebfffffe          BL       _init_box
000150  e59f7d98          LDR      r7,|L1.3824|
000154  e5864008          STR      r4,[r6,#8]            ;413  ; _usbd_q
000158  e3570000          CMP      r7,#0                 ;417
00015c  0a000002          BEQ      |L1.364|
000160  e2440010          SUB      r0,r4,#0x10           ;419
000164  ebfffffe          BL       usbd_app_driver_get_cb
000168  e5860004          STR      r0,[r6,#4]            ;419  ; _app_driver
                  |L1.364|
00016c  e5d60000          LDRB     r0,[r6,#0]            ;423  ; _app_driver_count
000170  e3a05000          MOV      r5,#0                 ;423
000174  e3700002          CMN      r0,#2                 ;423
000178  159f9d74          LDRNE    r9,|L1.3828|
00017c  0a000014          BEQ      |L1.468|
                  |L1.384|
000180  e3570000          CMP      r7,#0                 ;423
000184  e1a04005          MOV      r4,r5                 ;425
000188  0a000018          BEQ      |L1.496|
00018c  e5d60000          LDRB     r0,[r6,#0]            ;425  ; _app_driver_count
000190  e1540000          CMP      r4,r0                 ;425
000194  20450000          SUBCS    r0,r5,r0              ;425
000198  220040ff          ANDCS    r4,r0,#0xff           ;425
00019c  2a000013          BCS      |L1.496|
0001a0  e5960004          LDR      r0,[r6,#4]            ;425  ; _app_driver
0001a4  e0851085          ADD      r1,r5,r5,LSL #1       ;425
0001a8  e0801181          ADD      r1,r0,r1,LSL #3       ;425
                  |L1.428|
0001ac  e3510000          CMP      r1,#0                 ;426
0001b0  0a000012          BEQ      |L1.512|
0001b4  e5910000          LDR      r0,[r1,#0]            ;428
0001b8  e12fff30          BLX      r0                    ;428
0001bc  e5d60000          LDRB     r0,[r6,#0]            ;429  ; _app_driver_count
0001c0  e2851001          ADD      r1,r5,#1              ;429
0001c4  e20150ff          AND      r5,r1,#0xff           ;429
0001c8  e2800002          ADD      r0,r0,#2              ;429
0001cc  e1550000          CMP      r5,r0                 ;429
0001d0  3affffea          BCC      |L1.384|
                  |L1.468|
0001d4  e1a00008          MOV      r0,r8                 ;434
0001d8  e5c68001          STRB     r8,[r6,#1]            ;431  ; _usbd_rhport
0001dc  ebfffffe          BL       dcd_init
0001e0  e1a00008          MOV      r0,r8                 ;435
0001e4  ebfffffe          BL       dcd_int_enable
0001e8  e3a00001          MOV      r0,#1                 ;437
0001ec  e8bd87f0          POP      {r4-r10,pc}
                  |L1.496|
0001f0  e3540002          CMP      r4,#2
0001f4  30840084          ADDCC    r0,r4,r4,LSL #1
0001f8  30891180          ADDCC    r1,r9,r0,LSL #3
0001fc  3affffea          BCC      |L1.428|
                  |L1.512|
000200  e3a00000          MOV      r0,#0                 ;426
000204  e8bd87f0          POP      {r4-r10,pc}
;;;439    
                          ENDP

                  tud_task_event_ready PROC
;;;459    
;;;460    bool tud_task_event_ready(void)
000208  e59f0ccc          LDR      r0,|L1.3804|
;;;461    {
00020c  e92d4010          PUSH     {r4,lr}
000210  e5d01001          LDRB     r1,[r0,#1]  ; _usbd_rhport
000214  e35100ff          CMP      r1,#0xff
;;;462      // Skip if stack is not initialized
;;;463      if ( !tud_inited() ) return false;
000218  03a00000          MOVEQ    r0,#0
;;;464    
;;;465      return !osal_queue_empty(_usbd_q);
;;;466    }
00021c  08bd8010          POPEQ    {r4,pc}
000220  e5904008          LDR      r4,[r0,#8]  ; _usbd_q
000224  e5940008          LDR      r0,[r4,#8]
000228  ebfffffe          BL       os_mbx_check
00022c  e1d410b0          LDRH     r1,[r4,#0]
000230  e1500001          CMP      r0,r1
000234  03a00001          MOVEQ    r0,#1
000238  13a00000          MOVNE    r0,#0
00023c  e2200001          EOR      r0,r0,#1              ;465
000240  e8bd8010          POP      {r4,pc}
;;;467    
                          ENDP

                  usbd_edpt_stall PROC
;;;1318   
;;;1319   void usbd_edpt_stall(uint8_t rhport, uint8_t ep_addr)
000244  e59f3c8c          LDR      r3,|L1.3800|
;;;1320   {
;;;1321     rhport = _usbd_rhport;
;;;1322   
;;;1323     uint8_t const epnum = tu_edpt_number(ep_addr);
000248  e3c10080          BIC      r0,r1,#0x80
;;;1324     uint8_t const dir   = tu_edpt_dir(ep_addr);
;;;1325   
;;;1326     // only stalled if currently cleared
;;;1327     if ( !_usbd_dev.ep_status[epnum][dir].stalled )
00024c  e0833080          ADD      r3,r3,r0,LSL #1
000250  e92d4010          PUSH     {r4,lr}               ;1320
000254  e59f0c80          LDR      r0,|L1.3804|
000258  e08343a1          ADD      r4,r3,r1,LSR #7
00025c  e5d00001          LDRB     r0,[r0,#1]            ;1321  ; _usbd_rhport
000260  e5d4201b          LDRB     r2,[r4,#0x1b]
000264  e3120002          TST      r2,#2
;;;1328     {
;;;1329       TU_LOG(USBD_DBG, "    Stall EP %02X\r\n", ep_addr);
;;;1330       dcd_edpt_stall(rhport, ep_addr);
;;;1331       _usbd_dev.ep_status[epnum][dir].stalled = 1;
;;;1332       _usbd_dev.ep_status[epnum][dir].busy = 1;
;;;1333     }
;;;1334   }
000268  18bd8010          POPNE    {r4,pc}
00026c  ebfffffe          BL       dcd_edpt_stall
000270  e5d4001b          LDRB     r0,[r4,#0x1b]         ;1331
000274  e3800002          ORR      r0,r0,#2              ;1331
000278  e5c4001b          STRB     r0,[r4,#0x1b]         ;1331
00027c  e5d4001b          LDRB     r0,[r4,#0x1b]         ;1332
000280  e3800001          ORR      r0,r0,#1              ;1332
000284  e5c4001b          STRB     r0,[r4,#0x1b]         ;1332
000288  e8bd8010          POP      {r4,pc}
;;;1335   
                          ENDP

                  usbd_edpt_clear_stall PROC
;;;1336   void usbd_edpt_clear_stall(uint8_t rhport, uint8_t ep_addr)
00028c  e59f3c44          LDR      r3,|L1.3800|
;;;1337   {
;;;1338     rhport = _usbd_rhport;
;;;1339   
;;;1340     uint8_t const epnum = tu_edpt_number(ep_addr);
000290  e3c10080          BIC      r0,r1,#0x80
;;;1341     uint8_t const dir   = tu_edpt_dir(ep_addr);
;;;1342   
;;;1343     // only clear if currently stalled
;;;1344     if ( _usbd_dev.ep_status[epnum][dir].stalled )
000294  e0833080          ADD      r3,r3,r0,LSL #1
000298  e92d4010          PUSH     {r4,lr}               ;1337
00029c  e59f0c38          LDR      r0,|L1.3804|
0002a0  e08343a1          ADD      r4,r3,r1,LSR #7
0002a4  e5d00001          LDRB     r0,[r0,#1]            ;1338  ; _usbd_rhport
0002a8  e5d4201b          LDRB     r2,[r4,#0x1b]
0002ac  e3120002          TST      r2,#2
;;;1345     {
;;;1346       TU_LOG(USBD_DBG, "    Clear Stall EP %02X\r\n", ep_addr);
;;;1347       dcd_edpt_clear_stall(rhport, ep_addr);
;;;1348       _usbd_dev.ep_status[epnum][dir].stalled = 0;
;;;1349       _usbd_dev.ep_status[epnum][dir].busy = 0;
;;;1350     }
;;;1351   }
0002b0  08bd8010          POPEQ    {r4,pc}
0002b4  ebfffffe          BL       dcd_edpt_clear_stall
0002b8  e5d4001b          LDRB     r0,[r4,#0x1b]         ;1348
0002bc  e3c00002          BIC      r0,r0,#2              ;1348
0002c0  e5c4001b          STRB     r0,[r4,#0x1b]         ;1348
0002c4  e5d4001b          LDRB     r0,[r4,#0x1b]         ;1349
0002c8  e3c00001          BIC      r0,r0,#1              ;1349
0002cc  e5c4001b          STRB     r0,[r4,#0x1b]         ;1349
0002d0  e8bd8010          POP      {r4,pc}
;;;1352   
                          ENDP

                  usbd_edpt_stalled PROC
;;;1353   bool usbd_edpt_stalled(uint8_t rhport, uint8_t ep_addr)
0002d4  e59f2bfc          LDR      r2,|L1.3800|
;;;1354   {
;;;1355     (void) rhport;
;;;1356   
;;;1357     uint8_t const epnum = tu_edpt_number(ep_addr);
0002d8  e3c10080          BIC      r0,r1,#0x80
;;;1358     uint8_t const dir   = tu_edpt_dir(ep_addr);
;;;1359   
;;;1360     return _usbd_dev.ep_status[epnum][dir].stalled;
0002dc  e0820080          ADD      r0,r2,r0,LSL #1
0002e0  e08003a1          ADD      r0,r0,r1,LSR #7
0002e4  e5d0001b          LDRB     r0,[r0,#0x1b]
0002e8  e2000002          AND      r0,r0,#2
0002ec  e1a000a0          LSR      r0,r0,#1
;;;1361   }
0002f0  e12fff1e          BX       lr
;;;1362   
                          ENDP

                  tud_task_ext PROC
;;;485     */
;;;486    void tud_task_ext(uint32_t timeout_ms, bool in_isr)
0002f4  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;487    {
0002f8  e59f4bdc          LDR      r4,|L1.3804|
0002fc  e24dd04c          SUB      sp,sp,#0x4c
000300  e5d40001          LDRB     r0,[r4,#1]  ; _usbd_rhport
000304  e35000ff          CMP      r0,#0xff
;;;488      (void) in_isr; // not implemented yet
;;;489    
;;;490      // Skip if stack is not initialized
;;;491      if ( !tud_inited() ) return;
;;;492    
;;;493      // Loop until there is no more events in the queue
;;;494      while (1)
;;;495      {
;;;496        dcd_event_t event;
;;;497        if ( !osal_queue_receive(_usbd_q, &event, timeout_ms) ) return;
;;;498    
;;;499    #if CFG_TUSB_DEBUG >= 2
;;;500        if (event.event_id == DCD_EVENT_SETUP_RECEIVED) TU_LOG(USBD_DBG, "\r\n"); // extra line for setup
;;;501        TU_LOG(USBD_DBG, "USBD %s ", event.event_id < DCD_EVENT_COUNT ? _usbd_event_str[event.event_id] : "CORRUPTED");
;;;502    #endif
;;;503    
;;;504        switch ( event.event_id )
;;;505        {
;;;506          case DCD_EVENT_BUS_RESET:
;;;507            TU_LOG(USBD_DBG, ": %s Speed\r\n", tu_str_speed[event.bus_reset.speed]);
;;;508            usbd_reset(event.rhport);
;;;509            _usbd_dev.speed = event.bus_reset.speed;
;;;510          break;
;;;511    
;;;512          case DCD_EVENT_UNPLUGGED:
;;;513            TU_LOG(USBD_DBG, "\r\n");
;;;514            usbd_reset(event.rhport);
;;;515    
;;;516            // invoke callback
;;;517            if (tud_umount_cb) tud_umount_cb();
;;;518          break;
;;;519    
;;;520          case DCD_EVENT_SETUP_RECEIVED:
;;;521            TU_LOG_PTR(USBD_DBG, &event.setup_received);
;;;522            TU_LOG(USBD_DBG, "\r\n");
;;;523    
;;;524            // Mark as connected after receiving 1st setup packet.
;;;525            // But it is easier to set it every time instead of wasting time to check then set
;;;526            _usbd_dev.connected = 1;
;;;527    
;;;528            // mark both in & out control as free
;;;529            _usbd_dev.ep_status[0][TUSB_DIR_OUT].busy = 0;
;;;530            _usbd_dev.ep_status[0][TUSB_DIR_OUT].claimed = 0;
;;;531            _usbd_dev.ep_status[0][TUSB_DIR_IN ].busy = 0;
;;;532            _usbd_dev.ep_status[0][TUSB_DIR_IN ].claimed = 0;
;;;533    
;;;534            // Process control request
;;;535            if ( !process_control_request(event.rhport, &event.setup_received) )
;;;536            {
;;;537              TU_LOG(USBD_DBG, "  Stall EP0\r\n");
;;;538              // Failed -> stall both control endpoint IN and OUT
;;;539              dcd_edpt_stall(event.rhport, 0);
;;;540              dcd_edpt_stall(event.rhport, 0 | TUSB_DIR_IN_MASK);
;;;541            }
;;;542          break;
;;;543    
;;;544          case DCD_EVENT_XFER_COMPLETE:
;;;545          {
;;;546            // Invoke the class callback associated with the endpoint address
;;;547            uint8_t const ep_addr = event.xfer_complete.ep_addr;
;;;548            uint8_t const epnum   = tu_edpt_number(ep_addr);
;;;549            uint8_t const ep_dir  = tu_edpt_dir(ep_addr);
;;;550    
;;;551            TU_LOG(USBD_DBG, "on EP %02X with %u bytes\r\n", ep_addr, (unsigned int) event.xfer_complete.len);
;;;552    
;;;553            _usbd_dev.ep_status[epnum][ep_dir].busy = 0;
;;;554            _usbd_dev.ep_status[epnum][ep_dir].claimed = 0;
;;;555    
;;;556            if ( 0 == epnum )
;;;557            {
;;;558              usbd_control_xfer_cb(event.rhport, ep_addr, (xfer_result_t) event.xfer_complete.result, event.xfer_complete
;;;559              .len);
;;;560            }
;;;561            else
;;;562            {
;;;563              usbd_class_driver_t const * driver = get_driver( _usbd_dev.ep2drv[epnum][ep_dir] );
;;;564              TU_ASSERT(driver, );
;;;565    
;;;566              TU_LOG(USBD_DBG, "  %s xfer callback\r\n", driver->name);
;;;567              driver->xfer_cb(event.rhport, ep_addr, (xfer_result_t) event.xfer_complete.result, event.xfer_complete.len);
;;;568            }
;;;569          }
;;;570          break;
;;;571    
;;;572          case DCD_EVENT_SUSPEND:
;;;573            // NOTE: When plugging/unplugging device, the D+/D- state are unstable and
;;;574            // can accidentally meet the SUSPEND condition ( Bus Idle for 3ms ), which result in a series of event
;;;575            // e.g suspend -> resume -> unplug/plug. Skip suspend/resume if not connected
;;;576            if ( _usbd_dev.connected )
;;;577            {
;;;578              TU_LOG(USBD_DBG, ": Remote Wakeup = %u\r\n", _usbd_dev.remote_wakeup_en);
;;;579              if (tud_suspend_cb) tud_suspend_cb(_usbd_dev.remote_wakeup_en);
;;;580            }else
;;;581            {
;;;582              TU_LOG(USBD_DBG, " Skipped\r\n");
;;;583            }
;;;584          break;
;;;585    
;;;586          case DCD_EVENT_RESUME:
;;;587            if ( _usbd_dev.connected )
;;;588            {
;;;589              TU_LOG(USBD_DBG, "\r\n");
;;;590              if (tud_resume_cb) tud_resume_cb();
;;;591            }else
;;;592            {
;;;593              TU_LOG(USBD_DBG, " Skipped\r\n");
;;;594            }
;;;595          break;
;;;596    
;;;597          case USBD_EVENT_FUNC_CALL:
;;;598            TU_LOG(USBD_DBG, "\r\n");
;;;599            if ( event.func_call.func ) event.func_call.func(event.func_call.param);
;;;600          break;
;;;601    
;;;602          case DCD_EVENT_SOF:
;;;603          default:
;;;604            TU_BREAKPOINT();
;;;605          break;
;;;606        }
;;;607    
;;;608    #if CFG_TUSB_OS != OPT_OS_NONE && CFG_TUSB_OS != OPT_OS_PICO
;;;609        // return if there is no more events, for application to run other background
;;;610        if (osal_queue_empty(_usbd_q)) return;
;;;611    #endif
;;;612      }
;;;613    }
000308  028dd054          ADDEQ    sp,sp,#0x54
00030c  08bd8ff0          POPEQ    {r4-r11,pc}
000310  e59d204c          LDR      r2,[sp,#0x4c]         ;487
000314  e59f8bd4          LDR      r8,|L1.3824|
000318  e1a02802          LSL      r2,r2,#16             ;487
00031c  e1a02822          LSR      r2,r2,#16             ;487
000320  e58d203c          STR      r2,[sp,#0x3c]         ;487
000324  e59f2bcc          LDR      r2,|L1.3832|
000328  e58d2038          STR      r2,[sp,#0x38]         ;487
                  |L1.812|
00032c  e59d004c          LDR      r0,[sp,#0x4c]         ;497
000330  e5945008          LDR      r5,[r4,#8]            ;497  ; _usbd_q
000334  e3700001          CMN      r0,#1                 ;497
000338  059f2bbc          LDREQ    r2,|L1.3836|
00033c  e28d602c          ADD      r6,sp,#0x2c           ;497
000340  0a000002          BEQ      |L1.848|
000344  e59f2bb4          LDR      r2,|L1.3840|
000348  e1500002          CMP      r0,r2                 ;497
00034c  359d203c          LDRCC    r2,[sp,#0x3c]         ;497
                  |L1.848|
000350  e5950008          LDR      r0,[r5,#8]            ;497
000354  e1a0100d          MOV      r1,sp                 ;497
000358  ebfffffe          BL       os_mbx_wait
00035c  e1d520b2          LDRH     r2,[r5,#2]            ;497
000360  e59d1000          LDR      r1,[sp,#0]            ;497
000364  e1a00006          MOV      r0,r6                 ;497
000368  ebfffffe          BL       __aeabi_memcpy
00036c  e5950004          LDR      r0,[r5,#4]            ;497
000370  e59d1000          LDR      r1,[sp,#0]            ;497
000374  ef000002          SVC      #0x2                  ;497
000378  e5dd002d          LDRB     r0,[sp,#0x2d]         ;504
00037c  e3a05001          MOV      r5,#1                 ;504
000380  e3500009          CMP      r0,#9                 ;504
000384  379ff100          LDRCC    pc,[pc,r0,LSL #2]     ;504
                  ||__switch$$||                  ; Alternate entry point
;;;614    
000388  ea0002ed          B        |L1.3908|
                          DCD      ||__switch$$||+0xbbc
                          DCD      ||__switch$$||+0x28
                          DCD      ||__switch$$||+0xe4
                          DCD      ||__switch$$||+0xbbc
                          DCD      ||__switch$$||+0xb04
                          DCD      ||__switch$$||+0xb30
                          DCD      ||__switch$$||+0x1a0
                          DCD      ||__switch$$||+0xa58
                          DCD      ||__switch$$||+0xba4
0003b0  e5d40000          LDRB     r0,[r4,#0]  ; _app_driver_count
0003b4  e5dd902c          LDRB     r9,[sp,#0x2c]
0003b8  e3a06000          MOV      r6,#0
0003bc  e3700002          CMN      r0,#2
0003c0  159f7b2c          LDRNE    r7,|L1.3828|
0003c4  0a000019          BEQ      |L1.1072|
                  |L1.968|
0003c8  e3580000          CMP      r8,#0
0003cc  e1a05006          MOV      r5,r6
0003d0  0a000007          BEQ      |L1.1012|
0003d4  e5d40000          LDRB     r0,[r4,#0]  ; _app_driver_count
0003d8  e1550000          CMP      r5,r0
0003dc  20460000          SUBCS    r0,r6,r0
0003e0  220050ff          ANDCS    r5,r0,#0xff
0003e4  35940004          LDRCC    r0,[r4,#4]  ; _app_driver
0003e8  30861086          ADDCC    r1,r6,r6,LSL #1
0003ec  30800181          ADDCC    r0,r0,r1,LSL #3
0003f0  3a000003          BCC      |L1.1028|
                  |L1.1012|
0003f4  e3550002          CMP      r5,#2
0003f8  30850085          ADDCC    r0,r5,r5,LSL #1
0003fc  30870180          ADDCC    r0,r7,r0,LSL #3
000400  2a000014          BCS      |L1.1112|
                  |L1.1028|
000404  e3500000          CMP      r0,#0
000408  0a000012          BEQ      |L1.1112|
00040c  e5901004          LDR      r1,[r0,#4]
000410  e1a00009          MOV      r0,r9
000414  e12fff31          BLX      r1
000418  e5d40000          LDRB     r0,[r4,#0]  ; _app_driver_count
00041c  e2861001          ADD      r1,r6,#1
000420  e20160ff          AND      r6,r1,#0xff
000424  e2800002          ADD      r0,r0,#2
000428  e1560000          CMP      r6,r0
00042c  3affffe5          BCC      |L1.968|
                  |L1.1072|
000430  e59f0aa0          LDR      r0,|L1.3800|
000434  e3a01023          MOV      r1,#0x23
000438  ebfffffe          BL       __aeabi_memclr4
00043c  e59f0ac0          LDR      r0,|L1.3844|
000440  e3a020ff          MOV      r2,#0xff
000444  e3a01010          MOV      r1,#0x10
000448  ebfffffe          BL       __aeabi_memset
00044c  e59d0038          LDR      r0,[sp,#0x38]
000450  e3a010ff          MOV      r1,#0xff
000454  ebfffffe          BL       __ARM_common_memset1_8
                  |L1.1112|
000458  ebfffffe          BL       usbd_control_reset
00045c  e5dd1030          LDRB     r1,[sp,#0x30]
000460  e59f0a70          LDR      r0,|L1.3800|
000464  e5c01002          STRB     r1,[r0,#2]  ; _usbd_dev
000468  ea0002b5          B        |L1.3908|
00046c  e5d40000          LDRB     r0,[r4,#0]  ; _app_driver_count
000470  e5dd902c          LDRB     r9,[sp,#0x2c]
000474  e3a06000          MOV      r6,#0
000478  e3700002          CMN      r0,#2
00047c  159f7a70          LDRNE    r7,|L1.3828|
000480  0a000019          BEQ      |L1.1260|
                  |L1.1156|
000484  e3580000          CMP      r8,#0
000488  e1a05006          MOV      r5,r6
00048c  0a000007          BEQ      |L1.1200|
000490  e5d40000          LDRB     r0,[r4,#0]  ; _app_driver_count
000494  e1550000          CMP      r5,r0
000498  20460000          SUBCS    r0,r6,r0
00049c  220050ff          ANDCS    r5,r0,#0xff
0004a0  35940004          LDRCC    r0,[r4,#4]  ; _app_driver
0004a4  30861086          ADDCC    r1,r6,r6,LSL #1
0004a8  30800181          ADDCC    r0,r0,r1,LSL #3
0004ac  3a000003          BCC      |L1.1216|
                  |L1.1200|
0004b0  e3550002          CMP      r5,#2
0004b4  30850085          ADDCC    r0,r5,r5,LSL #1
0004b8  30870180          ADDCC    r0,r7,r0,LSL #3
0004bc  2a000014          BCS      |L1.1300|
                  |L1.1216|
0004c0  e3500000          CMP      r0,#0
0004c4  0a000012          BEQ      |L1.1300|
0004c8  e5901004          LDR      r1,[r0,#4]
0004cc  e1a00009          MOV      r0,r9
0004d0  e12fff31          BLX      r1
0004d4  e5d40000          LDRB     r0,[r4,#0]  ; _app_driver_count
0004d8  e2861001          ADD      r1,r6,#1
0004dc  e20160ff          AND      r6,r1,#0xff
0004e0  e2800002          ADD      r0,r0,#2
0004e4  e1560000          CMP      r6,r0
0004e8  3affffe5          BCC      |L1.1156|
                  |L1.1260|
0004ec  e59f09e4          LDR      r0,|L1.3800|
0004f0  e3a01023          MOV      r1,#0x23
0004f4  ebfffffe          BL       __aeabi_memclr4
0004f8  e59f0a04          LDR      r0,|L1.3844|
0004fc  e3a020ff          MOV      r2,#0xff
000500  e3a01010          MOV      r1,#0x10
000504  ebfffffe          BL       __aeabi_memset
000508  e59d0038          LDR      r0,[sp,#0x38]
00050c  e3a010ff          MOV      r1,#0xff
000510  ebfffffe          BL       __ARM_common_memset1_8
                  |L1.1300|
000514  ebfffffe          BL       usbd_control_reset
000518  e59f09e8          LDR      r0,|L1.3848|
00051c  e3500000          CMP      r0,#0
000520  1bfffffe          BLNE     tud_umount_cb
000524  ea000286          B        |L1.3908|
000528  e59f69a8          LDR      r6,|L1.3800|
00052c  e5d60000          LDRB     r0,[r6,#0]  ; _usbd_dev
000530  e3800001          ORR      r0,r0,#1
000534  e5c60000          STRB     r0,[r6,#0]  ; _usbd_dev
000538  e5d6001b          LDRB     r0,[r6,#0x1b]  ; _usbd_dev
00053c  e3c00001          BIC      r0,r0,#1
000540  e5c6001b          STRB     r0,[r6,#0x1b]  ; _usbd_dev
000544  e5d6001b          LDRB     r0,[r6,#0x1b]  ; _usbd_dev
000548  e3c00004          BIC      r0,r0,#4
00054c  e5c6001b          STRB     r0,[r6,#0x1b]  ; _usbd_dev
000550  e5d6001c          LDRB     r0,[r6,#0x1c]  ; _usbd_dev
000554  e3c00001          BIC      r0,r0,#1
000558  e5c6001c          STRB     r0,[r6,#0x1c]  ; _usbd_dev
00055c  e5d6001c          LDRB     r0,[r6,#0x1c]  ; _usbd_dev
000560  e3c00004          BIC      r0,r0,#4
000564  e5c6001c          STRB     r0,[r6,#0x1c]  ; _usbd_dev
000568  e5dd002c          LDRB     r0,[sp,#0x2c]
00056c  e58d0008          STR      r0,[sp,#8]
000570  e28d0030          ADD      r0,sp,#0x30
000574  e58d0004          STR      r0,[sp,#4]
000578  e3a00000          MOV      r0,#0
00057c  ebfffffe          BL       usbd_control_set_complete_callback
000580  e5dd2030          LDRB     r2,[sp,#0x30]
000584  e3a01003          MOV      r1,#3
000588  e1a00c82          LSL      r0,r2,#25
00058c  e1510f20          CMP      r1,r0,LSR #30
000590  9a0001d6          BLS      |L1.3312|
000594  e3a01002          MOV      r1,#2
000598  e1510f20          CMP      r1,r0,LSR #30
00059c  1a000008          BNE      |L1.1476|
0005a0  e59f0964          LDR      r0,|L1.3852|
0005a4  e3500000          CMP      r0,#0
0005a8  0a0001d0          BEQ      |L1.3312|
0005ac  ebfffffe          BL       usbd_control_set_complete_callback
0005b0  e59d0008          LDR      r0,[sp,#8]
0005b4  e59d2004          LDR      r2,[sp,#4]
0005b8  e3a01001          MOV      r1,#1
0005bc  ebfffffe          BL       tud_vendor_control_xfer_cb
0005c0  ea0001c1          B        |L1.3276|
                  |L1.1476|
0005c4  e212101f          ANDS     r1,r2,#0x1f
0005c8  0a000004          BEQ      |L1.1504|
0005cc  e3510001          CMP      r1,#1
0005d0  0a00015d          BEQ      |L1.2892|
0005d4  e3510002          CMP      r1,#2
0005d8  0a000195          BEQ      |L1.3124|
0005dc  ea0001c3          B        |L1.3312|
                  |L1.1504|
0005e0  e1550f20          CMP      r5,r0,LSR #30
0005e4  1a000018          BNE      |L1.1612|
0005e8  e1dd03b4          LDRH     r0,[sp,#0x34]
0005ec  e20000ff          AND      r0,r0,#0xff
0005f0  e3500010          CMP      r0,#0x10
0005f4  2a0001bd          BCS      |L1.3312|
0005f8  e0800006          ADD      r0,r0,r6
0005fc  e5d00003          LDRB     r0,[r0,#3]
000600  e3580000          CMP      r8,#0
000604  0a000008          BEQ      |L1.1580|
000608  e5d41000          LDRB     r1,[r4,#0]  ; _app_driver_count
00060c  e1500001          CMP      r0,r1
000610  20400001          SUBCS    r0,r0,r1
000614  220000ff          ANDCS    r0,r0,#0xff
000618  2a000003          BCS      |L1.1580|
00061c  e5941004          LDR      r1,[r4,#4]  ; _app_driver
000620  e0800080          ADD      r0,r0,r0,LSL #1
000624  e0815180          ADD      r5,r1,r0,LSL #3
000628  ea000004          B        |L1.1600|
                  |L1.1580|
00062c  e3500002          CMP      r0,#2
000630  2a0001ae          BCS      |L1.3312|
000634  e0801080          ADD      r1,r0,r0,LSL #1
000638  e59f08b4          LDR      r0,|L1.3828|
00063c  e0805181          ADD      r5,r0,r1,LSL #3
                  |L1.1600|
000640  e3550000          CMP      r5,#0
000644  0a0001a9          BEQ      |L1.3312|
000648  ea000197          B        |L1.3244|
                  |L1.1612|
00064c  e3120060          TST      r2,#0x60
000650  1a0001a6          BNE      |L1.3312|
000654  e5dd0031          LDRB     r0,[sp,#0x31]
000658  e350000a          CMP      r0,#0xa
00065c  379ff100          LDRCC    pc,[pc,r0,LSL #2]
                  |symbol_number.40|                  ; Alternate entry point
;;;485     */
;;;486    void tud_task_ext(uint32_t timeout_ms, bool in_isr)
;;;487    {
;;;488      (void) in_isr; // not implemented yet
;;;489    
;;;490      // Skip if stack is not initialized
;;;491      if ( !tud_inited() ) return;
;;;492    
;;;493      // Loop until there is no more events in the queue
;;;494      while (1)
;;;495      {
;;;496        dcd_event_t event;
;;;497        if ( !osal_queue_receive(_usbd_q, &event, timeout_ms) ) return;
;;;498    
;;;499    #if CFG_TUSB_DEBUG >= 2
;;;500        if (event.event_id == DCD_EVENT_SETUP_RECEIVED) TU_LOG(USBD_DBG, "\r\n"); // extra line for setup
;;;501        TU_LOG(USBD_DBG, "USBD %s ", event.event_id < DCD_EVENT_COUNT ? _usbd_event_str[event.event_id] : "CORRUPTED");
;;;502    #endif
;;;503    
;;;504        switch ( event.event_id )
;;;505        {
;;;506          case DCD_EVENT_BUS_RESET:
;;;507            TU_LOG(USBD_DBG, ": %s Speed\r\n", tu_str_speed[event.bus_reset.speed]);
;;;508            usbd_reset(event.rhport);
;;;509            _usbd_dev.speed = event.bus_reset.speed;
;;;510          break;
;;;511    
;;;512          case DCD_EVENT_UNPLUGGED:
;;;513            TU_LOG(USBD_DBG, "\r\n");
;;;514            usbd_reset(event.rhport);
;;;515    
;;;516            // invoke callback
;;;517            if (tud_umount_cb) tud_umount_cb();
;;;518          break;
;;;519    
;;;520          case DCD_EVENT_SETUP_RECEIVED:
;;;521            TU_LOG_PTR(USBD_DBG, &event.setup_received);
;;;522            TU_LOG(USBD_DBG, "\r\n");
;;;523    
;;;524            // Mark as connected after receiving 1st setup packet.
;;;525            // But it is easier to set it every time instead of wasting time to check then set
;;;526            _usbd_dev.connected = 1;
;;;527    
;;;528            // mark both in & out control as free
;;;529            _usbd_dev.ep_status[0][TUSB_DIR_OUT].busy = 0;
;;;530            _usbd_dev.ep_status[0][TUSB_DIR_OUT].claimed = 0;
;;;531            _usbd_dev.ep_status[0][TUSB_DIR_IN ].busy = 0;
;;;532            _usbd_dev.ep_status[0][TUSB_DIR_IN ].claimed = 0;
;;;533    
;;;534            // Process control request
;;;535            if ( !process_control_request(event.rhport, &event.setup_received) )
;;;536            {
;;;537              TU_LOG(USBD_DBG, "  Stall EP0\r\n");
;;;538              // Failed -> stall both control endpoint IN and OUT
;;;539              dcd_edpt_stall(event.rhport, 0);
;;;540              dcd_edpt_stall(event.rhport, 0 | TUSB_DIR_IN_MASK);
;;;541            }
;;;542          break;
;;;543    
;;;544          case DCD_EVENT_XFER_COMPLETE:
;;;545          {
;;;546            // Invoke the class callback associated with the endpoint address
;;;547            uint8_t const ep_addr = event.xfer_complete.ep_addr;
;;;548            uint8_t const epnum   = tu_edpt_number(ep_addr);
;;;549            uint8_t const ep_dir  = tu_edpt_dir(ep_addr);
;;;550    
;;;551            TU_LOG(USBD_DBG, "on EP %02X with %u bytes\r\n", ep_addr, (unsigned int) event.xfer_complete.len);
;;;552    
;;;553            _usbd_dev.ep_status[epnum][ep_dir].busy = 0;
;;;554            _usbd_dev.ep_status[epnum][ep_dir].claimed = 0;
;;;555    
;;;556            if ( 0 == epnum )
;;;557            {
;;;558              usbd_control_xfer_cb(event.rhport, ep_addr, (xfer_result_t) event.xfer_complete.result, event.xfer_complete
;;;559              .len);
;;;560            }
;;;561            else
;;;562            {
;;;563              usbd_class_driver_t const * driver = get_driver( _usbd_dev.ep2drv[epnum][ep_dir] );
;;;564              TU_ASSERT(driver, );
;;;565    
;;;566              TU_LOG(USBD_DBG, "  %s xfer callback\r\n", driver->name);
;;;567              driver->xfer_cb(event.rhport, ep_addr, (xfer_result_t) event.xfer_complete.result, event.xfer_complete.len);
;;;568            }
;;;569          }
;;;570          break;
;;;571    
;;;572          case DCD_EVENT_SUSPEND:
;;;573            // NOTE: When plugging/unplugging device, the D+/D- state are unstable and
;;;574            // can accidentally meet the SUSPEND condition ( Bus Idle for 3ms ), which result in a series of event
;;;575            // e.g suspend -> resume -> unplug/plug. Skip suspend/resume if not connected
;;;576            if ( _usbd_dev.connected )
;;;577            {
;;;578              TU_LOG(USBD_DBG, ": Remote Wakeup = %u\r\n", _usbd_dev.remote_wakeup_en);
;;;579              if (tud_suspend_cb) tud_suspend_cb(_usbd_dev.remote_wakeup_en);
;;;580            }else
;;;581            {
;;;582              TU_LOG(USBD_DBG, " Skipped\r\n");
;;;583            }
;;;584          break;
;;;585    
;;;586          case DCD_EVENT_RESUME:
;;;587            if ( _usbd_dev.connected )
;;;588            {
;;;589              TU_LOG(USBD_DBG, "\r\n");
;;;590              if (tud_resume_cb) tud_resume_cb();
;;;591            }else
;;;592            {
;;;593              TU_LOG(USBD_DBG, " Skipped\r\n");
;;;594            }
;;;595          break;
;;;596    
;;;597          case USBD_EVENT_FUNC_CALL:
;;;598            TU_LOG(USBD_DBG, "\r\n");
;;;599            if ( event.func_call.func ) event.func_call.func(event.func_call.param);
;;;600          break;
;;;601    
;;;602          case DCD_EVENT_SOF:
;;;603          default:
;;;604            TU_BREAKPOINT();
;;;605          break;
;;;606        }
;;;607    
;;;608    #if CFG_TUSB_OS != OPT_OS_NONE && CFG_TUSB_OS != OPT_OS_PICO
;;;609        // return if there is no more events, for application to run other background
;;;610        if (osal_queue_empty(_usbd_q)) return;
;;;611    #endif
;;;612      }
;;;613    }
;;;614    
000660  ea0001a2          B        |L1.3312|
                          DCD      |symbol_number.40|+0x4bc
                          DCD      |symbol_number.40|+0x4a0
                          DCD      |symbol_number.40|+0x690
                          DCD      |symbol_number.40|+0x488
                          DCD      |symbol_number.40|+0x690
                          DCD      |symbol_number.40|+0x2c
                          DCD      |symbol_number.40|+0x36c
                          DCD      |symbol_number.40|+0x690
                          DCD      |symbol_number.40|+0x54
                          DCD      |symbol_number.40|+0x74
00068c  e59d0004          LDR      r0,[sp,#4]
000690  ebfffffe          BL       usbd_control_set_request
000694  e1dd03b2          LDRH     r0,[sp,#0x32]
000698  e20010ff          AND      r1,r0,#0xff
00069c  e59d0008          LDR      r0,[sp,#8]
0006a0  ebfffffe          BL       dcd_set_address
0006a4  e5d60000          LDRB     r0,[r6,#0]  ; _usbd_dev
0006a8  e3800002          ORR      r0,r0,#2
0006ac  e5c60000          STRB     r0,[r6,#0]  ; _usbd_dev
0006b0  ea000223          B        |L1.3908|
0006b4  e5d60001          LDRB     r0,[r6,#1]  ; _usbd_dev
0006b8  e59d1004          LDR      r1,[sp,#4]
0006bc  e3a03001          MOV      r3,#1
0006c0  e5cd0000          STRB     r0,[sp,#0]
0006c4  e59d0008          LDR      r0,[sp,#8]
0006c8  e1a0200d          MOV      r2,sp
0006cc  ebfffffe          BL       tud_control_xfer
0006d0  ea00021b          B        |L1.3908|
0006d4  e59f07fc          LDR      r0,|L1.3800|
0006d8  e1dd13b2          LDRH     r1,[sp,#0x32]
0006dc  e5d02001          LDRB     r2,[r0,#1]  ; _usbd_dev
0006e0  e20100ff          AND      r0,r1,#0xff
0006e4  e1520000          CMP      r2,r0
0006e8  e58d0040          STR      r0,[sp,#0x40]
0006ec  0a0000b2          BEQ      |L1.2492|
0006f0  e59f77e0          LDR      r7,|L1.3800|
0006f4  e5d70001          LDRB     r0,[r7,#1]  ; _usbd_dev
0006f8  e3500000          CMP      r0,#0
0006fc  0a00002d          BEQ      |L1.1976|
000700  e59d0008          LDR      r0,[sp,#8]
000704  ebfffffe          BL       dcd_edpt_close_all
000708  e5d40000          LDRB     r0,[r4,#0]  ; _app_driver_count
00070c  e5d79002          LDRB     r9,[r7,#2]  ; _usbd_dev
000710  e59da008          LDR      r10,[sp,#8]
000714  e3700002          CMN      r0,#2
000718  159f67d4          LDRNE    r6,|L1.3828|
00071c  e3a05000          MOV      r5,#0
000720  0a000019          BEQ      |L1.1932|
                  |L1.1828|
000724  e3580000          CMP      r8,#0
000728  e1a00005          MOV      r0,r5
00072c  0a000007          BEQ      |L1.1872|
000730  e5d41000          LDRB     r1,[r4,#0]  ; _app_driver_count
000734  e1500001          CMP      r0,r1
000738  20450001          SUBCS    r0,r5,r1
00073c  35941004          LDRCC    r1,[r4,#4]  ; _app_driver
000740  220000ff          ANDCS    r0,r0,#0xff
000744  30850085          ADDCC    r0,r5,r5,LSL #1
000748  30810180          ADDCC    r0,r1,r0,LSL #3
00074c  3a000003          BCC      |L1.1888|
                  |L1.1872|
000750  e3500002          CMP      r0,#2
000754  30800080          ADDCC    r0,r0,r0,LSL #1
000758  30860180          ADDCC    r0,r6,r0,LSL #3
00075c  2a000014          BCS      |L1.1972|
                  |L1.1888|
000760  e3500000          CMP      r0,#0
000764  0a000012          BEQ      |L1.1972|
000768  e5901004          LDR      r1,[r0,#4]
00076c  e1a0000a          MOV      r0,r10
000770  e12fff31          BLX      r1
000774  e5d40000          LDRB     r0,[r4,#0]  ; _app_driver_count
000778  e2851001          ADD      r1,r5,#1
00077c  e20150ff          AND      r5,r1,#0xff
000780  e2800002          ADD      r0,r0,#2
000784  e1550000          CMP      r5,r0
000788  3affffe5          BCC      |L1.1828|
                  |L1.1932|
00078c  e59f0744          LDR      r0,|L1.3800|
000790  e3a01023          MOV      r1,#0x23
000794  ebfffffe          BL       __aeabi_memclr4
000798  e3a020ff          MOV      r2,#0xff
00079c  e3a01010          MOV      r1,#0x10
0007a0  e2870003          ADD      r0,r7,#3
0007a4  ebfffffe          BL       __aeabi_memset
0007a8  e59d0038          LDR      r0,[sp,#0x38]
0007ac  e3a010ff          MOV      r1,#0xff
0007b0  ebfffffe          BL       __ARM_common_memset1_8
                  |L1.1972|
0007b4  e5c79002          STRB     r9,[r7,#2]  ; _usbd_dev
                  |L1.1976|
0007b8  e59d0040          LDR      r0,[sp,#0x40]
0007bc  e3500000          CMP      r0,#0
0007c0  0a00007d          BEQ      |L1.2492|
0007c4  e59d0008          LDR      r0,[sp,#8]
0007c8  e58d0024          STR      r0,[sp,#0x24]
0007cc  e59d0040          LDR      r0,[sp,#0x40]
0007d0  e2400001          SUB      r0,r0,#1
0007d4  e20000ff          AND      r0,r0,#0xff
0007d8  ebfffffe          BL       tud_descriptor_configuration_cb
0007dc  e3500000          CMP      r0,#0
0007e0  0a000142          BEQ      |L1.3312|
0007e4  e5d01001          LDRB     r1,[r0,#1]
0007e8  e3510002          CMP      r1,#2
0007ec  1a00013f          BNE      |L1.3312|
0007f0  e5d01007          LDRB     r1,[r0,#7]
0007f4  e5d7c000          LDRB     r12,[r7,#0]  ; _usbd_dev
0007f8  e3a03010          MOV      r3,#0x10
0007fc  e00310a1          AND      r1,r3,r1,LSR #1
000800  e3cc3010          BIC      r3,r12,#0x10
000804  e1811003          ORR      r1,r1,r3
000808  e5c71000          STRB     r1,[r7,#0]  ; _usbd_dev
00080c  e5d03007          LDRB     r3,[r0,#7]
000810  e3a02020          MOV      r2,#0x20
000814  e3c11020          BIC      r1,r1,#0x20
000818  e00220a3          AND      r2,r2,r3,LSR #1
00081c  e1811002          ORR      r1,r1,r2
000820  e5c71000          STRB     r1,[r7,#0]  ; _usbd_dev
000824  e5d01003          LDRB     r1,[r0,#3]
000828  e5d02002          LDRB     r2,[r0,#2]
00082c  e2805009          ADD      r5,r0,#9
000830  e1821401          ORR      r1,r2,r1,LSL #8
000834  e0800001          ADD      r0,r0,r1
000838  e1550000          CMP      r5,r0
00083c  e58d0014          STR      r0,[sp,#0x14]
000840  2a00005a          BCS      |L1.2480|
                  |L1.2116|
000844  e5d50001          LDRB     r0,[r5,#1]
000848  e3a09001          MOV      r9,#1
00084c  e350000b          CMP      r0,#0xb
000850  1a000002          BNE      |L1.2144|
000854  e5d50000          LDRB     r0,[r5,#0]
000858  e5d59003          LDRB     r9,[r5,#3]
00085c  e0855000          ADD      r5,r5,r0
                  |L1.2144|
000860  e5d50001          LDRB     r0,[r5,#1]
000864  e3500004          CMP      r0,#4
000868  1a000120          BNE      |L1.3312|
00086c  e59d0014          LDR      r0,[sp,#0x14]
000870  e5d41000          LDRB     r1,[r4,#0]  ; _app_driver_count
000874  e0400005          SUB      r0,r0,r5
000878  e1a0b800          LSL      r11,r0,#16
00087c  e3710002          CMN      r1,#2
000880  e3a07000          MOV      r7,#0
000884  e1a0b82b          LSR      r11,r11,#16
000888  0a000041          BEQ      |L1.2452|
                  |L1.2188|
00088c  e3580000          CMP      r8,#0
000890  e1a00007          MOV      r0,r7
000894  0a000008          BEQ      |L1.2236|
000898  e5d41000          LDRB     r1,[r4,#0]  ; _app_driver_count
00089c  e1500001          CMP      r0,r1
0008a0  20470001          SUBCS    r0,r7,r1
0008a4  220000ff          ANDCS    r0,r0,#0xff
0008a8  2a000003          BCS      |L1.2236|
0008ac  e5941004          LDR      r1,[r4,#4]  ; _app_driver
0008b0  e0870087          ADD      r0,r7,r7,LSL #1
0008b4  e0816180          ADD      r6,r1,r0,LSL #3
0008b8  ea000004          B        |L1.2256|
                  |L1.2236|
0008bc  e3500002          CMP      r0,#2
0008c0  2a00010a          BCS      |L1.3312|
0008c4  e0801080          ADD      r1,r0,r0,LSL #1
0008c8  e59f0624          LDR      r0,|L1.3828|
0008cc  e0806181          ADD      r6,r0,r1,LSL #3
                  |L1.2256|
0008d0  e3560000          CMP      r6,#0
0008d4  0a000105          BEQ      |L1.3312|
0008d8  e5963008          LDR      r3,[r6,#8]
0008dc  e59d0024          LDR      r0,[sp,#0x24]
0008e0  e1a0200b          MOV      r2,r11
0008e4  e1a01005          MOV      r1,r5
0008e8  e12fff33          BLX      r3
0008ec  e3500009          CMP      r0,#9
0008f0  e1a0a000          MOV      r10,r0
0008f4  215b000a          CMPCS    r11,r10
0008f8  3a00001f          BCC      |L1.2428|
0008fc  e3590001          CMP      r9,#1
000900  0a00000b          BEQ      |L1.2356|
000904  e3590000          CMP      r9,#0
000908  e3a00000          MOV      r0,#0
00090c  9a000013          BLS      |L1.2400|
                  |L1.2320|
000910  e59f15c0          LDR      r1,|L1.3800|
                  |L1.2324|
000914  e5d52002          LDRB     r2,[r5,#2]
000918  e0822000          ADD      r2,r2,r0
00091c  e20220ff          AND      r2,r2,#0xff
000920  e0822001          ADD      r2,r2,r1
000924  e5d23003          LDRB     r3,[r2,#3]
000928  e35300ff          CMP      r3,#0xff
00092c  1a0000ef          BNE      |L1.3312|
000930  ea000005          B        |L1.2380|
                  |L1.2356|
000934  e59f05d4          LDR      r0,|L1.3856|
000938  e5961008          LDR      r1,[r6,#8]
00093c  e1510000          CMP      r1,r0
000940  03a09002          MOVEQ    r9,#2
000944  e3a00000          MOV      r0,#0
000948  eafffff0          B        |L1.2320|
                  |L1.2380|
00094c  e2800001          ADD      r0,r0,#1
000950  e20000ff          AND      r0,r0,#0xff
000954  e1500009          CMP      r0,r9
000958  e5c27003          STRB     r7,[r2,#3]
00095c  3affffec          BCC      |L1.2324|
                  |L1.2400|
000960  e59f0590          LDR      r0,|L1.3832|
000964  e1a03007          MOV      r3,r7
000968  e1a0200a          MOV      r2,r10
00096c  e1a01005          MOV      r1,r5
000970  ebfffffe          BL       tu_edpt_bind_driver
000974  e085500a          ADD      r5,r5,r10
000978  ea000005          B        |L1.2452|
                  |L1.2428|
00097c  e5d40000          LDRB     r0,[r4,#0]  ; _app_driver_count
000980  e2871001          ADD      r1,r7,#1
000984  e20170ff          AND      r7,r1,#0xff
000988  e2800002          ADD      r0,r0,#2
00098c  e1570000          CMP      r7,r0
000990  3affffbd          BCC      |L1.2188|
                  |L1.2452|
000994  e5d40000          LDRB     r0,[r4,#0]  ; _app_driver_count
000998  e2800002          ADD      r0,r0,#2
00099c  e1500007          CMP      r0,r7
0009a0  9a0000d2          BLS      |L1.3312|
0009a4  e59d0014          LDR      r0,[sp,#0x14]
0009a8  e1500005          CMP      r0,r5
0009ac  8affffa4          BHI      |L1.2116|
                  |L1.2480|
0009b0  e59f055c          LDR      r0,|L1.3860|
0009b4  e3500000          CMP      r0,#0
0009b8  1bfffffe          BLNE     tud_mount_cb
                  |L1.2492|
0009bc  e59f1514          LDR      r1,|L1.3800|
0009c0  e59d0040          LDR      r0,[sp,#0x40]
0009c4  e5c10001          STRB     r0,[r1,#1]  ; _usbd_dev
0009c8  ea000095          B        |L1.3108|
0009cc  e1dd13b2          LDRH     r1,[sp,#0x32]
0009d0  e99d0060          LDMIB    sp,{r5,r6}
0009d4  e1a00421          LSR      r0,r1,#8
0009d8  e3500006          CMP      r0,#6
0009dc  e20120ff          AND      r2,r1,#0xff
0009e0  0a000033          BEQ      |L1.2740|
0009e4  ca000006          BGT      |L1.2564|
0009e8  e3500001          CMP      r0,#1
0009ec  0a000009          BEQ      |L1.2584|
0009f0  e3500002          CMP      r0,#2
0009f4  0a000015          BEQ      |L1.2640|
0009f8  e3500003          CMP      r0,#3
0009fc  0a000026          BEQ      |L1.2716|
000a00  ea0000ba          B        |L1.3312|
                  |L1.2564|
000a04  e3500007          CMP      r0,#7
000a08  0a000010          BEQ      |L1.2640|
000a0c  e350000f          CMP      r0,#0xf
000a10  0a000007          BEQ      |L1.2612|
000a14  ea0000b5          B        |L1.3312|
                  |L1.2584|
000a18  ebfffffe          BL       tud_descriptor_device_cb
000a1c  e1a02000          MOV      r2,r0
000a20  e3a03012          MOV      r3,#0x12
000a24  e1a01005          MOV      r1,r5
000a28  e1a00006          MOV      r0,r6
000a2c  ebfffffe          BL       tud_control_xfer
000a30  ea000029          B        |L1.2780|
                  |L1.2612|
000a34  e59f04dc          LDR      r0,|L1.3864|
000a38  e3500000          CMP      r0,#0
000a3c  0a0000ab          BEQ      |L1.3312|
000a40  ebfffffe          BL       tud_descriptor_bos_cb
000a44  e1b02000          MOVS     r2,r0
000a48  0a0000a8          BEQ      |L1.3312|
000a4c  ea000008          B        |L1.2676|
                  |L1.2640|
000a50  e3500002          CMP      r0,#2
000a54  0a00000d          BEQ      |L1.2704|
000a58  e59f04bc          LDR      r0,|L1.3868|
000a5c  e3500000          CMP      r0,#0
000a60  0a0000a2          BEQ      |L1.3312|
000a64  e1a00002          MOV      r0,r2
000a68  ebfffffe          BL       tud_descriptor_other_speed_configuration_cb
                  |L1.2668|
000a6c  e1b02000          MOVS     r2,r0
000a70  0a00009e          BEQ      |L1.3312|
                  |L1.2676|
000a74  e5d21003          LDRB     r1,[r2,#3]
000a78  e5d20002          LDRB     r0,[r2,#2]
000a7c  e1803401          ORR      r3,r0,r1,LSL #8
000a80  e1a01005          MOV      r1,r5
000a84  e1a00006          MOV      r0,r6
000a88  ebfffffe          BL       tud_control_xfer
000a8c  ea000012          B        |L1.2780|
                  |L1.2704|
000a90  e1a00002          MOV      r0,r2
000a94  ebfffffe          BL       tud_descriptor_configuration_cb
000a98  eafffff3          B        |L1.2668|
                  |L1.2716|
000a9c  e1dd13b4          LDRH     r1,[sp,#0x34]
000aa0  e1a00002          MOV      r0,r2
000aa4  ebfffffe          BL       tud_descriptor_string_cb
000aa8  e1b02000          MOVS     r2,r0
000aac  1a000006          BNE      |L1.2764|
000ab0  ea00008e          B        |L1.3312|
                  |L1.2740|
000ab4  e59f0464          LDR      r0,|L1.3872|
000ab8  e3500000          CMP      r0,#0
000abc  0a00008b          BEQ      |L1.3312|
000ac0  ebfffffe          BL       tud_descriptor_device_qualifier_cb
000ac4  e1b02000          MOVS     r2,r0
000ac8  0a000088          BEQ      |L1.3312|
                  |L1.2764|
000acc  e5d23000          LDRB     r3,[r2,#0]
000ad0  e1a01005          MOV      r1,r5
000ad4  e1a00006          MOV      r0,r6
000ad8  ebfffffe          BL       tud_control_xfer
                  |L1.2780|
000adc  e3500000          CMP      r0,#0
000ae0  1a000117          BNE      |L1.3908|
000ae4  ea000081          B        |L1.3312|
000ae8  e1dd03b2          LDRH     r0,[sp,#0x32]
000aec  e3500001          CMP      r0,#1
000af0  05d60000          LDRBEQ   r0,[r6,#0]  ; _usbd_dev
000af4  03800008          ORREQ    r0,r0,#8
000af8  1a00007c          BNE      |L1.3312|
000afc  ea000004          B        |L1.2836|
000b00  e1dd03b2          LDRH     r0,[sp,#0x32]
000b04  e3500001          CMP      r0,#1
000b08  05d60000          LDRBEQ   r0,[r6,#0]  ; _usbd_dev
000b0c  03c00008          BICEQ    r0,r0,#8
000b10  1a000076          BNE      |L1.3312|
                  |L1.2836|
000b14  e5c60000          STRB     r0,[r6,#0]  ; _usbd_dev
000b18  ea000041          B        |L1.3108|
000b1c  e5d60000          LDRB     r0,[r6,#0]  ; _usbd_dev
000b20  e3a03002          MOV      r3,#2
000b24  e1a0200d          MOV      r2,sp
000b28  e2101008          ANDS     r1,r0,#8
000b2c  13a01002          MOVNE    r1,#2
000b30  e1a00d00          LSL      r0,r0,#26
000b34  e1810fa0          ORR      r0,r1,r0,LSR #31
000b38  e1cd00b0          STRH     r0,[sp,#0]
000b3c  e59d0008          LDR      r0,[sp,#8]
000b40  e59d1004          LDR      r1,[sp,#4]
000b44  ebfffffe          BL       tud_control_xfer
000b48  ea0000fd          B        |L1.3908|
                  |L1.2892|
000b4c  e1dd03b4          LDRH     r0,[sp,#0x34]
000b50  e20000ff          AND      r0,r0,#0xff
000b54  e3500010          CMP      r0,#0x10
000b58  2a000064          BCS      |L1.3312|
000b5c  e0800006          ADD      r0,r0,r6
000b60  e5d00003          LDRB     r0,[r0,#3]
000b64  e3580000          CMP      r8,#0
000b68  0a000008          BEQ      |L1.2960|
000b6c  e5d41000          LDRB     r1,[r4,#0]  ; _app_driver_count
000b70  e1500001          CMP      r0,r1
000b74  20400001          SUBCS    r0,r0,r1
000b78  220000ff          ANDCS    r0,r0,#0xff
000b7c  2a000003          BCS      |L1.2960|
000b80  e5941004          LDR      r1,[r4,#4]  ; _app_driver
000b84  e0800080          ADD      r0,r0,r0,LSL #1
000b88  e0815180          ADD      r5,r1,r0,LSL #3
000b8c  ea000004          B        |L1.2980|
                  |L1.2960|
000b90  e3500002          CMP      r0,#2
000b94  2a000055          BCS      |L1.3312|
000b98  e0801080          ADD      r1,r0,r0,LSL #1
000b9c  e59f0350          LDR      r0,|L1.3828|
000ba0  e0805181          ADD      r5,r0,r1,LSL #3
                  |L1.2980|
000ba4  e3550000          CMP      r5,#0
000ba8  0a000050          BEQ      |L1.3312|
000bac  e99d00c0          LDMIB    sp,{r6,r7}
000bb0  e595000c          LDR      r0,[r5,#0xc]
000bb4  ebfffffe          BL       usbd_control_set_complete_callback
000bb8  e595300c          LDR      r3,[r5,#0xc]
000bbc  e1a02006          MOV      r2,r6
000bc0  e3a01001          MOV      r1,#1
000bc4  e1a00007          MOV      r0,r7
000bc8  e12fff33          BLX      r3
000bcc  e3500000          CMP      r0,#0
000bd0  1a0000db          BNE      |L1.3908|
000bd4  e5dd0030          LDRB     r0,[sp,#0x30]
000bd8  e3100060          TST      r0,#0x60
000bdc  1a000043          BNE      |L1.3312|
000be0  e5dd0031          LDRB     r0,[sp,#0x31]
000be4  e350000a          CMP      r0,#0xa
000be8  1350000b          CMPNE    r0,#0xb
000bec  1a00003f          BNE      |L1.3312|
000bf0  e3a00000          MOV      r0,#0
000bf4  ebfffffe          BL       usbd_control_set_complete_callback
000bf8  e5dd0031          LDRB     r0,[sp,#0x31]
000bfc  e350000a          CMP      r0,#0xa
000c00  1a000007          BNE      |L1.3108|
000c04  e3a00000          MOV      r0,#0
000c08  e5cd0000          STRB     r0,[sp,#0]
000c0c  e59d0008          LDR      r0,[sp,#8]
000c10  e59d1004          LDR      r1,[sp,#4]
000c14  e3a03001          MOV      r3,#1
000c18  e1a0200d          MOV      r2,sp
000c1c  ebfffffe          BL       tud_control_xfer
000c20  ea0000c7          B        |L1.3908|
                  |L1.3108|
000c24  e59d0008          LDR      r0,[sp,#8]
000c28  e59d1004          LDR      r1,[sp,#4]
000c2c  ebfffffe          BL       tud_control_status
000c30  ea0000c3          B        |L1.3908|
                  |L1.3124|
000c34  e1dd03b4          LDRH     r0,[sp,#0x34]
000c38  e20010ff          AND      r1,r0,#0xff
000c3c  e3c10080          BIC      r0,r1,#0x80
000c40  e3500004          CMP      r0,#4
000c44  e1a033a1          LSR      r3,r1,#7
000c48  2a000028          BCS      |L1.3312|
000c4c  e0860080          ADD      r0,r6,r0,LSL #1
000c50  e0807003          ADD      r7,r0,r3
000c54  e5d70013          LDRB     r0,[r7,#0x13]
000c58  e3580000          CMP      r8,#0
000c5c  0a000008          BEQ      |L1.3204|
000c60  e5d43000          LDRB     r3,[r4,#0]  ; _app_driver_count
000c64  e1500003          CMP      r0,r3
000c68  20400003          SUBCS    r0,r0,r3
000c6c  220000ff          ANDCS    r0,r0,#0xff
000c70  2a000003          BCS      |L1.3204|
000c74  e5943004          LDR      r3,[r4,#4]  ; _app_driver
000c78  e0800080          ADD      r0,r0,r0,LSL #1
000c7c  e0835180          ADD      r5,r3,r0,LSL #3
000c80  ea000005          B        |L1.3228|
                  |L1.3204|
000c84  e3500002          CMP      r0,#2
000c88  23a05000          MOVCS    r5,#0
000c8c  2a000002          BCS      |L1.3228|
000c90  e0803080          ADD      r3,r0,r0,LSL #1
000c94  e59f0258          LDR      r0,|L1.3828|
000c98  e0805183          ADD      r5,r0,r3,LSL #3
                  |L1.3228|
000c9c  e3120060          TST      r2,#0x60
000ca0  0a00000c          BEQ      |L1.3288|
000ca4  e3550000          CMP      r5,#0
000ca8  0a000010          BEQ      |L1.3312|
                  |L1.3244|
000cac  e99d00c0          LDMIB    sp,{r6,r7}
000cb0  e595000c          LDR      r0,[r5,#0xc]
000cb4  ebfffffe          BL       usbd_control_set_complete_callback
000cb8  e595300c          LDR      r3,[r5,#0xc]
000cbc  e1a02006          MOV      r2,r6
000cc0  e3a01001          MOV      r1,#1
000cc4  e1a00007          MOV      r0,r7
000cc8  e12fff33          BLX      r3
                  |L1.3276|
000ccc  e3500000          CMP      r0,#0
000cd0  1a00009b          BNE      |L1.3908|
000cd4  ea000005          B        |L1.3312|
                  |L1.3288|
000cd8  e5dd0031          LDRB     r0,[sp,#0x31]
000cdc  e3500000          CMP      r0,#0
000ce0  0a000009          BEQ      |L1.3340|
000ce4  e3500001          CMP      r0,#1
000ce8  13500003          CMPNE    r0,#3
000cec  0a000010          BEQ      |L1.3380|
                  |L1.3312|
000cf0  e5dd002c          LDRB     r0,[sp,#0x2c]
000cf4  e3a01000          MOV      r1,#0
000cf8  ebfffffe          BL       dcd_edpt_stall
000cfc  e5dd002c          LDRB     r0,[sp,#0x2c]
000d00  e3a01080          MOV      r1,#0x80
000d04  ebfffffe          BL       dcd_edpt_stall
000d08  ea00008d          B        |L1.3908|
                  |L1.3340|
000d0c  e5d7001b          LDRB     r0,[r7,#0x1b]
000d10  e59d1004          LDR      r1,[sp,#4]
000d14  e3a03002          MOV      r3,#2
000d18  e2000002          AND      r0,r0,#2
000d1c  e1a000a0          LSR      r0,r0,#1
000d20  e1cd00b0          STRH     r0,[sp,#0]
000d24  e59d0008          LDR      r0,[sp,#8]
000d28  e1a0200d          MOV      r2,sp
000d2c  ebfffffe          BL       tud_control_xfer
000d30  ea000083          B        |L1.3908|
                  |L1.3380|
000d34  e1dd23b2          LDRH     r2,[sp,#0x32]
000d38  e3520000          CMP      r2,#0
000d3c  1a000017          BNE      |L1.3488|
000d40  e3500001          CMP      r0,#1
000d44  e5d7001b          LDRB     r0,[r7,#0x1b]
000d48  e2002002          AND      r2,r0,#2
000d4c  e5d40001          LDRB     r0,[r4,#1]  ; _usbd_rhport
000d50  0a000002          BEQ      |L1.3424|
000d54  e3520000          CMP      r2,#0
000d58  0a000009          BEQ      |L1.3460|
000d5c  ea00000f          B        |L1.3488|
                  |L1.3424|
000d60  e3520000          CMP      r2,#0
000d64  0a00000d          BEQ      |L1.3488|
000d68  ebfffffe          BL       dcd_edpt_clear_stall
000d6c  e5d7001b          LDRB     r0,[r7,#0x1b]
000d70  e3c00002          BIC      r0,r0,#2
000d74  e5c7001b          STRB     r0,[r7,#0x1b]
000d78  e5d7001b          LDRB     r0,[r7,#0x1b]
000d7c  e3c00001          BIC      r0,r0,#1
000d80  ea000005          B        |L1.3484|
                  |L1.3460|
000d84  ebfffffe          BL       dcd_edpt_stall
000d88  e5d7001b          LDRB     r0,[r7,#0x1b]
000d8c  e3800002          ORR      r0,r0,#2
000d90  e5c7001b          STRB     r0,[r7,#0x1b]
000d94  e5d7001b          LDRB     r0,[r7,#0x1b]
000d98  e3800001          ORR      r0,r0,#1
                  |L1.3484|
000d9c  e5c7001b          STRB     r0,[r7,#0x1b]
                  |L1.3488|
000da0  e3550000          CMP      r5,#0
000da4  0a000066          BEQ      |L1.3908|
000da8  e99d0280          LDMIB    sp,{r7,r9}
000dac  e595000c          LDR      r0,[r5,#0xc]
000db0  ebfffffe          BL       usbd_control_set_complete_callback
000db4  e595300c          LDR      r3,[r5,#0xc]
000db8  e1a02007          MOV      r2,r7
000dbc  e3a01001          MOV      r1,#1
000dc0  e1a00009          MOV      r0,r9
000dc4  e12fff33          BLX      r3
000dc8  e3a00000          MOV      r0,#0
000dcc  ebfffffe          BL       usbd_control_set_complete_callback
000dd0  e5d6001c          LDRB     r0,[r6,#0x1c]  ; _usbd_dev
000dd4  e3100001          TST      r0,#1
000dd8  0affff91          BEQ      |L1.3108|
000ddc  ea000058          B        |L1.3908|
000de0  e5dd1030          LDRB     r1,[sp,#0x30]
000de4  e59f00ec          LDR      r0,|L1.3800|
000de8  e3d12080          BICS     r2,r1,#0x80
000dec  e0800082          ADD      r0,r0,r2,LSL #1
000df0  e08003a1          ADD      r0,r0,r1,LSR #7
000df4  e5d0301b          LDRB     r3,[r0,#0x1b]
000df8  e3c33001          BIC      r3,r3,#1
000dfc  e5c0301b          STRB     r3,[r0,#0x1b]
000e00  e5d0301b          LDRB     r3,[r0,#0x1b]
000e04  e3c33004          BIC      r3,r3,#4
000e08  e5c0301b          STRB     r3,[r0,#0x1b]
000e0c  0a000019          BEQ      |L1.3704|
000e10  e5d00013          LDRB     r0,[r0,#0x13]
000e14  e3580000          CMP      r8,#0
000e18  0a000007          BEQ      |L1.3644|
000e1c  e5d42000          LDRB     r2,[r4,#0]  ; _app_driver_count
000e20  e1500002          CMP      r0,r2
000e24  20400002          SUBCS    r0,r0,r2
000e28  35942004          LDRCC    r2,[r4,#4]  ; _app_driver
000e2c  220000ff          ANDCS    r0,r0,#0xff
000e30  30800080          ADDCC    r0,r0,r0,LSL #1
000e34  30820180          ADDCC    r0,r2,r0,LSL #3
000e38  3a000005          BCC      |L1.3668|
                  |L1.3644|
000e3c  e3500002          CMP      r0,#2
000e40  228dd054          ADDCS    sp,sp,#0x54
000e44  28bd8ff0          POPCS    {r4-r11,pc}
000e48  e0802080          ADD      r2,r0,r0,LSL #1
000e4c  e59f00a0          LDR      r0,|L1.3828|
000e50  e0800182          ADD      r0,r0,r2,LSL #3
                  |L1.3668|
000e54  e3500000          CMP      r0,#0
000e58  028dd054          ADDEQ    sp,sp,#0x54
000e5c  08bd8ff0          POPEQ    {r4-r11,pc}
000e60  e590c010          LDR      r12,[r0,#0x10]
000e64  e59d3034          LDR      r3,[sp,#0x34]
000e68  e5dd2031          LDRB     r2,[sp,#0x31]
000e6c  e5dd002c          LDRB     r0,[sp,#0x2c]
000e70  e12fff3c          BLX      r12
000e74  ea000032          B        |L1.3908|
                  |L1.3704|
000e78  e59d3034          LDR      r3,[sp,#0x34]
000e7c  e5dd2031          LDRB     r2,[sp,#0x31]
000e80  e5dd002c          LDRB     r0,[sp,#0x2c]
000e84  ebfffffe          BL       usbd_control_xfer_cb
000e88  ea00002d          B        |L1.3908|
000e8c  e59f0044          LDR      r0,|L1.3800|
000e90  e5d01000          LDRB     r1,[r0,#0]  ; _usbd_dev
000e94  e3110001          TST      r1,#1
000e98  159f1084          LDRNE    r1,|L1.3876|
000e9c  13510000          CMPNE    r1,#0
000ea0  0a000027          BEQ      |L1.3908|
000ea4  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_dev
000ea8  e1a00e00          LSL      r0,r0,#28
000eac  e1a00fa0          LSR      r0,r0,#31
000eb0  ebfffffe          BL       tud_suspend_cb
000eb4  ea000022          B        |L1.3908|
000eb8  e59f0018          LDR      r0,|L1.3800|
000ebc  e5d00000          LDRB     r0,[r0,#0]  ; _usbd_dev
000ec0  e3100001          TST      r0,#1
000ec4  159f005c          LDRNE    r0,|L1.3880|
000ec8  13500000          CMPNE    r0,#0
000ecc  0a00001c          BEQ      |L1.3908|
000ed0  ebfffffe          BL       tud_resume_cb
000ed4  ea00001a          B        |L1.3908|
                  |L1.3800|
                          DCD      ||.bss||
                  |L1.3804|
                          DCD      ||.data||
                  |L1.3808|
                          DCD      dcd_disconnect
                  |L1.3812|
                          DCD      dcd_connect
                  |L1.3816|
                          DCD      ||.bss||+0x24
                  |L1.3820|
                          DCD      ||.data||+0x10
                  |L1.3824|
                          DCD      usbd_app_driver_get_cb
                  |L1.3828|
                          DCD      ||.constdata||
                  |L1.3832|
                          DCD      ||.bss||+0x13
                  |L1.3836|
                          DCD      0x0000ffff
                  |L1.3840|
                          DCD      0x0000fffe
                  |L1.3844|
                          DCD      ||.bss||+0x3
                  |L1.3848|
                          DCD      tud_umount_cb
                  |L1.3852|
                          DCD      tud_vendor_control_xfer_cb
                  |L1.3856|
                          DCD      cdcd_open
                  |L1.3860|
                          DCD      tud_mount_cb
                  |L1.3864|
                          DCD      tud_descriptor_bos_cb
                  |L1.3868|
                          DCD      tud_descriptor_other_speed_configuration_cb
                  |L1.3872|
                          DCD      tud_descriptor_device_qualifier_cb
                  |L1.3876|
                          DCD      tud_suspend_cb
                  |L1.3880|
                          DCD      tud_resume_cb
000f2c  e59d0030          LDR      r0,[sp,#0x30]
000f30  e3500000          CMP      r0,#0
000f34  0a000002          BEQ      |L1.3908|
000f38  e59d1030          LDR      r1,[sp,#0x30]
000f3c  e59d0034          LDR      r0,[sp,#0x34]
000f40  e12fff31          BLX      r1
                  |L1.3908|
000f44  e5945008          LDR      r5,[r4,#8]  ; _usbd_q
000f48  e5950008          LDR      r0,[r5,#8]
000f4c  ebfffffe          BL       os_mbx_check
000f50  e1d510b0          LDRH     r1,[r5,#0]
000f54  e1500001          CMP      r0,r1
000f58  1afffcf3          BNE      |L1.812|
000f5c  e28dd054          ADD      sp,sp,#0x54
000f60  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  dcd_event_handler PROC
;;;1084   //--------------------------------------------------------------------+
;;;1085   TU_ATTR_FAST_FUNC void dcd_event_handler(dcd_event_t const * event, bool in_isr)
000f64  e92d4ff0          PUSH     {r4-r11,lr}
;;;1086   {
000f68  e1a06000          MOV      r6,r0
;;;1087     switch (event->event_id)
000f6c  e5d00001          LDRB     r0,[r0,#1]
000f70  e51fb07c          LDR      r11,|L1.3836|
;;;1088     {
;;;1089       case DCD_EVENT_UNPLUGGED:
;;;1090         _usbd_dev.connected  = 0;
;;;1091         _usbd_dev.addressed  = 0;
;;;1092         _usbd_dev.cfg_num    = 0;
;;;1093         _usbd_dev.suspended  = 0;
;;;1094         osal_queue_send(_usbd_q, event, in_isr);
000f74  e51f80a0          LDR      r8,|L1.3804|
000f78  e51f50a8          LDR      r5,|L1.3800|
000f7c  e1a07001          MOV      r7,r1                 ;1086
000f80  e3500002          CMP      r0,#2                 ;1087
000f84  e24dd00c          SUB      sp,sp,#0xc            ;1086
000f88  e3a01000          MOV      r1,#0                 ;1086
000f8c  0a00000f          BEQ      |L1.4048|
000f90  e3500003          CMP      r0,#3                 ;1087
000f94  0a000047          BEQ      |L1.4280|
000f98  e3500004          CMP      r0,#4                 ;1087
000f9c  0a00001f          BEQ      |L1.4128|
000fa0  e3500005          CMP      r0,#5                 ;1087
000fa4  0a00002e          BEQ      |L1.4196|
000fa8  e5984008          LDR      r4,[r8,#8]            ;1087  ; _usbd_q
000fac  e5940004          LDR      r0,[r4,#4]            ;1087
000fb0  ef000001          SVC      #0x1                  ;1087
000fb4  e1d420b2          LDRH     r2,[r4,#2]            ;1087
000fb8  e1a05000          MOV      r5,r0                 ;1087
000fbc  e1a01006          MOV      r1,r6                 ;1087
000fc0  ebfffffe          BL       __aeabi_memcpy
000fc4  e3570000          CMP      r7,#0                 ;1087
000fc8  0a00007c          BEQ      |L1.4544|
000fcc  ea000034          B        |L1.4260|
                  |L1.4048|
000fd0  e5d50000          LDRB     r0,[r5,#0]            ;1090  ; _usbd_dev
000fd4  e3c00001          BIC      r0,r0,#1              ;1090
000fd8  e5c50000          STRB     r0,[r5,#0]            ;1090  ; _usbd_dev
000fdc  e5d50000          LDRB     r0,[r5,#0]            ;1091  ; _usbd_dev
000fe0  e3c00002          BIC      r0,r0,#2              ;1091
000fe4  e5c50000          STRB     r0,[r5,#0]            ;1091  ; _usbd_dev
000fe8  e5c51001          STRB     r1,[r5,#1]            ;1092  ; _usbd_dev
000fec  e5d50000          LDRB     r0,[r5,#0]            ;1093  ; _usbd_dev
000ff0  e3c00004          BIC      r0,r0,#4              ;1093
000ff4  e5c50000          STRB     r0,[r5,#0]            ;1093  ; _usbd_dev
000ff8  e5984008          LDR      r4,[r8,#8]            ;1093  ; _usbd_q
000ffc  e5940004          LDR      r0,[r4,#4]            ;1093
001000  ef000001          SVC      #0x1                  ;1093
001004  e1d420b2          LDRH     r2,[r4,#2]            ;1093
001008  e1a05000          MOV      r5,r0                 ;1093
00100c  e1a01006          MOV      r1,r6                 ;1093
001010  ebfffffe          BL       __aeabi_memcpy
001014  e3570000          CMP      r7,#0                 ;1093
001018  1a000021          BNE      |L1.4260|
00101c  ea000067          B        |L1.4544|
                  |L1.4128|
;;;1095       break;
;;;1096   
;;;1097       case DCD_EVENT_SUSPEND:
;;;1098         // NOTE: When plugging/unplugging device, the D+/D- state are unstable and
;;;1099         // can accidentally meet the SUSPEND condition ( Bus Idle for 3ms ).
;;;1100         // In addition, some MCUs such as SAMD or boards that haven no VBUS detection cannot distinguish
;;;1101         // suspended vs disconnected. We will skip handling SUSPEND/RESUME event if not currently connected
;;;1102         if ( _usbd_dev.connected )
001020  e5d50000          LDRB     r0,[r5,#0]  ; _usbd_dev
001024  e3100001          TST      r0,#1
;;;1103         {
;;;1104           _usbd_dev.suspended = 1;
;;;1105           osal_queue_send(_usbd_q, event, in_isr);
;;;1106         }
;;;1107       break;
;;;1108   
;;;1109       case DCD_EVENT_RESUME:
;;;1110         // skip event if not connected (especially required for SAMD)
;;;1111         if ( _usbd_dev.connected )
;;;1112         {
;;;1113           _usbd_dev.suspended = 0;
;;;1114           osal_queue_send(_usbd_q, event, in_isr);
;;;1115         }
;;;1116       break;
;;;1117   
;;;1118       case DCD_EVENT_SOF:
;;;1119         // SOF driver handler in ISR context
;;;1120         for (uint8_t i = 0; i < TOTAL_DRIVER_COUNT; i++)
;;;1121         {
;;;1122           usbd_class_driver_t const * driver = get_driver(i);
;;;1123           if (driver && driver->sof)
;;;1124           {
;;;1125             driver->sof(event->rhport, event->sof.frame_count);
;;;1126           }
;;;1127         }
;;;1128   
;;;1129         // Some MCUs after running dcd_remote_wakeup() does not have way to detect the end of remote wakeup
;;;1130         // which last 1-15 ms. DCD can use SOF as a clear indicator that bus is back to operational
;;;1131         if ( _usbd_dev.suspended )
;;;1132         {
;;;1133           _usbd_dev.suspended = 0;
;;;1134   
;;;1135           dcd_event_t const event_resume = { .rhport = event->rhport, .event_id = DCD_EVENT_RESUME };
;;;1136           osal_queue_send(_usbd_q, &event_resume, in_isr);
;;;1137         }
;;;1138   
;;;1139         // skip osal queue for SOF in usbd task
;;;1140       break;
;;;1141   
;;;1142       default:
;;;1143         osal_queue_send(_usbd_q, event, in_isr);
;;;1144       break;
;;;1145     }
;;;1146   }
001028  028dd00c          ADDEQ    sp,sp,#0xc
00102c  08bd8ff0          POPEQ    {r4-r11,pc}
001030  e5d50000          LDRB     r0,[r5,#0]            ;1104  ; _usbd_dev
001034  e3800004          ORR      r0,r0,#4              ;1104
001038  e5c50000          STRB     r0,[r5,#0]            ;1104  ; _usbd_dev
00103c  e5984008          LDR      r4,[r8,#8]            ;1104  ; _usbd_q
001040  e5940004          LDR      r0,[r4,#4]            ;1104
001044  ef000001          SVC      #0x1                  ;1104
001048  e1d420b2          LDRH     r2,[r4,#2]            ;1104
00104c  e1a05000          MOV      r5,r0                 ;1104
001050  e1a01006          MOV      r1,r6                 ;1104
001054  ebfffffe          BL       __aeabi_memcpy
001058  e3570000          CMP      r7,#0                 ;1104
00105c  0a000057          BEQ      |L1.4544|
001060  ea00000f          B        |L1.4260|
                  |L1.4196|
001064  e5d50000          LDRB     r0,[r5,#0]            ;1111  ; _usbd_dev
001068  e3100001          TST      r0,#1                 ;1111
00106c  028dd00c          ADDEQ    sp,sp,#0xc
001070  08bd8ff0          POPEQ    {r4-r11,pc}
001074  e5d50000          LDRB     r0,[r5,#0]            ;1113  ; _usbd_dev
001078  e3c00004          BIC      r0,r0,#4              ;1113
00107c  e5c50000          STRB     r0,[r5,#0]            ;1113  ; _usbd_dev
001080  e5984008          LDR      r4,[r8,#8]            ;1113  ; _usbd_q
001084  e5940004          LDR      r0,[r4,#4]            ;1113
001088  ef000001          SVC      #0x1                  ;1113
00108c  e1d420b2          LDRH     r2,[r4,#2]            ;1113
001090  e1a05000          MOV      r5,r0                 ;1113
001094  e1a01006          MOV      r1,r6                 ;1113
001098  ebfffffe          BL       __aeabi_memcpy
00109c  e3570000          CMP      r7,#0                 ;1113
0010a0  0a000046          BEQ      |L1.4544|
                  |L1.4260|
0010a4  e5940008          LDR      r0,[r4,#8]            ;1113
0010a8  e1a01005          MOV      r1,r5                 ;1113
0010ac  e28dd00c          ADD      sp,sp,#0xc            ;1113
0010b0  e8bd4ff0          POP      {r4-r11,lr}           ;1113
0010b4  eafffffe          B        isr_mbx_send
                  |L1.4280|
0010b8  e5d80000          LDRB     r0,[r8,#0]            ;1120  ; _app_driver_count
0010bc  e3a04000          MOV      r4,#0                 ;1120
0010c0  e3700002          CMN      r0,#2                 ;1120
0010c4  151f91dc          LDRNE    r9,|L1.3824|
0010c8  151fa1dc          LDRNE    r10,|L1.3828|
0010cc  0a00001b          BEQ      |L1.4416|
                  |L1.4304|
0010d0  e3590000          CMP      r9,#0                 ;1120
0010d4  e1a00004          MOV      r0,r4                 ;1122
0010d8  0a000007          BEQ      |L1.4348|
0010dc  e5d81000          LDRB     r1,[r8,#0]            ;1122  ; _app_driver_count
0010e0  e1500001          CMP      r0,r1                 ;1122
0010e4  20440001          SUBCS    r0,r4,r1              ;1122
0010e8  35981004          LDRCC    r1,[r8,#4]            ;1122  ; _app_driver
0010ec  220000ff          ANDCS    r0,r0,#0xff           ;1122
0010f0  30840084          ADDCC    r0,r4,r4,LSL #1       ;1122
0010f4  30810180          ADDCC    r0,r1,r0,LSL #3       ;1122
0010f8  3a000003          BCC      |L1.4364|
                  |L1.4348|
0010fc  e3500002          CMP      r0,#2                 ;1122
001100  30800080          ADDCC    r0,r0,r0,LSL #1       ;1122
001104  308a0180          ADDCC    r0,r10,r0,LSL #3      ;1122
001108  2a000006          BCS      |L1.4392|
                  |L1.4364|
00110c  e3500000          CMP      r0,#0                 ;1123
001110  15902014          LDRNE    r2,[r0,#0x14]         ;1123
001114  13520000          CMPNE    r2,#0                 ;1123
001118  0a000002          BEQ      |L1.4392|
00111c  e5961004          LDR      r1,[r6,#4]            ;1125
001120  e5d60000          LDRB     r0,[r6,#0]            ;1125
001124  e12fff32          BLX      r2                    ;1125
                  |L1.4392|
001128  e5d80000          LDRB     r0,[r8,#0]            ;1120  ; _app_driver_count
00112c  e2841001          ADD      r1,r4,#1              ;1120
001130  e20140ff          AND      r4,r1,#0xff           ;1120
001134  e2800002          ADD      r0,r0,#2              ;1120
001138  e1540000          CMP      r4,r0                 ;1120
00113c  3affffe3          BCC      |L1.4304|
                  |L1.4416|
001140  e5d50000          LDRB     r0,[r5,#0]            ;1131  ; _usbd_dev
001144  e3100004          TST      r0,#4                 ;1131
001148  028dd00c          ADDEQ    sp,sp,#0xc
00114c  08bd8ff0          POPEQ    {r4-r11,pc}
001150  e5d50000          LDRB     r0,[r5,#0]            ;1133  ; _usbd_dev
001154  e3c00004          BIC      r0,r0,#4              ;1133
001158  e5c50000          STRB     r0,[r5,#0]            ;1133  ; _usbd_dev
00115c  e59f13f4          LDR      r1,|L1.5464|
001160  e1a0500d          MOV      r5,sp                 ;1136
001164  e8910007          LDM      r1,{r0-r2}            ;1135
001168  e88d0007          STM      sp,{r0-r2}            ;1135
00116c  e5d60000          LDRB     r0,[r6,#0]            ;1135
001170  e5cd0000          STRB     r0,[sp,#0]            ;1135
001174  e5984008          LDR      r4,[r8,#8]            ;1135  ; _usbd_q
001178  e5940004          LDR      r0,[r4,#4]            ;1135
00117c  ef000001          SVC      #0x1                  ;1135
001180  e1d420b2          LDRH     r2,[r4,#2]            ;1135
001184  e1a06000          MOV      r6,r0                 ;1135
001188  e1a01005          MOV      r1,r5                 ;1135
00118c  ebfffffe          BL       __aeabi_memcpy
001190  e5940008          LDR      r0,[r4,#8]            ;1135
001194  e3570000          CMP      r7,#0                 ;1135
001198  0a000003          BEQ      |L1.4524|
00119c  e1a01006          MOV      r1,r6                 ;1135
0011a0  ebfffffe          BL       isr_mbx_send
0011a4  e28dd00c          ADD      sp,sp,#0xc
0011a8  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.4524|
0011ac  e1a0200b          MOV      r2,r11
0011b0  e1a01006          MOV      r1,r6
0011b4  ebfffffe          BL       os_mbx_send
0011b8  e28dd00c          ADD      sp,sp,#0xc
0011bc  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.4544|
0011c0  e5940008          LDR      r0,[r4,#8]
0011c4  e1a0200b          MOV      r2,r11
0011c8  e1a01005          MOV      r1,r5
0011cc  e28dd00c          ADD      sp,sp,#0xc
0011d0  e8bd4ff0          POP      {r4-r11,lr}
0011d4  eafffffe          B        os_mbx_send
;;;1147   
                          ENDP

                  usbd_int_set PROC
;;;1151   
;;;1152   void usbd_int_set(bool enabled)
0011d8  e51f1304          LDR      r1,|L1.3804|
;;;1153   {
;;;1154     if (enabled)
0011dc  e3500000          CMP      r0,#0
;;;1155     {
;;;1156       dcd_int_enable(_usbd_rhport);
0011e0  e5d10001          LDRB     r0,[r1,#1]
0011e4  0a000000          BEQ      |L1.4588|
0011e8  eafffffe          B        dcd_int_enable
                  |L1.4588|
;;;1157     }else
;;;1158     {
;;;1159       dcd_int_disable(_usbd_rhport);
0011ec  eafffffe          B        dcd_int_disable
;;;1160     }
;;;1161   }
;;;1162   
                          ENDP

                  usbd_edpt_open PROC
;;;1205   
;;;1206   bool usbd_edpt_open(uint8_t rhport, tusb_desc_endpoint_t const * desc_ep)
0011f0  e92d4070          PUSH     {r4-r6,lr}
;;;1207   {
;;;1208     rhport = _usbd_rhport;
;;;1209   
;;;1210     TU_ASSERT(tu_edpt_number(desc_ep->bEndpointAddress) < CFG_TUD_ENDPPOINT_MAX);
0011f4  e5d10002          LDRB     r0,[r1,#2]
0011f8  e1a04001          MOV      r4,r1                 ;1207
0011fc  e51f1328          LDR      r1,|L1.3804|
001200  e3c00080          BIC      r0,r0,#0x80
001204  e5d15001          LDRB     r5,[r1,#1]            ;1208  ; _usbd_rhport
001208  e3500004          CMP      r0,#4
00120c  23a00000          MOVCS    r0,#0
;;;1211     TU_ASSERT(tu_edpt_validate(desc_ep, (tusb_speed_t) _usbd_dev.speed));
;;;1212   
;;;1213     return dcd_edpt_open(rhport, desc_ep);
;;;1214   }
001210  28bd8070          POPCS    {r4-r6,pc}
001214  e51f0344          LDR      r0,|L1.3800|
001218  e5d01002          LDRB     r1,[r0,#2]            ;1211  ; _usbd_dev
00121c  e1a00004          MOV      r0,r4                 ;1211
001220  ebfffffe          BL       tu_edpt_validate
001224  e3500000          CMP      r0,#0                 ;1211
001228  08bd8070          POPEQ    {r4-r6,pc}
00122c  e1a01004          MOV      r1,r4                 ;1213
001230  e1a00005          MOV      r0,r5                 ;1213
001234  e8bd4070          POP      {r4-r6,lr}            ;1213
001238  eafffffe          B        dcd_edpt_open
;;;1215   
                          ENDP

                  usbd_open_edpt_pair PROC
;;;1163   // Parse consecutive endpoint descriptors (IN & OUT)
;;;1164   bool usbd_open_edpt_pair(uint8_t rhport, uint8_t const* p_desc, uint8_t ep_count, uint8_t xfer_type, uint8_t* ep_out, uint8_t* ep_in)
00123c  e92d5ff0          PUSH     {r4-r12,lr}
;;;1165   {
001240  e2526000          SUBS     r6,r2,#0
001244  c51f9370          LDRGT    r9,|L1.3804|
001248  c51fa378          LDRGT    r10,|L1.3800|
00124c  e1a07003          MOV      r7,r3
001250  e1a04001          MOV      r4,r1
;;;1166     for(int i=0; i<ep_count; i++)
001254  e3a05000          MOV      r5,#0
001258  da000020          BLE      |L1.4832|
                  |L1.4700|
;;;1167     {
;;;1168       tusb_desc_endpoint_t const * desc_ep = (tusb_desc_endpoint_t const *) p_desc;
;;;1169   
;;;1170       TU_ASSERT(TUSB_DESC_ENDPOINT == desc_ep->bDescriptorType && xfer_type == desc_ep->bmAttributes.xfer);
00125c  e5d40001          LDRB     r0,[r4,#1]
001260  e3500005          CMP      r0,#5
001264  1a00001f          BNE      |L1.4840|
001268  e5d40003          LDRB     r0,[r4,#3]
00126c  e2000003          AND      r0,r0,#3
001270  e1500007          CMP      r0,r7
001274  1a00001b          BNE      |L1.4840|
001278  e5d40002          LDRB     r0,[r4,#2]
00127c  e5d98001          LDRB     r8,[r9,#1]  ; _usbd_rhport
;;;1171       TU_ASSERT(usbd_edpt_open(rhport, desc_ep));
001280  e1a0b004          MOV      r11,r4
001284  e3c00080          BIC      r0,r0,#0x80
001288  e3500004          CMP      r0,#4
00128c  2a000015          BCS      |L1.4840|
001290  e5da1002          LDRB     r1,[r10,#2]  ; _usbd_dev
001294  e1a00004          MOV      r0,r4
001298  ebfffffe          BL       tu_edpt_validate
00129c  e3500000          CMP      r0,#0
0012a0  0a000010          BEQ      |L1.4840|
0012a4  e1a0100b          MOV      r1,r11
0012a8  e1a00008          MOV      r0,r8
0012ac  ebfffffe          BL       dcd_edpt_open
0012b0  e3500000          CMP      r0,#0
0012b4  0a00000b          BEQ      |L1.4840|
;;;1172   
;;;1173       if ( tu_edpt_dir(desc_ep->bEndpointAddress) == TUSB_DIR_IN )
0012b8  e5d40002          LDRB     r0,[r4,#2]
0012bc  e2855001          ADD      r5,r5,#1
0012c0  e3100080          TST      r0,#0x80
;;;1174       {
;;;1175         (*ep_in) = desc_ep->bEndpointAddress;
;;;1176       }else
;;;1177       {
;;;1178         (*ep_out) = desc_ep->bEndpointAddress;
0012c4  059d1028          LDREQ    r1,[sp,#0x28]
0012c8  159d102c          LDRNE    r1,[sp,#0x2c]         ;1175
;;;1179       }
;;;1180   
;;;1181       p_desc = tu_desc_next(p_desc);
;;;1182     }
0012cc  e1550006          CMP      r5,r6
0012d0  e5c10000          STRB     r0,[r1,#0]            ;1178
0012d4  e5d40000          LDRB     r0,[r4,#0]            ;1178
0012d8  e0844000          ADD      r4,r4,r0              ;1178
0012dc  baffffde          BLT      |L1.4700|
                  |L1.4832|
;;;1183   
;;;1184     return true;
0012e0  e3a00001          MOV      r0,#1
;;;1185   }
0012e4  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.4840|
0012e8  e3a00000          MOV      r0,#0                 ;1171
0012ec  e8bd9ff0          POP      {r4-r12,pc}
;;;1186   
                          ENDP

                  usbd_defer_func PROC
;;;1187   // Helper to defer an isr function
;;;1188   void usbd_defer_func(osal_task_func_t func, void* param, bool in_isr)
0012f0  e51f3404          LDR      r3,|L1.3828|
;;;1189   {
0012f4  e52de004          PUSH     {lr}
;;;1190     dcd_event_t event =
0012f8  e593303c          LDR      r3,[r3,#0x3c]  ; <Data9>
0012fc  e24dd00c          SUB      sp,sp,#0xc            ;1189
;;;1191     {
;;;1192         .rhport   = 0,
;;;1193         .event_id = USBD_EVENT_FUNC_CALL,
;;;1194     };
;;;1195   
;;;1196     event.func_call.func  = func;
;;;1197     event.func_call.param = param;
001300  e98d0003          STMIB    sp,{r0,r1}
;;;1198   
;;;1199     dcd_event_handler(&event, in_isr);
001304  e1a01002          MOV      r1,r2
001308  e1a0000d          MOV      r0,sp
00130c  e58d3000          STR      r3,[sp,#0]
001310  ebfffffe          BL       dcd_event_handler
;;;1200   }
001314  e28dd00c          ADD      sp,sp,#0xc
001318  e49df004          POP      {pc}
;;;1201   
                          ENDP

                  usbd_edpt_claim PROC
;;;1215   
;;;1216   bool usbd_edpt_claim(uint8_t rhport, uint8_t ep_addr)
00131c  e51f244c          LDR      r2,|L1.3800|
;;;1217   {
;;;1218     (void) rhport;
;;;1219   
;;;1220     // TODO add this check later, also make sure we don't starve an out endpoint while suspending
;;;1221     // TU_VERIFY(tud_ready());
;;;1222   
;;;1223     uint8_t const epnum       = tu_edpt_number(ep_addr);
001320  e3c10080          BIC      r0,r1,#0x80
;;;1224     uint8_t const dir         = tu_edpt_dir(ep_addr);
;;;1225     tu_edpt_state_t* ep_state = &_usbd_dev.ep_status[epnum][dir];
001324  e0820080          ADD      r0,r2,r0,LSL #1
001328  e08003a1          ADD      r0,r0,r1,LSR #7
;;;1226   
;;;1227     return tu_edpt_claim(ep_state, _usbd_mutex);
00132c  e51f1458          LDR      r1,|L1.3804|
001330  e280001b          ADD      r0,r0,#0x1b
001334  e591100c          LDR      r1,[r1,#0xc]  ; _usbd_mutex
001338  eafffffe          B        tu_edpt_claim
;;;1228   }
;;;1229   
                          ENDP

                  usbd_edpt_release PROC
;;;1230   bool usbd_edpt_release(uint8_t rhport, uint8_t ep_addr)
00133c  e51f246c          LDR      r2,|L1.3800|
;;;1231   {
;;;1232     (void) rhport;
;;;1233   
;;;1234     uint8_t const epnum       = tu_edpt_number(ep_addr);
001340  e3c10080          BIC      r0,r1,#0x80
;;;1235     uint8_t const dir         = tu_edpt_dir(ep_addr);
;;;1236     tu_edpt_state_t* ep_state = &_usbd_dev.ep_status[epnum][dir];
001344  e0820080          ADD      r0,r2,r0,LSL #1
001348  e08003a1          ADD      r0,r0,r1,LSR #7
;;;1237   
;;;1238     return tu_edpt_release(ep_state, _usbd_mutex);
00134c  e51f1478          LDR      r1,|L1.3804|
001350  e280001b          ADD      r0,r0,#0x1b
001354  e591100c          LDR      r1,[r1,#0xc]  ; _usbd_mutex
001358  eafffffe          B        tu_edpt_release
;;;1239   }
;;;1240   
                          ENDP

                  usbd_edpt_xfer PROC
;;;1241   bool usbd_edpt_xfer(uint8_t rhport, uint8_t ep_addr, uint8_t * buffer, uint16_t total_bytes)
00135c  e92d4010          PUSH     {r4,lr}
;;;1242   {
;;;1243     rhport = _usbd_rhport;
;;;1244   
;;;1245     uint8_t const epnum = tu_edpt_number(ep_addr);
;;;1246     uint8_t const dir   = tu_edpt_dir(ep_addr);
;;;1247   
;;;1248     // TODO skip ready() check for now since enumeration also use this API
;;;1249     // TU_VERIFY(tud_ready());
;;;1250   
;;;1251     TU_LOG(USBD_DBG, "  Queue EP %02X with %u bytes ...\r\n", ep_addr, total_bytes);
;;;1252   
;;;1253     // Attempt to transfer on a busy endpoint, sound like an race condition !
;;;1254     TU_ASSERT(_usbd_dev.ep_status[epnum][dir].busy == 0);
001360  e51f4490          LDR      r4,|L1.3800|
001364  e3c10080          BIC      r0,r1,#0x80           ;1245
001368  e0844080          ADD      r4,r4,r0,LSL #1
00136c  e51f0498          LDR      r0,|L1.3804|
001370  e08443a1          ADD      r4,r4,r1,LSR #7
001374  e5d00001          LDRB     r0,[r0,#1]            ;1243  ; _usbd_rhport
001378  e5d4c01b          LDRB     r12,[r4,#0x1b]
00137c  e31c0001          TST      r12,#1
001380  13a00000          MOVNE    r0,#0
;;;1255   
;;;1256     // Set busy first since the actual transfer can be complete before dcd_edpt_xfer()
;;;1257     // could return and USBD task can preempt and clear the busy
;;;1258     _usbd_dev.ep_status[epnum][dir].busy = 1;
;;;1259   
;;;1260     if ( dcd_edpt_xfer(rhport, ep_addr, buffer, total_bytes) )
;;;1261     {
;;;1262       return true;
;;;1263     }else
;;;1264     {
;;;1265       // DCD error, mark endpoint as ready to allow next transfer
;;;1266       _usbd_dev.ep_status[epnum][dir].busy = 0;
;;;1267       _usbd_dev.ep_status[epnum][dir].claimed = 0;
;;;1268       TU_LOG(USBD_DBG, "FAILED\r\n");
;;;1269       TU_BREAKPOINT();
;;;1270       return false;
;;;1271     }
;;;1272   }
001384  18bd8010          POPNE    {r4,pc}
001388  e5d4c01b          LDRB     r12,[r4,#0x1b]        ;1258
00138c  e38cc001          ORR      r12,r12,#1            ;1258
001390  e5c4c01b          STRB     r12,[r4,#0x1b]        ;1258
001394  ebfffffe          BL       dcd_edpt_xfer
001398  e3500000          CMP      r0,#0                 ;1260
00139c  13a00001          MOVNE    r0,#1                 ;1262
0013a0  18bd8010          POPNE    {r4,pc}
0013a4  e5d4001b          LDRB     r0,[r4,#0x1b]         ;1266
0013a8  e3c00001          BIC      r0,r0,#1              ;1266
0013ac  e5c4001b          STRB     r0,[r4,#0x1b]         ;1266
0013b0  e5d4001b          LDRB     r0,[r4,#0x1b]         ;1267
0013b4  e3c00004          BIC      r0,r0,#4              ;1267
0013b8  e5c4001b          STRB     r0,[r4,#0x1b]         ;1267
0013bc  e3a00000          MOV      r0,#0                 ;1270
0013c0  e8bd8010          POP      {r4,pc}
;;;1273   
                          ENDP

                  usbd_edpt_xfer_fifo PROC
;;;1277   // into the USB buffer!
;;;1278   bool usbd_edpt_xfer_fifo(uint8_t rhport, uint8_t ep_addr, tu_fifo_t * ff, uint16_t total_bytes)
0013c4  e92d4010          PUSH     {r4,lr}
;;;1279   {
;;;1280     rhport = _usbd_rhport;
;;;1281   
;;;1282     uint8_t const epnum = tu_edpt_number(ep_addr);
;;;1283     uint8_t const dir   = tu_edpt_dir(ep_addr);
;;;1284   
;;;1285     TU_LOG(USBD_DBG, "  Queue ISO EP %02X with %u bytes ... ", ep_addr, total_bytes);
;;;1286   
;;;1287     // Attempt to transfer on a busy endpoint, sound like an race condition !
;;;1288     TU_ASSERT(_usbd_dev.ep_status[epnum][dir].busy == 0);
0013c8  e51f44f8          LDR      r4,|L1.3800|
0013cc  e3c10080          BIC      r0,r1,#0x80           ;1282
0013d0  e0844080          ADD      r4,r4,r0,LSL #1
0013d4  e51f0500          LDR      r0,|L1.3804|
0013d8  e08443a1          ADD      r4,r4,r1,LSR #7
0013dc  e5d00001          LDRB     r0,[r0,#1]            ;1280  ; _usbd_rhport
0013e0  e5d4c01b          LDRB     r12,[r4,#0x1b]
0013e4  e31c0001          TST      r12,#1
0013e8  13a00000          MOVNE    r0,#0
;;;1289   
;;;1290     // Set busy first since the actual transfer can be complete before dcd_edpt_xfer() could return
;;;1291     // and usbd task can preempt and clear the busy
;;;1292     _usbd_dev.ep_status[epnum][dir].busy = 1;
;;;1293   
;;;1294     if (dcd_edpt_xfer_fifo(rhport, ep_addr, ff, total_bytes))
;;;1295     {
;;;1296       TU_LOG(USBD_DBG, "OK\r\n");
;;;1297       return true;
;;;1298     }else
;;;1299     {
;;;1300       // DCD error, mark endpoint as ready to allow next transfer
;;;1301       _usbd_dev.ep_status[epnum][dir].busy = 0;
;;;1302       _usbd_dev.ep_status[epnum][dir].claimed = 0;
;;;1303       TU_LOG(USBD_DBG, "failed\r\n");
;;;1304       TU_BREAKPOINT();
;;;1305       return false;
;;;1306     }
;;;1307   }
0013ec  18bd8010          POPNE    {r4,pc}
0013f0  e5d4c01b          LDRB     r12,[r4,#0x1b]        ;1292
0013f4  e38cc001          ORR      r12,r12,#1            ;1292
0013f8  e5c4c01b          STRB     r12,[r4,#0x1b]        ;1292
0013fc  ebfffffe          BL       dcd_edpt_xfer_fifo
001400  e3500000          CMP      r0,#0                 ;1294
001404  13a00001          MOVNE    r0,#1                 ;1297
001408  18bd8010          POPNE    {r4,pc}
00140c  e5d4001b          LDRB     r0,[r4,#0x1b]         ;1301
001410  e3c00001          BIC      r0,r0,#1              ;1301
001414  e5c4001b          STRB     r0,[r4,#0x1b]         ;1301
001418  e5d4001b          LDRB     r0,[r4,#0x1b]         ;1302
00141c  e3c00004          BIC      r0,r0,#4              ;1302
001420  e5c4001b          STRB     r0,[r4,#0x1b]         ;1302
001424  e3a00000          MOV      r0,#0                 ;1305
001428  e8bd8010          POP      {r4,pc}
;;;1308   
                          ENDP

                  usbd_edpt_busy PROC
;;;1309   bool usbd_edpt_busy(uint8_t rhport, uint8_t ep_addr)
00142c  e51f255c          LDR      r2,|L1.3800|
;;;1310   {
;;;1311     (void) rhport;
;;;1312   
;;;1313     uint8_t const epnum = tu_edpt_number(ep_addr);
001430  e3c10080          BIC      r0,r1,#0x80
;;;1314     uint8_t const dir   = tu_edpt_dir(ep_addr);
;;;1315   
;;;1316     return _usbd_dev.ep_status[epnum][dir].busy;
001434  e0820080          ADD      r0,r2,r0,LSL #1
001438  e08003a1          ADD      r0,r0,r1,LSR #7
00143c  e5d0001b          LDRB     r0,[r0,#0x1b]
001440  e2000001          AND      r0,r0,#1
;;;1317   }
001444  e12fff1e          BX       lr
;;;1318   
                          ENDP

                  usbd_edpt_close PROC
;;;1368    */
;;;1369   void usbd_edpt_close(uint8_t rhport, uint8_t ep_addr)
001448  e59f010c          LDR      r0,|L1.5468|
;;;1370   {
00144c  e92d4070          PUSH     {r4-r6,lr}
;;;1371     rhport = _usbd_rhport;
;;;1372   
;;;1373     TU_ASSERT(dcd_edpt_close, /**/);
001450  e3500000          CMP      r0,#0
001454  e51f0580          LDR      r0,|L1.3804|
001458  e5d00001          LDRB     r0,[r0,#1]            ;1371  ; _usbd_rhport
;;;1374     TU_LOG(USBD_DBG, "  CLOSING Endpoint: 0x%02X\r\n", ep_addr);
;;;1375   
;;;1376     uint8_t const epnum = tu_edpt_number(ep_addr);
;;;1377     uint8_t const dir   = tu_edpt_dir(ep_addr);
;;;1378   
;;;1379     dcd_edpt_close(rhport, ep_addr);
;;;1380     _usbd_dev.ep_status[epnum][dir].stalled = 0;
;;;1381     _usbd_dev.ep_status[epnum][dir].busy = 0;
;;;1382     _usbd_dev.ep_status[epnum][dir].claimed = 0;
;;;1383   
;;;1384     return;
;;;1385   }
00145c  08bd8070          POPEQ    {r4-r6,pc}
001460  e3c15080          BIC      r5,r1,#0x80           ;1376
001464  e1a043a1          LSR      r4,r1,#7              ;1377
001468  ebfffffe          BL       dcd_edpt_close
00146c  e51f059c          LDR      r0,|L1.3800|
001470  e0800085          ADD      r0,r0,r5,LSL #1       ;1380
001474  e0800004          ADD      r0,r0,r4              ;1380
001478  e5d0101b          LDRB     r1,[r0,#0x1b]         ;1380
00147c  e3c11002          BIC      r1,r1,#2              ;1380
001480  e5c0101b          STRB     r1,[r0,#0x1b]         ;1380
001484  e5d0101b          LDRB     r1,[r0,#0x1b]         ;1381
001488  e3c11001          BIC      r1,r1,#1              ;1381
00148c  e5c0101b          STRB     r1,[r0,#0x1b]         ;1381
001490  e5d0101b          LDRB     r1,[r0,#0x1b]         ;1382
001494  e3c11004          BIC      r1,r1,#4              ;1382
001498  e5c0101b          STRB     r1,[r0,#0x1b]         ;1382
00149c  e8bd8070          POP      {r4-r6,pc}
;;;1386   
                          ENDP

                  usbd_sof_enable PROC
;;;1387   void usbd_sof_enable(uint8_t rhport, bool en)
0014a0  e51f05cc          LDR      r0,|L1.3804|
;;;1388   {
;;;1389     rhport = _usbd_rhport;
0014a4  e5d00001          LDRB     r0,[r0,#1]  ; _usbd_rhport
;;;1390   
;;;1391     // TODO: Check needed if all drivers including the user sof_cb does not need an active SOF ISR any more.
;;;1392     // Only if all drivers switched off SOF calls the SOF interrupt may be disabled
;;;1393     dcd_sof_enable(rhport, en);
0014a8  eafffffe          B        dcd_sof_enable
;;;1394   }
;;;1395   
                          ENDP

                  usbd_edpt_iso_alloc PROC
;;;1396   bool usbd_edpt_iso_alloc(uint8_t rhport, uint8_t ep_addr, uint16_t largest_packet_size)
0014ac  e59f30ac          LDR      r3,|L1.5472|
;;;1397   {
;;;1398     rhport = _usbd_rhport;
0014b0  e51f05dc          LDR      r0,|L1.3804|
0014b4  e92d4010          PUSH     {r4,lr}               ;1397
;;;1399   
;;;1400     TU_ASSERT(dcd_edpt_iso_alloc);
0014b8  e3530000          CMP      r3,#0
0014bc  e5d00001          LDRB     r0,[r0,#1]            ;1398  ; _usbd_rhport
;;;1401     TU_ASSERT(tu_edpt_number(ep_addr) < CFG_TUD_ENDPPOINT_MAX);
0014c0  13c13080          BICNE    r3,r1,#0x80
0014c4  13530004          CMPNE    r3,#4
0014c8  23a00000          MOVCS    r0,#0
;;;1402   
;;;1403     return dcd_edpt_iso_alloc(rhport, ep_addr, largest_packet_size);
0014cc  3bfffffe          BLCC     dcd_edpt_iso_alloc
;;;1404   }
0014d0  e8bd8010          POP      {r4,pc}
;;;1405   
                          ENDP

                  usbd_edpt_iso_activate PROC
;;;1406   bool usbd_edpt_iso_activate(uint8_t rhport, tusb_desc_endpoint_t const * desc_ep)
0014d4  e92d41f0          PUSH     {r4-r8,lr}
;;;1407   {
;;;1408     rhport = _usbd_rhport;
;;;1409   
;;;1410     uint8_t const epnum = tu_edpt_number(desc_ep->bEndpointAddress);
0014d8  e5d10002          LDRB     r0,[r1,#2]
0014dc  e1a04001          MOV      r4,r1                 ;1407
0014e0  e51f160c          LDR      r1,|L1.3804|
0014e4  e3c05080          BIC      r5,r0,#0x80
0014e8  e5d17001          LDRB     r7,[r1,#1]            ;1408  ; _usbd_rhport
;;;1411     uint8_t const dir   = tu_edpt_dir(desc_ep->bEndpointAddress);
;;;1412   
;;;1413     TU_ASSERT(dcd_edpt_iso_activate);
0014ec  e59f1070          LDR      r1,|L1.5476|
0014f0  e1a083a0          LSR      r8,r0,#7              ;1411
0014f4  e3510000          CMP      r1,#0
;;;1414     TU_ASSERT(epnum < CFG_TUD_ENDPPOINT_MAX);
0014f8  13550004          CMPNE    r5,#4
0014fc  23a00000          MOVCS    r0,#0
;;;1415     TU_ASSERT(tu_edpt_validate(desc_ep, (tusb_speed_t) _usbd_dev.speed));
;;;1416   
;;;1417     _usbd_dev.ep_status[epnum][dir].stalled = 0;
;;;1418     _usbd_dev.ep_status[epnum][dir].busy = 0;
;;;1419     _usbd_dev.ep_status[epnum][dir].claimed = 0;
;;;1420     return dcd_edpt_iso_activate(rhport, desc_ep);
;;;1421   }
001500  28bd81f0          POPCS    {r4-r8,pc}
001504  e1a00004          MOV      r0,r4                 ;1415
001508  e51f6638          LDR      r6,|L1.3800|
00150c  e5d61002          LDRB     r1,[r6,#2]            ;1415  ; _usbd_dev
001510  ebfffffe          BL       tu_edpt_validate
001514  e3500000          CMP      r0,#0                 ;1415
001518  08bd81f0          POPEQ    {r4-r8,pc}
00151c  e0860085          ADD      r0,r6,r5,LSL #1       ;1417
001520  e0802008          ADD      r2,r0,r8              ;1417
001524  e5d2001b          LDRB     r0,[r2,#0x1b]         ;1417
001528  e3c00002          BIC      r0,r0,#2              ;1417
00152c  e5c2001b          STRB     r0,[r2,#0x1b]         ;1417
001530  e5d2001b          LDRB     r0,[r2,#0x1b]         ;1418
001534  e3c00001          BIC      r0,r0,#1              ;1418
001538  e5c2001b          STRB     r0,[r2,#0x1b]         ;1418
00153c  e5d2001b          LDRB     r0,[r2,#0x1b]         ;1419
001540  e3c00004          BIC      r0,r0,#4              ;1419
001544  e5c2001b          STRB     r0,[r2,#0x1b]         ;1419
001548  e1a01004          MOV      r1,r4                 ;1420
00154c  e1a00007          MOV      r0,r7                 ;1420
001550  ebfffffe          BL       dcd_edpt_iso_activate
001554  e8bd81f0          POP      {r4-r8,pc}
;;;1422   
                          ENDP

                  |L1.5464|
                          DCD      ||.constdata||+0x30
                  |L1.5468|
                          DCD      dcd_edpt_close
                  |L1.5472|
                          DCD      dcd_edpt_iso_alloc
                  |L1.5476|
                          DCD      dcd_edpt_iso_activate

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  _usbd_dev
                          %        36
                  _ubsd_mutexdef
                          %        16

                          AREA ||area_number.4||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.4||, ||.bss||
                  _usbd_qdef__mbox
                          %        80

                          AREA ||area_number.5||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.5||, ||.bss||
                  _usbd_qdef__pool
                          %        204

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  _usbd_driver
                          DCD      cdcd_init
                          DCD      cdcd_reset
                          DCD      cdcd_open
                          DCD      cdcd_control_xfer_cb
                          DCD      cdcd_xfer_cb
                          DCD      0x00000000
                          DCD      vendord_init
                          DCD      vendord_reset
                          DCD      vendord_open
                          DCD      tud_vendor_control_xfer_cb
                          DCD      vendord_xfer_cb
                          DCD      0x00000000
000030  00050000          DCB      0x00,0x05,0x00,0x00
                          %        8
00003c  00080000          DCB      0x00,0x08,0x00,0x00
                          %        8

                          AREA ||.data||, DATA, ALIGN=2

                  _app_driver_count
000000  00                DCB      0x00
                  _usbd_rhport
000001  ff0000            DCB      0xff,0x00,0x00
                  _app_driver
                          DCD      0x00000000
                  _usbd_q
                          DCD      0x00000000
                  _usbd_mutex
                          DCD      0x00000000
                  _usbd_qdef
000010  0010000c          DCW      0x0010,0x000c
                          DCD      _usbd_qdef__pool
                          DCD      _usbd_qdef__mbox

                          AREA ||i.__ARM_common_memcpy1_8||, COMGROUP=__ARM_common_memcpy1_8, CODE, READONLY, ALIGN=2

                  __ARM_common_memcpy1_8 PROC
000000  e5d12000          LDRB     r2,[r1,#0]
000004  e5c02000          STRB     r2,[r0,#0]
000008  e5d13001          LDRB     r3,[r1,#1]
00000c  e5c03001          STRB     r3,[r0,#1]
000010  e5d1c002          LDRB     r12,[r1,#2]
000014  e5c0c002          STRB     r12,[r0,#2]
000018  e5d12003          LDRB     r2,[r1,#3]
00001c  e5c02003          STRB     r2,[r0,#3]
000020  e5d13004          LDRB     r3,[r1,#4]
000024  e5c03004          STRB     r3,[r0,#4]
000028  e5d1c005          LDRB     r12,[r1,#5]
00002c  e5c0c005          STRB     r12,[r0,#5]
000030  e5d12006          LDRB     r2,[r1,#6]
000034  e5c02006          STRB     r2,[r0,#6]
000038  e5d13007          LDRB     r3,[r1,#7]
00003c  e5c03007          STRB     r3,[r0,#7]
000040  e12fff1e          BX       lr
                          ENDP


                          AREA ||i.__ARM_common_memset1_8||, COMGROUP=__ARM_common_memset1_8, CODE, READONLY, ALIGN=2

                  __ARM_common_memset1_8 PROC
000000  e20110ff          AND      r1,r1,#0xff
000004  e3100001          TST      r0,#1
000008  e1811401          ORR      r1,r1,r1,LSL #8
00000c  01c010b6          STRHEQ   r1,[r0,#6]
000010  15c01007          STRBNE   r1,[r0,#7]
000014  14c01001          STRBNE   r1,[r0],#1
000018  e1c010b0          STRH     r1,[r0,#0]
00001c  e1c010b2          STRH     r1,[r0,#2]
000020  e1c010b4          STRH     r1,[r0,#4]
000024  e12fff1e          BX       lr
                          ENDP

