###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         11/Sep/2021  20:10:57
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\step_axis_dima\src\board\dima_board.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EW99E0.tmp
#        (D:\proj\velograph\snail\stm32_snail\step_axis_dima\src\board\dima_board.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D DIMA_BRD -D STEP_X -D STM32F205xx
#        -lcN
#        D:\proj\velograph\snail\stm32_snail\step_axis_dima\step_x_dbg\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\step_axis_dima\step_x_dbg\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I D:\proj\velograph\snail\stm32_snail\step_axis_dima\.\ -I
#        D:\proj\velograph\snail\stm32_snail\step_axis_dima\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\step_axis_dima\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\step_axis_dima\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\step_axis_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I D:\proj\velograph\snail\stm32_snail\step_axis_dima\..\common\dbg\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\step_axis_dima\step_x_dbg\List\dima_board.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\step_axis_dima\step_x_dbg\Obj\dima_board.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\step_axis_dima\src\board\dima_board.c
      1          #include <string.h>
      2          #include "FreeRTOS.h"
      3          #include "queue.h"
      4          #include "semphr.h"
      5          ///#include "stm32f2xx_gpio.h"
      6          ///#include "stm32f2xx_rcc.h"
      7          
      8          ////#include "board.h"
      9          #include "board.h"
     10          #include "printk.h"
     11          
     12          extern void uDelay (const uint32_t usec);
     13          extern void  put_tst_pin(uint8_t idat);
     14          void mot_spi_wr(uint8_t addr,uint16_t idata);
     15          uint16_t mot_spi_rd(uint8_t addr);
     16          
     17          ///=============================
     18          int send_char_dbg (int c) 
     19          { 
     20          while (!(UART_DBG->SR & 0x0080));
     21          UART_DBG->DR = (c & 0x1FF);
     22          return (c);
     23          }
     24          
     25          int get_byte_dbg (void) 
     26          {
     27          while (!(UART_DBG->SR & USART_SR_RXNE));
     28          return (UART_DBG->DR);
     29          }
     30          int check_push_key_dbg(void)
     31          {
     32          return  (UART_DBG->SR & USART_SR_RXNE); 
     33          }
     34          
     35          void init_gpio(void)
     36          {
     37          ////RCC_AHBPeriphClockCmd(XEN_PIN_RCC_AHB,ENABLE);
     38          GPIO_InitTypeDef GPIO_InitStructure;
     39          ////=============== TST2 ============================
     40          RCC_AHB1PeriphClockCmd(TST2_PIN_RCC, ENABLE);
     41          GPIO_InitStructure.GPIO_Pin = TST2_PIN;
     42          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     43          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
     44          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     45          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
     46          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
     47          GPIO_Init( TST2_PIN_GPIO, &GPIO_InitStructure );
     48          ////=============== TST3 ============================
     49          RCC_AHB1PeriphClockCmd(TST3_PIN_RCC, ENABLE);
     50          GPIO_InitStructure.GPIO_Pin = TST3_PIN;
     51          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     52          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
     53          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     54          
     55          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     56          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
     57          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
     58          GPIO_Init( TST3_PIN_GPIO, &GPIO_InitStructure );
     59          GPIO_PinAFConfig(TST3_PIN_GPIO, TST3_PIN_NPIN, GPIO_AF_TIM1);
     60          
     61          ////=============== TST7 ============================
     62          RCC_AHB1PeriphClockCmd(TST7_PIN_RCC, ENABLE);
     63          GPIO_InitStructure.GPIO_Pin = TST7_PIN;
     64          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     65          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
     66          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     67          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     68          GPIO_Init( TST7_PIN_GPIO, &GPIO_InitStructure );
     69          GPIO_PinAFConfig(TST7_PIN_GPIO, TST7_PIN_NPIN, GPIO_AF_TIM8);
     70            
     71          ////=========== DBG_UART =================================================== 
     72          RCC_AHB1PeriphClockCmd(UART_DBG_TX_RCC, ENABLE);
     73          GPIO_InitStructure.GPIO_Pin = UART_DBG_TX_PIN;
     74          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     75          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     76          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     77          GPIO_Init( UART_DBG_TX_GPIO, &GPIO_InitStructure );
     78          
     79          RCC_AHB1PeriphClockCmd(UART_DBG_RX_RCC, ENABLE);
     80          GPIO_InitStructure.GPIO_Pin = UART_DBG_RX_PIN;
     81          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     82          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     83          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     84          GPIO_Init( UART_DBG_RX_GPIO, &GPIO_InitStructure );
     85            
     86          GPIO_PinAFConfig(UART_DBG_TX_GPIO, UART_DBG_TX_PIN_NPIN, UART_DBG_TX_AF);
     87          GPIO_PinAFConfig(UART_DBG_RX_GPIO, UART_DBG_RX_PIN_NPIN, UART_DBG_RX_AF);
     88          ////===================================================================
     89          ////=============== MOT_FAULT ============================
     90          RCC_AHB1PeriphClockCmd(MOT_FAULT_PIN_RCC, ENABLE);
     91          GPIO_InitStructure.GPIO_Pin = MOT_FAULT_PIN;
     92          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     93          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
     94          GPIO_Init( MOT_FAULT_PIN_GPIO, &GPIO_InitStructure );
     95          ////=============== MOT_STALLN ============================
     96          RCC_AHB1PeriphClockCmd(MOT_STALLN_PIN_RCC, ENABLE);
     97          GPIO_InitStructure.GPIO_Pin = MOT_STALLN_PIN;
     98          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     99          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    100          GPIO_Init( MOT_STALLN_PIN_GPIO, &GPIO_InitStructure );
    101          ////=============== CONC1 ============================
    102          RCC_AHB1PeriphClockCmd(CONC1_PIN_RCC, ENABLE);
    103          GPIO_InitStructure.GPIO_Pin = CONC1_PIN;
    104          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    105          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    106          GPIO_Init( CONC1_PIN_GPIO, &GPIO_InitStructure );
    107          ////=============== CONC0 ============================
    108          RCC_AHB1PeriphClockCmd(CONC0_PIN_RCC, ENABLE);
    109          GPIO_InitStructure.GPIO_Pin = CONC0_PIN;
    110          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    111          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    112          GPIO_Init( CONC0_PIN_GPIO, &GPIO_InitStructure );
    113          ////=============== ENC_A ============================
    114          ////RCC_AHB1PeriphClockCmd(ENC_A_PIN_RCC, ENABLE);
    115          ////GPIO_InitStructure.GPIO_Pin = ENC_A_PIN;
    116          ////GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    117          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    118          ////GPIO_Init( ENC_A_PIN_GPIO, &GPIO_InitStructure );
    119          ////=============== ENC_B ============================
    120          ////RCC_AHB1PeriphClockCmd(ENC_B_PIN_RCC, ENABLE);
    121          ////GPIO_InitStructure.GPIO_Pin = ENC_B_PIN;
    122          ////GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    123          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    124          ////GPIO_Init( ENC_B_PIN_GPIO, &GPIO_InitStructure );
    125          ////=============== ENC_C ============================
    126          ////RCC_AHB1PeriphClockCmd(ENC_C_PIN_RCC, ENABLE);
    127          ////GPIO_InitStructure.GPIO_Pin = ENC_C_PIN;
    128          ////GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    129          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    130          /////GPIO_Init( ENC_C_PIN_GPIO, &GPIO_InitStructure );
    131          ////=============== MOT_RESET ============================
    132          RCC_AHB1PeriphClockCmd(MOT_RESET_PIN_RCC, ENABLE);
    133          GPIO_InitStructure.GPIO_Pin = MOT_RESET_PIN;
    134          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    135          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    136          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    137          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    138          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    139          GPIO_Init( MOT_RESET_PIN_GPIO, &GPIO_InitStructure );
    140          ////=============== MOT_SLEEP ============================
    141          RCC_AHB1PeriphClockCmd(MOT_SLEEP_PIN_RCC, ENABLE);
    142          GPIO_InitStructure.GPIO_Pin = MOT_SLEEP_PIN;
    143          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    144          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    145          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    146          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    147          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    148          GPIO_Init( MOT_SLEEP_PIN_GPIO, &GPIO_InitStructure );
    149          ////#define MOT_STEP_TIM  	        TIM12
    150          ////=============== MOT_STEP ============================
    151          RCC_AHB1PeriphClockCmd(MOT_STEP_PIN_RCC, ENABLE);
    152          GPIO_InitStructure.GPIO_Pin = MOT_STEP_PIN;
    153          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    154          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    155          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    156          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    157          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    158          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    159          GPIO_Init( MOT_STEP_PIN_GPIO, &GPIO_InitStructure );
    160          GPIO_PinAFConfig(MOT_STEP_PIN_GPIO, MOT_STEP_PIN_NPIN, GPIO_AF_TIM1);
    161          ////===================================================================
    162          
    163          ////=============== MOT_DIR ============================
    164          RCC_AHB1PeriphClockCmd(MOT_DIR_PIN_RCC, ENABLE);
    165          GPIO_InitStructure.GPIO_Pin = MOT_DIR_PIN;
    166          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    167          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    168          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    169          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    170          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    171          GPIO_Init( MOT_DIR_PIN_GPIO, &GPIO_InitStructure );
    172          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    173          
    174          ////=============== MOT_SPI_SCS ============================
    175          RCC_AHB1PeriphClockCmd(MOT_SPI_SCS_PIN_RCC, ENABLE);
    176          GPIO_InitStructure.GPIO_Pin = MOT_SPI_SCS_PIN;
    177          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    178          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    179          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    180          GPIO_Init( MOT_SPI_SCS_PIN_GPIO, &GPIO_InitStructure );
    181          }
    182          ////=============================================
    183          void UART_DBG_Init(void)
    184          {
    185          ////GPIO_InitTypeDef GPIO_InitStructure;
    186          USART_InitTypeDef USART_InitStructure;
    187          UART_DBG_CLK_INIT(UART_DBG_CLK, ENABLE);
    188          USART_DeInit(UART_DBG);
    189          USART_InitStructure.USART_BaudRate = 115200;
    190          USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    191          USART_InitStructure.USART_StopBits = USART_StopBits_1 ;
    192          USART_InitStructure.USART_Parity = USART_Parity_No;
    193          USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    194          USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    195          USART_Init(UART_DBG, &USART_InitStructure);
    196          UART_DBG->CR1 |= USART_CR1_RXNEIE;
    197          USART_Cmd(UART_DBG, ENABLE);
    198          }
    199          
    200          ////==================================================
    201          
    202          void  set_sleep_mot(uint8_t idat)
    203          {
    204          if(idat&0x1)
    205            {
    206            GPIO_SetBits(MOT_SLEEP_PIN_GPIO, MOT_SLEEP_PIN);
    207            }
    208          else
    209            {
    210             GPIO_ResetBits(MOT_SLEEP_PIN_GPIO, MOT_SLEEP_PIN);
    211            }
    212          }
    213          void  set_dir_mot(uint8_t idat)
    214          {
    215          if(idat&0x1)
    216            {
    217            GPIO_SetBits(MOT_DIR_PIN_GPIO, MOT_DIR_PIN);
    218            }
    219          else
    220            {
    221             GPIO_ResetBits(MOT_DIR_PIN_GPIO, MOT_DIR_PIN);
    222            }
    223          }
    224          void  set_reset_mot(uint8_t idat)
    225          {
    226          if(idat&0x1)
    227            {
    228            GPIO_SetBits(MOT_RESET_PIN_GPIO, MOT_RESET_PIN);
    229            }
    230          else
    231            {
    232             GPIO_ResetBits(MOT_RESET_PIN_GPIO, MOT_RESET_PIN);
    233            }
    234          }
    235          
    236          ////==================================================
    237          
    238          volatile uint32_t num_step=0;
    239          
    240          void mot_step_tim_init(void)
    241          {
    242          NVIC_InitTypeDef NVIC_InitStructure; 
    243          
    244          RCC->APB2ENR |= MOT_STEP_TIM_RCC;
    245          MOT_STEP_TIM ->PSC = MOT_TIM_PRESC;
    246          MOT_STEP_TIM ->ARR = MOT_TIM_PERIOD;////
    247          MOT_STEP_TIM ->CCR1 = MOT_TIM_PERIOD/2;////30;
    248          MOT_STEP_TIM->CCER |= TIM_CCER_CC1E;////TIM_CCER_CC2NE;////| TIM_CCER_CC3NP;
    249          MOT_STEP_TIM->BDTR |= TIM_BDTR_MOE;
    250          MOT_STEP_TIM->CCMR1 = TIM_CCMR1_OC1M_0 | TIM_CCMR1_OC1M_1; 
    251          MOT_STEP_TIM->CR1 &= ~TIM_CR1_DIR;
    252          MOT_STEP_TIM->CR1 &= ~TIM_CR1_CMS;
    253          
    254          MOT_STEP_TIM ->DIER = TIM_DIER_CC1IE;
    255          TIM_ClearITPendingBit(MOT_STEP_TIM, TIM_IT_CC1);
    256          
    257          NVIC_InitStructure.NVIC_IRQChannel = MOT_TIM_IRQN;
    258          //// highest priority
    259          NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;
    260          
    261          NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    262          //// highest priority
    263          NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    264          NVIC_Init(&NVIC_InitStructure);
    265          
    266          }
    267          /*
    268          void init_enc_tim(void)
    269          {
    270          ////============= DPX_R ========================
    271          RCC->APB1ENR |= ENC_TIM_RCC;
    272          ENC_TIM ->CCER = TIM_CCER_CC1P | TIM_CCER_CC2P;
    273          ENC_TIM ->CCMR1 = TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
    274          ENC_TIM->SMCR = TIM_SMCR_SMS_0 | TIM_SMCR_SMS_1;
    275          ENC_TIM->ARR = ENC_TIM_PERIOD;////
    276          ENC_TIM->CR1 = TIM_CR1_CEN;
    277          }
    278          */
    279          
    280          void stop_mot_step_tim(void)
    281          {
    282          TIM_Cmd(MOT_STEP_TIM, DISABLE);
    283          }
    284          void ena_mot(uint8_t ena_dis)
    285          {
    286          uint16_t tmp;
    287           
    288          tmp=mot_spi_rd(ADDR_MOT_CTRL);
    289          if(ena_dis&0x1)
    290          {
    291          tmp|=0x1;
    292          }
    293          else
    294          {
    295          tmp&= ~0x1;
    296          }
    297          mot_spi_wr(ADDR_MOT_CTRL,tmp);
    298          }
    299          void put_mot_nstep(uint32_t nstep)
    300          {
    301          ena_mot(1) ;
    302           num_step=nstep; 
    303          TIM_ITConfig(MOT_STEP_TIM, TIM_IT_CC1, ENABLE);
    304          TIM_Cmd(MOT_STEP_TIM, ENABLE);
    305          }
    306          volatile uint32_t gsr;
    307          ////=======================================================
    308          void MOT_STEP_TIM_IRQHandler(void)
    309          { 
    310          if(num_step)
    311            {
    312            num_step--;  
    313            if(num_step==0)
    314              {
    315              stop_mot_step_tim(); 
    316              ena_mot(0) ;
    317              }
    318            }
    319          ////TIM_ClearITPendingBit(MOT_STEP_TIM, TIM_IT_CC2);
    320          TIM_ClearITPendingBit(MOT_STEP_TIM, TIM_IT_CC1);
    321          }
    322          ////===============================================
    323          uint8_t get_conc0(void)
    324          {
    325          return GPIO_ReadInputDataBit(CONC0_PIN_GPIO, CONC0_PIN);
    326          }
    327          uint8_t get_conc1(void)
    328          {
    329          return GPIO_ReadInputDataBit(CONC1_PIN_GPIO, CONC1_PIN);
    330          }
    331          ////=============================================
    332          void hw_board_init(void)
    333          {
    334          NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );
    335          init_gpio();
    336          UART_DBG_Init(); 
    337          
    338          mot_step_tim_init();
    339          mot_spi_init();
    340          ////init_enc_tim();
    341          }
    342          ////============================================
    343          ////==============================================
    344          void mot_spi_init(void)
    345          {
    346          GPIO_InitTypeDef GPIO_InitStructure;
    347          SPI_InitTypeDef  SPI_InitStructure;
    348            MOT_SPI_PeriphClockCmd(MOT_SPI_RCC, ENABLE);
    349            
    350          RCC_AHB1PeriphClockCmd(MOT_SPI_SCK_PIN_RCC,ENABLE);
    351          RCC_AHB1PeriphClockCmd(MOT_SPI_MISO_PIN_RCC,ENABLE);
    352          RCC_AHB1PeriphClockCmd(MOT_SPI_MOSI_PIN_RCC,ENABLE);
    353          ////RCC_AHB1PeriphClockCmd(MOT_SPI_SCS_PIN_RCC,ENABLE);
    354          
    355          GPIO_PinAFConfig(MOT_SPI_SCK_PIN_GPIO, MOT_SPI_SCK_PIN_NPIN, MOT_SPI_AF);
    356          GPIO_PinAFConfig(MOT_SPI_MISO_PIN_GPIO, MOT_SPI_MISO_PIN_NPIN, MOT_SPI_AF);
    357          GPIO_PinAFConfig(MOT_SPI_MOSI_PIN_GPIO, MOT_SPI_MOSI_PIN_NPIN, MOT_SPI_AF);
    358          ////GPIO_PinAFConfig(MOT_SPI_SCS_PIN_GPIO, MOT_SPI_SCS_PIN_NPIN, MOT_SPI_AF);
    359          
    360          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    361          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    362          ////GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    363          ///GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
    364          GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    365          GPIO_InitStructure.GPIO_Pin = MOT_SPI_MISO_PIN;
    366          GPIO_Init(MOT_SPI_MISO_PIN_GPIO, &GPIO_InitStructure);
    367          
    368          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    369          GPIO_InitStructure.GPIO_Pin = MOT_SPI_SCK_PIN;
    370          GPIO_Init(MOT_SPI_SCK_PIN_GPIO, &GPIO_InitStructure);
    371          ////GPIO_InitStructure.GPIO_Pin = MOT_SPI_MISO_PIN;
    372          /////GPIO_Init(MOT_SPI_MISO_PIN_GPIO, &GPIO_InitStructure);
    373          GPIO_InitStructure.GPIO_Pin = MOT_SPI_MOSI_PIN;
    374          GPIO_Init(MOT_SPI_MOSI_PIN_GPIO, &GPIO_InitStructure);
    375          
    376          ////GPIO_InitStructure.GPIO_Pin = MOT_SPI_SCS_PIN;
    377          /////GPIO_Init(MOT_SPI_SCS_PIN_GPIO, &GPIO_InitStructure);
    378          
    379          SPI_I2S_DeInit(MOT_SPI);
    380          SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
    381          SPI_InitStructure.SPI_DataSize = SPI_DataSize_16b;
    382          SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
    383          SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
    384          SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;///SPI_NSS_Hard;///SPI_NSS_Soft;///SPI_NSS_Hard;
    385          SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_64;
    386          SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
    387          SPI_InitStructure.SPI_CRCPolynomial = 7;
    388          SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
    389          SPI_Init(MOT_SPI, &SPI_InitStructure);
    390          SPI_Cmd(MOT_SPI, ENABLE);
    391          }
    392          uint16_t mot_spi_transfer(uint16_t i_data)
    393          {
    394          uint16_t rez=0; 
    395          GPIO_SetBits(MOT_SPI_SCS_PIN_GPIO, MOT_SPI_SCS_PIN);
    396          
    397          while (SPI_I2S_GetFlagStatus(MOT_SPI, SPI_I2S_FLAG_TXE) == RESET);
    398          SPI_I2S_SendData(MOT_SPI, i_data);
    399          while (SPI_I2S_GetFlagStatus(MOT_SPI, SPI_I2S_FLAG_RXNE) == RESET);
    400          while (SPI_I2S_GetFlagStatus(MOT_SPI, SPI_I2S_FLAG_TXE) == RESET);
    401          rez=SPI_I2S_ReceiveData(MOT_SPI);
    402          GPIO_ResetBits(MOT_SPI_SCS_PIN_GPIO, MOT_SPI_SCS_PIN);
    403          return rez;
    404          }
    405          ////==============================================
    406          void mot_spi_set_br(uint16_t br)
    407          {
    408          uint16_t tmpreg = 0;
    409          tmpreg = MOT_SPI->CR1& ~(0x7<<3);
    410          tmpreg |=	br&(0x7<<3);
    411          MOT_SPI->CR1=tmpreg;
    412          }
    413          
    414          void mot_spi_wr(uint8_t addr,uint16_t idata)
    415          {
    416          uint16_t tmp;
    417          tmp=(addr&0x7)<<12;
    418          tmp|= idata&0xfff;
    419          mot_spi_transfer(tmp);
    420          }
    421          void mot_spi_wrp(uint8_t addr,uint16_t *pdata)
    422          {
    423          uint16_t tmp;
    424          memcpy(&tmp,pdata,sizeof(uint16_t));
    425          mot_spi_wr(addr,tmp);       
    426          }
    427          uint16_t mot_spi_rd(uint8_t addr)
    428          {
    429          uint16_t rez;
    430          uint16_t tmp;
    431          tmp=(addr&0x7)<<12;
    432          tmp|= 0x8000;
    433          rez=mot_spi_transfer(tmp);
    434          return rez&0xfff;
    435          }
    436          ////========================================================  
    437          
    438          CTRL_Register_t 	G_CTRL_REG;
    439          TORQUE_Register_t 	G_TORQUE_REG;
    440           OFF_Register_t 	G_OFF_REG;
    441          BLANK_Register_t	G_BLANK_REG;
    442          DECAY_Register_t 	G_DECAY_REG;
    443          STALL_Register_t 	G_STALL_REG;
    444          DRIVE_Register_t 	G_DRIVE_REG;
    445          STATUS_Register_t 	G_STATUS_REG;
    446          
    447          void init_step_mot(void)
    448          {
    449            
    450          // CTRL Register
    451          
    452          G_CTRL_REG.DTIME 	= 0x03;
    453          G_CTRL_REG.ISGAIN 	= 0x03;
    454          G_CTRL_REG.EXSTALL 	= 0x00;
    455          G_CTRL_REG.MODE 	= 0;///0x03;
    456          G_CTRL_REG.RSTEP 	= 0x00;
    457          G_CTRL_REG.RDIR 	= 0x00;
    458          G_CTRL_REG.ENBL 	= 0x01;
    459          
    460          // TORQUE Register
    461          G_TORQUE_REG.SIMPLTH = 0x00;
    462          G_TORQUE_REG.TORQUE  = 0xBA;
    463          
    464          // OFF Register
    465          G_OFF_REG.PWMMODE 	= 0x00;
    466          G_OFF_REG.TOFF 		= 0x30;
    467          
    468          // BLANK Register
    469          G_BLANK_REG.ABT 	= 0x01;
    470          G_BLANK_REG.TBLANK 	= 0x08;
    471          
    472          // DECAY Register.
    473          G_DECAY_REG.DECMOD  = 0x03;
    474          G_DECAY_REG.TDECAY 	= 0x10;
    475          
    476          // STALL Register
    477          G_STALL_REG.VDIV 	= 0x03;
    478          G_STALL_REG.SDCNT 	= 0x03;
    479          G_STALL_REG.SDTHR 	= 0x40;
    480          
    481          // DRIVE Register
    482          G_DRIVE_REG.OCPTH 	= 0x01;
    483          G_DRIVE_REG.IDRIVEP = 0x00;
    484          G_DRIVE_REG.IDRIVEN = 0x00;
    485          G_DRIVE_REG.TDRIVEP = 0x01;
    486          G_DRIVE_REG.TDRIVEN = 0x01;
    487          G_DRIVE_REG.OCPDEG 	= 0x01;
    488          
    489          mot_spi_wrp(ADDR_MOT_CTRL,(uint16_t*)&G_CTRL_REG);
    490          mot_spi_wrp(ADDR_MOT_TORQUE,(uint16_t*)&G_TORQUE_REG);
    491          mot_spi_wrp(ADDR_MOT_OFF,(uint16_t*)&G_OFF_REG);
    492          mot_spi_wrp(ADDR_MOT_BLANK,(uint16_t*)&G_BLANK_REG);
    493          mot_spi_wrp(ADDR_MOT_DECAY,(uint16_t*)&G_DECAY_REG);
    494          mot_spi_wrp(ADDR_MOT_STALL,(uint16_t*)&G_STALL_REG);
    495          mot_spi_wrp(ADDR_MOT_DRIVE,(uint16_t*)&G_DRIVE_REG);
    496          
    497          }
    498          ////========================================================  
    499          void set_mot_rej(uint8_t rej)
    500          {
    501          uint16_t tmp;
    502          CTRL_Register_t 	*t_ctrl_reg=(CTRL_Register_t*)&tmp;
    503          tmp=mot_spi_rd(ADDR_MOT_CTRL);
    504          t_ctrl_reg->MODE=rej;
    505          mot_spi_wr(ADDR_MOT_CTRL,tmp);
    506          }
    507          
    508          ////============================================
    509          extern uint8_t can1_send(uint16_t id,uint8_t data_len,uint8_t *data);
    510          extern uint8_t  CAN_TxRdy;              /* CAN HW ready to transmit message */
    511          extern uint8_t  CAN_RxRdy;              /* CAN HW received a message        */
    512          extern CanRxMsg RxMessage;
    513          
    514          void set_mot_dir(uint8_t dir)
    515          {
    516            
    517          }
    518          
    519          void set_mot_step(uint8_t step)
    520          {
    521            
    522          }
    523          void reset_mot_step(void)
    524          {
    525            
    526          }
    527          
    528          ////========================================================  
    529          void tst1_task( void *pvParameters )
    530          {
    531          ////uint8_t btst=0; 
    532          uint8_t ii=0; 
    533          printk("\n\r tst1_task"); 
    534          for(;;)
    535            {
    536            if( CAN_RxRdy)
    537              {
    538              CAN_RxRdy=0;
    539              printk("\n\r can_rx"); 
    540              printk("\n\r ExtId[%x]",RxMessage.ExtId);
    541              printk("\n\r DLC[%x]\n\r ",RxMessage.DLC);
    542              for(ii=0;ii<8;ii++)
    543                {
    544                printk("[%x] ",RxMessage.Data[ii]);
    545                }
    546              }
    547            else
    548            {
    549              msleep(10);
    550            }
    551            }
    552          }
    553          ////=======================================================
    554          	

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   TIM1_CC_IRQHandler
         8   -> TIM_ClearITPendingBit
         8   -> ena_mot
         8   -> stop_mot_step_tim
      24   UART_DBG_Init
        24   -> RCC_APB2PeriphClockCmd
        24   -> USART_Cmd
        24   -> USART_DeInit
        24   -> USART_Init
       0   check_push_key_dbg
      16   ena_mot
        16   -> mot_spi_rd
        16   -> mot_spi_wr
       0   get_byte_dbg
       8   get_conc0
         8   -> GPIO_ReadInputDataBit
       8   get_conc1
         8   -> GPIO_ReadInputDataBit
       8   hw_board_init
         8   -> NVIC_PriorityGroupConfig
         8   -> UART_DBG_Init
         8   -> init_gpio
         8   -> mot_spi_init
         8   -> mot_step_tim_init
      32   init_gpio
        32   -> GPIO_Init
        32   -> GPIO_PinAFConfig
        32   -> RCC_AHB1PeriphClockCmd
      32   init_step_mot
        32   -> mot_spi_wrp
      40   mot_spi_init
        40   -> GPIO_Init
        40   -> GPIO_PinAFConfig
        40   -> RCC_AHB1PeriphClockCmd
        40   -> RCC_APB1PeriphClockCmd
        40   -> SPI_Cmd
        40   -> SPI_I2S_DeInit
        40   -> SPI_Init
      16   mot_spi_rd
        16   -> mot_spi_transfer
       4   mot_spi_set_br
      24   mot_spi_transfer
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> SPI_I2S_GetFlagStatus
        24   -> SPI_I2S_ReceiveData
        24   -> SPI_I2S_SendData
      16   mot_spi_wr
        16   -> mot_spi_transfer
      32   mot_spi_wrp
        32   -> __aeabi_memcpy
        32   -> mot_spi_wr
       8   mot_step_tim_init
         8   -> NVIC_Init
         8   -> TIM_ClearITPendingBit
      16   put_mot_nstep
        16   -> TIM_Cmd
        16   -> TIM_ITConfig
        16   -> ena_mot
       0   reset_mot_step
       0   send_char_dbg
       8   set_dir_mot
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
       0   set_mot_dir
      16   set_mot_rej
        16   -> mot_spi_rd
        16   -> mot_spi_wr
       0   set_mot_step
       8   set_reset_mot
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
       8   set_sleep_mot
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
       8   stop_mot_step_tim
         8   -> TIM_Cmd
      16   tst1_task
        16   -> printf
        16   -> vTaskDelay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_10
       4  ??DataTable18_11
       4  ??DataTable18_12
       4  ??DataTable18_13
       4  ??DataTable18_14
       4  ??DataTable18_15
       4  ??DataTable18_16
       4  ??DataTable18_17
       4  ??DataTable18_18
       4  ??DataTable18_19
       4  ??DataTable18_2
       4  ??DataTable18_20
       4  ??DataTable18_21
       4  ??DataTable18_22
       4  ??DataTable18_23
       4  ??DataTable18_24
       4  ??DataTable18_25
       4  ??DataTable18_26
       4  ??DataTable18_27
       4  ??DataTable18_28
       4  ??DataTable18_29
       4  ??DataTable18_3
       4  ??DataTable18_30
       4  ??DataTable18_31
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
       4  ??DataTable18_9
      16  ?_0
      12  ?_1
      16  ?_2
      16  ?_3
       8  ?_4
       2  G_BLANK_REG
       2  G_CTRL_REG
       2  G_DECAY_REG
       2  G_DRIVE_REG
       2  G_OFF_REG
       2  G_STALL_REG
       2  G_STATUS_REG
       2  G_TORQUE_REG
      46  TIM1_CC_IRQHandler
      86  UART_DBG_Init
      12  check_push_key_dbg
      40  ena_mot
      18  get_byte_dbg
      14  get_conc0
      14  get_conc1
       4  gsr
      28  hw_board_init
     594  init_gpio
     354  init_step_mot
     224  mot_spi_init
      32  mot_spi_rd
      30  mot_spi_set_br
      90  mot_spi_transfer
      32  mot_spi_wr
      40  mot_spi_wrp
     140  mot_step_tim_init
       4  num_step
      40  put_mot_nstep
       2  reset_mot_step
      22  send_char_dbg
      36  set_dir_mot
       2  set_mot_dir
      40  set_mot_rej
       2  set_mot_step
      36  set_reset_mot
      36  set_sleep_mot
      14  stop_mot_step_tim
      86  tst1_task

 
    24 bytes in section .bss
    68 bytes in section .rodata
 2'238 bytes in section .text
 
 2'238 bytes of CODE  memory
    68 bytes of CONST memory
    24 bytes of DATA  memory

Errors: none
Warnings: none
