###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         11/Sep/2021  20:10:58
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  D:\proj\velograph\snail\stm32_snail\common\grbl\stepper.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EW9DEF.tmp
#        (D:\proj\velograph\snail\stm32_snail\common\grbl\stepper.c -D
#        VECT_TAB_FLASH -D IAR_ARM_CM3 -D DIMA_BRD -D STEP_X -D STM32F205xx
#        -lcN
#        D:\proj\velograph\snail\stm32_snail\step_axis_dima\step_x_dbg\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\step_axis_dima\step_x_dbg\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I D:\proj\velograph\snail\stm32_snail\step_axis_dima\.\ -I
#        D:\proj\velograph\snail\stm32_snail\step_axis_dima\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\step_axis_dima\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\step_axis_dima\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\step_axis_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I D:\proj\velograph\snail\stm32_snail\step_axis_dima\..\common\dbg\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\step_axis_dima\step_x_dbg\List\stepper.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\step_axis_dima\step_x_dbg\Obj\stepper.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\common\grbl\stepper.c
      1          
      2          
      3          /*
      4            stepper.c - stepper motor driver: executes motion plans using stepper motors
      5            Part of Grbl
      6          
      7            Copyright (c) 2011-2016 Sungeun K. Jeon for Gnea Research LLC
      8            Copyright (c) 2009-2011 Simen Svale Skogsrud
      9          
     10            Grbl is free software: you can redistribute it and/or modify
     11            it under the terms of the GNU General Public License as published by
     12            the Free Software Foundation, either version 3 of the License, or
     13            (at your option) any later version.
     14          
     15            Grbl is distributed in the hope that it will be useful,
     16            but WITHOUT ANY WARRANTY; without even the implied warranty of
     17            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     18            GNU General Public License for more details.
     19          
     20            You should have received a copy of the GNU General Public License
     21            along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
     22          */
     23          #if 0
     24          #include "grbl.h"
     25          
     26          ////typedef int bool;
     27          ////#include "stm32f10x_rcc.h"
     28          ////#include "stm32f10x_tim.h"
     29          ////#include "stm32f10x_nvic.h"
     30          
     31          #include "misc.h"
     32          void TIM_Configuration(TIM_TypeDef* TIMER, u16 Period, u16 Prescaler, u8 PP);
     33          
     34          
     35          // Some useful constants.
     36          #define DT_SEGMENT (1.0f/(ACCELERATION_TICKS_PER_SECOND*60.0f)) // min/segment
     37          #define REQ_MM_INCREMENT_SCALAR 1.25f
     38          #define RAMP_ACCEL 0
     39          #define RAMP_CRUISE 1
     40          #define RAMP_DECEL 2
     41          #define RAMP_DECEL_OVERRIDE 3
     42          
     43          #define PREP_FLAG_RECALCULATE bit(0)
     44          #define PREP_FLAG_HOLD_PARTIAL_BLOCK bit(1)
     45          #define PREP_FLAG_PARKING bit(2)
     46          #define PREP_FLAG_DECEL_OVERRIDE bit(3)
     47          const PORTPINDEF step_pin_mask[N_AXIS] =
     48          {
     49          	1 << X_STEP_BIT,
     50          	1 << Y_STEP_BIT,
     51          	1 << Z_STEP_BIT,
     52          
     53          };
     54          const PORTPINDEF direction_pin_mask[N_AXIS] =
     55          {
     56          	1 << X_DIRECTION_BIT,
     57          	1 << Y_DIRECTION_BIT,
     58          	1 << Z_DIRECTION_BIT,
     59          };
     60          // Define Adaptive Multi-Axis Step-Smoothing(AMASS) levels and cutoff frequencies. The highest level
     61          // frequency bin starts at 0Hz and ends at its cutoff frequency. The next lower level frequency bin
     62          // starts at the next higher cutoff frequency, and so on. The cutoff frequencies for each level must
     63          // be considered carefully against how much it over-drives the stepper ISR, the accuracy of the 16-bit
     64          // timer, and the CPU overhead. Level 0 (no AMASS, normal operation) frequency bin starts at the
     65          // Level 1 cutoff frequency and up to as fast as the CPU allows (over 30kHz in limited testing).
     66          // NOTE: AMASS cutoff frequency multiplied by ISR overdrive factor must not exceed maximum step frequency.
     67          // NOTE: Current settings are set to overdrive the ISR to no more than 16kHz, balancing CPU overhead
     68          // and timer accuracy.  Do not alter these settings unless you know what you are doing.
     69          #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
     70          	#define MAX_AMASS_LEVEL 3
     71          	// AMASS_LEVEL0: Normal operation. No AMASS. No upper cutoff frequency. Starts at LEVEL1 cutoff frequency.
     72          	#define AMASS_LEVEL1 (F_CPU/8000) // Over-drives ISR (x2). Defined as F_CPU/(Cutoff frequency in Hz)
     73          	#define AMASS_LEVEL2 (F_CPU/4000) // Over-drives ISR (x4)
     74          	#define AMASS_LEVEL3 (F_CPU/2000) // Over-drives ISR (x8)
     75          
     76            #if MAX_AMASS_LEVEL <= 0
     77              error "AMASS must have 1 or more levels to operate correctly."
     78            #endif
     79          #endif
     80          
     81          
     82          // Stores the planner block Bresenham algorithm execution data for the segments in the segment
     83          // buffer. Normally, this buffer is partially in-use, but, for the worst case scenario, it will
     84          // never exceed the number of accessible stepper buffer segments (SEGMENT_BUFFER_SIZE-1).
     85          // NOTE: This data is copied from the prepped planner blocks so that the planner blocks may be
     86          // discarded when entirely consumed and completed by the segment buffer. Also, AMASS alters this
     87          // data for its own use.
     88          typedef struct {
     89            uint32_t steps[N_AXIS];
     90            uint32_t step_event_count;
     91            uint8_t direction_bits;
     92            #ifdef VARIABLE_SPINDLE
     93              uint8_t is_pwm_rate_adjusted; // Tracks motions that require constant laser power/rate
     94            #endif
     95          } st_block_t;
     96          static st_block_t st_block_buffer[SEGMENT_BUFFER_SIZE-1];
     97          
     98          // Primary stepper segment ring buffer. Contains small, short line segments for the stepper
     99          // algorithm to execute, which are "checked-out" incrementally from the first block in the
    100          // planner buffer. Once "checked-out", the steps in the segments buffer cannot be modified by
    101          // the planner, where the remaining planner block steps still can.
    102          typedef struct {
    103            uint16_t n_step;           // Number of step events to be executed for this segment
    104            uint16_t cycles_per_tick;  // Step distance traveled per ISR tick, aka step rate.
    105            uint8_t  st_block_index;   // Stepper block data index. Uses this information to execute this segment.
    106            #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    107              uint8_t amass_level;    // Indicates AMASS level for the ISR to execute this segment
    108            #else
    109              uint8_t prescaler;      // Without AMASS, a prescaler is required to adjust for slow timing.
    110            #endif
    111            #ifdef VARIABLE_SPINDLE
    112              uint8_t spindle_pwm;
    113            #endif
    114          } segment_t;
    115          static segment_t segment_buffer[SEGMENT_BUFFER_SIZE];
    116          
    117          // Stepper ISR data struct. Contains the running data for the main stepper ISR.
    118          typedef struct {
    119            // Used by the bresenham line algorithm
    120            uint32_t counter_x,        // Counter variables for the bresenham line tracer
    121                     counter_y,
    122                     counter_z;
    123            #ifdef STEP_PULSE_DELAY
    124              uint8_t step_bits;  // Stores out_bits output to complete the step pulse delay
    125            #endif
    126          
    127            uint8_t execute_step;     // Flags step execution for each interrupt.
    128            uint8_t step_pulse_time;  // Step pulse reset time after step rise
    129          
    130            PORTPINDEF step_outbits;         // The next stepping-bits to be output
    131            PORTPINDEF dir_outbits;
    132            #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    133              uint32_t steps[N_AXIS];
    134            #endif
    135          
    136            uint16_t step_count;       // Steps remaining in line segment motion
    137            uint8_t exec_block_index; // Tracks the current st_block index. Change indicates new block.
    138            st_block_t *exec_block;   // Pointer to the block data for the segment being executed
    139            segment_t *exec_segment;  // Pointer to the segment being executed
    140          } stepper_t;
    141          static stepper_t st;
    142          
    143          // Step segment ring buffer indices
    144          static volatile uint8_t segment_buffer_tail;
    145          static uint8_t segment_buffer_head;
    146          static uint8_t segment_next_head;
    147          
    148          // Step and direction port invert masks.
    149          static PORTPINDEF step_port_invert_mask;
    150          static PORTPINDEF dir_port_invert_mask;
    151          
    152          // Used to avoid ISR nesting of the "Stepper Driver Interrupt". Should never occur though.
    153          static volatile uint8_t busy;
    154          
    155          // Pointers for the step segment being prepped from the planner buffer. Accessed only by the
    156          // main program. Pointers may be planning segments or planner blocks ahead of what being executed.
    157          static plan_block_t *pl_block;     // Pointer to the planner block being prepped
    158          static st_block_t *st_prep_block;  // Pointer to the stepper block data being prepped
    159          
    160          // Segment preparation data struct. Contains all the necessary information to compute new segments
    161          // based on the current executing planner block.
    162          typedef struct {
    163            uint8_t st_block_index;  // Index of stepper common data block being prepped
    164            uint8_t recalculate_flag;
    165          
    166            float dt_remainder;
    167            float steps_remaining;
    168            float step_per_mm;
    169            float req_mm_increment;
    170          
    171            #ifdef PARKING_ENABLE
    172              uint8_t last_st_block_index;
    173              float last_steps_remaining;
    174              float last_step_per_mm;
    175              float last_dt_remainder;
    176            #endif
    177          
    178            uint8_t ramp_type;      // Current segment ramp state
    179            float mm_complete;      // End of velocity profile from end of current planner block in (mm).
    180                                    // NOTE: This value must coincide with a step(no mantissa) when converted.
    181            float current_speed;    // Current speed at the end of the segment buffer (mm/min)
    182            float maximum_speed;    // Maximum speed of executing block. Not always nominal speed. (mm/min)
    183            float exit_speed;       // Exit speed of executing block (mm/min)
    184            float accelerate_until; // Acceleration ramp end measured from end of block (mm)
    185            float decelerate_after; // Deceleration ramp start measured from end of block (mm)
    186          
    187            #ifdef VARIABLE_SPINDLE
    188              float inv_rate;    // Used by PWM laser mode to speed up segment calculations.
    189              uint8_t current_spindle_pwm;
    190            #endif
    191          } st_prep_t;
    192          static st_prep_t prep;
    193          
    194          
    195          /*    BLOCK VELOCITY PROFILE DEFINITION
    196                    __________________________
    197                   /|                        |\     _________________         ^
    198                  / |                        | \   /|               |\        |
    199                 /  |                        |  \ / |               | \       s
    200                /   |                        |   |  |               |  \      p
    201               /    |                        |   |  |               |   \     e
    202              +-----+------------------------+---+--+---------------+----+    e
    203              |               BLOCK 1            ^      BLOCK 2          |    d
    204                                                 |
    205                            time ----->      EXAMPLE: Block 2 entry speed is at max junction velocity
    206          
    207            The planner block buffer is planned assuming constant acceleration velocity profiles and are
    208            continuously joined at block junctions as shown above. However, the planner only actively computes
    209            the block entry speeds for an optimal velocity plan, but does not compute the block internal
    210            velocity profiles. These velocity profiles are computed ad-hoc as they are executed by the
    211            stepper algorithm and consists of only 7 possible types of profiles: cruise-only, cruise-
    212            deceleration, acceleration-cruise, acceleration-only, deceleration-only, full-trapezoid, and
    213            triangle(no cruise).
    214          
    215                                                  maximum_speed (< nominal_speed) ->  +
    216                              +--------+ <- maximum_speed (= nominal_speed)          /|\
    217                             /          \                                           / | \
    218           current_speed -> +            \                                         /  |  + <- exit_speed
    219                            |             + <- exit_speed                         /   |  |
    220                            +-------------+                     current_speed -> +----+--+
    221                             time -->  ^  ^                                           ^  ^
    222                                       |  |                                           |  |
    223                          decelerate_after(in mm)                             decelerate_after(in mm)
    224                              ^           ^                                           ^  ^
    225                              |           |                                           |  |
    226                          accelerate_until(in mm)                             accelerate_until(in mm)
    227          
    228            The step segment buffer computes the executing block velocity profile and tracks the critical
    229            parameters for the stepper algorithm to accurately trace the profile. These critical parameters
    230            are shown and defined in the above illustration.
    231          */
    232          
    233          
    234          // Stepper state initialization. Cycle should only start if the st.cycle_start flag is
    235          // enabled. Startup init and limits call this function but shouldn't start the cycle.
    236          void st_wake_up()
    237          {
    238            // Enable stepper drivers.
    239            if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) 
    240            { 
    241          	  SetStepperDisableBit();
    242            }
    243            else 
    244            { 
    245          	  ResetStepperDisableBit(); 
    246            }
    247          
    248            // Initialize stepper output bits to ensure first ISR call does not step.
    249            st.step_outbits = step_port_invert_mask;
    250          
    251            // Initialize step pulse timing from settings. Here to ensure updating after re-writing.
    252            #ifdef STEP_PULSE_DELAY
    253              // Set total step pulse time after direction pin set. Ad hoc computation from oscilloscope.
    254              st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);
    255              // Set delay between direction pin write and step command.
    256              OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
    257            #else // Normal operation
    258              // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
    259              st.step_pulse_time = (settings.pulse_microseconds)*TICKS_PER_MICROSECOND;
    260            #endif
    261          
    262            // Enable Stepper Driver Interrupt
    263            TIM3->ARR = st.step_pulse_time - 1;
    264            TIM3->EGR = TIM_PSCReloadMode_Immediate;
    265            TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
    266          
    267            TIM2->ARR = st.exec_segment->cycles_per_tick - 1;
    268            /* Set the Autoreload value */
    269          #ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        
    270            TIM2->PSC = st.exec_segment->prescaler;
    271          #endif
    272            TIM2->EGR = TIM_PSCReloadMode_Immediate;
    273            NVIC_EnableIRQ(TIM2_IRQn);
    274          }
    275          
    276          
    277          // Stepper shutdown
    278          void st_go_idle()
    279          {
    280            // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
    281            NVIC_DisableIRQ(TIM2_IRQn);
    282          
    283            busy = false;
    284          
    285            // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
    286            bool pin_state = false; // Keep enabled.
    287            if (((settings.stepper_idle_lock_time != 0xff) || sys_rt_exec_alarm || sys.state == STATE_SLEEP) && sys.state != STATE_HOMING) {
    288              // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    289              // stop and not drift from residual inertial forces at the end of the last movement.
    290              delay__ms(settings.stepper_idle_lock_time);
    291              pin_state = true; // Override. Disable steppers.
    292            }
    293            if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    294            if (pin_state) 
    295            { 
    296          	  SetStepperDisableBit();
    297            }
    298            else 
    299            { 
    300          	  ResetStepperDisableBit();
    301            }
    302          }
    303          
    304          
    305          /* "The Stepper Driver Interrupt" - This timer interrupt is the workhorse of Grbl. Grbl employs
    306             the venerable Bresenham line algorithm to manage and exactly synchronize multi-axis moves.
    307             Unlike the popular DDA algorithm, the Bresenham algorithm is not susceptible to numerical
    308             round-off errors and only requires fast integer counters, meaning low computational overhead
    309             and maximizing the Arduino's capabilities. However, the downside of the Bresenham algorithm
    310             is, for certain multi-axis motions, the non-dominant axes may suffer from un-smooth step
    311             pulse trains, or aliasing, which can lead to strange audible noises or shaking. This is
    312             particularly noticeable or may cause motion issues at low step frequencies (0-5kHz), but
    313             is usually not a physical problem at higher frequencies, although audible.
    314               To improve Bresenham multi-axis performance, Grbl uses what we call an Adaptive Multi-Axis
    315             Step Smoothing (AMASS) algorithm, which does what the name implies. At lower step frequencies,
    316             AMASS artificially increases the Bresenham resolution without effecting the algorithm's
    317             innate exactness. AMASS adapts its resolution levels automatically depending on the step
    318             frequency to be executed, meaning that for even lower step frequencies the step smoothing
    319             level increases. Algorithmically, AMASS is acheived by a simple bit-shifting of the Bresenham
    320             step count for each AMASS level. For example, for a Level 1 step smoothing, we bit shift
    321             the Bresenham step event count, effectively multiplying it by 2, while the axis step counts
    322             remain the same, and then double the stepper ISR frequency. In effect, we are allowing the
    323             non-dominant Bresenham axes step in the intermediate ISR tick, while the dominant axis is
    324             stepping every two ISR ticks, rather than every ISR tick in the traditional sense. At AMASS
    325             Level 2, we simply bit-shift again, so the non-dominant Bresenham axes can step within any
    326             of the four ISR ticks, the dominant axis steps every four ISR ticks, and quadruple the
    327             stepper ISR frequency. And so on. This, in effect, virtually eliminates multi-axis aliasing
    328             issues with the Bresenham algorithm and does not significantly alter Grbl's performance, but
    329             in fact, more efficiently utilizes unused CPU cycles overall throughout all configurations.
    330               AMASS retains the Bresenham algorithm exactness by requiring that it always executes a full
    331             Bresenham step, regardless of AMASS Level. Meaning that for an AMASS Level 2, all four
    332             intermediate steps must be completed such that baseline Bresenham (Level 0) count is always
    333             retained. Similarly, AMASS Level 3 means all eight intermediate steps must be executed.
    334             Although the AMASS Levels are in reality arbitrary, where the baseline Bresenham counts can
    335             be multiplied by any integer value, multiplication by powers of two are simply used to ease
    336             CPU overhead with bitshift integer operations.
    337               This interrupt is simple and dumb by design. All the computational heavy-lifting, as in
    338             determining accelerations, is performed elsewhere. This interrupt pops pre-computed segments,
    339             defined as constant velocity over n number of steps, from the step segment buffer and then
    340             executes them by pulsing the stepper pins appropriately via the Bresenham algorithm. This
    341             ISR is supported by The Stepper Port Reset Interrupt which it uses to reset the stepper port
    342             after each pulse. The bresenham line tracer algorithm controls all stepper outputs
    343             simultaneously with these two interrupts.
    344          
    345             NOTE: This interrupt must be as efficient as possible and complete before the next ISR tick,
    346             which for Grbl must be less than 33.3usec (@30kHz ISR rate). Oscilloscope measured time in
    347             ISR is 5usec typical and 25usec maximum, well below requirement.
    348             NOTE: This ISR expects at least one step to be executed per segment.
    349          */
    350          // TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller
    351          // int8 variables and update position counters only when a segment completes. This can get complicated
    352          // with probing and homing cycles that require true real-time positions.
    353          void TIM2_IRQHandler(void)
    354          {
    355          	if ((TIM2->SR & 0x0001) != 0)                  // check interrupt source
    356          	{
    357          		TIM2->SR &= ~(1 << 0);                          // clear UIF flag
    358          		TIM2->CNT = 0;
    359          	}
    360          	else
    361          	{
    362          		return;
    363          	}
    364          
    365            if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
    366            GPIO_Write(DIRECTION_PORT, (GPIO_ReadOutputData(DIRECTION_PORT) & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK));
    367            TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
    368          
    369            // Then pulse the stepping pins
    370            #ifdef STEP_PULSE_DELAY
    371              st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwriting.
    372            #else  // Normal operation
    373          	GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | st.step_outbits);
    374            #endif
    375          
    376            // Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after
    377            // exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.
    378             NVIC_EnableIRQ(TIM3_IRQn);
    379          
    380            busy = true;
    381          
    382            // If there is no step segment, attempt to pop one from the stepper buffer
    383            if (st.exec_segment == NULL) {
    384              // Anything in the buffer? If so, load and initialize next step segment.
    385              if (segment_buffer_head != segment_buffer_tail) {
    386                // Initialize new step segment and load number of steps to execute
    387                st.exec_segment = &segment_buffer[segment_buffer_tail];
    388          
    389                // Initialize step segment timing per step and load number of steps to execute.
    390          	  TIM2->ARR = st.exec_segment->cycles_per_tick - 1;
    391          	  /* Set the Autoreload value */
    392          #ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        
    393          	  TIM2->PSC = st.exec_segment->prescaler;
    394          #endif
    395                st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
    396                // If the new segment starts a new planner block, initialize stepper variables and counters.
    397                // NOTE: When the segment data index changes, this indicates a new planner block.
    398                if ( st.exec_block_index != st.exec_segment->st_block_index ) {
    399                  st.exec_block_index = st.exec_segment->st_block_index;
    400                  st.exec_block = &st_block_buffer[st.exec_block_index];
    401          
    402                  // Initialize Bresenham line and distance counters
    403                  st.counter_x = st.counter_y = st.counter_z = (st.exec_block->step_event_count >> 1);
    404                }
    405                st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask;
    406          
    407                #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    408                  // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
    409                  st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
    410                  st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
    411                  st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
    412                #endif
    413          
    414                #ifdef VARIABLE_SPINDLE
    415                  // Set real-time spindle output as segment is loaded, just prior to the first step.
    416                  spindle_set_speed(st.exec_segment->spindle_pwm);
    417                #endif
    418          
    419              } else {
    420                // Segment buffer empty. Shutdown.
    421                st_go_idle();
    422                // Ensure pwm is set properly upon completion of rate-controlled motion.
    423                #ifdef VARIABLE_SPINDLE
    424                if (st.exec_block->is_pwm_rate_adjusted) { spindle_set_speed(SPINDLE_PWM_OFF_VALUE); }
    425                #endif
    426                system_set_exec_state_flag(EXEC_CYCLE_STOP); // Flag main program for cycle end
    427                return; // Nothing to do but exit.
    428              }
    429            }
    430          
    431          
    432            // Check probing state.
    433            if (sys_probe_state == PROBE_ACTIVE) { probe_state_monitor(); }
    434          
    435            // Reset step out bits.
    436            st.step_outbits = 0;
    437          
    438            // Execute step displacement profile by Bresenham line algorithm
    439            #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    440              st.counter_x += st.steps[X_AXIS];
    441            #else
    442              st.counter_x += st.exec_block->steps[X_AXIS];
    443            #endif
    444            if (st.counter_x > st.exec_block->step_event_count) {
    445              st.step_outbits |= (1<<X_STEP_BIT);
    446              st.counter_x -= st.exec_block->step_event_count;
    447              if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys_position[X_AXIS]--; }
    448              else { sys_position[X_AXIS]++; }
    449            }
    450            #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    451              st.counter_y += st.steps[Y_AXIS];
    452            #else
    453              st.counter_y += st.exec_block->steps[Y_AXIS];
    454            #endif
    455            if (st.counter_y > st.exec_block->step_event_count) {
    456              st.step_outbits |= (1<<Y_STEP_BIT);
    457              st.counter_y -= st.exec_block->step_event_count;
    458              if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys_position[Y_AXIS]--; }
    459              else { sys_position[Y_AXIS]++; }
    460            }
    461            #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    462              st.counter_z += st.steps[Z_AXIS];
    463            #else
    464              st.counter_z += st.exec_block->steps[Z_AXIS];
    465            #endif
    466            if (st.counter_z > st.exec_block->step_event_count) {
    467              st.step_outbits |= (1<<Z_STEP_BIT);
    468              st.counter_z -= st.exec_block->step_event_count;
    469              if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys_position[Z_AXIS]--; }
    470              else { sys_position[Z_AXIS]++; }
    471            }
    472          
    473            // During a homing cycle, lock out and prevent desired axes from moving.
    474            if (sys.state == STATE_HOMING) { st.step_outbits &= sys.homing_axis_lock; }
    475          
    476            st.step_count--; // Decrement step events count
    477            if (st.step_count == 0) {
    478              // Segment is complete. Discard current segment and advance segment indexing.
    479              st.exec_segment = NULL;
    480              uint8_t segment_tail_next = segment_buffer_tail + 1;
    481              if (segment_tail_next == SEGMENT_BUFFER_SIZE)
    482              {
    483                segment_tail_next = 0;
    484              }
    485              segment_buffer_tail = segment_tail_next;
    486            }
    487          
    488            st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask
    489            busy = false;
    490          }
    491          
    492          
    493          /* The Stepper Port Reset Interrupt: Timer0 OVF interrupt handles the falling edge of the step
    494             pulse. This should always trigger before the next Timer1 COMPA interrupt and independently
    495             finish, if Timer1 is disabled after completing a move.
    496             NOTE: Interrupt collisions between the serial and stepper interrupts can cause delays by
    497             a few microseconds, if they execute right before one another. Not a big deal, but can
    498             cause issues at high step rates if another high frequency asynchronous interrupt is
    499             added to Grbl.
    500          */
    501          // This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
    502          // a step. This ISR resets the motor port after a short period (settings.pulse_microseconds)
    503          // completing one step cycle.
    504          void TIM3_IRQHandler(void)
    505          {
    506          	if ((TIM3->SR & 0x0001) != 0)                  // check interrupt source
    507          	{
    508          		TIM3->SR &= ~(1<<0);                          // clear UIF flag
    509          		TIM3->CNT = 0;
    510           		NVIC_DisableIRQ(TIM3_IRQn);
    511              // Reset stepping pins (leave the direction pins)
    512          		GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK));
    513          	}
    514          }
    515          
    516          
    517          // Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
    518          void st_generate_step_dir_invert_masks()
    519          {
    520            uint8_t idx;
    521            step_port_invert_mask = 0;
    522            dir_port_invert_mask = 0;
    523            for (idx=0; idx<N_AXIS; idx++) {
    524              if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= step_pin_mask[idx]; }
    525              if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= direction_pin_mask[idx]; }
    526            }
    527          }
    528          
    529          
    530          // Reset and clear stepper subsystem variables
    531          void st_reset()
    532          {
    533            // Initialize stepper driver idle state.
    534            st_go_idle();
    535          
    536            // Initialize stepper algorithm variables.
    537            memset(&prep, 0, sizeof(st_prep_t));
    538            memset(&st, 0, sizeof(stepper_t));
    539            st.exec_segment = NULL;
    540            pl_block = NULL;  // Planner block pointer used by segment buffer
    541            segment_buffer_tail = 0;
    542            segment_buffer_head = 0; // empty = tail
    543            segment_next_head = 1;
    544            busy = false;
    545          
    546            st_generate_step_dir_invert_masks();
    547            st.dir_outbits = dir_port_invert_mask; // Initialize direction bits to default.
    548          
    549            // Initialize step and direction port pins.
    550            GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK));
    551            GPIO_Write(DIRECTION_PORT, (GPIO_ReadOutputData(DIRECTION_PORT) & ~DIRECTION_MASK) | (dir_port_invert_mask & DIRECTION_MASK));
    552          }
    553          
    554          // Initialize and start the stepper motor subsystem
    555          void stepper_init()
    556          {
    557            // Configure step and direction interface pins
    558          	GPIO_InitTypeDef GPIO_InitStructure;
    559          	RCC_APB2PeriphClockCmd(RCC_STEPPERS_DISABLE_PORT, ENABLE);
    560          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    561          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    562          	GPIO_InitStructure.GPIO_Pin = STEPPERS_DISABLE_MASK;
    563          	GPIO_Init(STEPPERS_DISABLE_PORT, &GPIO_InitStructure);
    564          
    565          	RCC_APB2PeriphClockCmd(RCC_STEP_PORT, ENABLE);
    566          	GPIO_InitStructure.GPIO_Pin = STEP_MASK;
    567          	GPIO_Init(STEP_PORT, &GPIO_InitStructure);
    568          
    569          	RCC_APB2PeriphClockCmd(RCC_DIRECTION_PORT, ENABLE);
    570          	GPIO_InitStructure.GPIO_Pin = DIRECTION_MASK;
    571          	GPIO_Init(DIRECTION_PORT, &GPIO_InitStructure);
    572            
    573            // Configurating TIM2
    574            RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
    575          	// RCC->APB1ENR |= RCC_APB1Periph_TIM2;
    576          	TIM_Configuration(TIM2, 1, 1, 1);
    577          
    578            // Configurating TIM3
    579            RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
    580          	// RCC->APB1ENR |= RCC_APB1Periph_TIM3;
    581          	TIM_Configuration(TIM3, 1, 1, 1);
    582          
    583            // Stop/Distable TIM2 & TIM3 here
    584           	NVIC_DisableIRQ(TIM3_IRQn);
    585           	NVIC_DisableIRQ(TIM2_IRQn);
    586          }
    587          
    588          
    589          // Called by planner_recalculate() when the executing block is updated by the new plan.
    590          void st_update_plan_block_parameters()
    591          {
    592            if (pl_block != NULL) { // Ignore if at start of a new block.
    593              prep.recalculate_flag |= PREP_FLAG_RECALCULATE;
    594              pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
    595              pl_block = NULL; // Flag st_prep_segment() to load and check active velocity profile.
    596            }
    597          }
    598          
    599          
    600          // Increments the step segment buffer block data ring buffer.
    601          static uint8_t st_next_block_index(uint8_t block_index)
    602          {
    603            block_index++;
    604            if ( block_index == (SEGMENT_BUFFER_SIZE-1) ) { return(0); }
    605            return(block_index);
    606          }
    607          
    608          
    609          #ifdef PARKING_ENABLE
    610            // Changes the run state of the step segment buffer to execute the special parking motion.
    611            void st_parking_setup_buffer()
    612            {
    613              // Store step execution data of partially completed block, if necessary.
    614              if (prep.recalculate_flag & PREP_FLAG_HOLD_PARTIAL_BLOCK) {
    615                prep.last_st_block_index = prep.st_block_index;
    616                prep.last_steps_remaining = prep.steps_remaining;
    617                prep.last_dt_remainder = prep.dt_remainder;
    618                prep.last_step_per_mm = prep.step_per_mm;
    619              }
    620              // Set flags to execute a parking motion
    621              prep.recalculate_flag |= PREP_FLAG_PARKING;
    622              prep.recalculate_flag &= ~(PREP_FLAG_RECALCULATE);
    623              pl_block = NULL; // Always reset parking motion to reload new block.
    624            }
    625          
    626          
    627            // Restores the step segment buffer to the normal run state after a parking motion.
    628            void st_parking_restore_buffer()
    629            {
    630              // Restore step execution data and flags of partially completed block, if necessary.
    631              if (prep.recalculate_flag & PREP_FLAG_HOLD_PARTIAL_BLOCK) {
    632                st_prep_block = &st_block_buffer[prep.last_st_block_index];
    633                prep.st_block_index = prep.last_st_block_index;
    634                prep.steps_remaining = prep.last_steps_remaining;
    635                prep.dt_remainder = prep.last_dt_remainder;
    636                prep.step_per_mm = prep.last_step_per_mm;
    637                prep.recalculate_flag = (PREP_FLAG_HOLD_PARTIAL_BLOCK | PREP_FLAG_RECALCULATE);
    638                prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm; // Recompute this value.
    639              } else {
    640                prep.recalculate_flag = false;
    641              }
    642              pl_block = NULL; // Set to reload next block.
    643            }
    644          #endif
    645          
    646          
    647          /* Prepares step segment buffer. Continuously called from main program.
    648          
    649             The segment buffer is an intermediary buffer interface between the execution of steps
    650             by the stepper algorithm and the velocity profiles generated by the planner. The stepper
    651             algorithm only executes steps within the segment buffer and is filled by the main program
    652             when steps are "checked-out" from the first block in the planner buffer. This keeps the
    653             step execution and planning optimization processes atomic and protected from each other.
    654             The number of steps "checked-out" from the planner buffer and the number of segments in
    655             the segment buffer is sized and computed such that no operation in the main program takes
    656             longer than the time it takes the stepper algorithm to empty it before refilling it.
    657             Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
    658             NOTE: Computation units are in steps, millimeters, and minutes.
    659          */
    660          void st_prep_buffer()
    661          {
    662            // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
    663            if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }
    664          
    665            while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
    666          
    667              // Determine if we need to load a new planner block or if the block needs to be recomputed.
    668              if (pl_block == NULL) {
    669          
    670                // Query planner for a queued block
    671                if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) { pl_block = plan_get_system_motion_block(); }
    672                else { pl_block = plan_get_current_block(); }
    673                if (pl_block == NULL) { return; } // No planner blocks. Exit.
    674          
    675                // Check if we need to only recompute the velocity profile or load a new block.
    676                if (prep.recalculate_flag & PREP_FLAG_RECALCULATE) {
    677          
    678                  #ifdef PARKING_ENABLE
    679                    if (prep.recalculate_flag & PREP_FLAG_PARKING) { prep.recalculate_flag &= ~(PREP_FLAG_RECALCULATE); }
    680                    else { prep.recalculate_flag = false; }
    681                  #else
    682                    prep.recalculate_flag = false;
    683                  #endif
    684          
    685                } else {
    686          
    687                  // Load the Bresenham stepping data for the block.
    688                  prep.st_block_index = st_next_block_index(prep.st_block_index);
    689          
    690                  // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
    691                  // when the segment buffer completes the planner block, it may be discarded when the
    692                  // segment buffer finishes the prepped block, but the stepper ISR is still executing it.
    693                  st_prep_block = &st_block_buffer[prep.st_block_index];
    694                  st_prep_block->direction_bits = pl_block->direction_bits;
    695                  uint8_t idx;
    696                  #ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    697                    for (idx=0; idx<N_AXIS; idx++) { st_prep_block->steps[idx] = (pl_block->steps[idx] << 1); }
    698                    st_prep_block->step_event_count = (pl_block->step_event_count << 1);
    699                  #else
    700                    // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS
    701                    // level, such that we never divide beyond the original data anywhere in the algorithm.
    702                    // If the original data is divided, we can lose a step from integer roundoff.
    703                    for (idx=0; idx<N_AXIS; idx++) { st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL; }
    704                    st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
    705                  #endif
    706          
    707                  // Initialize segment buffer data for generating the segments.
    708                  prep.steps_remaining = (float)pl_block->step_event_count;
    709                  prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
    710                  prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
    711                  prep.dt_remainder = 0.0f; // Reset for new segment block
    712          
    713                  if ((sys.step_control & STEP_CONTROL_EXECUTE_HOLD) || (prep.recalculate_flag & PREP_FLAG_DECEL_OVERRIDE)) {
    714                    // New block loaded mid-hold. Override planner block entry speed to enforce deceleration.
    715                    prep.current_speed = prep.exit_speed;
    716                    pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed;
    717                    prep.recalculate_flag &= ~(PREP_FLAG_DECEL_OVERRIDE);
    718                  } else {
    719                    prep.current_speed = sqrtf(pl_block->entry_speed_sqr);
    720                  }
    721          #ifdef VARIABLE_SPINDLE
    722                  // Setup laser mode variables. PWM rate adjusted motions will always complete a motion with the
    723                  // spindle off. 
    724                  st_prep_block->is_pwm_rate_adjusted = false;
    725                  if (settings.flags & BITFLAG_LASER_MODE) {
    726                    if (pl_block->condition & PL_COND_FLAG_SPINDLE_CCW) {
    727                      // Pre-compute inverse programmed rate to speed up PWM updating per step segment.
    728                      prep.inv_rate = 1.0f / pl_block->programmed_rate;
    729                      st_prep_block->is_pwm_rate_adjusted = true;
    730                    }
    731                  }
    732          #endif
    733                }
    734          
    735          			/* ---------------------------------------------------------------------------------
    736          			 Compute the velocity profile of a new planner block based on its entry and exit
    737          			 speeds, or recompute the profile of a partially-completed planner block if the
    738          			 planner has updated it. For a commanded forced-deceleration, such as from a feed
    739          			 hold, override the planner velocities and decelerate to the target exit speed.
    740          			*/
    741          			prep.mm_complete = 0.0f; // Default velocity profile complete at 0.0mm from end of block.
    742          			float inv_2_accel = 0.5f/pl_block->acceleration;
    743          			if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { // [Forced Deceleration to Zero Velocity]
    744          				// Compute velocity profile parameters for a feed hold in-progress. This profile overrides
    745          				// the planner block profile, enforcing a deceleration to zero speed.
    746          				prep.ramp_type = RAMP_DECEL;
    747          				// Compute decelerate distance relative to end of block.
    748          				float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
    749          				if (decel_dist < 0.0f) {
    750          					// Deceleration through entire planner block. End of feed hold is not in this block.
    751          					prep.exit_speed = sqrtf(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
    752          				} else {
    753          					prep.mm_complete = decel_dist; // End of feed hold.
    754          					prep.exit_speed = 0.0f;
    755          				}
    756          			} else { // [Normal Operation]
    757          				// Compute or recompute velocity profile parameters of the prepped planner block.
    758          				prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
    759          				prep.accelerate_until = pl_block->millimeters;
    760          
    761          				float exit_speed_sqr;
    762          				float nominal_speed;
    763                  if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
    764                    prep.exit_speed = exit_speed_sqr = 0.0f; // Enforce stop at end of system motion.
    765                  } else {
    766                    exit_speed_sqr = plan_get_exec_block_exit_speed_sqr();
    767                    prep.exit_speed = sqrtf(exit_speed_sqr);
    768                  }
    769          
    770                  nominal_speed = plan_compute_profile_nominal_speed(pl_block);
    771          				float nominal_speed_sqr = nominal_speed*nominal_speed;
    772          				float intersect_distance =
    773          								0.5f*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
    774          
    775                  if (pl_block->entry_speed_sqr > nominal_speed_sqr) { // Only occurs during override reductions.
    776                    prep.accelerate_until = pl_block->millimeters - inv_2_accel*(pl_block->entry_speed_sqr-nominal_speed_sqr);
    777                    if (prep.accelerate_until <= 0.0f) { // Deceleration-only.
    778                      prep.ramp_type = RAMP_DECEL;
    779                      // prep.decelerate_after = pl_block->millimeters;
    780                      // prep.maximum_speed = prep.current_speed;
    781          
    782                      // Compute override block exit speed since it doesn't match the planner exit speed.
    783                      prep.exit_speed = sqrtf(pl_block->entry_speed_sqr - 2*pl_block->acceleration*pl_block->millimeters);
    784                      prep.recalculate_flag |= PREP_FLAG_DECEL_OVERRIDE; // Flag to load next block as deceleration override.
    785          
    786                      // TODO: Determine correct handling of parameters in deceleration-only.
    787                      // Can be tricky since entry speed will be current speed, as in feed holds.
    788                      // Also, look into near-zero speed handling issues with this.
    789          
    790                    } else {
    791                      // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
    792                      prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr); // Should always be >= 0.0 due to planner reinit.
    793          						prep.maximum_speed = nominal_speed;
    794                      prep.ramp_type = RAMP_DECEL_OVERRIDE;
    795                    }
    796          				} else if (intersect_distance > 0.0f) {
    797          					if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
    798          						// NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
    799          						prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
    800          						if (prep.decelerate_after < intersect_distance) { // Trapezoid type
    801          							prep.maximum_speed = nominal_speed;
    802          							if (pl_block->entry_speed_sqr == nominal_speed_sqr) {
    803          								// Cruise-deceleration or cruise-only type.
    804          								prep.ramp_type = RAMP_CRUISE;
    805          							} else {
    806          								// Full-trapezoid or acceleration-cruise types
    807          								prep.accelerate_until -= inv_2_accel*(nominal_speed_sqr-pl_block->entry_speed_sqr);
    808          							}
    809          						} else { // Triangle type
    810          							prep.accelerate_until = intersect_distance;
    811          							prep.decelerate_after = intersect_distance;
    812          							prep.maximum_speed = sqrtf(2.0f*pl_block->acceleration*intersect_distance+exit_speed_sqr);
    813          						}
    814          					} else { // Deceleration-only type
    815                      prep.ramp_type = RAMP_DECEL;
    816                      // prep.decelerate_after = pl_block->millimeters;
    817                      // prep.maximum_speed = prep.current_speed;
    818          					}
    819          				} else { // Acceleration-only type
    820          					prep.accelerate_until = 0.0f;
    821          					// prep.decelerate_after = 0.0f;
    822          					prep.maximum_speed = prep.exit_speed;
    823          				}
    824          			}
    825                
    826                #ifdef VARIABLE_SPINDLE
    827                  bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); // Force update whenever updating block.
    828                #endif
    829              }
    830              
    831              // Initialize new segment
    832              segment_t *prep_segment = &segment_buffer[segment_buffer_head];
    833          
    834              // Set new segment to point to the current segment data block.
    835              prep_segment->st_block_index = prep.st_block_index;
    836          
    837              /*------------------------------------------------------------------------------------
    838                  Compute the average velocity of this new segment by determining the total distance
    839                traveled over the segment time DT_SEGMENT. The following code first attempts to create
    840                a full segment based on the current ramp conditions. If the segment time is incomplete
    841                when terminating at a ramp state change, the code will continue to loop through the
    842                progressing ramp states to fill the remaining segment execution time. However, if
    843                an incomplete segment terminates at the end of the velocity profile, the segment is
    844                considered completed despite having a truncated execution time less than DT_SEGMENT.
    845                  The velocity profile is always assumed to progress through the ramp sequence:
    846                acceleration ramp, cruising state, and deceleration ramp. Each ramp's travel distance
    847                may range from zero to the length of the block. Velocity profiles can end either at
    848                the end of planner block (typical) or mid-block at the end of a forced deceleration,
    849                such as from a feed hold.
    850              */
    851              float dt_max = DT_SEGMENT; // Maximum segment time
    852              float dt = 0.0f; // Initialize segment time
    853              float time_var = dt_max; // Time worker variable
    854              float mm_var; // mm-Distance worker variable
    855              float speed_var; // Speed worker variable
    856              float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    857              float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    858              if (minimum_mm < 0.0f) { minimum_mm = 0.0f; }
    859          
    860              do {
    861                switch (prep.ramp_type) {
    862                  case RAMP_DECEL_OVERRIDE:
    863                    speed_var = pl_block->acceleration*time_var;
    864          					if (prep.current_speed-prep.maximum_speed <= speed_var) {
    865                      // Cruise or cruise-deceleration types only for deceleration override.
    866          						mm_remaining = prep.accelerate_until;
    867                      time_var = 2.0f*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    868                      prep.ramp_type = RAMP_CRUISE;
    869                      prep.current_speed = prep.maximum_speed;
    870                    } else { // Mid-deceleration override ramp.
    871          						mm_remaining -= time_var*(prep.current_speed - 0.5f*speed_var);
    872                      prep.current_speed -= speed_var;
    873                    }
    874                    break;
    875                  case RAMP_ACCEL:
    876                    // NOTE: Acceleration ramp only computes during first do-while loop.
    877                    speed_var = pl_block->acceleration*time_var;
    878                    mm_remaining -= time_var*(prep.current_speed + 0.5f*speed_var);
    879                    if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    880                      // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
    881                      mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
    882                      time_var = 2.0f*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    883                      if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    884                      else { prep.ramp_type = RAMP_CRUISE; }
    885                      prep.current_speed = prep.maximum_speed;
    886                    } else { // Acceleration only.
    887                      prep.current_speed += speed_var;
    888                    }
    889                    break;
    890                  case RAMP_CRUISE:
    891                    // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
    892                    // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To
    893                    //   prevent this, simply enforce a minimum speed threshold in the planner.
    894                    mm_var = mm_remaining - prep.maximum_speed*time_var;
    895                    if (mm_var < prep.decelerate_after) { // End of cruise.
    896                      // Cruise-deceleration junction or end of block.
    897                      time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
    898                      mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
    899                      prep.ramp_type = RAMP_DECEL;
    900                    } else { // Cruising only.
    901                      mm_remaining = mm_var;
    902                    }
    903                    break;
    904                  default: // case RAMP_DECEL:
    905                    // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
    906                    speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
    907                    if (prep.current_speed > speed_var) { // Check if at or below zero speed.
    908                      // Compute distance from end of segment to end of block.
    909                      mm_var = mm_remaining - time_var*(prep.current_speed - 0.5f*speed_var); // (mm)
    910                      if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
    911                        mm_remaining = mm_var;
    912                        prep.current_speed -= speed_var;
    913                        break; // Segment complete. Exit switch-case statement. Continue do-while loop.
    914                      }
    915                    }
    916                    // Otherwise, at end of block or end of forced-deceleration.
    917                    time_var = 2.0f*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    918                    mm_remaining = prep.mm_complete;
    919                    prep.current_speed = prep.exit_speed;
    920                }
    921                dt += time_var; // Add computed ramp time to total segment time.
    922                if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
    923                else {
    924                  if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
    925                    // Increase segment time to ensure at least one step in segment. Override and loop
    926                    // through distance calculations until minimum_mm or mm_complete.
    927                    dt_max += DT_SEGMENT;
    928                    time_var = dt_max - dt;
    929                  } else {
    930                    break; // **Complete** Exit loop. Segment execution time maxed.
    931                  }
    932                }
    933              } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
    934          
    935              #ifdef VARIABLE_SPINDLE
    936                /* -----------------------------------------------------------------------------------
    937                  Compute spindle speed PWM output for step segment
    938                */
    939          
    940                if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
    941                  if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
    942                    float rpm = pl_block->spindle_speed;
    943                    // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.        
    944                    if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
    945                    // If current_speed is zero, then may need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE)
    946                    // but this would be instantaneous only and during a motion. May not matter at all.
    947                    prep.current_spindle_pwm = spindle_compute_pwm_value(rpm);
    948                  }
    949                  else {
    950                    sys.spindle_speed = 0.0;
    951                    prep.current_spindle_pwm = SPINDLE_PWM_OFF_VALUE;
    952                  }
    953                  bit_false(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    954                }
    955                prep_segment->spindle_pwm = prep.current_spindle_pwm; // Reload segment PWM value
    956          
    957              #endif
    958              
    959              /* -----------------------------------------------------------------------------------
    960                 Compute segment step rate, steps to execute, and apply necessary rate corrections.
    961                 NOTE: Steps are computed by direct scalar conversion of the millimeter distance
    962                 remaining in the block, rather than incrementally tallying the steps executed per
    963                 segment. This helps in removing floating point round-off issues of several additions.
    964                 However, since floats have only 7.2 significant digits, long moves with extremely
    965                 high step counts can exceed the precision of floats, which can lead to lost steps.
    966                 Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
    967                 supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    968              */
    969              float step_dist_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
    970              float n_steps_remaining = ceilf(step_dist_remaining); // Round-up current steps remaining
    971              float last_n_steps_remaining = ceilf(prep.steps_remaining); // Round-up last steps remaining
    972          	prep_segment->n_step = (uint16_t)(last_n_steps_remaining - n_steps_remaining); // Compute number of steps to execute.
    973          
    974              // Bail if we are at the end of a feed hold and don't have a step to execute.
    975              if (prep_segment->n_step == 0) {
    976                if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) {
    977                  // Less than one step to decelerate to zero speed, but already very close. AMASS
    978                  // requires full steps to execute. So, just bail.
    979                  bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    980                  #ifdef PARKING_ENABLE
    981                    if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
    982                  #endif
    983                  return; // Segment not generated, but current step data still retained.
    984                }
    985              }
    986          
    987              // Compute segment step rate. Since steps are integers and mm distances traveled are not,
    988              // the end of every segment can have a partial step of varying magnitudes that are not
    989              // executed, because the stepper ISR requires whole steps due to the AMASS algorithm. To
    990              // compensate, we track the time to execute the previous segment's partial step and simply
    991              // apply it with the partial step distance to the current segment, so that it minutely
    992              // adjusts the whole segment rate to keep step output exact. These rate adjustments are
    993              // typically very small and do not adversely effect performance, but ensures that Grbl
    994              // outputs the exact acceleration and velocity profiles as computed by the planner.
    995              dt += prep.dt_remainder; // Apply previous segment partial step execute time
    996              float inv_rate = dt/(last_n_steps_remaining - step_dist_remaining); // Compute adjusted step rate inverse
    997          
    998              // Compute CPU cycles per step for the prepped segment.
    999           ////???	uint32_t cycles = (uint32_t)ceilf((TICKS_PER_MICROSECOND * 1000000) *inv_rate * 60); // (cycles/step)
   1000          uint32_t cycles = 1000;////????
   1001              #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
   1002                // Compute step timing and multi-axis smoothing level.
   1003                // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
   1004                if (cycles < AMASS_LEVEL1) 
   1005                { 
   1006                  prep_segment->amass_level = 0; 
   1007                }
   1008                else {
   1009                  if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
   1010                  else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
   1011                  else { prep_segment->amass_level = 3; }
   1012                  cycles >>= prep_segment->amass_level;
   1013                  prep_segment->n_step <<= prep_segment->amass_level;
   1014                }
   1015                if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
   1016                else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
   1017              #else
   1018                // Compute step timing and timer prescalar for normal step generation.
   1019                if (cycles < (1UL << 16)) { // < 65536  (4.1ms @ 16MHz)
   1020                  prep_segment->prescaler = 1; // prescaler: 0
   1021                  prep_segment->cycles_per_tick = cycles;
   1022                } else if (cycles < (1UL << 19)) { // < 524288 (32.8ms@16MHz)
   1023                  prep_segment->prescaler = 2; // prescaler: 8
   1024                  prep_segment->cycles_per_tick = cycles >> 3;
   1025                } else {
   1026                  prep_segment->prescaler = 3; // prescaler: 64
   1027                  if (cycles < (1UL << 22)) { // < 4194304 (262ms@16MHz)
   1028                    prep_segment->cycles_per_tick =  cycles >> 6;
   1029                  } else { // Just set the slowest speed possible. (Around 4 step/sec.)
   1030                    prep_segment->cycles_per_tick = 0xffff;
   1031                  }
   1032                }
   1033              #endif
   1034          
   1035              // Segment complete! Increment segment buffer indices, so stepper ISR can immediately execute it.
   1036              segment_buffer_head = segment_next_head;
   1037              if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
   1038          
   1039              // Update the appropriate planner and segment data.
   1040              pl_block->millimeters = mm_remaining;
   1041              prep.steps_remaining = n_steps_remaining;
   1042              prep.dt_remainder = (n_steps_remaining - step_dist_remaining)*inv_rate;
   1043          
   1044              // Check for exit conditions and flag to load next planner block.
   1045              if (mm_remaining == prep.mm_complete) {
   1046                // End of planner block or forced-termination. No more distance to be executed.
   1047                if (mm_remaining > 0.0f) { // At end of forced-termination.
   1048                  // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
   1049                  // the segment queue, where realtime protocol will set new state upon receiving the
   1050                  // cycle stop flag from the ISR. Prep_segment is blocked until then.
   1051                  bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
   1052                  #ifdef PARKING_ENABLE
   1053                    if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
   1054                  #endif
   1055                  return; // Bail!
   1056                } else { // End of planner block
   1057                  // The planner block is complete. All steps are set to be executed in the segment buffer.
   1058                  if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
   1059                    bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
   1060                    return;
   1061                  }
   1062                  pl_block = NULL; // Set pointer to indicate check and load next planner block.
   1063                  plan_discard_current_block();
   1064                }
   1065              }
   1066          
   1067            }
   1068          }
   1069          
   1070          
   1071          // Called by realtime status reporting to fetch the current speed being executed. This value
   1072          // however is not exactly the current speed, but the speed computed in the last step segment
   1073          // in the segment buffer. It will always be behind by up to the number of segment blocks (-1)
   1074          // divided by the ACCELERATION TICKS PER SECOND in seconds.
   1075          float st_get_realtime_rate()
   1076          {
   1077            if (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)){
   1078              return prep.current_speed;
   1079            }
   1080            return 0.0f;
   1081          }
   1082          
   1083          void TIM_Configuration(TIM_TypeDef* TIMER, u16 Period, u16 Prescaler, u8 PP)
   1084          {
   1085          	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
   1086           	NVIC_InitTypeDef NVIC_InitStructure;
   1087          
   1088          	TIM_TimeBaseStructure.TIM_Period = Period - 1;
   1089          	TIM_TimeBaseStructure.TIM_Prescaler = Prescaler - 1;
   1090          	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
   1091          	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   1092          	TIM_TimeBaseInit(TIMER, &TIM_TimeBaseStructure);
   1093          
   1094          	TIM_ClearITPendingBit(TIMER, TIM_IT_Update);
   1095          	TIM_ITConfig(TIMER, TIM_IT_Update, ENABLE);
   1096          	TIM_Cmd(TIMER, ENABLE);
   1097          
   1098          	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
   1099           	if (TIMER == TIM2) 
   1100                    { 
   1101                    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn; 
   1102                    }
   1103           	else if (TIMER == TIM3) 
   1104                    { 
   1105                    NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn; 
   1106                    }
   1107           	else if (TIMER == TIM4) 
   1108                    { 
   1109            ////????        NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn; 
   1110                    }
   1111          
   1112          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = PP;
   1113          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
   1114          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   1115          	NVIC_Init(&NVIC_InitStructure);
   1116          }
   1117          #endif


 
 
 0 bytes of memory

Errors: none
Warnings: none
