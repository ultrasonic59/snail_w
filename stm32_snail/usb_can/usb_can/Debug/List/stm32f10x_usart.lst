###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         30/May/2020  18:12:42
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\SPL\src\stm32f10x_usart.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EW7605.tmp
#        (D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\SPL\src\stm32f10x_usart.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D STM32F10X_LD -D USEUSB -lcN
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\.\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\freertos\source\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\freertos\source\port\ARM_CM3\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\SPL\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\stm_usb_fs_lib\inc\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\usb\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\board\ -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\List\stm32f10x_usart.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\Obj\stm32f10x_usart.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\SPL\src\stm32f10x_usart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_usart.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    11-March-2011
      7            * @brief   This file provides all the USART firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f10x_usart.h"
     24          #include "stm32f10x_rcc.h"
     25          #include "stm32f10x_conf.h"
     26          
     27          /** @addtogroup STM32F10x_StdPeriph_Driver
     28            * @{
     29            */
     30          
     31          /** @defgroup USART 
     32            * @brief USART driver modules
     33            * @{
     34            */
     35          
     36          /** @defgroup USART_Private_TypesDefinitions
     37            * @{
     38            */
     39          
     40          /**
     41            * @}
     42            */
     43          
     44          /** @defgroup USART_Private_Defines
     45            * @{
     46            */
     47          
     48          #define CR1_UE_Set                ((uint16_t)0x2000)  /*!< USART Enable Mask */
     49          #define CR1_UE_Reset              ((uint16_t)0xDFFF)  /*!< USART Disable Mask */
     50          
     51          #define CR1_WAKE_Mask             ((uint16_t)0xF7FF)  /*!< USART WakeUp Method Mask */
     52          
     53          #define CR1_RWU_Set               ((uint16_t)0x0002)  /*!< USART mute mode Enable Mask */
     54          #define CR1_RWU_Reset             ((uint16_t)0xFFFD)  /*!< USART mute mode Enable Mask */
     55          #define CR1_SBK_Set               ((uint16_t)0x0001)  /*!< USART Break Character send Mask */
     56          #define CR1_CLEAR_Mask            ((uint16_t)0xE9F3)  /*!< USART CR1 Mask */
     57          #define CR2_Address_Mask          ((uint16_t)0xFFF0)  /*!< USART address Mask */
     58          
     59          #define CR2_LINEN_Set              ((uint16_t)0x4000)  /*!< USART LIN Enable Mask */
     60          #define CR2_LINEN_Reset            ((uint16_t)0xBFFF)  /*!< USART LIN Disable Mask */
     61          
     62          #define CR2_LBDL_Mask             ((uint16_t)0xFFDF)  /*!< USART LIN Break detection Mask */
     63          #define CR2_STOP_CLEAR_Mask       ((uint16_t)0xCFFF)  /*!< USART CR2 STOP Bits Mask */
     64          #define CR2_CLOCK_CLEAR_Mask      ((uint16_t)0xF0FF)  /*!< USART CR2 Clock Mask */
     65          
     66          #define CR3_SCEN_Set              ((uint16_t)0x0020)  /*!< USART SC Enable Mask */
     67          #define CR3_SCEN_Reset            ((uint16_t)0xFFDF)  /*!< USART SC Disable Mask */
     68          
     69          #define CR3_NACK_Set              ((uint16_t)0x0010)  /*!< USART SC NACK Enable Mask */
     70          #define CR3_NACK_Reset            ((uint16_t)0xFFEF)  /*!< USART SC NACK Disable Mask */
     71          
     72          #define CR3_HDSEL_Set             ((uint16_t)0x0008)  /*!< USART Half-Duplex Enable Mask */
     73          #define CR3_HDSEL_Reset           ((uint16_t)0xFFF7)  /*!< USART Half-Duplex Disable Mask */
     74          
     75          #define CR3_IRLP_Mask             ((uint16_t)0xFFFB)  /*!< USART IrDA LowPower mode Mask */
     76          #define CR3_CLEAR_Mask            ((uint16_t)0xFCFF)  /*!< USART CR3 Mask */
     77          
     78          #define CR3_IREN_Set              ((uint16_t)0x0002)  /*!< USART IrDA Enable Mask */
     79          #define CR3_IREN_Reset            ((uint16_t)0xFFFD)  /*!< USART IrDA Disable Mask */
     80          #define GTPR_LSB_Mask             ((uint16_t)0x00FF)  /*!< Guard Time Register LSB Mask */
     81          #define GTPR_MSB_Mask             ((uint16_t)0xFF00)  /*!< Guard Time Register MSB Mask */
     82          #define IT_Mask                   ((uint16_t)0x001F)  /*!< USART Interrupt Mask */
     83          
     84          /* USART OverSampling-8 Mask */
     85          #define CR1_OVER8_Set             ((u16)0x8000)  /* USART OVER8 mode Enable Mask */
     86          #define CR1_OVER8_Reset           ((u16)0x7FFF)  /* USART OVER8 mode Disable Mask */
     87          
     88          /* USART One Bit Sampling Mask */
     89          #define CR3_ONEBITE_Set           ((u16)0x0800)  /* USART ONEBITE mode Enable Mask */
     90          #define CR3_ONEBITE_Reset         ((u16)0xF7FF)  /* USART ONEBITE mode Disable Mask */
     91          
     92          /**
     93            * @}
     94            */
     95          
     96          /** @defgroup USART_Private_Macros
     97            * @{
     98            */
     99          
    100          /**
    101            * @}
    102            */
    103          
    104          /** @defgroup USART_Private_Variables
    105            * @{
    106            */
    107          
    108          /**
    109            * @}
    110            */
    111          
    112          /** @defgroup USART_Private_FunctionPrototypes
    113            * @{
    114            */
    115          
    116          /**
    117            * @}
    118            */
    119          
    120          /** @defgroup USART_Private_Functions
    121            * @{
    122            */
    123          
    124          /**
    125            * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
    126            * @param  USARTx: Select the USART or the UART peripheral. 
    127            *   This parameter can be one of the following values: 
    128            *      USART1, USART2, USART3, UART4 or UART5.
    129            * @retval None
    130            */
    131          void USART_DeInit(USART_TypeDef* USARTx)
    132          {
    133            /* Check the parameters */
    134            assert_param(IS_USART_ALL_PERIPH(USARTx));
    135          
    136            if (USARTx == USART1)
    137            {
    138              RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
    139              RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
    140            }
    141            else if (USARTx == USART2)
    142            {
    143              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
    144              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
    145            }
    146            else if (USARTx == USART3)
    147            {
    148              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
    149              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
    150            }    
    151            else if (USARTx == UART4)
    152            {
    153              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
    154              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
    155            }    
    156            else
    157            {
    158              if (USARTx == UART5)
    159              { 
    160                RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
    161                RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
    162              }
    163            }
    164          }
    165          
    166          /**
    167            * @brief  Initializes the USARTx peripheral according to the specified
    168            *         parameters in the USART_InitStruct .
    169            * @param  USARTx: Select the USART or the UART peripheral. 
    170            *   This parameter can be one of the following values:
    171            *   USART1, USART2, USART3, UART4 or UART5.
    172            * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
    173            *         that contains the configuration information for the specified USART 
    174            *         peripheral.
    175            * @retval None
    176            */
    177          void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
    178          {
    179            uint32_t tmpreg = 0x00, apbclock = 0x00;
    180            uint32_t integerdivider = 0x00;
    181            uint32_t fractionaldivider = 0x00;
    182            uint32_t usartxbase = 0;
    183            RCC_ClocksTypeDef RCC_ClocksStatus;
    184            /* Check the parameters */
    185            assert_param(IS_USART_ALL_PERIPH(USARTx));
    186            assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
    187            assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
    188            assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
    189            assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
    190            assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
    191            assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
    192            /* The hardware flow control is available only for USART1, USART2 and USART3 */
    193            if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
    194            {
    195              assert_param(IS_USART_123_PERIPH(USARTx));
    196            }
    197          
    198            usartxbase = (uint32_t)USARTx;
    199          
    200          /*---------------------------- USART CR2 Configuration -----------------------*/
    201            tmpreg = USARTx->CR2;
    202            /* Clear STOP[13:12] bits */
    203            tmpreg &= CR2_STOP_CLEAR_Mask;
    204            /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
    205            /* Set STOP[13:12] bits according to USART_StopBits value */
    206            tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
    207            
    208            /* Write to USART CR2 */
    209            USARTx->CR2 = (uint16_t)tmpreg;
    210          
    211          /*---------------------------- USART CR1 Configuration -----------------------*/
    212            tmpreg = USARTx->CR1;
    213            /* Clear M, PCE, PS, TE and RE bits */
    214            tmpreg &= CR1_CLEAR_Mask;
    215            /* Configure the USART Word Length, Parity and mode ----------------------- */
    216            /* Set the M bits according to USART_WordLength value */
    217            /* Set PCE and PS bits according to USART_Parity value */
    218            /* Set TE and RE bits according to USART_Mode value */
    219            tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
    220                      USART_InitStruct->USART_Mode;
    221            /* Write to USART CR1 */
    222            USARTx->CR1 = (uint16_t)tmpreg;
    223          
    224          /*---------------------------- USART CR3 Configuration -----------------------*/  
    225            tmpreg = USARTx->CR3;
    226            /* Clear CTSE and RTSE bits */
    227            tmpreg &= CR3_CLEAR_Mask;
    228            /* Configure the USART HFC -------------------------------------------------*/
    229            /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
    230            tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
    231            /* Write to USART CR3 */
    232            USARTx->CR3 = (uint16_t)tmpreg;
    233          
    234          /*---------------------------- USART BRR Configuration -----------------------*/
    235            /* Configure the USART Baud Rate -------------------------------------------*/
    236            RCC_GetClocksFreq(&RCC_ClocksStatus);
    237            if (usartxbase == USART1_BASE)
    238            {
    239              apbclock = RCC_ClocksStatus.PCLK2_Frequency;
    240            }
    241            else
    242            {
    243              apbclock = RCC_ClocksStatus.PCLK1_Frequency;
    244            }
    245            
    246            /* Determine the integer part */
    247            if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
    248            {
    249              /* Integer part computing in case Oversampling mode is 8 Samples */
    250              integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
    251            }
    252            else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
    253            {
    254              /* Integer part computing in case Oversampling mode is 16 Samples */
    255              integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
    256            }
    257            tmpreg = (integerdivider / 100) << 4;
    258          
    259            /* Determine the fractional part */
    260            fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
    261          
    262            /* Implement the fractional part in the register */
    263            if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
    264            {
    265              tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
    266            }
    267            else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
    268            {
    269              tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
    270            }
    271            
    272            /* Write to USART BRR */
    273            USARTx->BRR = (uint16_t)tmpreg;
    274          }
    275          
    276          /**
    277            * @brief  Fills each USART_InitStruct member with its default value.
    278            * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
    279            *         which will be initialized.
    280            * @retval None
    281            */
    282          void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
    283          {
    284            /* USART_InitStruct members default value */
    285            USART_InitStruct->USART_BaudRate = 9600;
    286            USART_InitStruct->USART_WordLength = USART_WordLength_8b;
    287            USART_InitStruct->USART_StopBits = USART_StopBits_1;
    288            USART_InitStruct->USART_Parity = USART_Parity_No ;
    289            USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    290            USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
    291          }
    292          
    293          /**
    294            * @brief  Initializes the USARTx peripheral Clock according to the 
    295            *          specified parameters in the USART_ClockInitStruct .
    296            * @param  USARTx: where x can be 1, 2, 3 to select the USART peripheral.
    297            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
    298            *         structure that contains the configuration information for the specified 
    299            *         USART peripheral.  
    300            * @note The Smart Card and Synchronous modes are not available for UART4 and UART5.
    301            * @retval None
    302            */
    303          void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
    304          {
    305            uint32_t tmpreg = 0x00;
    306            /* Check the parameters */
    307            assert_param(IS_USART_123_PERIPH(USARTx));
    308            assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
    309            assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
    310            assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
    311            assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
    312            
    313          /*---------------------------- USART CR2 Configuration -----------------------*/
    314            tmpreg = USARTx->CR2;
    315            /* Clear CLKEN, CPOL, CPHA and LBCL bits */
    316            tmpreg &= CR2_CLOCK_CLEAR_Mask;
    317            /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
    318            /* Set CLKEN bit according to USART_Clock value */
    319            /* Set CPOL bit according to USART_CPOL value */
    320            /* Set CPHA bit according to USART_CPHA value */
    321            /* Set LBCL bit according to USART_LastBit value */
    322            tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
    323                           USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
    324            /* Write to USART CR2 */
    325            USARTx->CR2 = (uint16_t)tmpreg;
    326          }
    327          
    328          /**
    329            * @brief  Fills each USART_ClockInitStruct member with its default value.
    330            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
    331            *         structure which will be initialized.
    332            * @retval None
    333            */
    334          void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
    335          {
    336            /* USART_ClockInitStruct members default value */
    337            USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
    338            USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
    339            USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
    340            USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
    341          }
    342          
    343          /**
    344            * @brief  Enables or disables the specified USART peripheral.
    345            * @param  USARTx: Select the USART or the UART peripheral. 
    346            *         This parameter can be one of the following values:
    347            *           USART1, USART2, USART3, UART4 or UART5.
    348            * @param  NewState: new state of the USARTx peripheral.
    349            *         This parameter can be: ENABLE or DISABLE.
    350            * @retval None
    351            */
    352          void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
    353          {
    354            /* Check the parameters */
    355            assert_param(IS_USART_ALL_PERIPH(USARTx));
    356            assert_param(IS_FUNCTIONAL_STATE(NewState));
    357            
    358            if (NewState != DISABLE)
    359            {
    360              /* Enable the selected USART by setting the UE bit in the CR1 register */
    361              USARTx->CR1 |= CR1_UE_Set;
    362            }
    363            else
    364            {
    365              /* Disable the selected USART by clearing the UE bit in the CR1 register */
    366              USARTx->CR1 &= CR1_UE_Reset;
    367            }
    368          }
    369          
    370          /**
    371            * @brief  Enables or disables the specified USART interrupts.
    372            * @param  USARTx: Select the USART or the UART peripheral. 
    373            *   This parameter can be one of the following values:
    374            *   USART1, USART2, USART3, UART4 or UART5.
    375            * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
    376            *   This parameter can be one of the following values:
    377            *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
    378            *     @arg USART_IT_LBD:  LIN Break detection interrupt
    379            *     @arg USART_IT_TXE:  Transmit Data Register empty interrupt
    380            *     @arg USART_IT_TC:   Transmission complete interrupt
    381            *     @arg USART_IT_RXNE: Receive Data register not empty interrupt
    382            *     @arg USART_IT_IDLE: Idle line detection interrupt
    383            *     @arg USART_IT_PE:   Parity Error interrupt
    384            *     @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
    385            * @param  NewState: new state of the specified USARTx interrupts.
    386            *   This parameter can be: ENABLE or DISABLE.
    387            * @retval None
    388            */
    389          void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
    390          {
    391            uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
    392            uint32_t usartxbase = 0x00;
    393            /* Check the parameters */
    394            assert_param(IS_USART_ALL_PERIPH(USARTx));
    395            assert_param(IS_USART_CONFIG_IT(USART_IT));
    396            assert_param(IS_FUNCTIONAL_STATE(NewState));
    397            /* The CTS interrupt is not available for UART4 and UART5 */
    398            if (USART_IT == USART_IT_CTS)
    399            {
    400              assert_param(IS_USART_123_PERIPH(USARTx));
    401            }   
    402            
    403            usartxbase = (uint32_t)USARTx;
    404          
    405            /* Get the USART register index */
    406            usartreg = (((uint8_t)USART_IT) >> 0x05);
    407          
    408            /* Get the interrupt position */
    409            itpos = USART_IT & IT_Mask;
    410            itmask = (((uint32_t)0x01) << itpos);
    411              
    412            if (usartreg == 0x01) /* The IT is in CR1 register */
    413            {
    414              usartxbase += 0x0C;
    415            }
    416            else if (usartreg == 0x02) /* The IT is in CR2 register */
    417            {
    418              usartxbase += 0x10;
    419            }
    420            else /* The IT is in CR3 register */
    421            {
    422              usartxbase += 0x14; 
    423            }
    424            if (NewState != DISABLE)
    425            {
    426              *(__IO uint32_t*)usartxbase  |= itmask;
    427            }
    428            else
    429            {
    430              *(__IO uint32_t*)usartxbase &= ~itmask;
    431            }
    432          }
    433          
    434          /**
    435            * @brief  Enables or disables the USART’s DMA interface.
    436            * @param  USARTx: Select the USART or the UART peripheral. 
    437            *   This parameter can be one of the following values:
    438            *   USART1, USART2, USART3, UART4 or UART5.
    439            * @param  USART_DMAReq: specifies the DMA request.
    440            *   This parameter can be any combination of the following values:
    441            *     @arg USART_DMAReq_Tx: USART DMA transmit request
    442            *     @arg USART_DMAReq_Rx: USART DMA receive request
    443            * @param  NewState: new state of the DMA Request sources.
    444            *   This parameter can be: ENABLE or DISABLE.
    445            * @note The DMA mode is not available for UART5 except in the STM32
    446            *       High density value line devices(STM32F10X_HD_VL).  
    447            * @retval None
    448            */
    449          void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
    450          {
    451            /* Check the parameters */
    452            assert_param(IS_USART_ALL_PERIPH(USARTx));
    453            assert_param(IS_USART_DMAREQ(USART_DMAReq));  
    454            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
    455            if (NewState != DISABLE)
    456            {
    457              /* Enable the DMA transfer for selected requests by setting the DMAT and/or
    458                 DMAR bits in the USART CR3 register */
    459              USARTx->CR3 |= USART_DMAReq;
    460            }
    461            else
    462            {
    463              /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
    464                 DMAR bits in the USART CR3 register */
    465              USARTx->CR3 &= (uint16_t)~USART_DMAReq;
    466            }
    467          }
    468          
    469          /**
    470            * @brief  Sets the address of the USART node.
    471            * @param  USARTx: Select the USART or the UART peripheral. 
    472            *   This parameter can be one of the following values:
    473            *   USART1, USART2, USART3, UART4 or UART5.
    474            * @param  USART_Address: Indicates the address of the USART node.
    475            * @retval None
    476            */
    477          void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
    478          {
    479            /* Check the parameters */
    480            assert_param(IS_USART_ALL_PERIPH(USARTx));
    481            assert_param(IS_USART_ADDRESS(USART_Address)); 
    482              
    483            /* Clear the USART address */
    484            USARTx->CR2 &= CR2_Address_Mask;
    485            /* Set the USART address node */
    486            USARTx->CR2 |= USART_Address;
    487          }
    488          
    489          /**
    490            * @brief  Selects the USART WakeUp method.
    491            * @param  USARTx: Select the USART or the UART peripheral. 
    492            *   This parameter can be one of the following values:
    493            *   USART1, USART2, USART3, UART4 or UART5.
    494            * @param  USART_WakeUp: specifies the USART wakeup method.
    495            *   This parameter can be one of the following values:
    496            *     @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
    497            *     @arg USART_WakeUp_AddressMark: WakeUp by an address mark
    498            * @retval None
    499            */
    500          void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
    501          {
    502            /* Check the parameters */
    503            assert_param(IS_USART_ALL_PERIPH(USARTx));
    504            assert_param(IS_USART_WAKEUP(USART_WakeUp));
    505            
    506            USARTx->CR1 &= CR1_WAKE_Mask;
    507            USARTx->CR1 |= USART_WakeUp;
    508          }
    509          
    510          /**
    511            * @brief  Determines if the USART is in mute mode or not.
    512            * @param  USARTx: Select the USART or the UART peripheral. 
    513            *   This parameter can be one of the following values:
    514            *   USART1, USART2, USART3, UART4 or UART5.
    515            * @param  NewState: new state of the USART mute mode.
    516            *   This parameter can be: ENABLE or DISABLE.
    517            * @retval None
    518            */
    519          void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    520          {
    521            /* Check the parameters */
    522            assert_param(IS_USART_ALL_PERIPH(USARTx));
    523            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
    524            
    525            if (NewState != DISABLE)
    526            {
    527              /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
    528              USARTx->CR1 |= CR1_RWU_Set;
    529            }
    530            else
    531            {
    532              /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
    533              USARTx->CR1 &= CR1_RWU_Reset;
    534            }
    535          }
    536          
    537          /**
    538            * @brief  Sets the USART LIN Break detection length.
    539            * @param  USARTx: Select the USART or the UART peripheral. 
    540            *   This parameter can be one of the following values:
    541            *   USART1, USART2, USART3, UART4 or UART5.
    542            * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
    543            *   This parameter can be one of the following values:
    544            *     @arg USART_LINBreakDetectLength_10b: 10-bit break detection
    545            *     @arg USART_LINBreakDetectLength_11b: 11-bit break detection
    546            * @retval None
    547            */
    548          void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
    549          {
    550            /* Check the parameters */
    551            assert_param(IS_USART_ALL_PERIPH(USARTx));
    552            assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
    553            
    554            USARTx->CR2 &= CR2_LBDL_Mask;
    555            USARTx->CR2 |= USART_LINBreakDetectLength;  
    556          }
    557          
    558          /**
    559            * @brief  Enables or disables the USART’s LIN mode.
    560            * @param  USARTx: Select the USART or the UART peripheral. 
    561            *   This parameter can be one of the following values:
    562            *   USART1, USART2, USART3, UART4 or UART5.
    563            * @param  NewState: new state of the USART LIN mode.
    564            *   This parameter can be: ENABLE or DISABLE.
    565            * @retval None
    566            */
    567          void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    568          {
    569            /* Check the parameters */
    570            assert_param(IS_USART_ALL_PERIPH(USARTx));
    571            assert_param(IS_FUNCTIONAL_STATE(NewState));
    572            
    573            if (NewState != DISABLE)
    574            {
    575              /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    576              USARTx->CR2 |= CR2_LINEN_Set;
    577            }
    578            else
    579            {
    580              /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    581              USARTx->CR2 &= CR2_LINEN_Reset;
    582            }
    583          }
    584          
    585          /**
    586            * @brief  Transmits single data through the USARTx peripheral.
    587            * @param  USARTx: Select the USART or the UART peripheral. 
    588            *   This parameter can be one of the following values:
    589            *   USART1, USART2, USART3, UART4 or UART5.
    590            * @param  Data: the data to transmit.
    591            * @retval None
    592            */
    593          void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
    594          {
    595            /* Check the parameters */
    596            assert_param(IS_USART_ALL_PERIPH(USARTx));
    597            assert_param(IS_USART_DATA(Data)); 
    598              
    599            /* Transmit Data */
    600            USARTx->DR = (Data & (uint16_t)0x01FF);
    601          }
    602          
    603          /**
    604            * @brief  Returns the most recent received data by the USARTx peripheral.
    605            * @param  USARTx: Select the USART or the UART peripheral. 
    606            *   This parameter can be one of the following values:
    607            *   USART1, USART2, USART3, UART4 or UART5.
    608            * @retval The received data.
    609            */
    610          uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
    611          {
    612            /* Check the parameters */
    613            assert_param(IS_USART_ALL_PERIPH(USARTx));
    614            
    615            /* Receive Data */
    616            return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
    617          }
    618          
    619          /**
    620            * @brief  Transmits break characters.
    621            * @param  USARTx: Select the USART or the UART peripheral. 
    622            *   This parameter can be one of the following values:
    623            *   USART1, USART2, USART3, UART4 or UART5.
    624            * @retval None
    625            */
    626          void USART_SendBreak(USART_TypeDef* USARTx)
    627          {
    628            /* Check the parameters */
    629            assert_param(IS_USART_ALL_PERIPH(USARTx));
    630            
    631            /* Send break characters */
    632            USARTx->CR1 |= CR1_SBK_Set;
    633          }
    634          
    635          /**
    636            * @brief  Sets the specified USART guard time.
    637            * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.
    638            * @param  USART_GuardTime: specifies the guard time.
    639            * @note The guard time bits are not available for UART4 and UART5.   
    640            * @retval None
    641            */
    642          void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
    643          {    
    644            /* Check the parameters */
    645            assert_param(IS_USART_123_PERIPH(USARTx));
    646            
    647            /* Clear the USART Guard time */
    648            USARTx->GTPR &= GTPR_LSB_Mask;
    649            /* Set the USART guard time */
    650            USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
    651          }
    652          
    653          /**
    654            * @brief  Sets the system clock prescaler.
    655            * @param  USARTx: Select the USART or the UART peripheral. 
    656            *   This parameter can be one of the following values:
    657            *   USART1, USART2, USART3, UART4 or UART5.
    658            * @param  USART_Prescaler: specifies the prescaler clock.  
    659            * @note   The function is used for IrDA mode with UART4 and UART5.
    660            * @retval None
    661            */
    662          void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
    663          { 
    664            /* Check the parameters */
    665            assert_param(IS_USART_ALL_PERIPH(USARTx));
    666            
    667            /* Clear the USART prescaler */
    668            USARTx->GTPR &= GTPR_MSB_Mask;
    669            /* Set the USART prescaler */
    670            USARTx->GTPR |= USART_Prescaler;
    671          }
    672          
    673          /**
    674            * @brief  Enables or disables the USART’s Smart Card mode.
    675            * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.
    676            * @param  NewState: new state of the Smart Card mode.
    677            *   This parameter can be: ENABLE or DISABLE.     
    678            * @note The Smart Card mode is not available for UART4 and UART5. 
    679            * @retval None
    680            */
    681          void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    682          {
    683            /* Check the parameters */
    684            assert_param(IS_USART_123_PERIPH(USARTx));
    685            assert_param(IS_FUNCTIONAL_STATE(NewState));
    686            if (NewState != DISABLE)
    687            {
    688              /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    689              USARTx->CR3 |= CR3_SCEN_Set;
    690            }
    691            else
    692            {
    693              /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    694              USARTx->CR3 &= CR3_SCEN_Reset;
    695            }
    696          }
    697          
    698          /**
    699            * @brief  Enables or disables NACK transmission.
    700            * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral. 
    701            * @param  NewState: new state of the NACK transmission.
    702            *   This parameter can be: ENABLE or DISABLE.  
    703            * @note The Smart Card mode is not available for UART4 and UART5.
    704            * @retval None
    705            */
    706          void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    707          {
    708            /* Check the parameters */
    709            assert_param(IS_USART_123_PERIPH(USARTx));  
    710            assert_param(IS_FUNCTIONAL_STATE(NewState));
    711            if (NewState != DISABLE)
    712            {
    713              /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    714              USARTx->CR3 |= CR3_NACK_Set;
    715            }
    716            else
    717            {
    718              /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    719              USARTx->CR3 &= CR3_NACK_Reset;
    720            }
    721          }
    722          
    723          /**
    724            * @brief  Enables or disables the USART’s Half Duplex communication.
    725            * @param  USARTx: Select the USART or the UART peripheral. 
    726            *   This parameter can be one of the following values:
    727            *   USART1, USART2, USART3, UART4 or UART5.
    728            * @param  NewState: new state of the USART Communication.
    729            *   This parameter can be: ENABLE or DISABLE.
    730            * @retval None
    731            */
    732          void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    733          {
    734            /* Check the parameters */
    735            assert_param(IS_USART_ALL_PERIPH(USARTx));
    736            assert_param(IS_FUNCTIONAL_STATE(NewState));
    737            
    738            if (NewState != DISABLE)
    739            {
    740              /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    741              USARTx->CR3 |= CR3_HDSEL_Set;
    742            }
    743            else
    744            {
    745              /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    746              USARTx->CR3 &= CR3_HDSEL_Reset;
    747            }
    748          }
    749          
    750          
    751          /**
    752            * @brief  Enables or disables the USART's 8x oversampling mode.
    753            * @param  USARTx: Select the USART or the UART peripheral.
    754            *   This parameter can be one of the following values:
    755            *   USART1, USART2, USART3, UART4 or UART5.
    756            * @param  NewState: new state of the USART one bit sampling method.
    757            *   This parameter can be: ENABLE or DISABLE.
    758            * @note
    759            *     This function has to be called before calling USART_Init()
    760            *     function in order to have correct baudrate Divider value.   
    761            * @retval None
    762            */
    763          void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
    764          {
    765            /* Check the parameters */
    766            assert_param(IS_USART_ALL_PERIPH(USARTx));
    767            assert_param(IS_FUNCTIONAL_STATE(NewState));
    768            
    769            if (NewState != DISABLE)
    770            {
    771              /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    772              USARTx->CR1 |= CR1_OVER8_Set;
    773            }
    774            else
    775            {
    776              /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
    777              USARTx->CR1 &= CR1_OVER8_Reset;
    778            }
    779          }
    780          
    781          /**
    782            * @brief  Enables or disables the USART's one bit sampling method.
    783            * @param  USARTx: Select the USART or the UART peripheral.
    784            *   This parameter can be one of the following values:
    785            *   USART1, USART2, USART3, UART4 or UART5.
    786            * @param  NewState: new state of the USART one bit sampling method.
    787            *   This parameter can be: ENABLE or DISABLE.
    788            * @retval None
    789            */
    790          void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    791          {
    792            /* Check the parameters */
    793            assert_param(IS_USART_ALL_PERIPH(USARTx));
    794            assert_param(IS_FUNCTIONAL_STATE(NewState));
    795            
    796            if (NewState != DISABLE)
    797            {
    798              /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    799              USARTx->CR3 |= CR3_ONEBITE_Set;
    800            }
    801            else
    802            {
    803              /* Disable tthe one bit method by clearing the ONEBITE bit in the CR3 register */
    804              USARTx->CR3 &= CR3_ONEBITE_Reset;
    805            }
    806          }
    807          
    808          /**
    809            * @brief  Configures the USART's IrDA interface.
    810            * @param  USARTx: Select the USART or the UART peripheral. 
    811            *   This parameter can be one of the following values:
    812            *   USART1, USART2, USART3, UART4 or UART5.
    813            * @param  USART_IrDAMode: specifies the IrDA mode.
    814            *   This parameter can be one of the following values:
    815            *     @arg USART_IrDAMode_LowPower
    816            *     @arg USART_IrDAMode_Normal
    817            * @retval None
    818            */
    819          void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
    820          {
    821            /* Check the parameters */
    822            assert_param(IS_USART_ALL_PERIPH(USARTx));
    823            assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
    824              
    825            USARTx->CR3 &= CR3_IRLP_Mask;
    826            USARTx->CR3 |= USART_IrDAMode;
    827          }
    828          
    829          /**
    830            * @brief  Enables or disables the USART's IrDA interface.
    831            * @param  USARTx: Select the USART or the UART peripheral. 
    832            *   This parameter can be one of the following values:
    833            *   USART1, USART2, USART3, UART4 or UART5.
    834            * @param  NewState: new state of the IrDA mode.
    835            *   This parameter can be: ENABLE or DISABLE.
    836            * @retval None
    837            */
    838          void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
    839          {
    840            /* Check the parameters */
    841            assert_param(IS_USART_ALL_PERIPH(USARTx));
    842            assert_param(IS_FUNCTIONAL_STATE(NewState));
    843              
    844            if (NewState != DISABLE)
    845            {
    846              /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    847              USARTx->CR3 |= CR3_IREN_Set;
    848            }
    849            else
    850            {
    851              /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    852              USARTx->CR3 &= CR3_IREN_Reset;
    853            }
    854          }
    855          
    856          /**
    857            * @brief  Checks whether the specified USART flag is set or not.
    858            * @param  USARTx: Select the USART or the UART peripheral. 
    859            *   This parameter can be one of the following values:
    860            *   USART1, USART2, USART3, UART4 or UART5.
    861            * @param  USART_FLAG: specifies the flag to check.
    862            *   This parameter can be one of the following values:
    863            *     @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
    864            *     @arg USART_FLAG_LBD:  LIN Break detection flag
    865            *     @arg USART_FLAG_TXE:  Transmit data register empty flag
    866            *     @arg USART_FLAG_TC:   Transmission Complete flag
    867            *     @arg USART_FLAG_RXNE: Receive data register not empty flag
    868            *     @arg USART_FLAG_IDLE: Idle Line detection flag
    869            *     @arg USART_FLAG_ORE:  OverRun Error flag
    870            *     @arg USART_FLAG_NE:   Noise Error flag
    871            *     @arg USART_FLAG_FE:   Framing Error flag
    872            *     @arg USART_FLAG_PE:   Parity Error flag
    873            * @retval The new state of USART_FLAG (SET or RESET).
    874            */
    875          FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
    876          {
    877            FlagStatus bitstatus = RESET;
    878            /* Check the parameters */
    879            assert_param(IS_USART_ALL_PERIPH(USARTx));
    880            assert_param(IS_USART_FLAG(USART_FLAG));
    881            /* The CTS flag is not available for UART4 and UART5 */
    882            if (USART_FLAG == USART_FLAG_CTS)
    883            {
    884              assert_param(IS_USART_123_PERIPH(USARTx));
    885            }  
    886            
    887            if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
    888            {
    889              bitstatus = SET;
    890            }
    891            else
    892            {
    893              bitstatus = RESET;
    894            }
    895            return bitstatus;
    896          }
    897          
    898          /**
    899            * @brief  Clears the USARTx's pending flags.
    900            * @param  USARTx: Select the USART or the UART peripheral. 
    901            *   This parameter can be one of the following values:
    902            *   USART1, USART2, USART3, UART4 or UART5.
    903            * @param  USART_FLAG: specifies the flag to clear.
    904            *   This parameter can be any combination of the following values:
    905            *     @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
    906            *     @arg USART_FLAG_LBD:  LIN Break detection flag.
    907            *     @arg USART_FLAG_TC:   Transmission Complete flag.
    908            *     @arg USART_FLAG_RXNE: Receive data register not empty flag.
    909            *   
    910            * @note
    911            *   - PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
    912            *     error) and IDLE (Idle line detected) flags are cleared by software 
    913            *     sequence: a read operation to USART_SR register (USART_GetFlagStatus()) 
    914            *     followed by a read operation to USART_DR register (USART_ReceiveData()).
    915            *   - RXNE flag can be also cleared by a read to the USART_DR register 
    916            *     (USART_ReceiveData()).
    917            *   - TC flag can be also cleared by software sequence: a read operation to 
    918            *     USART_SR register (USART_GetFlagStatus()) followed by a write operation
    919            *     to USART_DR register (USART_SendData()).
    920            *   - TXE flag is cleared only by a write to the USART_DR register 
    921            *     (USART_SendData()).
    922            * @retval None
    923            */
    924          void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
    925          {
    926            /* Check the parameters */
    927            assert_param(IS_USART_ALL_PERIPH(USARTx));
    928            assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
    929            /* The CTS flag is not available for UART4 and UART5 */
    930            if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
    931            {
    932              assert_param(IS_USART_123_PERIPH(USARTx));
    933            } 
    934             
    935            USARTx->SR = (uint16_t)~USART_FLAG;
    936          }
    937          
    938          /**
    939            * @brief  Checks whether the specified USART interrupt has occurred or not.
    940            * @param  USARTx: Select the USART or the UART peripheral. 
    941            *   This parameter can be one of the following values:
    942            *   USART1, USART2, USART3, UART4 or UART5.
    943            * @param  USART_IT: specifies the USART interrupt source to check.
    944            *   This parameter can be one of the following values:
    945            *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
    946            *     @arg USART_IT_LBD:  LIN Break detection interrupt
    947            *     @arg USART_IT_TXE:  Tansmit Data Register empty interrupt
    948            *     @arg USART_IT_TC:   Transmission complete interrupt
    949            *     @arg USART_IT_RXNE: Receive Data register not empty interrupt
    950            *     @arg USART_IT_IDLE: Idle line detection interrupt
    951            *     @arg USART_IT_ORE:  OverRun Error interrupt
    952            *     @arg USART_IT_NE:   Noise Error interrupt
    953            *     @arg USART_IT_FE:   Framing Error interrupt
    954            *     @arg USART_IT_PE:   Parity Error interrupt
    955            * @retval The new state of USART_IT (SET or RESET).
    956            */
    957          ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
    958          {
    959            uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
    960            ITStatus bitstatus = RESET;
    961            /* Check the parameters */
    962            assert_param(IS_USART_ALL_PERIPH(USARTx));
    963            assert_param(IS_USART_GET_IT(USART_IT));
    964            /* The CTS interrupt is not available for UART4 and UART5 */ 
    965            if (USART_IT == USART_IT_CTS)
    966            {
    967              assert_param(IS_USART_123_PERIPH(USARTx));
    968            }   
    969            
    970            /* Get the USART register index */
    971            usartreg = (((uint8_t)USART_IT) >> 0x05);
    972            /* Get the interrupt position */
    973            itmask = USART_IT & IT_Mask;
    974            itmask = (uint32_t)0x01 << itmask;
    975            
    976            if (usartreg == 0x01) /* The IT  is in CR1 register */
    977            {
    978              itmask &= USARTx->CR1;
    979            }
    980            else if (usartreg == 0x02) /* The IT  is in CR2 register */
    981            {
    982              itmask &= USARTx->CR2;
    983            }
    984            else /* The IT  is in CR3 register */
    985            {
    986              itmask &= USARTx->CR3;
    987            }
    988            
    989            bitpos = USART_IT >> 0x08;
    990            bitpos = (uint32_t)0x01 << bitpos;
    991            bitpos &= USARTx->SR;
    992            if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
    993            {
    994              bitstatus = SET;
    995            }
    996            else
    997            {
    998              bitstatus = RESET;
    999            }
   1000            
   1001            return bitstatus;  
   1002          }
   1003          
   1004          /**
   1005            * @brief  Clears the USARTx's interrupt pending bits.
   1006            * @param  USARTx: Select the USART or the UART peripheral. 
   1007            *   This parameter can be one of the following values:
   1008            *   USART1, USART2, USART3, UART4 or UART5.
   1009            * @param  USART_IT: specifies the interrupt pending bit to clear.
   1010            *   This parameter can be one of the following values:
   1011            *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
   1012            *     @arg USART_IT_LBD:  LIN Break detection interrupt
   1013            *     @arg USART_IT_TC:   Transmission complete interrupt. 
   1014            *     @arg USART_IT_RXNE: Receive Data register not empty interrupt.
   1015            *   
   1016            * @note
   1017            *   - PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
   1018            *     error) and IDLE (Idle line detected) pending bits are cleared by 
   1019            *     software sequence: a read operation to USART_SR register 
   1020            *     (USART_GetITStatus()) followed by a read operation to USART_DR register 
   1021            *     (USART_ReceiveData()).
   1022            *   - RXNE pending bit can be also cleared by a read to the USART_DR register 
   1023            *     (USART_ReceiveData()).
   1024            *   - TC pending bit can be also cleared by software sequence: a read 
   1025            *     operation to USART_SR register (USART_GetITStatus()) followed by a write 
   1026            *     operation to USART_DR register (USART_SendData()).
   1027            *   - TXE pending bit is cleared only by a write to the USART_DR register 
   1028            *     (USART_SendData()).
   1029            * @retval None
   1030            */
   1031          void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
   1032          {
   1033            uint16_t bitpos = 0x00, itmask = 0x00;
   1034            /* Check the parameters */
   1035            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1036            assert_param(IS_USART_CLEAR_IT(USART_IT));
   1037            /* The CTS interrupt is not available for UART4 and UART5 */
   1038            if (USART_IT == USART_IT_CTS)
   1039            {
   1040              assert_param(IS_USART_123_PERIPH(USARTx));
   1041            }   
   1042            
   1043            bitpos = USART_IT >> 0x08;
   1044            itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
   1045            USARTx->SR = (uint16_t)~itmask;
   1046          }
   1047          /**
   1048            * @}
   1049            */
   1050          
   1051          /**
   1052            * @}
   1053            */
   1054          
   1055          /**
   1056            * @}
   1057            */
   1058          
   1059          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   USART_ClearFlag
      12   USART_ClearITPendingBit
       8   USART_ClockInit
       0   USART_ClockStructInit
       0   USART_Cmd
       0   USART_DMACmd
       8   USART_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       0   USART_GetFlagStatus
      16   USART_GetITStatus
       0   USART_HalfDuplexCmd
      24   USART_ITConfig
      64   USART_Init
        64   -> RCC_GetClocksFreq
       0   USART_IrDACmd
       0   USART_IrDAConfig
       0   USART_LINBreakDetectLengthConfig
       0   USART_LINCmd
       0   USART_OneBitMethodCmd
       0   USART_OverSampling8Cmd
       0   USART_ReceiveData
       0   USART_ReceiverWakeUpCmd
       0   USART_SendBreak
       0   USART_SendData
       0   USART_SetAddress
       0   USART_SetGuardTime
       0   USART_SetPrescaler
       0   USART_SmartCardCmd
       0   USART_SmartCardNACKCmd
       0   USART_StructInit
       0   USART_WakeUpConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
      16  USART_ClearFlag
      38  USART_ClearITPendingBit
      34  USART_ClockInit
      18  USART_ClockStructInit
      30  USART_Cmd
      24  USART_DMACmd
     144  USART_DeInit
      28  USART_GetFlagStatus
     106  USART_GetITStatus
      30  USART_HalfDuplexCmd
     112  USART_ITConfig
     214  USART_Init
      30  USART_IrDACmd
      18  USART_IrDAConfig
      18  USART_LINBreakDetectLengthConfig
      30  USART_LINCmd
      30  USART_OneBitMethodCmd
      28  USART_OverSampling8Cmd
       8  USART_ReceiveData
      30  USART_ReceiverWakeUpCmd
      10  USART_SendBreak
       8  USART_SendData
      22  USART_SetAddress
      22  USART_SetGuardTime
      20  USART_SetPrescaler
      30  USART_SmartCardCmd
      30  USART_SmartCardNACKCmd
      28  USART_StructInit
      18  USART_WakeUpConfig

 
 1'194 bytes in section .text
 
 1'194 bytes of CODE memory

Errors: none
Warnings: none
