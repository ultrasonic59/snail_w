###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         09/May/2021  15:42:36
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can\common\grbl\report.c
#    Command line =
#        -f C:\Users\vagol\AppData\Local\Temp\EWE851.tmp
#        (D:\proj\velograph\snail\stm32_snail\usb_can\common\grbl\report.c -D
#        VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -D MSTEP_BRD -D USE_USB_OTG_FS
#        -lcN D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\.\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\dbg\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\core\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\drv\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\hdlc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\cdc\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\List\report.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\Obj\report.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\usb_can\common\grbl\report.c
      1          /*
      2            report.c - reporting and messaging methods
      3            Part of Grbl
      4          
      5            Copyright (c) 2012-2016 Sungeun K. Jeon for Gnea Research LLC
      6          
      7            Grbl is free software: you can redistribute it and/or modify
      8            it under the terms of the GNU General Public License as published by
      9            the Free Software Foundation, either version 3 of the License, or
     10            (at your option) any later version.
     11          
     12            Grbl is distributed in the hope that it will be useful,
     13            but WITHOUT ANY WARRANTY; without even the implied warranty of
     14            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15            GNU General Public License for more details.
     16          
     17            You should have received a copy of the GNU General Public License
     18            along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
     19          */
     20          
     21          /*
     22            This file functions as the primary feedback interface for Grbl. Any outgoing data, such
     23            as the protocol status messages, feedback messages, and status reports, are stored here.
     24            For the most part, these functions primarily are called from protocol.c methods. If a
     25            different style feedback is desired (i.e. JSON), then a user can change these following
     26            methods to accomodate their needs.
     27          */
     28          
     29          #include "grbl.h"
     30          
     31          
     32          // Internal report utilities to reduce flash with repetitive tasks turned into functions.
     33          void report_util_setting_prefix(uint8_t n) { serial_write('$'); print_uint8_base10(n); serial_write('='); }
     34          static void report_util_line_feed() { printPgmString(PSTR("\r\n")); }
     35          static void report_util_feedback_line_feed() { serial_write(']'); report_util_line_feed(); }
     36          static void report_util_gcode_modes_G() { printPgmString(PSTR(" G")); }
     37          static void report_util_gcode_modes_M() { printPgmString(PSTR(" M")); }
     38          // static void report_util_comment_line_feed() { serial_write(')'); report_util_line_feed(); }
     39          static void report_util_axis_values(float *axis_value) {
     40            uint8_t idx;
     41            for (idx=0; idx<N_AXIS; idx++) {
     42              printFloat_CoordValue(axis_value[idx]);
     43              if (idx < (N_AXIS-1)) { serial_write(','); }
     44            }
     45          }
     46          
     47          /*
     48          static void report_util_setting_string(uint8_t n) {
     49            serial_write(' ');
     50            serial_write('(');
     51            switch(n) {
     52              case 0: printPgmString(PSTR("stp pulse")); break;
     53              case 1: printPgmString(PSTR("idl delay")); break; 
     54              case 2: printPgmString(PSTR("stp inv")); break;
     55              case 3: printPgmString(PSTR("dir inv")); break;
     56              case 4: printPgmString(PSTR("stp en inv")); break;
     57              case 5: printPgmString(PSTR("lim inv")); break;
     58              case 6: printPgmString(PSTR("prb inv")); break;
     59              case 10: printPgmString(PSTR("rpt")); break;
     60              case 11: printPgmString(PSTR("jnc dev")); break;
     61              case 12: printPgmString(PSTR("arc tol")); break;
     62              case 13: printPgmString(PSTR("rpt inch")); break;
     63              case 20: printPgmString(PSTR("sft lim")); break;
     64              case 21: printPgmString(PSTR("hrd lim")); break;
     65              case 22: printPgmString(PSTR("hm cyc")); break;
     66              case 23: printPgmString(PSTR("hm dir inv")); break;
     67              case 24: printPgmString(PSTR("hm feed")); break;
     68              case 25: printPgmString(PSTR("hm seek")); break;
     69              case 26: printPgmString(PSTR("hm delay")); break;
     70              case 27: printPgmString(PSTR("hm pulloff")); break;
     71              case 30: printPgmString(PSTR("rpm max")); break;
     72              case 31: printPgmString(PSTR("rpm min")); break;
     73              case 32: printPgmString(PSTR("laser")); break;
     74              default:
     75                n -= AXIS_SETTINGS_START_VAL;
     76                uint8_t idx = 0;
     77                while (n >= AXIS_SETTINGS_INCREMENT) {
     78                  n -= AXIS_SETTINGS_INCREMENT;
     79                  idx++;
     80                }
     81                serial_write(n+'x');
     82                switch (idx) {
     83                  case 0: printPgmString(PSTR(":stp/mm")); break;
     84                  case 1: printPgmString(PSTR(":mm/min")); break;
     85                  case 2: printPgmString(PSTR(":mm/s^2")); break;
     86                  case 3: printPgmString(PSTR(":mm max")); break;
     87                }
     88                break;
     89            }
     90            report_util_comment_line_feed();
     91          }
     92          */
     93          
     94          static void report_util_uint8_setting(uint8_t n, int val) {
     95            report_util_setting_prefix(n);
     96            print_uint8_base10(val);
     97            report_util_line_feed(); // report_util_setting_string(n); 
     98          }
     99          static void report_util_float_setting(uint8_t n, float val, uint8_t n_decimal) {
    100            report_util_setting_prefix(n);
    101            printFloat(val, n_decimal);
    102            report_util_line_feed(); // report_util_setting_string(n);
    103          }
    104          
    105          // Handles the primary confirmation protocol response for streaming interfaces and human-feedback.
    106          // For every incoming line, this method responds with an 'ok' for a successful command or an
    107          // 'error:'  to indicate some error event with the line or some critical system error during
    108          // operation. Errors events can originate from the g-code parser, settings module, or asynchronously
    109          // from a critical error, such as a triggered hard limit. Interface should always monitor for these
    110          // responses.
    111          void report_status_message(uint8_t status_code)
    112          {
    113            switch(status_code) {
    114              case STATUS_OK: // STATUS_OK
    115                printPgmString(PSTR("ok\r\n")); break;
    116              default:
    117                printPgmString(PSTR("error:"));
    118                print_uint8_base10(status_code);
    119                report_util_line_feed();
    120            }
    121          }
    122          
    123          // Prints alarm messages.
    124          void report_alarm_message(uint8_t alarm_code)
    125          {
    126            printPgmString(PSTR("ALARM:"));
    127            print_uint8_base10(alarm_code);
    128            report_util_line_feed();
    129            delay__ms(500); // Force delay to ensure message clears serial write buffer.
    130          }
    131          
    132          // Prints feedback messages. This serves as a centralized method to provide additional
    133          // user feedback for things that are not of the status/alarm message protocol. These are
    134          // messages such as setup warnings, switch toggling, and how to exit alarms.
    135          // NOTE: For interfaces, messages are always placed within brackets. And if silent mode
    136          // is installed, the message number codes are less than zero.
    137          void report_feedback_message(uint8_t message_code)
    138          {
    139            printPgmString(PSTR("[MSG:"));
    140            switch(message_code) {
    141              case MESSAGE_CRITICAL_EVENT:
    142                printPgmString(PSTR("Reset to continue")); break;
    143              case MESSAGE_ALARM_LOCK:
    144                printPgmString(PSTR("'$H'|'$X' to unlock")); break;
    145              case MESSAGE_ALARM_UNLOCK:
    146                printPgmString(PSTR("Caution: Unlocked")); break;
    147              case MESSAGE_ENABLED:
    148                printPgmString(PSTR("Enabled")); break;
    149              case MESSAGE_DISABLED:
    150                printPgmString(PSTR("Disabled")); break;
    151              case MESSAGE_SAFETY_DOOR_AJAR:
    152                printPgmString(PSTR("Check Door")); break;
    153              case MESSAGE_CHECK_LIMITS:
    154                printPgmString(PSTR("Check Limits")); break;
    155              case MESSAGE_PROGRAM_END:
    156                printPgmString(PSTR("Pgm End")); break;
    157              case MESSAGE_RESTORE_DEFAULTS:
    158                printPgmString(PSTR("Restoring defaults")); break;
    159              case MESSAGE_SPINDLE_RESTORE:
    160                printPgmString(PSTR("Restoring spindle")); break;
    161              case MESSAGE_SLEEP_MODE:
    162                printPgmString(PSTR("Sleeping")); break;
    163            }
    164            report_util_feedback_line_feed();
    165          }
    166          
    167          
    168          // Welcome message
    169          void report_init_message()
    170          {
    171            printPgmString(PSTR("\r\nGrbl " GRBL_VERSION " ['$' for help]\r\n"));
    172          }
    173          
    174          // Grbl help message
    175          void report_grbl_help() {
    176            printPgmString(PSTR("[HLP:$$ $# $G $I $N $x=val $Nx=line $J=line $SLP $C $X $H ~ ! ? ctrl-x]\r\n"));    
    177          }
    178          
    179          
    180          // Grbl global settings print out.
    181          // NOTE: The numbering scheme here must correlate to storing in settings.c
    182          void report_grbl_settings() {
    183            // Print Grbl settings.
    184            report_util_uint8_setting(0,settings.pulse_microseconds);
    185            report_util_uint8_setting(1,settings.stepper_idle_lock_time);
    186            report_util_uint8_setting(2,settings.step_invert_mask);
    187            report_util_uint8_setting(3,settings.dir_invert_mask);
    188            report_util_uint8_setting(4,bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE));
    189            report_util_uint8_setting(5,bit_istrue(settings.flags,BITFLAG_INVERT_LIMIT_PINS));
    190            report_util_uint8_setting(6,bit_istrue(settings.flags,BITFLAG_INVERT_PROBE_PIN));
    191            report_util_uint8_setting(10,settings.status_report_mask);
    192            report_util_float_setting(11,settings.junction_deviation,N_DECIMAL_SETTINGVALUE);
    193            report_util_float_setting(12,settings.arc_tolerance,N_DECIMAL_SETTINGVALUE);
    194            report_util_uint8_setting(13,bit_istrue(settings.flags,BITFLAG_REPORT_INCHES));
    195            report_util_uint8_setting(20,bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE));
    196            report_util_uint8_setting(21,bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE));
    197            report_util_uint8_setting(22,bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE));
    198            report_util_uint8_setting(23,settings.homing_dir_mask);
    199            report_util_float_setting(24,settings.homing_feed_rate,N_DECIMAL_SETTINGVALUE);
    200            report_util_float_setting(25,settings.homing_seek_rate,N_DECIMAL_SETTINGVALUE);
    201            report_util_uint8_setting(26,settings.homing_debounce_delay);
    202            report_util_float_setting(27,settings.homing_pulloff,N_DECIMAL_SETTINGVALUE);
    203            report_util_float_setting(30,settings.rpm_max,N_DECIMAL_RPMVALUE);
    204            report_util_float_setting(31,settings.rpm_min,N_DECIMAL_RPMVALUE);
    205            #ifdef VARIABLE_SPINDLE
    206              report_util_uint8_setting(32,bit_istrue(settings.flags,BITFLAG_LASER_MODE));
    207            #else
    208              report_util_uint8_setting(32,0);
    209            #endif
    210            // Print axis settings
    211            uint8_t idx, set_idx;
    212            uint8_t val = AXIS_SETTINGS_START_VAL;
    213            for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    214              for (idx=0; idx<N_AXIS; idx++) {
    215                switch (set_idx) {
    216                  case 0: report_util_float_setting(val+idx,settings.steps_per_mm[idx],N_DECIMAL_SETTINGVALUE); break;
    217                  case 1: report_util_float_setting(val+idx,settings.max_rate[idx],N_DECIMAL_SETTINGVALUE); break;
    218                  case 2: report_util_float_setting(val+idx,settings.acceleration[idx]/(60*60),N_DECIMAL_SETTINGVALUE); break;
    219                  case 3: report_util_float_setting(val+idx,-settings.max_travel[idx],N_DECIMAL_SETTINGVALUE); break;
    220                }
    221              }
    222              val += AXIS_SETTINGS_INCREMENT;
    223            }
    224          }
    225          
    226          
    227          // Prints current probe parameters. Upon a probe command, these parameters are updated upon a
    228          // successful probe or upon a failed probe with the G38.3 without errors command (if supported).
    229          // These values are retained until Grbl is power-cycled, whereby they will be re-zeroed.
    230          void report_probe_parameters()
    231          {
    232            // Report in terms of machine position.
    233            printPgmString(PSTR("[PRB:"));
    234            float print_position[N_AXIS];
    235            system_convert_array_steps_to_mpos(print_position,sys_probe_position);
    236            report_util_axis_values(print_position);
    237            serial_write(':');
    238            print_uint8_base10(sys.probe_succeeded);
    239            report_util_feedback_line_feed();
    240          }
    241          
    242          
    243          // Prints Grbl NGC parameters (coordinate offsets, probing)
    244          void report_ngc_parameters()
    245          {
    246            float coord_data[N_AXIS];
    247            uint8_t coord_select;
    248            for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) {
    249              if (!(settings_read_coord_data(coord_select,coord_data))) {
    250                report_status_message(STATUS_SETTING_READ_FAIL);
    251                return;
    252              }
    253              printPgmString(PSTR("[G"));
    254              switch (coord_select) {
    255                case 6: printPgmString(PSTR("28")); break;
    256                case 7: printPgmString(PSTR("30")); break;
    257                default: print_uint8_base10(coord_select+54); break; // G54-G59
    258              }
    259              serial_write(':');
    260              report_util_axis_values(coord_data);
    261              report_util_feedback_line_feed();
    262            }
    263            printPgmString(PSTR("[G92:")); // Print G92,G92.1 which are not persistent in memory
    264            report_util_axis_values(gc_state.coord_offset);
    265            report_util_feedback_line_feed();
    266            printPgmString(PSTR("[TLO:")); // Print tool length offset value
    267            printFloat_CoordValue(gc_state.tool_length_offset);
    268            report_util_feedback_line_feed();
    269            report_probe_parameters(); // Print probe parameters. Not persistent in memory.
    270          }
    271          
    272          
    273          // Print current gcode parser mode state
    274          void report_gcode_modes()
    275          {
    276            printPgmString(PSTR("[GC:G"));
    277            if (gc_state.modal.motion >= MOTION_MODE_PROBE_TOWARD) {
    278              printPgmString(PSTR("38."));
    279              print_uint8_base10(gc_state.modal.motion - (MOTION_MODE_PROBE_TOWARD-2));
    280            } else {
    281              print_uint8_base10(gc_state.modal.motion);
    282            }
    283          
    284            report_util_gcode_modes_G();
    285            print_uint8_base10(gc_state.modal.coord_select+54);
    286          
    287            report_util_gcode_modes_G();
    288            print_uint8_base10(gc_state.modal.plane_select+17);
    289          
    290            report_util_gcode_modes_G();
    291            print_uint8_base10(21-gc_state.modal.units);
    292          
    293            report_util_gcode_modes_G();
    294            print_uint8_base10(gc_state.modal.distance+90);
    295          
    296            report_util_gcode_modes_G();
    297            print_uint8_base10(94-gc_state.modal.feed_rate);
    298          
    299            if (gc_state.modal.program_flow) {
    300              report_util_gcode_modes_M();
    301              switch (gc_state.modal.program_flow) {
    302                case PROGRAM_FLOW_PAUSED : serial_write('0'); break;
    303                // case PROGRAM_FLOW_OPTIONAL_STOP : serial_write('1'); break; // M1 is ignored and not supported.
    304                case PROGRAM_FLOW_COMPLETED_M2 : 
    305                case PROGRAM_FLOW_COMPLETED_M30 : 
    306                  print_uint8_base10(gc_state.modal.program_flow);
    307                  break;
    308              }
    309            }
    310          
    311            report_util_gcode_modes_M();
    312            switch (gc_state.modal.spindle) {
    313              case SPINDLE_ENABLE_CW : serial_write('3'); break;
    314              case SPINDLE_ENABLE_CCW : serial_write('4'); break;
    315              case SPINDLE_DISABLE : serial_write('5'); break;
    316            }
    317          
    318            report_util_gcode_modes_M();
    319            #ifdef ENABLE_M7
    320              if (gc_state.modal.coolant) { // Note: Multiple coolant states may be active at the same time.
    321                if (gc_state.modal.coolant & PL_COND_FLAG_COOLANT_MIST) { report_util_gcode_modes_M(); serial_write('7'); }
    322                if (gc_state.modal.coolant & PL_COND_FLAG_COOLANT_FLOOD) { report_util_gcode_modes_M(); serial_write('8'); }
    323              } else { report_util_gcode_modes_M(); serial_write('9'); }
    324            #else
    325              report_util_gcode_modes_M();
    326              if (gc_state.modal.coolant) { serial_write('8'); }
    327              else { serial_write('9'); }
    328            #endif
    329          
    330          	#ifdef ENABLE_PARKING_OVERRIDE_CONTROL
    331          		if (sys.override_ctrl == OVERRIDE_PARKING_MOTION) {
    332          			report_util_gcode_modes_M();
    333          			print_uint8_base10(56);
    334          		}
    335          	#endif
    336          
    337            printPgmString(PSTR(" T"));
    338            print_uint8_base10(gc_state.tool);
    339          
    340            printPgmString(PSTR(" F"));
    341            printFloat_RateValue(gc_state.feed_rate);
    342          
    343            #ifdef VARIABLE_SPINDLE
    344              printPgmString(PSTR(" S"));
    345              printFloat(gc_state.spindle_speed,N_DECIMAL_RPMVALUE);
    346            #endif
    347          
    348            report_util_feedback_line_feed();
    349          }
    350          
    351          // Prints specified startup line
    352          void report_startup_line(uint8_t n, char *line)
    353          {
    354            printPgmString(PSTR("$N"));
    355            print_uint8_base10(n);
    356            serial_write('=');
    357            printString(line);
    358            report_util_line_feed();
    359          }
    360          
    361          void report_execute_startup_message(char *line, uint8_t status_code)
    362          {
    363            serial_write('>');
    364            printString(line);
    365            serial_write(':');
    366            report_status_message(status_code);
    367          }
    368          
    369          // Prints build info line
    370          void report_build_info(char *line)
    371          {
    372            printPgmString(PSTR("[VER:" GRBL_VERSION "." GRBL_VERSION_BUILD ":"));
    373            printString(line);
    374            report_util_feedback_line_feed();
    375            printPgmString(PSTR("[OPT:")); // Generate compile-time build option list
    376            #ifdef VARIABLE_SPINDLE
    377              serial_write('V');
    378            #endif
    379            #ifdef USE_LINE_NUMBERS
    380              serial_write('N');
    381            #endif
    382            #ifdef ENABLE_M7
    383              serial_write('M');
    384            #endif
    385            #ifdef COREXY
    386              serial_write('C');
    387            #endif
    388            #ifdef PARKING_ENABLE
    389              serial_write('P');
    390            #endif
    391            #ifdef HOMING_FORCE_SET_ORIGIN
    392              serial_write('Z');
    393            #endif
    394            #ifdef HOMING_SINGLE_AXIS_COMMANDS
    395              serial_write('H');
    396            #endif
    397            #ifdef LIMITS_TWO_SWITCHES_ON_AXES
    398              serial_write('T');
    399            #endif
    400            #ifdef ALLOW_FEED_OVERRIDE_DURING_PROBE_CYCLES
    401              serial_write('A');
    402            #endif
    403          	#ifdef USE_SPINDLE_DIR_AS_ENABLE_PIN
    404          		serial_write('D');
    405          	#endif
    406          	#ifdef SPINDLE_ENABLE_OFF_WITH_ZERO_SPEED
    407          		serial_write('0');
    408          	#endif
    409          	#ifdef ENABLE_SOFTWARE_DEBOUNCE
    410          		serial_write('S');
    411          	#endif
    412          	#ifdef ENABLE_PARKING_OVERRIDE_CONTROL
    413          		serial_write('R');
    414          	#endif
    415          	#ifndef ENABLE_RESTORE_EEPROM_WIPE_ALL // NOTE: Shown when disabled.
    416              serial_write('*');
    417            #endif
    418            #ifndef ENABLE_RESTORE_EEPROM_DEFAULT_SETTINGS // NOTE: Shown when disabled.
    419              serial_write('$');
    420            #endif
    421            #ifndef ENABLE_RESTORE_EEPROM_CLEAR_PARAMETERS // NOTE: Shown when disabled.
    422              serial_write('#');
    423            #endif
    424            #ifndef ENABLE_BUILD_INFO_WRITE_COMMAND // NOTE: Shown when disabled.
    425              serial_write('I');
    426            #endif
    427            #ifndef FORCE_BUFFER_SYNC_DURING_EEPROM_WRITE // NOTE: Shown when disabled.
    428              serial_write('E');
    429            #endif
    430            #ifndef FORCE_BUFFER_SYNC_DURING_WCO_CHANGE // NOTE: Shown when disabled.
    431              serial_write('W');
    432            #endif
    433          	#ifndef HOMING_INIT_LOCK
    434          		serial_write('L');
    435          	#endif
    436          
    437            // NOTE: Compiled values, like override increments/max/min values, may be added at some point later.
    438          	serial_write(',');
    439          	print_uint8_base10(BLOCK_BUFFER_SIZE - 1);
    440          	serial_write(',');
    441          	print_uint8_base10(RX_BUFFER_SIZE);
    442          
    443          	report_util_feedback_line_feed();
    444          }
    445          
    446          
    447          // Prints the character string line Grbl has received from the user, which has been pre-parsed,
    448          // and has been sent into protocol_execute_line() routine to be executed by Grbl.
    449          void report_echo_line_received(char *line)
    450          {
    451            printPgmString(PSTR("[echo: ")); printString(line);
    452            report_util_feedback_line_feed();
    453          }
    454          
    455          
    456           // Prints real-time data. This function grabs a real-time snapshot of the stepper subprogram
    457           // and the actual location of the CNC machine. Users may change the following function to their
    458           // specific needs, but the desired real-time data report must be as short as possible. This is
    459           // requires as it minimizes the computational overhead and allows grbl to keep running smoothly,
    460           // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
    461          void report_realtime_status()
    462          {
    463            uint8_t idx;
    464            int32_t current_position[N_AXIS]; // Copy current state of the system position variable
    465            memcpy(current_position, sys_position, sizeof(sys_position));
    466            float print_position[N_AXIS];
    467            system_convert_array_steps_to_mpos(print_position, current_position);
    468          
    469            // Report current machine state and sub-states
    470            serial_write('<');
    471            switch (sys.state) {
    472            case STATE_IDLE: printPgmString(PSTR("Idle")); break;
    473            case STATE_CYCLE: printPgmString(PSTR("Run")); break;
    474            case STATE_HOLD:
    475              if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
    476                printPgmString(PSTR("Hold:"));
    477                if (sys.suspend & SUSPEND_HOLD_COMPLETE) { serial_write('0'); } // Ready to resume
    478                else { serial_write('1'); } // Actively holding
    479                break;
    480              } // Continues to print jog state during jog cancel.
    481            case STATE_JOG: printPgmString(PSTR("Jog")); break;
    482            case STATE_HOMING: printPgmString(PSTR("Home")); break;
    483            case STATE_ALARM: printPgmString(PSTR("Alarm")); break;
    484            case STATE_CHECK_MODE: printPgmString(PSTR("Check")); break;
    485            case STATE_SAFETY_DOOR:
    486              printPgmString(PSTR("Door:"));
    487              if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
    488                serial_write('3'); // Restoring
    489              }
    490              else {
    491                if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
    492                  if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) {
    493                    serial_write('1'); // Door ajar
    494                  }
    495                  else {
    496                    serial_write('0');
    497                  } // Door closed and ready to resume
    498                }
    499                else {
    500                  serial_write('2'); // Retracting
    501                }
    502              }
    503              break;
    504            case STATE_SLEEP: printPgmString(PSTR("Sleep")); break;
    505            }
    506          
    507            float wco[N_AXIS];
    508            if (bit_isfalse(settings.status_report_mask, BITFLAG_RT_STATUS_POSITION_TYPE) ||
    509              (sys.report_wco_counter == 0)) {
    510              for (idx = 0; idx< N_AXIS; idx++) {
    511                // Apply work coordinate offsets and tool length offset to current position.
    512                wco[idx] = gc_state.coord_system[idx] + gc_state.coord_offset[idx];
    513                if (idx == TOOL_LENGTH_OFFSET_AXIS) { wco[idx] += gc_state.tool_length_offset; }
    514                if (bit_isfalse(settings.status_report_mask, BITFLAG_RT_STATUS_POSITION_TYPE)) {
    515                  print_position[idx] -= wco[idx];
    516                }
    517              }
    518            }
    519          
    520            // Report machine position
    521            if (bit_istrue(settings.status_report_mask, BITFLAG_RT_STATUS_POSITION_TYPE)) {
    522              printPgmString(PSTR("|MPos:"));
    523            }
    524            else {
    525              printPgmString(PSTR("|WPos:"));
    526            }
    527            report_util_axis_values(print_position);
    528          
    529            // Returns planner and serial read buffer states.
    530          #ifdef REPORT_FIELD_BUFFER_STATE
    531            if (bit_istrue(settings.status_report_mask, BITFLAG_RT_STATUS_BUFFER_STATE)) {
    532              printPgmString(PSTR("|Bf:"));
    533              print_uint8_base10(plan_get_block_buffer_available());
    534              serial_write(',');
    535              print_uint8_base10(serial_get_rx_buffer_available());
    536            }
    537          #endif
    538          
    539          #ifdef USE_LINE_NUMBERS
    540          #ifdef REPORT_FIELD_LINE_NUMBERS
    541            // Report current line number
    542            plan_block_t * cur_block = plan_get_current_block();
    543            if (cur_block != NULL) {
    544              uint32_t ln = cur_block->line_number;
    545              if (ln > 0) {
    546                printPgmString(PSTR("|Ln:"));
    547                printInteger(ln);
    548              }
    549            }
    550          #endif
    551          #endif
    552          
    553            // Report realtime feed speed
    554          #ifdef REPORT_FIELD_CURRENT_FEED_SPEED
    555          #ifdef VARIABLE_SPINDLE
    556            printPgmString(PSTR("|FS:"));
    557            printFloat_RateValue(st_get_realtime_rate());
    558            serial_write(',');
    559            printFloat(sys.spindle_speed, N_DECIMAL_RPMVALUE);
    560          #else
    561            printPgmString(PSTR("|F:"));
    562            printFloat_RateValue(st_get_realtime_rate());
    563          #endif      
    564          #endif
    565          
    566          #ifdef REPORT_FIELD_PIN_STATE
    567            uint8_t lim_pin_state = limits_get_state();
    568            uint8_t ctrl_pin_state = system_control_get_state();
    569            uint8_t prb_pin_state = probe_get_state();
    570            if (lim_pin_state | ctrl_pin_state | prb_pin_state) {
    571              printPgmString(PSTR("|Pn:"));
    572              if (prb_pin_state) { serial_write('P'); }
    573              if (lim_pin_state) {
    574                if (bit_istrue(lim_pin_state, bit(X_AXIS))) { serial_write('X'); }
    575                if (bit_istrue(lim_pin_state, bit(Y_AXIS))) { serial_write('Y'); }
    576                if (bit_istrue(lim_pin_state, bit(Z_AXIS))) { serial_write('Z'); }
    577              }
    578              if (ctrl_pin_state) {
    579          #ifdef ENABLE_SAFETY_DOOR_INPUT_PIN
    580                if (bit_istrue(ctrl_pin_state, CONTROL_PIN_INDEX_SAFETY_DOOR)) { serial_write('D'); }
    581          #endif
    582                if (bit_istrue(ctrl_pin_state, CONTROL_PIN_INDEX_RESET)) { serial_write('R'); }
    583                if (bit_istrue(ctrl_pin_state, CONTROL_PIN_INDEX_FEED_HOLD)) { serial_write('H'); }
    584                if (bit_istrue(ctrl_pin_state, CONTROL_PIN_INDEX_CYCLE_START)) { serial_write('S'); }
    585              }
    586            }
    587          #endif
    588          
    589          #ifdef REPORT_FIELD_WORK_COORD_OFFSET
    590            if (sys.report_wco_counter > 0) { sys.report_wco_counter--; }
    591            else {
    592              if (sys.state & (STATE_HOMING | STATE_CYCLE | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)) {
    593                sys.report_wco_counter = (REPORT_WCO_REFRESH_BUSY_COUNT - 1); // Reset counter for slow refresh
    594              }
    595              else { sys.report_wco_counter = (REPORT_WCO_REFRESH_IDLE_COUNT - 1); }
    596              if (sys.report_ovr_counter == 0) { sys.report_ovr_counter = 1; } // Set override on next report.
    597              printPgmString(PSTR("|WCO:"));
    598              report_util_axis_values(wco);
    599            }
    600          #endif
    601          
    602            #ifdef REPORT_FIELD_OVERRIDES
    603              if (sys.report_ovr_counter > 0) { sys.report_ovr_counter--; }
    604              else {
    605                if (sys.state & (STATE_HOMING | STATE_CYCLE | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)) {
    606                  sys.report_ovr_counter = (REPORT_OVR_REFRESH_BUSY_COUNT - 1); // Reset counter for slow refresh
    607                }
    608                else { sys.report_ovr_counter = (REPORT_OVR_REFRESH_IDLE_COUNT - 1); }
    609                printPgmString(PSTR("|Ov:"));
    610                print_uint8_base10(sys.f_override);
    611                serial_write(',');
    612                print_uint8_base10(sys.r_override);
    613                serial_write(',');
    614                print_uint8_base10(sys.spindle_speed_ovr);
    615          
    616                uint8_t sp_state = spindle_get_state();
    617                uint8_t cl_state = coolant_get_state();
    618                if (sp_state || cl_state) {
    619                  printPgmString(PSTR("|A:"));
    620                  if (sp_state) { // != SPINDLE_STATE_DISABLE
    621                    #ifdef VARIABLE_SPINDLE 
    622                      #ifdef USE_SPINDLE_DIR_AS_ENABLE_PIN
    623                        serial_write('S'); // CW
    624                      #else
    625                        if (sp_state == SPINDLE_STATE_CW) { serial_write('S'); } // CW
    626                        else { serial_write('C'); } // CCW
    627                      #endif
    628                    #else
    629                      if (sp_state & SPINDLE_STATE_CW) { serial_write('S'); } // CW
    630                      else { serial_write('C'); } // CCW
    631                    #endif
    632                  }
    633                  if (cl_state & COOLANT_STATE_FLOOD) { serial_write('F'); }
    634                  #ifdef ENABLE_M7
    635                    if (cl_state & COOLANT_STATE_MIST) { serial_write('M'); }
    636                  #endif
    637                }
    638              }
    639            #endif
    640          
    641            serial_write('>');
    642            report_util_line_feed();
    643          }
    644          
    645          
    646          #ifdef DEBUG
    647            void report_realtime_debug()
    648            {
    649          
    650            }
    651          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   report_alarm_message
         8   -> delay__ms
         8   -> printString
         8   -> print_uint8_base10
         8   -> report_util_line_feed
       8   report_build_info
         8   -> printString
         8   -> print_uint8_base10
         8   -> report_util_feedback_line_feed
         8   -> serial_write
       8   report_echo_line_received
         8   -> printString
         8   -> report_util_feedback_line_feed
      16   report_execute_startup_message
        16   -> printString
        16   -> report_status_message
        16   -> serial_write
       8   report_feedback_message
         8   -> printString
         8   -> report_util_feedback_line_feed
       8   report_gcode_modes
         8   -> printFloat
         8   -> printFloat_RateValue
         8   -> printString
         8   -> print_uint8_base10
         8   -> report_util_feedback_line_feed
         8   -> report_util_gcode_modes_G
         8   -> report_util_gcode_modes_M
         8   -> serial_write
       8   report_grbl_help
         8   -> printString
      24   report_grbl_settings
        24   -> __aeabi_fdiv
        24   -> report_util_float_setting
        24   -> report_util_uint8_setting
       8   report_init_message
         8   -> printString
      24   report_ngc_parameters
        24   -> printFloat_CoordValue
        24   -> printString
        24   -> print_uint8_base10
        24   -> report_probe_parameters
        24   -> report_status_message
        24   -> report_util_axis_values
        24   -> report_util_feedback_line_feed
        24   -> serial_write
        24   -> settings_read_coord_data
      16   report_probe_parameters
        16   -> printString
        16   -> print_uint8_base10
        16   -> report_util_axis_values
        16   -> report_util_feedback_line_feed
        16   -> serial_write
        16   -> system_convert_array_steps_to_mpos
      64   report_realtime_status
        64   -> __aeabi_fadd
        64   -> __aeabi_fsub
        64   -> __aeabi_memcpy
        64   -> coolant_get_state
        64   -> limits_get_state
        64   -> plan_get_block_buffer_available
        64   -> printFloat
        64   -> printFloat_RateValue
        64   -> printString
        64   -> print_uint8_base10
        64   -> probe_get_state
        64   -> report_util_axis_values
        64   -> report_util_line_feed
        64   -> serial_get_rx_buffer_available
        64   -> serial_write
        64   -> spindle_get_state
        64   -> st_get_realtime_rate
        64   -> system_control_get_state
        64   -> system_convert_array_steps_to_mpos
      16   report_startup_line
        16   -> printString
        16   -> print_uint8_base10
        16   -> report_util_line_feed
        16   -> serial_write
       8   report_status_message
         8   -> printString
         8   -> print_uint8_base10
         8   -> report_util_line_feed
      16   report_util_axis_values
        16   -> printFloat_CoordValue
        16   -> serial_write
       8   report_util_feedback_line_feed
         8   -> report_util_line_feed
         8   -> serial_write
      16   report_util_float_setting
        16   -> printFloat
        16   -> report_util_line_feed
        16   -> report_util_setting_prefix
       8   report_util_gcode_modes_G
         8   -> printString
       8   report_util_gcode_modes_M
         8   -> printString
       8   report_util_line_feed
         8   -> printString
       8   report_util_setting_prefix
         8   -> print_uint8_base10
         8   -> serial_write
      16   report_util_uint8_setting
        16   -> print_uint8_base10
        16   -> report_util_line_feed
        16   -> report_util_setting_prefix


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_18
       4  ??DataTable16_19
       4  ??DataTable16_2
       4  ??DataTable16_20
       4  ??DataTable16_21
       4  ??DataTable16_22
       4  ??DataTable16_23
       4  ??DataTable16_24
       4  ??DataTable16_25
       4  ??DataTable16_26
       4  ??DataTable16_27
       4  ??DataTable16_28
       4  ??DataTable16_29
       4  ??DataTable16_3
       4  ??DataTable16_30
       4  ??DataTable16_31
       4  ??DataTable16_32
       4  ??DataTable16_33
       4  ??DataTable16_34
       4  ??DataTable16_35
       4  ??DataTable16_36
       4  ??DataTable16_37
       4  ??DataTable16_38
       4  ??DataTable16_39
       4  ??DataTable16_4
       4  ??DataTable16_40
       4  ??DataTable16_41
       4  ??DataTable16_42
       4  ??DataTable16_43
       4  ??DataTable16_44
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ?_0
       4  ?_1
       8  ?_10
      12  ?_11
      12  ?_12
      16  ?_13
       8  ?_14
      20  ?_15
      20  ?_16
      12  ?_17
      32  ?_18
      76  ?_19
       4  ?_2
       8  ?_20
       4  ?_21
       4  ?_22
       4  ?_23
       8  ?_24
       8  ?_25
       8  ?_26
       4  ?_27
       4  ?_28
       4  ?_29
       8  ?_3
       4  ?_30
       4  ?_31
      20  ?_32
       8  ?_33
       8  ?_34
       8  ?_35
       4  ?_36
       8  ?_37
       4  ?_38
       8  ?_39
       8  ?_4
       8  ?_40
       8  ?_41
       8  ?_42
       8  ?_43
       8  ?_44
       8  ?_45
       8  ?_46
       8  ?_47
       8  ?_48
       8  ?_49
       8  ?_5
       8  ?_50
       4  ?_51
       8  ?_6
      20  ?_7
      20  ?_8
      20  ?_9
      34  report_alarm_message
      66  report_build_info
      24  report_echo_line_received
      34  report_execute_startup_message
     168  report_feedback_message
     272  report_gcode_modes
      12  report_grbl_help
     446  report_grbl_settings
      12  report_init_message
     148  report_ngc_parameters
      48  report_probe_parameters
     828  report_realtime_status
      38  report_startup_line
      44  report_status_message
      46  report_util_axis_values
      14  report_util_feedback_line_feed
      32  report_util_float_setting
      10  report_util_gcode_modes_G
      10  report_util_gcode_modes_M
      10  report_util_line_feed
      26  report_util_setting_prefix
      28  report_util_uint8_setting

 
   544 bytes in section .rodata
 2'574 bytes in section .text
 
 2'574 bytes of CODE  memory
   544 bytes of CONST memory

Errors: none
Warnings: none
