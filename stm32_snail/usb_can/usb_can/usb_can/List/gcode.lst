###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         09/May/2021  15:42:35
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can\common\grbl\gcode.c
#    Command line =
#        -f C:\Users\vagol\AppData\Local\Temp\EWE2A2.tmp
#        (D:\proj\velograph\snail\stm32_snail\usb_can\common\grbl\gcode.c -D
#        VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -D MSTEP_BRD -D USE_USB_OTG_FS
#        -lcN D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\.\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\dbg\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\core\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\drv\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\hdlc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\cdc\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\List\gcode.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\Obj\gcode.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\usb_can\common\grbl\gcode.c
      1          /*
      2            gcode.c - rs274/ngc parser.
      3            Part of Grbl
      4          
      5            Copyright (c) 2011-2016 Sungeun K. Jeon for Gnea Research LLC
      6            Copyright (c) 2009-2011 Simen Svale Skogsrud
      7          
      8            Grbl is free software: you can redistribute it and/or modify
      9            it under the terms of the GNU General Public License as published by
     10            the Free Software Foundation, either version 3 of the License, or
     11            (at your option) any later version.
     12          
     13            Grbl is distributed in the hope that it will be useful,
     14            but WITHOUT ANY WARRANTY; without even the implied warranty of
     15            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16            GNU General Public License for more details.
     17          
     18            You should have received a copy of the GNU General Public License
     19            along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
     20          */
     21          
     22          #include "grbl.h"
     23          
     24          // NOTE: Max line number is defined by the g-code standard to be 99999. It seems to be an
     25          // arbitrary value, and some GUIs may require more. So we increased it based on a max safe
     26          // value when converting a float (7.2 digit precision)s to an integer.
     27          #define MAX_LINE_NUMBER 10000000
     28          #define MAX_TOOL_NUMBER 255 // Limited by max unsigned 8-bit value
     29          
     30          #define AXIS_COMMAND_NONE 0
     31          #define AXIS_COMMAND_NON_MODAL 1
     32          #define AXIS_COMMAND_MOTION_MODE 2
     33          #define AXIS_COMMAND_TOOL_LENGTH_OFFSET 3 // *Undefined but required
     34          
     35          // Declare gc extern struct
     36          parser_state_t gc_state;
     37          parser_block_t gc_block;
     38          
     39          #define FAIL(status) return(status);
     40          
     41          
     42          void gc_init()
     43          {
     44            memset(&gc_state, 0, sizeof(parser_state_t));
     45          
     46            // Load default G54 coordinate system.
     47            if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) {
     48              report_status_message(STATUS_SETTING_READ_FAIL);
     49            }
     50          }
     51          
     52          
     53          // Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
     54          // limit pull-off routines.
     55          void gc_sync_position()
     56          {
     57            system_convert_array_steps_to_mpos(gc_state.position,sys_position);
     58          }
     59          
     60          
     61          // Executes one line of 0-terminated G-Code. The line is assumed to contain only uppercase
     62          // characters and signed floating point values (no whitespace). Comments and block delete
     63          // characters have been removed. In this function, all units and positions are converted and
     64          // exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine
     65          // coordinates, respectively.
     66          uint8_t gc_execute_line(char *line)
     67          {
     68            /* -------------------------------------------------------------------------------------
     69               STEP 1: Initialize parser block struct and copy current g-code state modes. The parser
     70               updates these modes and commands as the block line is parser and will only be used and
     71               executed after successful error-checking. The parser block struct also contains a block
     72               values struct, word tracking variables, and a non-modal commands tracker for the new
     73               block. This struct contains all of the necessary information to execute the block. */
     74          
     75            memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
     76            memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
     77          
     78            uint8_t axis_command = AXIS_COMMAND_NONE;
     79            uint8_t axis_0, axis_1, axis_linear;
     80            uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
     81          
     82            // Initialize bitflag tracking variables for axis indices compatible operations.
     83            uint8_t axis_words = 0; // XYZ tracking
     84            uint8_t ijk_words = 0; // IJK tracking
     85          
     86            // Initialize command and value words and parser flags variables.
     87            uint16_t command_words = 0; // Tracks G and M command words. Also used for modal group violations.
     88            uint16_t value_words = 0; // Tracks value words.
     89            uint8_t gc_parser_flags = GC_PARSER_NONE;
     90          
     91            // Determine if the line is a jogging motion or a normal g-code block.
     92            if (line[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
     93          						// Set G1 and G94 enforced modes to ensure accurate error checks.
     94              gc_parser_flags |= GC_PARSER_JOG_MOTION;
     95          	gc_block.modal.motion = MOTION_MODE_LINEAR;
     96              gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
     97          #ifdef USE_LINE_NUMBERS
     98               gc_block.values.n = JOG_LINE_NUMBER; // Initialize default line number reported during jog.
     99          #endif
    100            }
    101          
    102            /* -------------------------------------------------------------------------------------
    103               STEP 2: Import all g-code words in the block line. A g-code word is a letter followed by
    104               a number, which can either be a 'G'/'M' command or sets/assigns a command value. Also,
    105               perform initial error-checks for command word modal group violations, for any repeated
    106               words, and for negative values set for the value words F, N, P, T, and S. */
    107          
    108            uint8_t word_bit; // Bit-value for assigning tracking variables
    109            uint8_t char_counter;
    110            char letter;
    111            float value;
    112            uint8_t int_value = 0;
    113            uint16_t mantissa = 0;
    114            if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
    115            else { char_counter = 0; }
    116          
    117            while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    118          
    119              // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    120              letter = line[char_counter];
    121              if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
    122              char_counter++;
    123              if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
    124          
    125              // Convert values to smaller uint8 significand and mantissa values for parsing this word.
    126              // NOTE: Mantissa is multiplied by 100 to catch non-integer command values. This is more
    127              // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
    128              // accurate enough for value words that require integers to within 0.0001. This should be
    129              // a good enough comprimise and catch most all non-integer errors. To make it compliant,
    130              // we would simply need to change the mantissa to int16, but this add compiled flash space.
    131              // Maybe update this later.
    132              int_value = (uint8_t)truncf(value);
    133          	mantissa = (uint16_t)lroundf(100 * (value - int_value)); // Compute mantissa for Gxx.x commands.
    134              // NOTE: Rounding must be used to catch small floating point errors.
    135          
    136              // Check if the g-code word is supported or errors due to modal group violations or has
    137              // been repeated in the g-code block. If ok, update the command or record its value.
    138              switch(letter) {
    139          
    140                /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
    141                   NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */
    142          
    143                case 'G':
    144                  // Determine 'G' command and its modal group
    145                  switch(int_value) {
    146                    case 10: case 28: case 30: case 92:
    147                      // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
    148                      // * G43.1 is also an axis command but is not explicitly defined this way.
    149                      if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
    150                        if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    151                        axis_command = AXIS_COMMAND_NON_MODAL;
    152                      }
    153                      // No break. Continues to next line.
    154                    case 4: case 53:
    155                      word_bit = MODAL_GROUP_G0;
    156                      gc_block.non_modal_command = int_value;
    157                      if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
    158                        if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
    159                        gc_block.non_modal_command += mantissa;
    160                        mantissa = 0; // Set to zero to indicate valid non-integer G command.
    161                      }                
    162                      break;
    163                    case 0: case 1: case 2: case 3: case 38:
    164                      // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
    165                      // * G43.1 is also an axis command but is not explicitly defined this way.
    166                      if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    167                      axis_command = AXIS_COMMAND_MOTION_MODE;
    168                      // No break. Continues to next line.
    169                    case 80:
    170                      word_bit = MODAL_GROUP_G1;
    171                      gc_block.modal.motion = int_value;
    172                      if (int_value == 38){
    173                        if (!((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))) {
    174                          FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
    175                        }
    176                        gc_block.modal.motion += (mantissa/10)+100;
    177                        mantissa = 0; // Set to zero to indicate valid non-integer G command.
    178                      }  
    179                      break;
    180                    case 17: case 18: case 19:
    181                      word_bit = MODAL_GROUP_G2;
    182                      gc_block.modal.plane_select = int_value - 17;
    183                      break;
    184                    case 90: case 91:
    185                      if (mantissa == 0) {
    186                        word_bit = MODAL_GROUP_G3;
    187                        gc_block.modal.distance = int_value - 90;
    188                      } else {
    189                        word_bit = MODAL_GROUP_G4;
    190                        if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
    191                        mantissa = 0; // Set to zero to indicate valid non-integer G command.
    192                        // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
    193                      }
    194                      break;
    195                    case 93: case 94:
    196                      word_bit = MODAL_GROUP_G5;
    197                      gc_block.modal.feed_rate = 94 - int_value;
    198                      break;
    199                    case 20: case 21:
    200                      word_bit = MODAL_GROUP_G6;
    201                      gc_block.modal.units = 21 - int_value;
    202                      break;
    203                    case 40:
    204                      word_bit = MODAL_GROUP_G7;
    205                      // NOTE: Not required since cutter radius compensation is always disabled. Only here
    206                      // to support G40 commands that often appear in g-code program headers to setup defaults.
    207                      // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
    208                      break;
    209                    case 43: case 49:
    210                      word_bit = MODAL_GROUP_G8;
    211                      // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
    212                      // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
    213                      // all are explicit axis commands, regardless if they require axis words or not.
    214                      if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    215                      axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
    216                      if (int_value == 49) { // G49
    217                        gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
    218                      } else if (mantissa == 10) { // G43.1
    219                        gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
    220                      } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
    221                      mantissa = 0; // Set to zero to indicate valid non-integer G command.
    222                      break;
    223                    case 54: case 55: case 56: case 57: case 58: case 59:
    224                      // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
    225                      word_bit = MODAL_GROUP_G12;
    226                      gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
    227                      break;
    228                    case 61:
    229                      word_bit = MODAL_GROUP_G13;
    230                      if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
    231                      // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
    232                      break;
    233                    default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
    234                  }
    235                  if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    236                  // Check for more than one command per modal group violations in the current block
    237                  // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
    238                  if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    239                  command_words |= bit(word_bit);
    240                  break;
    241          
    242                case 'M':
    243          
    244                  // Determine 'M' command and its modal group
    245                  if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    246                  switch(int_value) {
    247                    case 0: case 1: case 2: case 30:
    248                      word_bit = MODAL_GROUP_M4;
    249                      switch(int_value) {
    250                        case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    251                        case 1: break; // Optional stop not supported. Ignore.
    252                        default: gc_block.modal.program_flow = int_value; // Program end and reset
    253                      }
    254                      break;
    255          					case 3: case 4: case 5:
    256                      word_bit = MODAL_GROUP_M7;
    257                      switch(int_value) {
    258                        case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    259                        case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    260                        case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    261                      }
    262                      break;
    263                    #ifdef ENABLE_M7
    264                      case 7: case 8: case 9:
    265                    #else
    266                      case 8: case 9:
    267                    #endif
    268                      word_bit = MODAL_GROUP_M8;
    269                      switch(int_value) {
    270                        #ifdef ENABLE_M7
    271                          case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
    272                        #endif
    273                        case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
    274                        case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
    275                      }
    276                      break;
    277          					#ifdef ENABLE_PARKING_OVERRIDE_CONTROL
    278          						case 56:
    279          							word_bit = MODAL_GROUP_M9;
    280          							gc_block.modal.override = OVERRIDE_PARKING_MOTION;
    281          							break;
    282          					#endif
    283                    default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
    284                  }
    285          
    286                  // Check for more than one command per modal group violations in the current block
    287                  // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
    288                  if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    289                  command_words |= bit(word_bit);
    290                  break;
    291          
    292                // NOTE: All remaining letters assign values.
    293                default:
    294          
    295                  /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
    296                     legal g-code words and stores their value. Error-checking is performed later since some
    297                     words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */
    298                  switch(letter){
    299                    // case 'A': // Not supported
    300                    // case 'B': // Not supported
    301                    // case 'C': // Not supported
    302                    // case 'D': // Not supported
    303                    case 'F': word_bit = WORD_F; gc_block.values.f = value; break;
    304                    // case 'H': // Not supported
    305                    case 'I': word_bit = WORD_I; gc_block.values.ijk[X_AXIS] = value; ijk_words |= (1<<X_AXIS); break;
    306                    case 'J': word_bit = WORD_J; gc_block.values.ijk[Y_AXIS] = value; ijk_words |= (1<<Y_AXIS); break;
    307                    case 'K': word_bit = WORD_K; gc_block.values.ijk[Z_AXIS] = value; ijk_words |= (1<<Z_AXIS); break;
    308                    case 'L': word_bit = WORD_L; gc_block.values.l = int_value; break;
    309                    case 'N': 
    310                      word_bit = WORD_N; 
    311                      gc_block.values.n = (uint32_t)truncf(value); 
    312                      break;
    313                    case 'P': 
    314                      word_bit = WORD_P; 
    315                      gc_block.values.p = value; 
    316                      break;
    317                    // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
    318                    // case 'Q': // Not supported
    319                    case 'R': 
    320                      word_bit = WORD_R; 
    321                      gc_block.values.r = value; 
    322                      break;
    323                    case 'S': 
    324                      word_bit = WORD_S; 
    325                      gc_block.values.s = value; 
    326                      break;
    327                    case 'T': 
    328                      word_bit = WORD_T;
    329                      if (value > MAX_TOOL_NUMBER) 
    330                        { 
    331                        FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); 
    332                        }
    333                      gc_block.values.t = int_value;
    334                      break;
    335          		  case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
    336                    case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
    337                    case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
    338                    default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
    339                  }
    340          
    341                  // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
    342                  if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    343                  // Check for invalid negative values for words F, N, P, T, and S.
    344                  // NOTE: Negative value check is done here simply for code-efficiency.
    345                  if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
    346                    if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    347                  }
    348                  value_words |= bit(word_bit); // Flag to indicate parameter assigned.
    349          
    350              }
    351            }
    352            // Parsing complete!
    353          
    354          
    355            /* -------------------------------------------------------------------------------------
    356               STEP 3: Error-check all commands and values passed in this block. This step ensures all of
    357               the commands are valid for execution and follows the NIST standard as closely as possible.
    358               If an error is found, all commands and values in this block are dumped and will not update
    359               the active system g-code modes. If the block is ok, the active system g-code modes will be
    360               updated based on the commands of this block, and signal for it to be executed.
    361          
    362               Also, we have to pre-convert all of the values passed based on the modes set by the parsed
    363               block. There are a number of error-checks that require target information that can only be
    364               accurately calculated if we convert these values in conjunction with the error-checking.
    365               This relegates the next execution step as only updating the system g-code modes and
    366               performing the programmed actions in order. The execution step should not require any
    367               conversion calculations and would only require minimal checks necessary to execute.
    368            */
    369          
    370            /* NOTE: At this point, the g-code block has been parsed and the block line can be freed.
    371               NOTE: It's also possible, at some future point, to break up STEP 2, to allow piece-wise
    372               parsing of the block on a per-word basis, rather than the entire block. This could remove
    373               the need for maintaining a large string variable for the entire block and free up some memory.
    374               To do this, this would simply need to retain all of the data in STEP 1, such as the new block
    375               data struct, the modal group and value bitflag tracking variables, and axis array indices
    376               compatible variables. This data contains all of the information necessary to error-check the
    377               new g-code block when the EOL character is received. However, this would break Grbl's startup
    378               lines in how it currently works and would require some refactoring to make it compatible.
    379            */
    380          
    381            // [0. Non-specific/common error-checks and miscellaneous setup]:
    382          
    383            // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
    384            // command has been sent. If so, set axis command to current motion mode.
    385            if (axis_words) {
    386              if (!axis_command) { axis_command = AXIS_COMMAND_MOTION_MODE; } // Assign implicit motion-mode
    387            }
    388          
    389            // Check for valid line number N value.
    390            if (bit_istrue(value_words,bit(WORD_N))) {
    391              // Line number value cannot be less than zero (done) or greater than max line number.
    392              if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    393            }
    394            // bit_false(value_words,bit(WORD_N)); // NOTE: Single-meaning value word. Set at end of error-checking.
    395          
    396            // Track for unused words at the end of error-checking.
    397            // NOTE: Single-meaning value words are removed all at once at the end of error-checking, because
    398            // they are always used when present. This was done to save a few bytes of flash. For clarity, the
    399            // single-meaning value words may be removed as they are used. Also, axis words are treated in the
    400            // same way. If there is an explicit/implicit axis command, XYZ words are always used and are
    401            // are removed at the end of error-checking.
    402          
    403            // [1. Comments ]: MSG's NOT SUPPORTED. Comment handling performed by protocol.
    404          
    405            // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
    406            //   is not defined after switching to G94 from G93.
    407            // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
    408            if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    409              if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); }
    410              if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    411            } else {
    412              if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    413                // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
    414                if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    415          		if ((gc_block.modal.motion != MOTION_MODE_NONE) && (gc_block.modal.motion != MOTION_MODE_SEEK)) {
    416                    if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    417                  }
    418                }
    419                // NOTE: It seems redundant to check for an F word to be passed after switching from G94 to G93. We would
    420                // accomplish the exact same thing if the feed rate value is always reset to zero and undefined after each
    421                // inverse time block, since the commands that use this value already perform undefined checks. This would
    422                // also allow other commands, following this switch, to execute and not error out needlessly. This code is
    423                // combined with the above feed rate mode and the below set feed rate error-checking.
    424          
    425                // [3. Set feed rate ]: F is negative (done.)
    426                // - In inverse time mode: Always implicitly zero the feed rate value before and after block completion.
    427                // NOTE: If in G93 mode or switched into it from G94, just keep F value as initialized zero or passed F word
    428                // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error
    429                // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
    430                // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.
    431              } else { // = G94
    432                // - In units per mm mode: If F word passed, ensure value is in mm/min, otherwise push last state value.
    433                if (gc_state.modal.feed_rate == FEED_RATE_MODE_UNITS_PER_MIN) { // Last state is also G94
    434                  if (bit_istrue(value_words,bit(WORD_F))) {
    435                    if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    436                  } else {
    437                    gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
    438                  }
    439                } // Else, switching to G94 from G93, so don't push last state feed rate. Its undefined or the passed F word value.
    440              }
    441            }
    442            // bit_false(value_words,bit(WORD_F)); // NOTE: Single-meaning value word. Set at end of error-checking.
    443          
    444            // [4. Set spindle speed ]: S is negative (done.)
    445            if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
    446            // bit_false(value_words,bit(WORD_S)); // NOTE: Single-meaning value word. Set at end of error-checking.
    447          
    448            // [5. Select tool ]: NOT SUPPORTED. Only tracks value. T is negative (done.) Not an integer. Greater than max tool value.
    449            // bit_false(value_words,bit(WORD_T)); // NOTE: Single-meaning value word. Set at end of error-checking.
    450          
    451            // [6. Change tool ]: N/A
    452            // [7. Spindle control ]: N/A
    453            // [8. Coolant control ]: N/A
    454          	// [9. Override control ]: Not supported except for a Grbl-only parking motion override control.
    455          #ifdef ENABLE_PARKING_OVERRIDE_CONTROL
    456          	if (bit_istrue(command_words, bit(MODAL_GROUP_M9))) { // Already set as enabled in parser.
    457          		if (bit_istrue(value_words, bit(WORD_P))) {
    458          			if (gc_block.values.p == 0.0f) { gc_block.modal.override = OVERRIDE_DISABLED; }
    459          			bit_false(value_words, bit(WORD_P));
    460          		}
    461          	}
    462          #endif
    463          	
    464            // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
    465            if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    466              if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    467              bit_false(value_words,bit(WORD_P));
    468            }
    469          
    470            // [11. Set active plane ]: N/A
    471            switch (gc_block.modal.plane_select) {
    472              case PLANE_SELECT_XY:
    473                axis_0 = X_AXIS;
    474                axis_1 = Y_AXIS;
    475                axis_linear = Z_AXIS;
    476                break;
    477              case PLANE_SELECT_ZX:
    478                axis_0 = Z_AXIS;
    479                axis_1 = X_AXIS;
    480                axis_linear = Y_AXIS;
    481                break;
    482              default: // case PLANE_SELECT_YZ:
    483                axis_0 = Y_AXIS;
    484                axis_1 = Z_AXIS;
    485                axis_linear = X_AXIS;
    486            }
    487          
    488            // [12. Set length units ]: N/A
    489            // Pre-convert XYZ coordinate values to millimeters, if applicable.
    490            uint8_t idx;
    491            if (gc_block.modal.units == UNITS_MODE_INCHES) {
    492              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    493                if (bit_istrue(axis_words,bit(idx)) ) {
    494                  gc_block.values.xyz[idx] *= MM_PER_INCH;
    495                }
    496              }
    497            }
    498          
    499            // [13. Cutter radius compensation ]: G41/42 NOT SUPPORTED. Error, if enabled while G53 is active.
    500            // [G40 Errors]: G2/3 arc is programmed after a G40. The linear move after disabling is less than tool diameter.
    501            //   NOTE: Since cutter radius compensation is never enabled, these G40 errors don't apply. Grbl supports G40
    502            //   only for the purpose to not error when G40 is sent with a g-code program header to setup the default modes.
    503          
    504            // [14. Cutter length compensation ]: G43 NOT SUPPORTED, but G43.1 and G49 are.
    505            // [G43.1 Errors]: Motion command in same line.
    506            //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid
    507            //   axis that is configured (in config.h). There should be an error if the configured axis
    508            //   is absent or if any of the other axis words are present.
    509            if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    510              if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
    511                if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    512              }
    513            }
    514          
    515            // [15. Coordinate system selection ]: *N/A. Error, if cutter radius comp is active.
    516            // TODO: An EEPROM read of the coordinate data may require a buffer sync when the cycle
    517            // is active. The read pauses the processor temporarily and may cause a rare crash. For
    518            // future versions on processors with enough memory, all coordinate data should be stored
    519            // in memory and written to EEPROM only when there is not a cycle active.
    520            float block_coord_system[N_AXIS];
    521            memcpy(block_coord_system,gc_state.coord_system,sizeof(gc_state.coord_system));
    522            if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    523              if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    524              if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    525                if (!(settings_read_coord_data(gc_block.modal.coord_select,block_coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    526              }
    527            }
    528          
    529            // [16. Set path control mode ]: N/A. Only G61. G61.1 and G64 NOT SUPPORTED.
    530            // [17. Set distance mode ]: N/A. Only G91.1. G90.1 NOT SUPPORTED.
    531            // [18. Set retract mode ]: NOT SUPPORTED.
    532          
    533            // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offsets.
    534            // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), as these
    535            // commands all treat axis words differently. G10 as absolute offsets or computes current position as
    536            // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that observes
    537            // all the current coordinate system and G92 offsets.
    538            switch (gc_block.non_modal_command) {
    539              case NON_MODAL_SET_COORDINATE_DATA:
    540                // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
    541                // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
    542                // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
    543                if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    544                if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    545                coord_select = (uint8_t)truncf(gc_block.values.p); // Convert p value to int.
    546                if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    547                if (gc_block.values.l != 20) {
    548                  if (gc_block.values.l == 2) {
    549                    if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    550                  } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
    551                }
    552                bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
    553          
    554                // Determine coordinate system to change and try to load from EEPROM.
    555                if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
    556                else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
    557                
    558                // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
    559                if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    560          
    561                // Pre-calculate the coordinate data changes.
    562                for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    563                  // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
    564                  if (bit_istrue(axis_words,bit(idx)) ) {
    565                    if (gc_block.values.l == 20) {
    566                      // L20: Update coordinate system axis at current position (with modifiers) with programmed value
    567                      // WPos = MPos - WCS - G92 - TLO  ->  WCS = MPos - G92 - TLO - WPos
    568                      gc_block.values.ijk[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
    569                      if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.ijk[idx] -= gc_state.tool_length_offset; }
    570                    } else {
    571                      // L2: Update coordinate system axis to programmed value.
    572                      gc_block.values.ijk[idx] = gc_block.values.xyz[idx];
    573                    }
    574                  } // Else, keep current stored value.
    575                }
    576                break;
    577              case NON_MODAL_SET_COORDINATE_OFFSET:
    578                // [G92 Errors]: No axis words.
    579                if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    580          
    581                // Update axes defined only in block. Offsets current system to defined value. Does not update when
    582                // active coordinate system is selected, but is still active unless G92.1 disables it.
    583                for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    584                  if (bit_istrue(axis_words,bit(idx)) ) {
    585                    // WPos = MPos - WCS - G92 - TLO  ->  G92 = MPos - WCS - TLO - WPos
    586                    gc_block.values.xyz[idx] = gc_state.position[idx]-block_coord_system[idx]-gc_block.values.xyz[idx];
    587                    if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
    588                  } else {
    589                    gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
    590                  }
    591                }
    592                break;
    593          
    594              default:
    595          
    596                // At this point, the rest of the explicit axis commands treat the axis values as the traditional
    597                // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
    598                // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
    599                // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
    600                if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
    601                  if (axis_words) {
    602                    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    603                      if ( bit_isfalse(axis_words,bit(idx)) ) {
    604                        gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
    605                      } else {
    606                        // Update specified value according to distance mode or ignore if absolute override is active.
    607                        // NOTE: G53 is never active with G28/30 since they are in the same modal group.
    608                        if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
    609                          // Apply coordinate offsets based on distance mode.
    610                          if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    611                            gc_block.values.xyz[idx] += block_coord_system[idx] + gc_state.coord_offset[idx];
    612                            if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
    613                          } else {  // Incremental mode
    614                            gc_block.values.xyz[idx] += gc_state.position[idx];
    615                          }
    616                        }
    617                      }
    618                    }
    619                  }
    620                }
    621          
    622                // Check remaining non-modal commands for errors.
    623                switch (gc_block.non_modal_command) {
    624                  case NON_MODAL_GO_HOME_0: // G28
    625                  case NON_MODAL_GO_HOME_1: // G30
    626                    // [G28/30 Errors]: Cutter compensation is enabled.
    627                    // Retreive G28/30 go-home position data (in machine coordinates) from EEPROM
    628                    // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
    629                    if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
    630                      if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    631                    } else { // == NON_MODAL_GO_HOME_1
    632                      if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    633                    }
    634                    if (axis_words) {
    635                      // Move only the axes specified in secondary move.
    636                      for (idx=0; idx<N_AXIS; idx++) {
    637                        if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
    638                      }
    639                    } else {
    640                      axis_command = AXIS_COMMAND_NONE; // Set to none if no intermediate motion.
    641                    }
    642                    break;
    643                  case NON_MODAL_SET_HOME_0: // G28.1
    644                  case NON_MODAL_SET_HOME_1: // G30.1
    645                    // [G28.1/30.1 Errors]: Cutter compensation is enabled.
    646                    // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
    647                    break;
    648                  case NON_MODAL_RESET_COORDINATE_OFFSET:
    649                    // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
    650                    break;
    651                  case NON_MODAL_ABSOLUTE_OVERRIDE:
    652                    // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
    653                    // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
    654                    if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
    655                      FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
    656                    }
    657                    break;
    658                }
    659            }
    660          
    661            // [20. Motion modes ]:
    662            if (gc_block.modal.motion == MOTION_MODE_NONE) {
    663              // [G80 Errors]: Axis word are programmed while G80 is active.
    664              // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    665              if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    666          
    667            // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), or
    668            // was explicitly commanded in the g-code block.
    669            } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {
    670          
    671              if (gc_block.modal.motion == MOTION_MODE_SEEK) {
    672                // [G0 Errors]: Axis letter not configured or without real value (done.)
    673                // Axis words are optional. If missing, set axis command flag to ignore execution.
    674                if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    675          
    676              // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    677              // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    678              } else {
    679                // Check if feed rate is defined for the motion modes that require it.
    680                if (gc_block.values.f == 0.0f) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    681          
    682                switch (gc_block.modal.motion) {
    683                  case MOTION_MODE_LINEAR:
    684                    // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
    685                    // Axis words are optional. If missing, set axis command flag to ignore execution.
    686                    if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    687          
    688                    break;
    689                  case MOTION_MODE_CW_ARC: 
    690                    gc_parser_flags |= GC_PARSER_ARC_IS_CLOCKWISE; // No break intentional.
    691                  case MOTION_MODE_CCW_ARC:
    692                    // [G2/3 Errors All-Modes]: Feed rate undefined.
    693                    // [G2/3 Radius-Mode Errors]: No axis words in selected plane. Target point is same as current.
    694                    // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current
    695                    //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).
    696                    // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.
    697                    // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.
    698          
    699                    if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    700                    if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    701          
    702                    // Calculate the change in position along each selected axis
    703                    float x,y;
    704                    x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
    705                    y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target
    706          
    707                    if (value_words & bit(WORD_R)) { // Arc Radius Mode
    708                      bit_false(value_words,bit(WORD_R));
    709                      if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    710          
    711                      // Convert radius value to proper units.
    712                      if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
    713                      /*  We need to calculate the center of the circle that has the designated radius and passes
    714                          through both the current position and the target position. This method calculates the following
    715                          set of equations where [x,y] is the vector from current to target position, d == magnitude of
    716                          that vector, h == hypotenuse of the triangle formed by the radius of the circle, the distance to
    717                          the center of the travel vector. A vector perpendicular to the travel vector [-y,x] is scaled to the
    718                          length of h [-y/d*h, x/d*h] and added to the center of the travel vector [x/2,y/2] to form the new point
    719                          [i,j] at [x/2-y/d*h, y/2+x/d*h] which will be the center of our arc.
    720          
    721                          d^2 == x^2 + y^2
    722                          h^2 == r^2 - (d/2)^2
    723                          i == x/2 - y/d*h
    724                          j == y/2 + x/d*h
    725          
    726                                                                               O <- [i,j]
    727                                                                            -  |
    728                                                                  r      -     |
    729                                                                      -        |
    730                                                                   -           | h
    731                                                                -              |
    732                                                  [0,0] ->  C -----------------+--------------- T  <- [x,y]
    733                                                            | <------ d/2 ---->|
    734          
    735                          C - Current position
    736                          T - Target position
    737                          O - center of circle that pass through both C and T
    738                          d - distance from C to T
    739                          r - designated radius
    740                          h - distance from center of CT to O
    741          
    742                          Expanding the equations:
    743          
    744                          d -> sqrt(x^2 + y^2)
    745                          h -> sqrt(4 * r^2 - x^2 - y^2)/2
    746                          i -> (x - (y * sqrt(4 * r^2 - x^2 - y^2)) / sqrt(x^2 + y^2)) / 2
    747                          j -> (y + (x * sqrt(4 * r^2 - x^2 - y^2)) / sqrt(x^2 + y^2)) / 2
    748          
    749                          Which can be written:
    750          
    751                          i -> (x - (y * sqrt(4 * r^2 - x^2 - y^2))/sqrt(x^2 + y^2))/2
    752                          j -> (y + (x * sqrt(4 * r^2 - x^2 - y^2))/sqrt(x^2 + y^2))/2
    753          
    754                          Which we for size and speed reasons optimize to:
    755          
    756                          h_x2_div_d = sqrt(4 * r^2 - x^2 - y^2)/sqrt(x^2 + y^2)
    757                          i = (x - (y * h_x2_div_d))/2
    758                          j = (y + (x * h_x2_div_d))/2
    759                      */
    760          
    761                      // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
    762                      // than d. If so, the sqrt of a negative number is complex and error out.
    763                      float h_x2_div_d = 4.0f * gc_block.values.r*gc_block.values.r - x*x - y*y;
    764          
    765                      if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    766          
    767                      // Finish computing h_x2_div_d.
    768                      h_x2_div_d = -sqrtf(h_x2_div_d)/hypot_f(x,y); // == -(h * 2 / d)
    769                      // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
    770                      if (gc_block.modal.motion == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }
    771          
    772                      /* The counter clockwise circle lies to the left of the target direction. When offset is positive,
    773                         the left hand circle will be generated - when it is negative the right hand circle is generated.
    774          
    775                                                                             T  <-- Target position
    776          
    777                                                                             ^
    778                                  Clockwise circles with this center         |          Clockwise circles with this center will have
    779                                  will have > 180 deg of angular travel      |          < 180 deg of angular travel, which is a good thing!
    780                                                                   \         |          /
    781                      center of arc when h_x2_div_d is positive ->  x <----- | -----> x <- center of arc when h_x2_div_d is negative
    782                                                                             |
    783                                                                             |
    784          
    785                                                                             C  <-- Current position
    786                      */
    787                      // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel" (go figure!),
    788                      // even though it is advised against ever generating such circles in a single line of g-code. By
    789                      // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of
    790                      // travel and thus we get the unadvisably long arcs as prescribed.
    791                      if (gc_block.values.r < 0) {
    792                          h_x2_div_d = -h_x2_div_d;
    793                          gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
    794                      }
    795                      // Complete the operation by calculating the actual center of the arc
    796                      gc_block.values.ijk[axis_0] = 0.5f*(x-(y*h_x2_div_d));
    797                      gc_block.values.ijk[axis_1] = 0.5f*(y+(x*h_x2_div_d));
    798          
    799                    } else { // Arc Center Format Offset Mode
    800                      if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    801                      bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));
    802          
    803                      // Convert IJK values to proper units.
    804                      if (gc_block.modal.units == UNITS_MODE_INCHES) {
    805                        for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    806                          if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
    807                        }
    808                      }
    809          
    810                      // Arc radius from center to target
    811                      x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
    812                      y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
    813                      float target_r = hypot_f(x,y);
    814          
    815                      // Compute arc radius for mc_arc. Defined from current location to center.
    816                      gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]);
    817          
    818                      // Compute difference between current location and target radii for final error-checks.
    819                      float delta_r = fabsf(target_r-gc_block.values.r);
    820                      if (delta_r > 0.005f) {
    821                        if (delta_r > 0.5f) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    822                        if (delta_r > (0.001f*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    823                      }
    824                    }
    825                    break;
    826                  case MOTION_MODE_PROBE_TOWARD_NO_ERROR: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
    827                      gc_parser_flags |= GC_PARSER_PROBE_IS_NO_ERROR; // No break intentional.
    828                  case MOTION_MODE_PROBE_TOWARD: case MOTION_MODE_PROBE_AWAY:
    829                      if ((gc_block.modal.motion == MOTION_MODE_PROBE_AWAY) ||
    830                          (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_PARSER_PROBE_IS_AWAY; }
    831                    // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
    832                    //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
    833                    //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to
    834                    //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
    835                    if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    836                    if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    837                    break;
    838                }
    839              }
    840            }
    841          
    842            // [21. Program flow ]: No error checks required.
    843          
    844            // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
    845            // radius mode, or axis words that aren't used in the block.
    846            if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    847                // Jogging only uses the F feed rate and XYZ value words. N is valid, but S and T are invalid.
    848                bit_false(value_words, (bit(WORD_N) | bit(WORD_F)));
    849            } else {
    850                bit_false(value_words, (bit(WORD_N) | bit(WORD_F) | bit(WORD_S) | bit(WORD_T))); // Remove single-meaning value words.
    851            }
    852            if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words.
    853            if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    854          
    855            /* -------------------------------------------------------------------------------------
    856               STEP 4: EXECUTE!!
    857               Assumes that all error-checking has been completed and no failure modes exist. We just
    858               need to update the state and execute the block according to the order-of-execution.
    859            */
    860          
    861            // Initialize planner data struct for motion blocks.
    862            plan_line_data_t plan_data;
    863            plan_line_data_t *pl_data = &plan_data;
    864            memset(pl_data,0,sizeof(plan_line_data_t)); // Zero pl_data struct
    865          
    866                                                        // Intercept jog commands and complete error checking for valid jog commands and execute.
    867                                                        // NOTE: G-code parser state is not updated, except the position to ensure sequential jog
    868                                                        // targets are computed correctly. The final parser position after a jog is updated in
    869                                                        // protocol_execute_realtime() when jogging completes or is canceled.
    870            if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    871                // Only distance and unit modal commands and G53 absolute override command are allowed.
    872                // NOTE: Feed rate word and axis word checks have already been performed in STEP 3.
    873                if (command_words & ~(bit(MODAL_GROUP_G3) | bit(MODAL_GROUP_G6 | bit(MODAL_GROUP_G0)))) { FAIL(STATUS_INVALID_JOG_COMMAND) };
    874                if (!(gc_block.non_modal_command == NON_MODAL_ABSOLUTE_OVERRIDE || gc_block.non_modal_command == NON_MODAL_NO_ACTION)) { FAIL(STATUS_INVALID_JOG_COMMAND); }
    875          
    876                // Initialize planner data to current spindle and coolant modal state.
    877                pl_data->spindle_speed = gc_state.spindle_speed;
    878                plan_data.condition = (gc_state.modal.spindle | gc_state.modal.coolant);
    879          
    880                uint8_t status = jog_execute(&plan_data, &gc_block);
    881                if (status == STATUS_OK) { memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); }
    882                return(status);
    883            }
    884          
    885            // If in laser mode, setup laser power based on current and past parser conditions.
    886            if (bit_istrue(settings.flags, BITFLAG_LASER_MODE)) {
    887                if (!((gc_block.modal.motion == MOTION_MODE_LINEAR) || (gc_block.modal.motion == MOTION_MODE_CW_ARC)
    888                    || (gc_block.modal.motion == MOTION_MODE_CCW_ARC))) {
    889                    gc_parser_flags |= GC_PARSER_LASER_DISABLE;
    890                }
    891          
    892                // Any motion mode with axis words is allowed to be passed from a spindle speed update. 
    893                // NOTE: G1 and G0 without axis words sets axis_command to none. G28/30 are intentionally omitted.
    894                // TODO: Check sync conditions for M3 enabled motions that don't enter the planner. (zero length).
    895                if (axis_words && (axis_command == AXIS_COMMAND_MOTION_MODE)) {
    896                  gc_parser_flags |= GC_PARSER_LASER_ISMOTION;
    897                }
    898                else {
    899                  // M3 constant power laser requires planner syncs to update the laser when changing between
    900                  // a G1/2/3 motion mode state and vice versa when there is no motion in the line.
    901                  if (gc_state.modal.spindle == SPINDLE_ENABLE_CW) {
    902                    if ((gc_state.modal.motion == MOTION_MODE_LINEAR) || (gc_state.modal.motion == MOTION_MODE_CW_ARC)
    903                      || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
    904                      if (bit_istrue(gc_parser_flags, GC_PARSER_LASER_DISABLE)) {
    905                        gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC; // Change from G1/2/3 motion mode.
    906                      }
    907                    }
    908                    else {
    909                      // When changing to a G1 motion mode without axis words from a non-G1/2/3 motion mode.
    910                      if (bit_isfalse(gc_parser_flags, GC_PARSER_LASER_DISABLE)) {
    911                        gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC;
    912                      }
    913                    }
    914                  }
    915                }
    916            }
    917          
    918            // [0. Non-specific/common error-checks and miscellaneous setup]:
    919            // NOTE: If no line number is present, the value is zero.
    920            gc_state.line_number = gc_block.values.n;
    921            #ifdef USE_LINE_NUMBERS
    922              pl_data->line_number = gc_state.line_number; // Record data for planner use.
    923            #endif
    924          
    925            // [1. Comments feedback ]:  NOT SUPPORTED
    926          
    927            // [2. Set feed rate mode ]:
    928            gc_state.modal.feed_rate = gc_block.modal.feed_rate;
    929            if (gc_state.modal.feed_rate) { pl_data->condition |= PL_COND_FLAG_INVERSE_TIME; } // Set condition flag for planner use.
    930          
    931            // [3. Set feed rate ]:
    932            gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
    933            pl_data->feed_rate = gc_state.feed_rate; // Record data for planner use.
    934          
    935            // [4. Set spindle speed ]:
    936            if ((gc_state.spindle_speed != gc_block.values.s) || bit_istrue(gc_parser_flags, GC_PARSER_LASER_FORCE_SYNC)) {
    937                if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    938          #ifdef VARIABLE_SPINDLE
    939                  if (bit_isfalse(gc_parser_flags, GC_PARSER_LASER_ISMOTION)) {
    940                    if (bit_istrue(gc_parser_flags, GC_PARSER_LASER_DISABLE)) {
    941                      spindle_sync(gc_state.modal.spindle, 0.0);
    942                    }
    943                    else { spindle_sync(gc_state.modal.spindle, gc_block.values.s); }
    944                  }
    945          #else
    946                    spindle_sync(gc_state.modal.spindle, 0.0);
    947          #endif
    948                }
    949                gc_state.spindle_speed = gc_block.values.s; // Update spindle speed state.
    950            }
    951            // NOTE: Pass zero spindle speed for all restricted laser motions.
    952            if (bit_isfalse(gc_parser_flags, GC_PARSER_LASER_DISABLE)) {
    953                pl_data->spindle_speed = gc_state.spindle_speed; // Record data for planner use. 
    954            } // else { pl_data->spindle_speed = 0.0; } // Initialized as zero already.
    955          
    956            // [5. Select tool ]: NOT SUPPORTED. Only tracks tool value.
    957            gc_state.tool = gc_block.values.t;
    958          
    959            // [6. Change tool ]: NOT SUPPORTED
    960          
    961            // [7. Spindle control ]:
    962            if (gc_state.modal.spindle != gc_block.modal.spindle) {
    963              // Update spindle control and apply spindle speed when enabling it in this block.
    964              // NOTE: All spindle state changes are synced, even in laser mode. Also, pl_data,
    965              // rather than gc_state, is used to manage laser state for non-laser motions.
    966              spindle_sync(gc_block.modal.spindle, pl_data->spindle_speed);
    967              gc_state.modal.spindle = gc_block.modal.spindle;
    968            }
    969            pl_data->condition |= gc_state.modal.spindle; // Set condition flag for planner use.
    970          
    971            // [8. Coolant control ]:
    972            if (gc_state.modal.coolant != gc_block.modal.coolant) {
    973              // NOTE: Coolant M-codes are modal. Only one command per line is allowed. But, multiple states
    974              // can exist at the same time, while coolant disable clears all states.
    975              coolant_sync(gc_block.modal.coolant);
    976              if (gc_block.modal.coolant == COOLANT_DISABLE) { gc_state.modal.coolant = COOLANT_DISABLE; }
    977              else { gc_state.modal.coolant |= gc_block.modal.coolant; }
    978            }
    979            pl_data->condition |= gc_state.modal.coolant; // Set condition flag for planner use.
    980          
    981          	// [9. Override control ]: NOT SUPPORTED. Always enabled. Except for a Grbl-only parking control.
    982          #ifdef ENABLE_PARKING_OVERRIDE_CONTROL
    983          	if (gc_state.modal.override != gc_block.modal.override) {
    984          		gc_state.modal.override = gc_block.modal.override;
    985          		mc_override_ctrl_update(gc_state.modal.override);
    986          	}
    987          #endif
    988          
    989            // [10. Dwell ]:
    990            if (gc_block.non_modal_command == NON_MODAL_DWELL) { mc_dwell(gc_block.values.p); }
    991          
    992            // [11. Set active plane ]:
    993            gc_state.modal.plane_select = gc_block.modal.plane_select;
    994          
    995            // [12. Set length units ]:
    996            gc_state.modal.units = gc_block.modal.units;
    997          
    998            // [13. Cutter radius compensation ]: G41/42 NOT SUPPORTED
    999            // gc_state.modal.cutter_comp = gc_block.modal.cutter_comp; // NOTE: Not needed since always disabled.
   1000          
   1001            // [14. Cutter length compensation ]: G43.1 and G49 supported. G43 NOT SUPPORTED.
   1002            // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
   1003            // of execution. The error-checking step would simply load the offset value into the correct
   1004            // axis of the block XYZ value array.
   1005            if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates a change.
   1006              gc_state.modal.tool_length = gc_block.modal.tool_length;
   1007              if (gc_state.modal.tool_length == TOOL_LENGTH_OFFSET_CANCEL) { // G49
   1008                gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] = 0.0f;
   1009              } // else G43.1
   1010              if ( gc_state.tool_length_offset != gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] ) {
   1011                gc_state.tool_length_offset = gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS];
   1012                system_flag_wco_change();
   1013              }
   1014            }
   1015          
   1016            // [15. Coordinate system selection ]:
   1017            if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
   1018              gc_state.modal.coord_select = gc_block.modal.coord_select;
   1019              memcpy(gc_state.coord_system,block_coord_system,N_AXIS*sizeof(float));
   1020              system_flag_wco_change();
   1021            }
   1022          
   1023            // [16. Set path control mode ]: G61.1/G64 NOT SUPPORTED
   1024            // gc_state.modal.control = gc_block.modal.control; // NOTE: Always default.
   1025          
   1026            // [17. Set distance mode ]:
   1027            gc_state.modal.distance = gc_block.modal.distance;
   1028          
   1029            // [18. Set retract mode ]: NOT SUPPORTED
   1030          
   1031            // [19. Go to predefined position, Set G10, or Set axis offsets ]:
   1032            switch(gc_block.non_modal_command) {
   1033              case NON_MODAL_SET_COORDINATE_DATA:
   1034                settings_write_coord_data(coord_select,gc_block.values.ijk);
   1035                // Update system coordinate system if currently active.
   1036                if (gc_state.modal.coord_select == coord_select) {
   1037                  memcpy(gc_state.coord_system,gc_block.values.ijk,N_AXIS*sizeof(float));
   1038                  system_flag_wco_change();
   1039                }
   1040                break;
   1041              case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1:
   1042                // Move to intermediate position before going home. Obeys current coordinate system and offsets
   1043                // and absolute and incremental modes.
   1044                pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
   1045                if (axis_command) { mc_line(gc_block.values.xyz, pl_data); }
   1046                mc_line(gc_block.values.ijk, pl_data);
   1047                memcpy(gc_state.position, gc_block.values.ijk, N_AXIS*sizeof(float));
   1048                break;
   1049              case NON_MODAL_SET_HOME_0:
   1050                settings_write_coord_data(SETTING_INDEX_G28,gc_state.position);
   1051                break;
   1052              case NON_MODAL_SET_HOME_1:
   1053                settings_write_coord_data(SETTING_INDEX_G30,gc_state.position);
   1054                break;
   1055              case NON_MODAL_SET_COORDINATE_OFFSET:
   1056                memcpy(gc_state.coord_offset,gc_block.values.xyz,sizeof(gc_block.values.xyz));
   1057                system_flag_wco_change();
   1058                break;
   1059              case NON_MODAL_RESET_COORDINATE_OFFSET:
   1060                clear_vector(gc_state.coord_offset); // Disable G92 offsets by zeroing offset vector.
   1061                system_flag_wco_change();
   1062                break;
   1063            }
   1064          
   1065          
   1066            // [20. Motion modes ]:
   1067            // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes.
   1068            // Enter motion modes only if there are axis words or a motion mode command word in the block.
   1069            gc_state.modal.motion = gc_block.modal.motion;
   1070            if (gc_state.modal.motion != MOTION_MODE_NONE) {
   1071              if (axis_command == AXIS_COMMAND_MOTION_MODE) {
   1072                uint8_t gc_update_pos = GC_UPDATE_POS_TARGET;
   1073                if (gc_state.modal.motion == MOTION_MODE_LINEAR) {
   1074                  mc_line(gc_block.values.xyz, pl_data);
   1075                } else if (gc_state.modal.motion == MOTION_MODE_SEEK) {
   1076                  pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
   1077                  mc_line(gc_block.values.xyz, pl_data);
   1078                } else if ((gc_state.modal.motion == MOTION_MODE_CW_ARC) || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
   1079                    mc_arc(gc_block.values.xyz, pl_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
   1080                        axis_0, axis_1, axis_linear, bit_istrue(gc_parser_flags, GC_PARSER_ARC_IS_CLOCKWISE));
   1081                } else {
   1082                  // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position value. So
   1083                  // upon a successful probing cycle, the machine position and the returned value should be the same.
   1084                  #ifndef ALLOW_FEED_OVERRIDE_DURING_PROBE_CYCLES
   1085                    pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
   1086                  #endif
   1087                  gc_update_pos = mc_probe_cycle(gc_block.values.xyz, pl_data, gc_parser_flags);
   1088              }  
   1089               
   1090                // As far as the parser is concerned, the position is now == target. In reality the
   1091                // motion control system might still be processing the action and the real tool position
   1092                // in any intermediate location.
   1093                if (gc_update_pos == GC_UPDATE_POS_TARGET) {
   1094                  memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); // gc_state.position[] = gc_block.values.xyz[]
   1095                } else if (gc_update_pos == GC_UPDATE_POS_SYSTEM) {
   1096                  gc_sync_position(); // gc_state.position[] = sys_position
   1097                } // == GC_UPDATE_POS_NONE
   1098              }     
   1099          
   1100            }
   1101          
   1102            // [21. Program flow ]:
   1103            // M0,M1,M2,M30: Perform non-running program flow actions. During a program pause, the buffer may
   1104            // refill and can only be resumed by the cycle start run-time command.
   1105            gc_state.modal.program_flow = gc_block.modal.program_flow;
   1106            if (gc_state.modal.program_flow) {
   1107              protocol_buffer_synchronize(); // Sync and finish all remaining buffered motions before moving on.
   1108              if (gc_state.modal.program_flow == PROGRAM_FLOW_PAUSED) {
   1109                if (sys.state != STATE_CHECK_MODE) {
   1110                  system_set_exec_state_flag(EXEC_FEED_HOLD); // Use feed hold for program pause.
   1111                  protocol_execute_realtime(); // Execute suspend.
   1112                }
   1113              } else { // == PROGRAM_FLOW_COMPLETED
   1114                // Upon program complete, only a subset of g-codes reset to certain defaults, according to
   1115                // LinuxCNC's program end descriptions and testing. Only modal groups [G-code 1,2,3,5,7,12]
   1116                // and [M-code 7,8,9] reset to [G1,G17,G90,G94,G40,G54,M5,M9,M48]. The remaining modal groups
   1117                // [G-code 4,6,8,10,13,14,15] and [M-code 4,5,6] and the modal words [F,S,T,H] do not reset.
   1118                gc_state.modal.motion = MOTION_MODE_LINEAR;
   1119                gc_state.modal.plane_select = PLANE_SELECT_XY;
   1120                gc_state.modal.distance = DISTANCE_MODE_ABSOLUTE;
   1121                gc_state.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
   1122                // gc_state.modal.cutter_comp = CUTTER_COMP_DISABLE; // Not supported.
   1123                gc_state.modal.coord_select = 0; // G54
   1124                gc_state.modal.spindle = SPINDLE_DISABLE;
   1125                gc_state.modal.coolant = COOLANT_DISABLE;
   1126          			#ifdef ENABLE_PARKING_OVERRIDE_CONTROL
   1127          				#ifdef DEACTIVATE_PARKING_UPON_INIT
   1128          					gc_state.modal.override = OVERRIDE_DISABLED;
   1129          				#else
   1130          					gc_state.modal.override = OVERRIDE_PARKING_MOTION;
   1131          				#endif
   1132          			#endif
   1133          
   1134                #ifdef RESTORE_OVERRIDES_AFTER_PROGRAM_END
   1135                  sys.f_override = DEFAULT_FEED_OVERRIDE;
   1136                  sys.r_override = DEFAULT_RAPID_OVERRIDE;
   1137                  sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE;
   1138                #endif
   1139          
   1140                // Execute coordinate change and spindle/coolant stop.
   1141                if (sys.state != STATE_CHECK_MODE) {
   1142                  if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
   1143                  system_flag_wco_change(); // Set to refresh immediately just in case something altered.
   1144                  spindle_set_state(SPINDLE_DISABLE,0.0f);
   1145                  coolant_set_state(COOLANT_DISABLE);
   1146                }
   1147                report_feedback_message(MESSAGE_PROGRAM_END);
   1148              }
   1149              gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; // Reset program flow.
   1150            }
   1151          
   1152            // TODO: % to denote start of program.
   1153          
   1154            return(STATUS_OK);
   1155          }
   1156          
   1157          
   1158          /*
   1159            Not supported:
   1160          
   1161            - Canned cycles
   1162            - Tool radius compensation
   1163            - A,B,C-axes
   1164            - Evaluation of expressions
   1165            - Variables
   1166            - Override control (TBD)
   1167            - Tool changes
   1168            - Switches
   1169          
   1170             (*) Indicates optional parameter, enabled through config.h and re-compile
   1171             group 0 = {G92.2, G92.3} (Non modal: Cancel and re-enable G92 offsets)
   1172             group 1 = {G81 - G89} (Motion modes: Canned cycles)
   1173             group 4 = {M1} (Optional stop, ignored)
   1174             group 6 = {M6} (Tool change)
   1175             group 7 = {G41, G42} cutter radius compensation (G40 is supported)
   1176             group 8 = {G43} tool length offset (G43.1/G49 are supported)
   1177             group 8 = {M7*} enable mist coolant (* Compile-option)
   1178          	 group 9 = {M48, M49, M56*} enable/disable override switches (* Compile-option)
   1179          	 group 10 = {G98, G99} return mode canned cycles
   1180             group 13 = {G61.1, G64} path control mode (G61 is supported)
   1181          */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     104   gc_execute_line
       104   -> __aeabi_f2iz
       104   -> __aeabi_f2uiz
       104   -> __aeabi_fadd
       104   -> __aeabi_fdiv
       104   -> __aeabi_fmul
       104   -> __aeabi_fsub
       104   -> __aeabi_memcpy
       104   -> __aeabi_memset
       104   -> __aeabi_ui2f
       104   -> coolant_set_state
       104   -> coolant_sync
       104   -> gc_sync_position
       104   -> hypot_f
       104   -> jog_execute
       104   -> lroundf
       104   -> mc_arc
       104   -> mc_dwell
       104   -> mc_line
       104   -> mc_probe_cycle
       104   -> memcmp
       104   -> protocol_buffer_synchronize
       104   -> protocol_execute_realtime
       104   -> read_float
       104   -> report_feedback_message
       104   -> settings_read_coord_data
       104   -> settings_write_coord_data
       104   -> spindle_set_state
       104   -> spindle_sync
       104   -> sqrtf
       104   -> system_flag_wco_change
       104   -> system_set_exec_state_flag
       104   -> truncf
       104 __aeabi_cfcmpeq
       104 __aeabi_cfcmple
       104 __aeabi_cfrcmple
      24   gc_init
        24   -> __aeabi_memset
        24   -> report_status_message
        24   -> settings_read_coord_data
       8   gc_sync_position
         8   -> system_convert_array_steps_to_mpos


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
      64  gc_block
    4904  gc_execute_line
      42  gc_init
      68  gc_state
      12  gc_sync_position

 
   132 bytes in section .bss
 4'990 bytes in section .text
 
 4'990 bytes of CODE memory
   132 bytes of DATA memory

Errors: none
Warnings: none
