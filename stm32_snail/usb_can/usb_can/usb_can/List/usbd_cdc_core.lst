###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         05/Dec/2020  18:54:23
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\common\usb\cdc\usbd_cdc_core.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EW2697.tmp
#        (D:\proj\velograph\snail\stm32_snail\common\usb\cdc\usbd_cdc_core.c -D
#        VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -D MSTEP_BRD -D USE_USB_OTG_FS
#        -lcN D:\proj\velograph\snail\stm32_snail\mstep_usb\usb_can\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\usb_can\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\.\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_usb\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\libraries\inc\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\dbg\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\usb\core\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\usb\drv\inc\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\usb\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\usb\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\hdlc\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\usb\cdc\ -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\usb_can\List\usbd_cdc_core.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\usb_can\Obj\usbd_cdc_core.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\common\usb\cdc\usbd_cdc_core.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbd_cdc_core.c
      4            * @author  MCD Application Team
      5            * @version V1.2.0
      6            * @date    09-November-2015
      7            * @brief   This file provides the high layer firmware functions to manage the 
      8            *          following functionalities of the USB CDC Class:
      9            *           - Initialization and Configuration of high and low layer
     10            *           - Enumeration as CDC Device (and enumeration for each implemented memory interface)
     11            *           - OUT/IN data transfer
     12            *           - Command IN transfer (class requests management)
     13            *           - Error management
     14            *           
     15            *  @verbatim
     16            *      
     17            *          ===================================================================      
     18            *                                CDC Class Driver Description
     19            *          =================================================================== 
     20            *           This driver manages the "Universal Serial Bus Class Definitions for Communications Devices
     21            *           Revision 1.2 November 16, 2007" and the sub-protocol specification of "Universal Serial Bus 
     22            *           Communications Class Subclass Specification for PSTN Devices Revision 1.2 February 9, 2007"
     23            *           This driver implements the following aspects of the specification:
     24            *             - Device descriptor management
     25            *             - Configuration descriptor management
     26            *             - Enumeration as CDC device with 2 data endpoints (IN and OUT) and 1 command endpoint (IN)
     27            *             - Requests management (as described in section 6.2 in specification)
     28            *             - Abstract Control Model compliant
     29            *             - Union Functional collection (using 1 IN endpoint for control)
     30            *             - Data interface class
     31          
     32            *           @note
     33            *             For the Abstract Control Model, this core allows only transmitting the requests to
     34            *             lower layer dispatcher (ie. usbd_cdc_vcp.c/.h) which should manage each request and
     35            *             perform relative actions.
     36            * 
     37            *           These aspects may be enriched or modified for a specific user application.
     38            *          
     39            *            This driver doesn't implement the following aspects of the specification 
     40            *            (but it is possible to manage these features with some modifications on this driver):
     41            *             - Any class-specific aspect relative to communication classes should be managed by user application.
     42            *             - All communication classes other than PSTN are not managed
     43            *      
     44            *  @endverbatim
     45            *                                  
     46            ******************************************************************************
     47            * @attention
     48            *
     49            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     50            *
     51            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     52            * You may not use this file except in compliance with the License.
     53            * You may obtain a copy of the License at:
     54            *
     55            *        http://www.st.com/software_license_agreement_liberty_v2
     56            *
     57            * Unless required by applicable law or agreed to in writing, software 
     58            * distributed under the License is distributed on an "AS IS" BASIS, 
     59            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     60            * See the License for the specific language governing permissions and
     61            * limitations under the License.
     62            *
     63            ******************************************************************************
     64            */ 
     65          
     66          /* Includes ------------------------------------------------------------------*/
     67          #include "usbd_cdc_core.h"
     68          #include "usbd_desc.h"
     69          #include "usbd_req.h"
     70          
     71          
     72          /** @addtogroup STM32_USB_OTG_DEVICE_LIBRARY
     73            * @{
     74            */
     75          
     76          
     77          /** @defgroup usbd_cdc 
     78            * @brief usbd core module
     79            * @{
     80            */ 
     81          
     82          /** @defgroup usbd_cdc_Private_TypesDefinitions
     83            * @{
     84            */ 
     85          /**
     86            * @}
     87            */ 
     88          
     89          
     90          /** @defgroup usbd_cdc_Private_Defines
     91            * @{
     92            */ 
     93          
     94          #define USB_CDC_IDLE         0
     95          #define USB_CDC_BUSY         1
     96          #define USB_CDC_ZLP          2
     97          
     98          /**
     99            * @}
    100            */ 
    101          
    102          
    103          /** @defgroup usbd_cdc_Private_Macros
    104            * @{
    105            */ 
    106          /**
    107            * @}
    108            */ 
    109          
    110          
    111          /** @defgroup usbd_cdc_Private_FunctionPrototypes
    112            * @{
    113            */
    114          
    115          /*********************************************
    116             CDC Device library callbacks
    117           *********************************************/
    118          uint8_t  usbd_cdc_Init        (void  *pdev, uint8_t cfgidx);
    119          uint8_t  usbd_cdc_DeInit      (void  *pdev, uint8_t cfgidx);
    120          uint8_t  usbd_cdc_Setup       (void  *pdev, USB_SETUP_REQ *req);
    121          uint8_t  usbd_cdc_EP0_RxReady  (void *pdev);
    122          uint8_t  usbd_cdc_DataIn      (void *pdev, uint8_t epnum);
    123          uint8_t  usbd_cdc_DataOut     (void *pdev, uint8_t epnum);
    124          uint8_t  usbd_cdc_SOF         (void *pdev);
    125          
    126          /*********************************************
    127             CDC specific management functions
    128           *********************************************/
    129          static void Handle_USBAsynchXfer  (void *pdev);
    130          static uint8_t  *USBD_cdc_GetCfgDesc (uint8_t speed, uint16_t *length);
    131          #ifdef USE_USB_OTG_HS  
    132          static uint8_t  *USBD_cdc_GetOtherCfgDesc (uint8_t speed, uint16_t *length);
    133          #endif
    134          /**
    135            * @}
    136            */ 
    137          
    138          /** @defgroup usbd_cdc_Private_Variables
    139            * @{
    140            */ 
    141          extern CDC_IF_Prop_TypeDef  APP_FOPS;
    142          extern uint8_t USBD_DeviceDesc   [USB_SIZ_DEVICE_DESC];
    143          
    144          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
    145            #if defined ( __ICCARM__ ) /*!< IAR Compiler */
    146              #pragma data_alignment=4   
    147            #endif
    148          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    149          __ALIGN_BEGIN uint8_t usbd_cdc_CfgDesc  [USB_CDC_CONFIG_DESC_SIZ] __ALIGN_END ;
    150          
    151          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
    152            #if defined ( __ICCARM__ ) /*!< IAR Compiler */
    153              #pragma data_alignment=4   
    154            #endif
    155          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    156          __ALIGN_BEGIN uint8_t usbd_cdc_OtherCfgDesc  [USB_CDC_CONFIG_DESC_SIZ] __ALIGN_END ;
    157          
    158          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
    159            #if defined ( __ICCARM__ ) /*!< IAR Compiler */
    160              #pragma data_alignment=4   
    161            #endif
    162          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    163          __ALIGN_BEGIN static __IO uint32_t  usbd_cdc_AltSet  __ALIGN_END = 0;
    164          
    165          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
    166            #if defined ( __ICCARM__ ) /*!< IAR Compiler */
    167              #pragma data_alignment=4   
    168            #endif
    169          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    170          __ALIGN_BEGIN uint8_t USB_Rx_Buffer   [CDC_DATA_MAX_PACKET_SIZE] __ALIGN_END ;
    171          
    172          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
    173            #if defined ( __ICCARM__ ) /*!< IAR Compiler */
    174              #pragma data_alignment=4   
    175            #endif
    176          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    177          __ALIGN_BEGIN uint8_t APP_Rx_Buffer   [APP_RX_DATA_SIZE] __ALIGN_END ; 
    178          
    179          
    180          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
    181            #if defined ( __ICCARM__ ) /*!< IAR Compiler */
    182              #pragma data_alignment=4   
    183            #endif
    184          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    185          __ALIGN_BEGIN uint8_t CmdBuff[CDC_CMD_PACKET_SZE] __ALIGN_END ;
    186          
    187          uint32_t APP_Rx_ptr_in  = 0;
    188          uint32_t APP_Rx_ptr_out = 0;
    189          uint32_t APP_Rx_length  = 0;
    190          
    191          uint8_t  USB_Tx_State = USB_CDC_IDLE;
    192          
    193          static uint32_t cdcCmd = 0xFF;
    194          static uint32_t cdcLen = 0;
    195          
    196          /* CDC interface class callbacks structure */
    197          USBD_Class_cb_TypeDef  USBD_CDC_cb = 
    198          {
    199            usbd_cdc_Init,
    200            usbd_cdc_DeInit,
    201            usbd_cdc_Setup,
    202            NULL,                 /* EP0_TxSent, */
    203            usbd_cdc_EP0_RxReady,
    204            usbd_cdc_DataIn,
    205            usbd_cdc_DataOut,
    206            usbd_cdc_SOF,
    207            NULL,
    208            NULL,     
    209            USBD_cdc_GetCfgDesc,
    210          };
    211          
    212          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
    213            #if defined ( __ICCARM__ ) /*!< IAR Compiler */
    214              #pragma data_alignment=4   
    215            #endif
    216          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    217          /* USB CDC device Configuration Descriptor */
    218          __ALIGN_BEGIN uint8_t usbd_cdc_CfgDesc[USB_CDC_CONFIG_DESC_SIZ]  __ALIGN_END =
    219          {
    220            /*Configuration Descriptor*/
    221            0x09,   /* bLength: Configuration Descriptor size */
    222            USB_CONFIGURATION_DESCRIPTOR_TYPE,      /* bDescriptorType: Configuration */
    223            USB_CDC_CONFIG_DESC_SIZ,                /* wTotalLength:no of returned bytes */
    224            0x00,
    225            0x02,   /* bNumInterfaces: 2 interface */
    226            0x01,   /* bConfigurationValue: Configuration value */
    227            0x00,   /* iConfiguration: Index of string descriptor describing the configuration */
    228            0xC0,   /* bmAttributes: self powered */
    229            0x32,   /* MaxPower 0 mA */
    230            
    231            /*---------------------------------------------------------------------------*/
    232            
    233            /*Interface Descriptor */
    234            0x09,   /* bLength: Interface Descriptor size */
    235            USB_INTERFACE_DESCRIPTOR_TYPE,  /* bDescriptorType: Interface */
    236            /* Interface descriptor type */
    237            0x00,   /* bInterfaceNumber: Number of Interface */
    238            0x00,   /* bAlternateSetting: Alternate setting */
    239            0x01,   /* bNumEndpoints: One endpoints used */
    240            0x02,   /* bInterfaceClass: Communication Interface Class */
    241            0x02,   /* bInterfaceSubClass: Abstract Control Model */
    242            0x01,   /* bInterfaceProtocol: Common AT commands */
    243            0x00,   /* iInterface: */
    244            
    245            /*Header Functional Descriptor*/
    246            0x05,   /* bLength: Endpoint Descriptor size */
    247            0x24,   /* bDescriptorType: CS_INTERFACE */
    248            0x00,   /* bDescriptorSubtype: Header Func Desc */
    249            0x10,   /* bcdCDC: spec release number */
    250            0x01,
    251            
    252            /*Call Management Functional Descriptor*/
    253            0x05,   /* bFunctionLength */
    254            0x24,   /* bDescriptorType: CS_INTERFACE */
    255            0x01,   /* bDescriptorSubtype: Call Management Func Desc */
    256            0x00,   /* bmCapabilities: D0+D1 */
    257            0x01,   /* bDataInterface: 1 */
    258            
    259            /*ACM Functional Descriptor*/
    260            0x04,   /* bFunctionLength */
    261            0x24,   /* bDescriptorType: CS_INTERFACE */
    262            0x02,   /* bDescriptorSubtype: Abstract Control Management desc */
    263            0x02,   /* bmCapabilities */
    264            
    265            /*Union Functional Descriptor*/
    266            0x05,   /* bFunctionLength */
    267            0x24,   /* bDescriptorType: CS_INTERFACE */
    268            0x06,   /* bDescriptorSubtype: Union func desc */
    269            0x00,   /* bMasterInterface: Communication class interface */
    270            0x01,   /* bSlaveInterface0: Data Class Interface */
    271            
    272            /*Endpoint 2 Descriptor*/
    273            0x07,                           /* bLength: Endpoint Descriptor size */
    274            USB_ENDPOINT_DESCRIPTOR_TYPE,   /* bDescriptorType: Endpoint */
    275            CDC_CMD_EP,                     /* bEndpointAddress */
    276            0x03,                           /* bmAttributes: Interrupt */
    277            LOBYTE(CDC_CMD_PACKET_SZE),     /* wMaxPacketSize: */
    278            HIBYTE(CDC_CMD_PACKET_SZE),
    279            0xFF,                           /* bInterval: */
    280            
    281            /*---------------------------------------------------------------------------*/
    282            
    283            /*Data class interface descriptor*/
    284            0x09,   /* bLength: Endpoint Descriptor size */
    285            USB_INTERFACE_DESCRIPTOR_TYPE,  /* bDescriptorType: */
    286            0x01,   /* bInterfaceNumber: Number of Interface */
    287            0x00,   /* bAlternateSetting: Alternate setting */
    288            0x02,   /* bNumEndpoints: Two endpoints used */
    289            0x0A,   /* bInterfaceClass: CDC */
    290            0x00,   /* bInterfaceSubClass: */
    291            0x00,   /* bInterfaceProtocol: */
    292            0x00,   /* iInterface: */
    293            
    294            /*Endpoint OUT Descriptor*/
    295            0x07,   /* bLength: Endpoint Descriptor size */
    296            USB_ENDPOINT_DESCRIPTOR_TYPE,      /* bDescriptorType: Endpoint */
    297            CDC_OUT_EP,                        /* bEndpointAddress */
    298            0x02,                              /* bmAttributes: Bulk */
    299            LOBYTE(CDC_DATA_MAX_PACKET_SIZE),  /* wMaxPacketSize: */
    300            HIBYTE(CDC_DATA_MAX_PACKET_SIZE),
    301            0x00,                              /* bInterval: ignore for Bulk transfer */
    302            
    303            /*Endpoint IN Descriptor*/
    304            0x07,   /* bLength: Endpoint Descriptor size */
    305            USB_ENDPOINT_DESCRIPTOR_TYPE,      /* bDescriptorType: Endpoint */
    306            CDC_IN_EP,                         /* bEndpointAddress */
    307            0x02,                              /* bmAttributes: Bulk */
    308            LOBYTE(CDC_DATA_MAX_PACKET_SIZE),  /* wMaxPacketSize: */
    309            HIBYTE(CDC_DATA_MAX_PACKET_SIZE),
    310            0x00                               /* bInterval: ignore for Bulk transfer */
    311          } ;
    312          
    313          
    314          /**
    315            * @brief  usbd_cdc_Init
    316            *         Initialize the CDC interface
    317            * @param  pdev: device instance
    318            * @param  cfgidx: Configuration index
    319            * @retval status
    320            */
    321          uint8_t  usbd_cdc_Init (void  *pdev, 
    322                                         uint8_t cfgidx)
    323          {
    324            uint8_t *pbuf;
    325          
    326            /* Open EP IN */
    327            DCD_EP_Open(pdev,
    328                        CDC_IN_EP,
    329                        CDC_DATA_IN_PACKET_SIZE,
    330                        USB_OTG_EP_BULK);
    331            
    332            /* Open EP OUT */
    333            DCD_EP_Open(pdev,
    334                        CDC_OUT_EP,
    335                        CDC_DATA_OUT_PACKET_SIZE,
    336                        USB_OTG_EP_BULK);
    337            
    338            /* Open Command IN EP */
    339            DCD_EP_Open(pdev,
    340                        CDC_CMD_EP,
    341                        CDC_CMD_PACKET_SZE,
    342                        USB_OTG_EP_INT);
    343            
    344            pbuf = (uint8_t *)USBD_DeviceDesc;
    345            pbuf[4] = DEVICE_CLASS_CDC;
    346            pbuf[5] = DEVICE_SUBCLASS_CDC;
    347            
    348            /* Initialize the Interface physical components */
    349            APP_FOPS.pIf_Init();
    350          
    351            /* Prepare Out endpoint to receive next packet */
    352            DCD_EP_PrepareRx(pdev,
    353                             CDC_OUT_EP,
    354                             (uint8_t*)(USB_Rx_Buffer),
    355                             CDC_DATA_OUT_PACKET_SIZE);
    356            
    357            return USBD_OK;
    358          }
    359          
    360          /**
    361            * @brief  usbd_cdc_Init
    362            *         DeInitialize the CDC layer
    363            * @param  pdev: device instance
    364            * @param  cfgidx: Configuration index
    365            * @retval status
    366            */
    367          uint8_t  usbd_cdc_DeInit (void  *pdev, 
    368                                           uint8_t cfgidx)
    369          {
    370            /* Open EP IN */
    371            DCD_EP_Close(pdev,
    372                        CDC_IN_EP);
    373            
    374            /* Open EP OUT */
    375            DCD_EP_Close(pdev,
    376                        CDC_OUT_EP);
    377            
    378            /* Open Command IN EP */
    379            DCD_EP_Close(pdev,
    380                        CDC_CMD_EP);
    381          
    382            /* Restore default state of the Interface physical components */
    383            APP_FOPS.pIf_DeInit();
    384            
    385            return USBD_OK;
    386          }
    387          
    388          /**
    389            * @brief  usbd_cdc_Setup
    390            *         Handle the CDC specific requests
    391            * @param  pdev: instance
    392            * @param  req: usb requests
    393            * @retval status
    394            */
    395          uint8_t  usbd_cdc_Setup (void  *pdev, 
    396                                          USB_SETUP_REQ *req)
    397          {
    398            switch (req->bmRequest & USB_REQ_TYPE_MASK)
    399            {
    400              /* CDC Class Requests -------------------------------*/
    401            case USB_REQ_TYPE_CLASS :
    402                /* Check if the request is a data setup packet */
    403                if (req->wLength)
    404                {
    405                  /* Check if the request is Device-to-Host */
    406                  if (req->bmRequest & 0x80)
    407                  {
    408                    /* Get the data to be sent to Host from interface layer */
    409                    APP_FOPS.pIf_Ctrl(req->bRequest, CmdBuff, req->wLength);
    410                    
    411                    /* Send the data to the host */
    412                    USBD_CtlSendData (pdev, 
    413                                      CmdBuff,
    414                                      req->wLength);          
    415                  }
    416                  else /* Host-to-Device request */
    417                  {
    418                    /* Set the value of the current command to be processed */
    419                    cdcCmd = req->bRequest;
    420                    cdcLen = req->wLength;
    421                    
    422                    /* Prepare the reception of the buffer over EP0
    423                    Next step: the received data will be managed in usbd_cdc_EP0_TxSent() 
    424                    function. */
    425                    USBD_CtlPrepareRx (pdev,
    426                                       CmdBuff,
    427                                       req->wLength);          
    428                  }
    429                }
    430                else /* No Data request */
    431                {
    432                  /* Transfer the command to the interface layer */
    433                  APP_FOPS.pIf_Ctrl(req->bRequest, NULL, 0);
    434                }
    435                
    436                return USBD_OK;
    437                
    438              default:
    439                USBD_CtlError (pdev, req);
    440                return USBD_FAIL;
    441              
    442              /* Standard Requests -------------------------------*/
    443            case USB_REQ_TYPE_STANDARD:
    444              switch (req->bRequest)
    445              {
    446              case USB_REQ_GET_DESCRIPTOR: 
    447                USBD_CtlError (pdev, req);
    448                return USBD_FAIL;
    449                
    450              case USB_REQ_GET_INTERFACE :
    451                USBD_CtlSendData (pdev,
    452                                  (uint8_t *)&usbd_cdc_AltSet,
    453                                  1);
    454                break;
    455                
    456              case USB_REQ_SET_INTERFACE :
    457                if ((uint8_t)(req->wValue) < USBD_ITF_MAX_NUM)
    458                {
    459                  usbd_cdc_AltSet = (uint8_t)(req->wValue);
    460                }
    461                else
    462                {
    463                  /* Call the error management function (command will be nacked */
    464                  USBD_CtlError (pdev, req);
    465                }
    466                break;
    467              }
    468            }
    469            return USBD_OK;
    470          }
    471          
    472          /**
    473            * @brief  usbd_cdc_EP0_RxReady
    474            *         Data received on control endpoint
    475            * @param  pdev: device instance
    476            * @retval status
    477            */
    478          uint8_t  usbd_cdc_EP0_RxReady (void  *pdev)
    479          { 
    480            if (cdcCmd != NO_CMD)
    481            {
    482              /* Process the data */
    483              APP_FOPS.pIf_Ctrl(cdcCmd, CmdBuff, cdcLen);
    484              
    485              /* Reset the command variable to default value */
    486              cdcCmd = NO_CMD;
    487            }
    488            
    489            return USBD_OK;
    490          }
    491          
    492          
    493          /**
    494            * @brief  usbd_audio_DataIn
    495            *         Data sent on non-control IN endpoint
    496            * @param  pdev: device instance
    497            * @param  epnum: endpoint number
    498            * @retval status
    499            */
    500          uint8_t  usbd_cdc_DataIn (void *pdev, uint8_t epnum)
    501          {
    502            uint16_t USB_Tx_ptr;
    503            uint16_t USB_Tx_length;
    504            
    505            if (USB_Tx_State == USB_CDC_BUSY)
    506            {
    507              if (APP_Rx_length == 0) 
    508              {
    509                USB_Tx_State = USB_CDC_IDLE;
    510              }
    511              else 
    512              {
    513                if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE){
    514                  USB_Tx_ptr = APP_Rx_ptr_out;
    515                  USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
    516                  
    517                  APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;
    518                  APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;    
    519                }
    520                else 
    521                {
    522                  USB_Tx_ptr = APP_Rx_ptr_out;
    523                  USB_Tx_length = APP_Rx_length;
    524                  
    525                  APP_Rx_ptr_out += APP_Rx_length;
    526                  APP_Rx_length = 0;
    527                  if(USB_Tx_length == CDC_DATA_IN_PACKET_SIZE)
    528                  {
    529                    USB_Tx_State = USB_CDC_ZLP;
    530                  }
    531                }
    532                
    533                /* Prepare the available data buffer to be sent on IN endpoint */
    534                DCD_EP_Tx (pdev,
    535                           CDC_IN_EP,
    536                           (uint8_t*)&APP_Rx_Buffer[USB_Tx_ptr],
    537                           USB_Tx_length);
    538                return USBD_OK;
    539              }
    540            }  
    541            
    542            /* Avoid any asynchronous transfer during ZLP */
    543            if (USB_Tx_State == USB_CDC_ZLP)
    544            {
    545              /*Send ZLP to indicate the end of the current transfer */
    546              DCD_EP_Tx (pdev,
    547                         CDC_IN_EP,
    548                         NULL,
    549                         0);
    550              
    551              USB_Tx_State = USB_CDC_IDLE;
    552            }
    553            return USBD_OK;
    554          }
    555          
    556          /**
    557            * @brief  usbd_cdc_DataOut
    558            *         Data received on non-control Out endpoint
    559            * @param  pdev: device instance
    560            * @param  epnum: endpoint number
    561            * @retval status
    562            */
    563          uint8_t  usbd_cdc_DataOut (void *pdev, uint8_t epnum)
    564          {      
    565            uint16_t USB_Rx_Cnt;
    566            
    567            /* Get the received data buffer and update the counter */
    568            USB_Rx_Cnt = ((USB_OTG_CORE_HANDLE*)pdev)->dev.out_ep[epnum].xfer_count;
    569            
    570            /* USB data will be immediately processed, this allow next USB traffic being 
    571            NAKed till the end of the application Xfer */
    572            APP_FOPS.pIf_DataRx(USB_Rx_Buffer, USB_Rx_Cnt);
    573            
    574            /* Prepare Out endpoint to receive next packet */
    575            DCD_EP_PrepareRx(pdev,
    576                             CDC_OUT_EP,
    577                             (uint8_t*)(USB_Rx_Buffer),
    578                             CDC_DATA_OUT_PACKET_SIZE);
    579            
    580            return USBD_OK;
    581          }
    582          
    583          /**
    584            * @brief  usbd_audio_SOF
    585            *         Start Of Frame event management
    586            * @param  pdev: instance
    587            * @param  epnum: endpoint number
    588            * @retval status
    589            */
    590          uint8_t  usbd_cdc_SOF (void *pdev)
    591          {      
    592            static uint32_t FrameCount = 0;
    593            
    594            if (FrameCount++ == CDC_IN_FRAME_INTERVAL)
    595            {
    596              /* Reset the frame counter */
    597              FrameCount = 0;
    598              
    599              /* Check the data to be sent through IN pipe */
    600              Handle_USBAsynchXfer(pdev);
    601            }
    602            
    603            return USBD_OK;
    604          }
    605          
    606          /**
    607            * @brief  Handle_USBAsynchXfer
    608            *         Send data to USB
    609            * @param  pdev: instance
    610            * @retval None
    611            */
    612          static void Handle_USBAsynchXfer (void *pdev)
    613          {
    614            uint16_t USB_Tx_ptr;
    615            uint16_t USB_Tx_length;
    616            
    617            if(USB_Tx_State == USB_CDC_IDLE)
    618            {
    619              if (APP_Rx_ptr_out == APP_RX_DATA_SIZE)
    620              {
    621                APP_Rx_ptr_out = 0;
    622              }
    623              
    624              if(APP_Rx_ptr_out == APP_Rx_ptr_in) 
    625              {
    626                USB_Tx_State = USB_CDC_IDLE; 
    627                return;
    628              }
    629              
    630              if(APP_Rx_ptr_out > APP_Rx_ptr_in) /* rollback */
    631              { 
    632                APP_Rx_length = APP_RX_DATA_SIZE - APP_Rx_ptr_out;
    633                
    634              }
    635              else 
    636              {
    637                APP_Rx_length = APP_Rx_ptr_in - APP_Rx_ptr_out;
    638                
    639              }
    640          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
    641              APP_Rx_length &= ~0x03;
    642          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
    643              
    644              if (APP_Rx_length > CDC_DATA_IN_PACKET_SIZE)
    645              {
    646                USB_Tx_ptr = APP_Rx_ptr_out;
    647                USB_Tx_length = CDC_DATA_IN_PACKET_SIZE;
    648                
    649                APP_Rx_ptr_out += CDC_DATA_IN_PACKET_SIZE;	
    650                APP_Rx_length -= CDC_DATA_IN_PACKET_SIZE;
    651                USB_Tx_State = USB_CDC_BUSY;
    652              }
    653              else
    654              {
    655                USB_Tx_ptr = APP_Rx_ptr_out;
    656                USB_Tx_length = APP_Rx_length;
    657                
    658                APP_Rx_ptr_out += APP_Rx_length;
    659                APP_Rx_length = 0;
    660                if(USB_Tx_length == CDC_DATA_IN_PACKET_SIZE)
    661                {
    662                  USB_Tx_State = USB_CDC_ZLP;
    663                }
    664                else
    665                {
    666                  USB_Tx_State = USB_CDC_BUSY;
    667                }
    668              }
    669              
    670              DCD_EP_Tx (pdev,
    671                         CDC_IN_EP,
    672                         (uint8_t*)&APP_Rx_Buffer[USB_Tx_ptr],
    673                         USB_Tx_length);
    674            }  
    675          }
    676          
    677          /**
    678            * @brief  USBD_cdc_GetCfgDesc 
    679            *         Return configuration descriptor
    680            * @param  speed : current device speed
    681            * @param  length : pointer data length
    682            * @retval pointer to descriptor buffer
    683            */
    684          static uint8_t  *USBD_cdc_GetCfgDesc (uint8_t speed, uint16_t *length)
    685          {
    686            *length = sizeof (usbd_cdc_CfgDesc);
    687            return usbd_cdc_CfgDesc;
    688          }
    689          
    690          /**
    691            * @brief  USBD_cdc_GetCfgDesc 
    692            *         Return configuration descriptor
    693            * @param  speed : current device speed
    694            * @param  length : pointer data length
    695            * @retval pointer to descriptor buffer
    696            */
    697          #ifdef USE_USB_OTG_HS 
    698          static uint8_t  *USBD_cdc_GetOtherCfgDesc (uint8_t speed, uint16_t *length)
    699          {
    700            *length = sizeof (usbd_cdc_OtherCfgDesc);
    701            return usbd_cdc_OtherCfgDesc;
    702          }
    703          #endif
    704          /**
    705            * @}
    706            */ 
    707          
    708          /**
    709            * @}
    710            */ 
    711          
    712          /**
    713            * @}
    714            */ 
    715          
    716          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   Handle_USBAsynchXfer
        24   -> DCD_EP_Tx
       0   USBD_cdc_GetCfgDesc
      24   usbd_cdc_DataIn
        24   -> DCD_EP_Tx
      24   usbd_cdc_DataOut
        24   -- Indirect call
        24   -> DCD_EP_PrepareRx
      16   usbd_cdc_DeInit
        16   -- Indirect call
        16   -> DCD_EP_Close
      16   usbd_cdc_EP0_RxReady
        16   -- Indirect call
      16   usbd_cdc_Init
        16   -- Indirect call
        16   -> DCD_EP_Open
        16   -> DCD_EP_PrepareRx
       8   usbd_cdc_SOF
         8   -> Handle_USBAsynchXfer
      16   usbd_cdc_Setup
        16   -- Indirect call
        16   -> USBD_CtlError
        16   -> USBD_CtlPrepareRx
        16   -> USBD_CtlSendData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
    1024  APP_Rx_Buffer
       4  APP_Rx_length
       4  APP_Rx_ptr_in
       4  APP_Rx_ptr_out
       8  CmdBuff
       4  FrameCount
     168  Handle_USBAsynchXfer
      44  USBD_CDC_cb
      10  USBD_cdc_GetCfgDesc
      64  USB_Rx_Buffer
       1  USB_Tx_State
       4  cdcCmd
       4  cdcLen
       4  usbd_cdc_AltSet
      68  usbd_cdc_CfgDesc
     144  usbd_cdc_DataIn
      52  usbd_cdc_DataOut
      40  usbd_cdc_DeInit
      34  usbd_cdc_EP0_RxReady
      74  usbd_cdc_Init
      68  usbd_cdc_OtherCfgDesc
      30  usbd_cdc_SOF
     180  usbd_cdc_Setup

 
 1'189 bytes in section .bss
   116 bytes in section .data
   788 bytes in section .text
 
   788 bytes of CODE memory
 1'305 bytes of DATA memory

Errors: none
Warnings: none
