###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         09/May/2021  15:42:34
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can\common\hdlc\hdlc1.c
#    Command line =
#        -f C:\Users\vagol\AppData\Local\Temp\EWE2B3.tmp
#        (D:\proj\velograph\snail\stm32_snail\usb_can\common\hdlc\hdlc1.c -D
#        VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -D MSTEP_BRD -D USE_USB_OTG_FS
#        -lcN D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\.\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\dbg\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\core\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\drv\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\hdlc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\cdc\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\List\hdlc1.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\Obj\hdlc1.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\usb_can\common\hdlc\hdlc1.c
      1          ///#ifdef EMW3165
      2            #include "stm32f2xx.h"
      3            #include "stm32f2xx_conf.h"
      4          
      5          #include <string.h>
      6          #include <stdlib.h>
      7          #include <stdio.h>
      8          
      9          #include "FreeRTOS.h"
     10          #include "task.h"
     11          #include "queue.h"
     12          #include "_hdlc.h"
     13          #include "my_types.h"
     14          #include "printk.h"
     15          
     16          extern void addfcs16(unsigned char *cp,int len );
     17          ///============================
     18          /*
     19          xQueueHandle ev_rsv_ack;
     20          xQueueHandle ev_rsv_dat;
     21          xQueueHandle ev_rsv_frame;
     22          xQueueHandle ev_snd_frame;
     23          ///xQueueHandle ua_rsv_dat;
     24          xQueueHandle ua_snd_dat;
     25          */
     26          ///============================
     27          ///==================================
     28          ////#define HDLC1_OBR_BUF_LENGTH_MAX   8192
     29          ///#define hdlc1_obr_buff g_hdlc_st.obr_buff
     30          ///#define hdlc1_tbuff1_send g_hdlc_st.t_snd_buff1
     31          ///#define hdlc1_tbuff2_send g_hdlc_st.t_snd_buff2
     32          
     33          ///==============================
     34          void hdlc1_error( char const *err )
     35          {
     36          puts(err);
     37          }
     38          ///==============================
     39          void hdlc1_init(hdlc_stat_t *p_hdlc)
     40          {
     41          p_hdlc->frame_in_pos  =0;	
     42          p_hdlc->in_esc_byte		=0;	
     43          p_hdlc->frame_out_len	= 0;
     44          p_hdlc->snd_buff_len= 0;
     45          p_hdlc->snd_buff1_len= 0;
     46          ///p_hdlc->snd_buff2_len= 0;
     47          p_hdlc->in_buf = (u8*) pvPortMalloc( HDLC1_MAX_FRAME_LEN );
     48          if( p_hdlc->in_buf == NULL ) 
     49          	hdlc1_error("hdlc_frames_init(): NO MEM\n");
     50          
     51          p_hdlc->snd_buff	= (uint8_t*)pvPortMalloc(HDLC1_MAX_FRAME_LEN);
     52          if(p_hdlc->snd_buff == NULL )
     53          	hdlc1_error("hdlc1_init(): NO MEM FOR SND_BUF\n");
     54          p_hdlc->obr_buff	= (uint8_t*)pvPortMalloc(HDLC1_MAX_FRAME_LEN);
     55          if( p_hdlc->obr_buff == NULL )
     56          	hdlc1_error("hdlc1_init(): NO MEM FOR OBR_TMPBUF\n");
     57          	
     58          p_hdlc->t_snd_buff1 = (u8*)pvPortMalloc(HDLC1_MAX_FRAME_LEN);
     59          if(p_hdlc->t_snd_buff1 == NULL)
     60          	{
     61          	hdlc1_error("hdlc1_init(): NO MEM FOR hdlc1_tbuff_send\n");
     62          	return ;	
     63          	}
     64          memset(p_hdlc->t_snd_buff1,0,HDLC1_MAX_FRAME_LEN);	
     65          #if 0
     66          p_hdlc->t_snd_buff2 = (u8*)pvPortMalloc(HDLC1_MAX_FRAME_LEN);
     67          if(p_hdlc->t_snd_buff2 == NULL)
     68          	{
     69          	hdlc1_error("hdlc1_init(): NO MEM FOR hdlc1_tbuff_send\n");
     70          	return ;	
     71          	}
     72          #endif
     73          
     74          }
     75          
     76          ///======================================
     77          ///	Обработка ошибки длины входящего кадра
     78          #if 0
     79          void hdlc1_error_frame_len(hdlc_stat_t *p_hdlc)
     80          {
     81          p_hdlc->err_len++;
     82          }
     83          #endif
     84          ///volatile uint8_t tst_buf[512];
     85          ///int ptr_tst_buf=0;
     86          ///========================================================
     87          uint8_t hdlc1_send_iframe(hdlc_stat_t *p_hdlc,u8 *data, int len)
     88          {
     89          ////frame_t fr;
     90          uint16_t len_o=0;
     91          u16 ii;
     92          u8 bt;
     93          uint8_t rez=TRUE;
     94          ///================================
     95          ////p_hdlc->snd_buff2_len=0;
     96          ///================================
     97          memcpy(p_hdlc->snd_buff, data, len );
     98          p_hdlc->frame_out_len=len ;
     99          addfcs16(p_hdlc->snd_buff,p_hdlc->frame_out_len);				// Добавить циклический код
    100          p_hdlc->frame_out_len += 2;
    101          p_hdlc->fn_send_byte(PPP_FRAME);
    102          len_o++;
    103          for(ii=0;ii<p_hdlc->frame_out_len;ii++)
    104          	{
    105          	bt = p_hdlc->snd_buff[ii];
    106          	if( bt == PPP_FRAME || bt == PPP_ESCAPE )			// Замена "FLAG" или "ESC" на ESC-последовательность
    107          		{
    108          		p_hdlc->fn_send_byte(PPP_ESCAPE);
    109          		len_o++;
    110          		p_hdlc->fn_send_byte((bt ^ PPP_ESCAPE_BIT));
    111          		len_o++;
    112          		}
    113          	else
    114          		{
    115          		p_hdlc->fn_send_byte(bt);
    116          		len_o++;
    117          		}
    118          		}
    119          p_hdlc->fn_send_byte(PPP_FRAME);
    120          ///len_o++;
    121          ///put_tst1(0);
    122          
    123          ////rez = hdlc1_send_frame(send_byte_ua0,&snd_fr);
    124          ////p_hdlc->fn_send_frame(p_hdlc->t_snd_buff2,len_o);
    125          
    126          return rez;
    127          }
    128          
    129          ///==============================
    130          int hdlc1_parse_iframe(hdlc_stat_t *p_hdlc,u8 *in_buf,u16 len)
    131          {
    132          int rez =0;
    133          u8 btmp;
    134          uint32_t wtmp=0;
    135          uint16_t h_rez;
    136          ////t_frametx frame_tx;
    137          
    138          switch(*in_buf)
    139          	{
    140          	case CMD_ACK:
    141          		btmp = *(in_buf+1);
    142          		xQueueSend(p_hdlc->ev_rsv_ack,&btmp,TIMEOUT_SEND);
    143          		break;	
    144          	case CMD_PUT_DAT:
    145          		btmp = *(in_buf+1);
    146          		p_hdlc->fn_set_rec_dat(btmp,(void *)((u32)in_buf+2));
    147          	///	xQueueSend(ev_rsv_dat,&btmp,TIMEOUT_SEND);
    148          		wtmp=SEND_ACK;
    149          		wtmp |= (btmp<<8);
    150          		xQueueSend(p_hdlc->ev_snd_frame,&wtmp,TIMEOUT_SEND);
    151          		break;
    152          	case CMD_PUT_CMD:
    153          		btmp = *(in_buf+1);
    154          		h_rez=p_hdlc->fn_set_rec_dat(btmp,(void *)((u32)in_buf+2));
    155          	///	xQueueSend(ev_rsv_dat,&btmp,TIMEOUT_SEND);
    156          		wtmp=SEND_REZ;
    157          		wtmp |= (btmp<<8);
    158          		wtmp |= (h_rez<<16);
    159           		xQueueSend(p_hdlc->ev_snd_frame,&wtmp,TIMEOUT_SEND);
    160          		break;
    161          	case CMD_PUT_REQ_DAT:
    162          		btmp = *(in_buf+1);
    163          		p_hdlc->fn_set_rec_dat(btmp,(void *)((u32)in_buf+2));
    164                          xQueueSend(p_hdlc->ev_rsv_dat,&btmp,TIMEOUT_SEND);
    165          ///		htmp=SEND_ACK;
    166          ///		htmp |= (btmp<<8);
    167          ///		xQueueSend(ev_snd_frame,&htmp,TIMEOUT_SEND);
    168          		break;
    169          	case CMD_REQ_DAT:
    170          		btmp = *(in_buf+1);
    171          		p_hdlc->offs_snd_buf = *(in_buf+2);
    172          		p_hdlc->offs_snd_buf |= (*(in_buf+3))<<8;
    173          		wtmp = SEND_REQ_DAT;
    174          		wtmp |= (btmp<<8);
    175          ///		set_req_rez((req_rez_t *)((u32)in_buf+1) );
    176          		xQueueSend(p_hdlc->ev_snd_frame,&wtmp,TIMEOUT_SEND);	
    177          		rez =0;
    178          ////		printk("r");
    179          		break;
    180          	}
    181          return rez;
    182          }
    183          ///==================================
    184          int hdlc1_check_framein(hdlc_stat_t *p_hdlc)
    185          {
    186          int res = 1;
    187          if(p_hdlc->len_obr_dat < 3 )
    188          	{
    189          ////	p_hdlc->err_len++;
    190          	res = -1;
    191          	}
    192          else if( !checkfcs16(p_hdlc->obr_buff, p_hdlc->len_obr_dat - 2 ) )
    193          	{
    194          ////	p_hdlc->err_fcs++;
    195          	res = -2;
    196          	}
    197          return res;
    198          }
    199          ///=====================================
    200          void hdlc1_parse_framein(hdlc_stat_t *p_hdlc)
    201          {
    202          ///int flg_parse;
    203          ////hdlc_hdr_t *hdr;
    204          p_hdlc->frames_received++;
    205          hdlc1_parse_iframe(p_hdlc, p_hdlc->obr_buff , p_hdlc->len_obr_dat);
    206          }
    207          ///================================
    208          int	hdlc1_send_ack_to(hdlc_stat_t *p_hdlc,u8 ipar)
    209          {
    210          int num_send=0;
    211          u8 *p_tmp	 =p_hdlc->t_snd_buff1;
    212          *p_tmp++  = CMD_ACK;
    213          num_send++;
    214          *p_tmp++  = ipar;
    215          num_send++;
    216          return hdlc1_send_iframe(p_hdlc,p_hdlc->t_snd_buff1, num_send);
    217          ////return 0;
    218          }
    219          int	hdlc1_send_rez_to(hdlc_stat_t *p_hdlc,u8 ipar,u16 rez)
    220          {
    221          int num_send=0;
    222          u8 *p_tmp	 =p_hdlc->t_snd_buff1;
    223          *p_tmp++  = CMD_REZ;
    224          num_send++;
    225          *p_tmp++  = ipar;
    226          num_send++;
    227          *p_tmp++  = rez&0xff;
    228          num_send++;
    229          *p_tmp++  = (rez>>8)&0xff;
    230          num_send++;
    231          return hdlc1_send_iframe(p_hdlc,p_hdlc->t_snd_buff1, num_send);
    232          ////return 0;
    233          }
    234          
    235          ///====== from uart isr ============================
    236          int hdlc1_on_bytein(hdlc_stat_t *p_hdlc, u8 in_bt )
    237          {
    238          p_hdlc->bytes_received++;
    239          if( in_bt == PPP_FRAME )						// Пришел флаг
    240          	{
    241          	if(p_hdlc->frame_in_pos > 2 )				// Если между двумя флагами были данные:
    242          		{
    243          		memcpy(p_hdlc->obr_buff,p_hdlc->in_buf,p_hdlc->frame_in_pos);
    244          		p_hdlc->len_obr_dat=p_hdlc->frame_in_pos;
    245          		p_hdlc->frame_in_pos = 0;			
    246          		p_hdlc->in_esc_byte	 = 0;
    247          		return 1;
    248          		}
    249          	}
    250          else
    251          	{
    252          	if(p_hdlc->frame_in_pos >= HDLC1_MAX_FRAME_LEN )
    253          		{
    254          ////		hdlc1_error_frame_len(p_hdlc);
    255          		printk("\n hdlc1_error_frame_len");
    256          		return -1;
    257          		}
    258          	if(p_hdlc->in_esc_byte )								// Второй байт ESC-последовательности
    259          		{
    260          		p_hdlc->in_buf[p_hdlc->frame_in_pos++] = in_bt ^ PPP_ESCAPE_BIT;
    261          		p_hdlc->in_esc_byte = 0;
    262          		}
    263          	else
    264          		{
    265          		if( in_bt == PPP_ESCAPE)						// Первый байт ESC-последовательности
    266          			{
    267          			p_hdlc->in_esc_byte = TRUE;
    268          			}
    269          		else								// Обычный байт данных
    270          			{
    271          			p_hdlc->in_buf[p_hdlc->frame_in_pos++] = in_bt;	// Запись пришедшего байта в буфер
    272          			}
    273          		}
    274          	return 0;	
    275          	}
    276          return 0;	
    277          }
    278          ///==============================
    279          extern u16 pppfcs16(register u16 fcs, register unsigned char *cp, register int len);
    280          ///====================================
    281          void obr_hdlc1_cmd(hdlc_stat_t *p_hdlc)
    282          {
    283          int res;
    284          u8 ii;
    285          if((res= hdlc1_check_framein(p_hdlc))>0 )	// Проверить правильность входящего кадра
    286          	{
    287          ///==================================
    288          	hdlc1_parse_framein(p_hdlc);
    289          	}
    290          else
    291          	{
    292          	printk("\n\r error framein[%d][%02x]",res,p_hdlc->len_obr_dat);
    293          	if(res==-2)
    294          		{
    295                            printk("\n\r[%02x]:",p_hdlc->len_obr_dat);
    296          	for(ii=0;ii<p_hdlc->len_obr_dat;ii++)
    297          		{
    298          		printk("%02x ",p_hdlc->obr_buff[ii]);
    299          		}
    300          ///	printf("%x\r\n ", 0xffff ^ pppfcs16( 0xffff, p_hdlc->obr_buff, p_hdlc->len_obr_dat-2));	// dbg!
    301          	}
    302          	;
    303          	}
    304          }
    305          ///====================================
    306          void hdlc1_obr_frame(void *pdata)
    307          {
    308          ///u8 addr= *((u8*)pdata);
    309          hdlc_stat_t *p_hdlc=(hdlc_stat_t *)pdata;
    310          u8 res_byte;
    311          ///u8 btmp=0x33;
    312          ///u16 cnt=0;
    313          printk("\n\r=== hdlc1_obr_frame===  [%s]",pcTaskGetTaskName(NULL) );
    314          for(;;)
    315          	{
    316          	xQueueReceive(p_hdlc->ev_rsv_frame,&res_byte,portMAX_DELAY);
    317          	obr_hdlc1_cmd(p_hdlc);
    318          	}
    319          }
    320          
    321          uint8_t hdlc1_send_dat(hdlc_stat_t *p_hdlc, u8 icmd, u8 *idat, u16 len)
    322          {
    323          uint8_t res_byte;
    324          uint16_t htmp;
    325          uint8_t res=FALSE;
    326          int num_send=0;
    327          u8 *p_tmp=p_hdlc->t_snd_buff1;
    328          if (len == 0)
    329            return FALSE;
    330          *p_tmp++  = CMD_PUT_DAT;
    331          num_send++;
    332          *p_tmp++  = icmd;
    333          num_send++;
    334          *p_tmp++  = len&0xff;
    335          num_send++;
    336          *p_tmp++  = (len>>8)&0xff;
    337          num_send++;
    338          memcpy(p_tmp, idat, len);
    339          num_send += len;
    340          p_hdlc->snd_buff1_len=num_send;
    341          htmp=SEND_DAT;
    342          htmp |= (icmd<<8);
    343          if (xQueueSend(p_hdlc->ev_snd_frame, &htmp, TIMEOUT_SEND) == pdFAIL)
    344            {
    345            return FALSE;
    346            }
    347          if(xQueuePeek(p_hdlc->ev_rsv_ack,&res_byte,TIMEOUT_RSV)==pdTRUE)
    348            {
    349            if(res_byte==icmd)
    350              {
    351              xQueueReceive(p_hdlc->ev_rsv_ack,&res_byte,portMAX_DELAY);
    352              res=TRUE;
    353              }
    354            }
    355          else
    356            {
    357            res=FALSE;
    358            }	
    359          return res;
    360          }
    361          int	hdlc1_send_to(hdlc_stat_t *p_hdlc,u8 type_send,u8 type_dat,u16 rez)
    362          {
    363          int res=0;
    364          u16 len_dat;
    365          int num_send=0;
    366          u8 *p_tmp1;
    367          u8 *p_tmp	 = p_hdlc->snd_buff;
    368          if(type_send == SEND_REZ)
    369          	{
    370          	res=hdlc1_send_rez_to(p_hdlc,type_dat,rez);
    371          	}
    372          else if(type_send == SEND_ACK)
    373          	{
    374          	res=hdlc1_send_ack_to(p_hdlc,type_dat);
    375          	}
    376          else if(type_send == SEND_REQ_DAT)
    377          	{
    378          	*p_tmp++  = CMD_PUT_REQ_DAT;
    379          	num_send++;
    380          	*p_tmp++  = type_dat;
    381          	num_send++;
    382          	p_tmp1 = p_tmp+2;  
    383          	len_dat = p_hdlc->fn_get_req_dat(type_dat,p_hdlc->offs_snd_buf, p_tmp1);
    384          	*p_tmp++  = len_dat&0xff;
    385          	num_send++;
    386          	*p_tmp++  = (len_dat>>8)&0xff;
    387          	num_send++;
    388          	if(len_dat > HDLC1_MAX_FRAME_LEN)
    389          		len_dat = HDLC1_MAX_FRAME_LEN;
    390          	num_send += len_dat;
    391          	res=hdlc1_send_iframe(p_hdlc,p_hdlc->snd_buff, num_send);
    392          	}
    393          else if(type_send == SEND_DAT)
    394          	{
    395          	num_send = p_hdlc->snd_buff_len;
    396          	memcpy(p_tmp,p_hdlc->snd_buff,num_send);
    397          	res=hdlc1_send_iframe(p_hdlc,p_hdlc->snd_buff, num_send);
    398          	}
    399          else if(type_send == SEND_REQ)
    400          	{
    401          	num_send = p_hdlc->snd_buff_len;
    402          	memcpy(p_tmp,p_hdlc->snd_buff,num_send);
    403          	res=hdlc1_send_iframe(p_hdlc,p_hdlc->snd_buff, num_send);
    404          	}
    405          return res;
    406          }
    407          
    408          void hdlc1_snd_task(void *pdata)
    409          {
    410          ////t_frametx frame_tx;
    411          u32 type_send;
    412          hdlc_stat_t *p_hdlc=(hdlc_stat_t *)pdata;
    413          ///==================================
    414          #if 0
    415          for(;;)
    416          {
    417          send_char_bt(0x33);
    418          vTaskDelay(5);
    419          send_char_bt(0xcc);
    420          vTaskDelay(5);
    421          }
    422          #endif
    423          ///==================================
    424          ////u8 addr= *((u8*)pdata);
    425          ////_printk("\n\r=== hdlc1_snd_task=== [%s]",pcTaskGetTaskName(NULL));
    426          
    427          
    428          for(;;)
    429            {
    430            if(xQueueReceive(p_hdlc->ev_snd_frame,&type_send,portMAX_DELAY))
    431              hdlc1_send_to(p_hdlc,type_send&0xff,type_send>>8,type_send>>16);	
    432            }
    433          }
    434          ///====================================
    435          
    436          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   hdlc1_check_framein
        16   -> checkfcs16
       8   hdlc1_error
         8   -> puts
      24   hdlc1_init
        24   -> __aeabi_memset
        24   -> hdlc1_error
        24   -> pvPortMalloc
      16   hdlc1_obr_frame
        16   -> obr_hdlc1_cmd
        16   -> pcTaskGetName
        16   -> printf
        16   -> xQueueReceive
      24   hdlc1_on_bytein
        24   -> __aeabi_memcpy
        24   -> printf
       8   hdlc1_parse_framein
         8   -> hdlc1_parse_iframe
      32   hdlc1_parse_iframe
        32   -- Indirect call
        32   -> xQueueGenericSend
      24   hdlc1_send_ack_to
        24   -> hdlc1_send_iframe
      48   hdlc1_send_dat
        48   -> __aeabi_memcpy
        48   -> xQueueGenericSend
        48   -> xQueuePeek
        48   -> xQueueReceive
      40   hdlc1_send_iframe
        40   -- Indirect call
        40   -> __aeabi_memcpy
        40   -> addfcs16
      24   hdlc1_send_rez_to
        24   -> hdlc1_send_iframe
      56   hdlc1_send_to
        56   -- Indirect call
        56   -> __aeabi_memcpy
        56   -> hdlc1_send_ack_to
        56   -> hdlc1_send_iframe
        56   -> hdlc1_send_rez_to
      16   hdlc1_snd_task
        16   -> hdlc1_send_to
        16   -> xQueueReceive
      16   obr_hdlc1_cmd
        16   -> hdlc1_check_framein
        16   -> hdlc1_parse_framein
        16   -> printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
      28  ?_0
      36  ?_1
      40  ?_2
      44  ?_3
      24  ?_4
      28  ?_5
      12  ?_6
       8  ?_7
      32  ?_8
      44  hdlc1_check_framein
      12  hdlc1_error
     142  hdlc1_init
      40  hdlc1_obr_frame
     146  hdlc1_on_bytein
      22  hdlc1_parse_framein
     254  hdlc1_parse_iframe
      36  hdlc1_send_ack_to
     212  hdlc1_send_dat
     154  hdlc1_send_iframe
      62  hdlc1_send_rez_to
     290  hdlc1_send_to
      46  hdlc1_snd_task
      84  obr_hdlc1_cmd

 
   252 bytes in section .rodata
 1'580 bytes in section .text
 
 1'580 bytes of CODE  memory
   252 bytes of CONST memory

Errors: none
Warnings: none
