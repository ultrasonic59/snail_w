###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         04/Jun/2021  18:09:55
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can\common\libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_can.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EWC11F.tmp
#        (D:\proj\velograph\snail\stm32_snail\usb_can\common\libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_can.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -D MSTEP_BRD -D
#        USE_USB_OTG_FS -lcN
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\.\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\dbg\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\core\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\drv\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\hdlc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\cdc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\src\my_grbl\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\List\stm32f2xx_can.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\Obj\stm32f2xx_can.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\usb_can\common\libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_can.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_can.c
      4            * @author  MCD Application Team
      5            * @version V1.1.0
      6            * @date    07-October-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Controller area network (CAN) peripheral:           
      9            *           - Initialization and Configuration 
     10            *           - CAN Frames Transmission 
     11            *           - CAN Frames Reception    
     12            *           - Operation modes switch  
     13            *           - Error management          
     14            *           - Interrupts and flags        
     15            *         
     16            *  @verbatim
     17            *                               
     18            *          ===================================================================      
     19            *                                   How to use this driver
     20            *          ===================================================================
     21                          
     22            *          1.  Enable the CAN controller interface clock using 
     23            *                  RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE); for CAN1 
     24            *              and RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN2, ENABLE); for CAN2
     25            *  @note   In case you are using CAN2 only, you have to enable the CAN1 clock.
     26            *     
     27            *          2. CAN pins configuration
     28            *               - Enable the clock for the CAN GPIOs using the following function:
     29            *                   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);   
     30            *               - Connect the involved CAN pins to AF9 using the following function 
     31            *                   GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_CANx); 
     32            *                - Configure these CAN pins in alternate function mode by calling
     33            *                  the function  GPIO_Init();
     34            *    
     35            *          3.  Initialise and configure the CAN using CAN_Init() and 
     36            *               CAN_FilterInit() functions.   
     37            *               
     38            *          4.  Transmit the desired CAN frame using CAN_Transmit() function.
     39            *         
     40            *          5.  Check the transmission of a CAN frame using CAN_TransmitStatus()
     41            *              function.
     42            *               
     43            *          6.  Cancel the transmission of a CAN frame using CAN_CancelTransmit()
     44            *              function.  
     45            *            
     46            *          7.  Receive a CAN frame using CAN_Recieve() function.
     47            *         
     48            *          8.  Release the receive FIFOs using CAN_FIFORelease() function.
     49            *               
     50            *          9. Return the number of pending received frames using 
     51            *              CAN_MessagePending() function.            
     52            *                   
     53            *          10. To control CAN events you can use one of the following two methods:
     54            *               - Check on CAN flags using the CAN_GetFlagStatus() function.  
     55            *               - Use CAN interrupts through the function CAN_ITConfig() at 
     56            *                 initialization phase and CAN_GetITStatus() function into 
     57            *                 interrupt routines to check if the event has occurred or not.
     58            *             After checking on a flag you should clear it using CAN_ClearFlag()
     59            *             function. And after checking on an interrupt event you should 
     60            *             clear it using CAN_ClearITPendingBit() function.            
     61            *               
     62            *              
     63            *  @endverbatim
     64            *         
     65            ******************************************************************************
     66            * @attention
     67            *
     68            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     69            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     70            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     71            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     72            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     73            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     74            *
     75            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     76            ******************************************************************************  
     77            */
     78          
     79          /* Includes ------------------------------------------------------------------*/
     80          #include "stm32f2xx_can.h"
     81          ////#include "stm32f2xx_rcc.h"
     82          #include "stm32f2xx_conf.h"
     83          
     84          /** @addtogroup STM32F2xx_StdPeriph_Driver
     85            * @{
     86            */
     87          
     88          /** @defgroup CAN 
     89            * @brief CAN driver modules
     90            * @{
     91            */ 
     92          /* Private typedef -----------------------------------------------------------*/
     93          /* Private define ------------------------------------------------------------*/
     94          
     95          /* CAN Master Control Register bits */
     96          #define MCR_DBF           ((uint32_t)0x00010000) /* software master reset */
     97          
     98          /* CAN Mailbox Transmit Request */
     99          #define TMIDxR_TXRQ       ((uint32_t)0x00000001) /* Transmit mailbox request */
    100          
    101          /* CAN Filter Master Register bits */
    102          #define FMR_FINIT         ((uint32_t)0x00000001) /* Filter init mode */
    103          
    104          /* Time out for INAK bit */
    105          #define INAK_TIMEOUT      ((uint32_t)0x0000FFFF)
    106          /* Time out for SLAK bit */
    107          #define SLAK_TIMEOUT      ((uint32_t)0x0000FFFF)
    108          
    109          /* Flags in TSR register */
    110          #define CAN_FLAGS_TSR     ((uint32_t)0x08000000) 
    111          /* Flags in RF1R register */
    112          #define CAN_FLAGS_RF1R    ((uint32_t)0x04000000) 
    113          /* Flags in RF0R register */
    114          #define CAN_FLAGS_RF0R    ((uint32_t)0x02000000) 
    115          /* Flags in MSR register */
    116          #define CAN_FLAGS_MSR     ((uint32_t)0x01000000) 
    117          /* Flags in ESR register */
    118          #define CAN_FLAGS_ESR     ((uint32_t)0x00F00000) 
    119          
    120          /* Mailboxes definition */
    121          #define CAN_TXMAILBOX_0   ((uint8_t)0x00)
    122          #define CAN_TXMAILBOX_1   ((uint8_t)0x01)
    123          #define CAN_TXMAILBOX_2   ((uint8_t)0x02) 
    124          
    125          #define CAN_MODE_MASK     ((uint32_t) 0x00000003)
    126          
    127          /* Private macro -------------------------------------------------------------*/
    128          /* Private variables ---------------------------------------------------------*/
    129          /* Private function prototypes -----------------------------------------------*/
    130          /* Private functions ---------------------------------------------------------*/
    131          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);
    132          
    133          /** @defgroup CAN_Private_Functions
    134            * @{
    135            */
    136          
    137          /** @defgroup CAN_Group1 Initialization and Configuration functions
    138           *  @brief    Initialization and Configuration functions 
    139           *
    140          @verbatim    
    141           ===============================================================================
    142                                Initialization and Configuration functions
    143           ===============================================================================  
    144            This section provides functions allowing to 
    145             - Initialize the CAN peripherals : Prescaler, operating mode, the maximum number 
    146               of time quanta to perform resynchronization, the number of time quanta in
    147               Bit Segment 1 and 2 and many other modes. 
    148               Refer to  @ref CAN_InitTypeDef  for more details.
    149             - Configures the CAN reception filter.                                      
    150             - Select the start bank filter for slave CAN.
    151             - Enables or disables the Debug Freeze mode for CAN
    152             - Enables or disables the CAN Time Trigger Operation communication mode
    153             
    154          @endverbatim
    155            * @{
    156            */
    157            
    158          /**
    159            * @brief  Deinitializes the CAN peripheral registers to their default reset values.
    160            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    161            * @retval None.
    162            */
    163          void CAN_DeInit(CAN_TypeDef* CANx)
    164          {
    165            /* Check the parameters */
    166            assert_param(IS_CAN_ALL_PERIPH(CANx));
    167           
    168            if (CANx == CAN1)
    169            {
    170              /* Enable CAN1 reset state */
    171              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
    172              /* Release CAN1 from reset state */
    173              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
    174            }
    175            else
    176            {  
    177              /* Enable CAN2 reset state */
    178              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
    179              /* Release CAN2 from reset state */
    180              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
    181            }
    182          }
    183          
    184          /**
    185            * @brief  Initializes the CAN peripheral according to the specified
    186            *         parameters in the CAN_InitStruct.
    187            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    188            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that contains
    189            *         the configuration information for the CAN peripheral.
    190            * @retval Constant indicates initialization succeed which will be 
    191            *         CAN_InitStatus_Failed or CAN_InitStatus_Success.
    192            */
    193          uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
    194          {
    195            uint8_t InitStatus = CAN_InitStatus_Failed;
    196            uint32_t wait_ack = 0x00000000;
    197            /* Check the parameters */
    198            assert_param(IS_CAN_ALL_PERIPH(CANx));
    199            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
    200            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
    201            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
    202            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
    203            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
    204            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
    205            assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
    206            assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
    207            assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
    208            assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
    209            assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
    210          
    211            /* Exit from sleep mode */
    212            CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
    213          
    214            /* Request initialisation */
    215            CANx->MCR |= CAN_MCR_INRQ ;
    216          
    217            /* Wait the acknowledge */
    218            while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    219            {
    220              wait_ack++;
    221            }
    222          
    223            /* Check acknowledge */
    224            if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
    225            {
    226              InitStatus = CAN_InitStatus_Failed;
    227            }
    228            else 
    229            {
    230              /* Set the time triggered communication mode */
    231              if (CAN_InitStruct->CAN_TTCM == ENABLE)
    232              {
    233                CANx->MCR |= CAN_MCR_TTCM;
    234              }
    235              else
    236              {
    237                CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
    238              }
    239          
    240              /* Set the automatic bus-off management */
    241              if (CAN_InitStruct->CAN_ABOM == ENABLE)
    242              {
    243                CANx->MCR |= CAN_MCR_ABOM;
    244              }
    245              else
    246              {
    247                CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
    248              }
    249          
    250              /* Set the automatic wake-up mode */
    251              if (CAN_InitStruct->CAN_AWUM == ENABLE)
    252              {
    253                CANx->MCR |= CAN_MCR_AWUM;
    254              }
    255              else
    256              {
    257                CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
    258              }
    259          
    260              /* Set the no automatic retransmission */
    261              if (CAN_InitStruct->CAN_NART == ENABLE)
    262              {
    263                CANx->MCR |= CAN_MCR_NART;
    264              }
    265              else
    266              {
    267                CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
    268              }
    269          
    270              /* Set the receive FIFO locked mode */
    271              if (CAN_InitStruct->CAN_RFLM == ENABLE)
    272              {
    273                CANx->MCR |= CAN_MCR_RFLM;
    274              }
    275              else
    276              {
    277                CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
    278              }
    279          
    280              /* Set the transmit FIFO priority */
    281              if (CAN_InitStruct->CAN_TXFP == ENABLE)
    282              {
    283                CANx->MCR |= CAN_MCR_TXFP;
    284              }
    285              else
    286              {
    287                CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    288              }
    289          
    290              /* Set the bit timing register */
    291              CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
    292                          ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
    293                          ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
    294                          ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
    295                         ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
    296          
    297              /* Request leave initialisation */
    298              CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
    299          
    300             /* Wait the acknowledge */
    301             wait_ack = 0;
    302          
    303             while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    304             {
    305               wait_ack++;
    306             }
    307          
    308              /* ...and check acknowledged */
    309              if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
    310              {
    311                InitStatus = CAN_InitStatus_Failed;
    312              }
    313              else
    314              {
    315                InitStatus = CAN_InitStatus_Success ;
    316              }
    317            }
    318          
    319            /* At this step, return the status of initialization */
    320            return InitStatus;
    321          }
    322          
    323          /**
    324            * @brief  Configures the CAN reception filter according to the specified
    325            *         parameters in the CAN_FilterInitStruct.
    326            * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef structure that
    327            *         contains the configuration information.
    328            * @retval None
    329            */
    330          void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
    331          {
    332            uint32_t filter_number_bit_pos = 0;
    333            /* Check the parameters */
    334            assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
    335            assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
    336            assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
    337            assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
    338            assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
    339          
    340            filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
    341          
    342            /* Initialisation mode for the filter */
    343            CAN1->FMR |= FMR_FINIT;
    344          
    345            /* Filter Deactivation */
    346            CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
    347          
    348            /* Filter Scale */
    349            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
    350            {
    351              /* 16-bit scale for the filter */
    352              CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
    353          
    354              /* First 16-bit identifier and First 16-bit mask */
    355              /* Or First 16-bit identifier and Second 16-bit identifier */
    356              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    357                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
    358                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
    359          
    360              /* Second 16-bit identifier and Second 16-bit mask */
    361              /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    362              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    363                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    364                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
    365            }
    366          
    367            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
    368            {
    369              /* 32-bit scale for the filter */
    370              CAN1->FS1R |= filter_number_bit_pos;
    371              /* 32-bit identifier or First 32-bit identifier */
    372              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    373                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
    374                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
    375              /* 32-bit mask or Second 32-bit identifier */
    376              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    377                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    378                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
    379            }
    380          
    381            /* Filter Mode */
    382            if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
    383            {
    384              /*Id/Mask mode for the filter*/
    385              CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
    386            }
    387            else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    388            {
    389              /*Identifier list mode for the filter*/
    390              CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
    391            }
    392          
    393            /* Filter FIFO assignment */
    394            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
    395            {
    396              /* FIFO 0 assignation for the filter */
    397              CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
    398            }
    399          
    400            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
    401            {
    402              /* FIFO 1 assignation for the filter */
    403              CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
    404            }
    405            
    406            /* Filter activation */
    407            if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
    408            {
    409              CAN1->FA1R |= filter_number_bit_pos;
    410            }
    411          
    412            /* Leave the initialisation mode for the filter */
    413            CAN1->FMR &= ~FMR_FINIT;
    414          }
    415          
    416          /**
    417            * @brief  Fills each CAN_InitStruct member with its default value.
    418            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which ill be initialized.
    419            * @retval None
    420            */
    421          void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
    422          {
    423            /* Reset CAN init structure parameters values */
    424            
    425            /* Initialize the time triggered communication mode */
    426            CAN_InitStruct->CAN_TTCM = DISABLE;
    427            
    428            /* Initialize the automatic bus-off management */
    429            CAN_InitStruct->CAN_ABOM = DISABLE;
    430            
    431            /* Initialize the automatic wake-up mode */
    432            CAN_InitStruct->CAN_AWUM = DISABLE;
    433            
    434            /* Initialize the no automatic retransmission */
    435            CAN_InitStruct->CAN_NART = DISABLE;
    436            
    437            /* Initialize the receive FIFO locked mode */
    438            CAN_InitStruct->CAN_RFLM = DISABLE;
    439            
    440            /* Initialize the transmit FIFO priority */
    441            CAN_InitStruct->CAN_TXFP = DISABLE;
    442            
    443            /* Initialize the CAN_Mode member */
    444            CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
    445            
    446            /* Initialize the CAN_SJW member */
    447            CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
    448            
    449            /* Initialize the CAN_BS1 member */
    450            CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
    451            
    452            /* Initialize the CAN_BS2 member */
    453            CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
    454            
    455            /* Initialize the CAN_Prescaler member */
    456            CAN_InitStruct->CAN_Prescaler = 1;
    457          }
    458          
    459          /**
    460            * @brief  Select the start bank filter for slave CAN.
    461            * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
    462            * @retval None
    463            */
    464          void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
    465          {
    466            /* Check the parameters */
    467            assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
    468            
    469            /* Enter Initialisation mode for the filter */
    470            CAN1->FMR |= FMR_FINIT;
    471            
    472            /* Select the start slave bank */
    473            CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
    474            CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
    475            
    476            /* Leave Initialisation mode for the filter */
    477            CAN1->FMR &= ~FMR_FINIT;
    478          }
    479          
    480          /**
    481            * @brief  Enables or disables the DBG Freeze for CAN.
    482            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    483            * @param  NewState: new state of the CAN peripheral. 
    484            *          This parameter can be: ENABLE (CAN reception/transmission is frozen
    485            *          during debug. Reception FIFOs can still be accessed/controlled normally) 
    486            *          or DISABLE (CAN is working during debug).
    487            * @retval None
    488            */
    489          void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
    490          {
    491            /* Check the parameters */
    492            assert_param(IS_CAN_ALL_PERIPH(CANx));
    493            assert_param(IS_FUNCTIONAL_STATE(NewState));
    494            
    495            if (NewState != DISABLE)
    496            {
    497              /* Enable Debug Freeze  */
    498              CANx->MCR |= MCR_DBF;
    499            }
    500            else
    501            {
    502              /* Disable Debug Freeze */
    503              CANx->MCR &= ~MCR_DBF;
    504            }
    505          }
    506          
    507          
    508          /**
    509            * @brief  Enables or disables the CAN Time TriggerOperation communication mode.
    510            * @note   DLC must be programmed as 8 in order Time Stamp (2 bytes) to be 
    511            *         sent over the CAN bus.  
    512            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    513            * @param  NewState: Mode new state. This parameter can be: ENABLE or DISABLE.
    514            *         When enabled, Time stamp (TIME[15:0]) value is  sent in the last two
    515            *         data bytes of the 8-byte message: TIME[7:0] in data byte 6 and TIME[15:8] 
    516            *         in data byte 7. 
    517            * @retval None
    518            */
    519          void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
    520          {
    521            /* Check the parameters */
    522            assert_param(IS_CAN_ALL_PERIPH(CANx));
    523            assert_param(IS_FUNCTIONAL_STATE(NewState));
    524            if (NewState != DISABLE)
    525            {
    526              /* Enable the TTCM mode */
    527              CANx->MCR |= CAN_MCR_TTCM;
    528          
    529              /* Set TGT bits */
    530              CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
    531              CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
    532              CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
    533            }
    534            else
    535            {
    536              /* Disable the TTCM mode */
    537              CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
    538          
    539              /* Reset TGT bits */
    540              CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
    541              CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
    542              CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
    543            }
    544          }
    545          /**
    546            * @}
    547            */
    548          
    549          
    550          /** @defgroup CAN_Group2 CAN Frames Transmission functions
    551           *  @brief    CAN Frames Transmission functions 
    552           *
    553          @verbatim    
    554           ===============================================================================
    555                                CAN Frames Transmission functions
    556           ===============================================================================  
    557            This section provides functions allowing to 
    558             - Initiate and transmit a CAN frame message (if there is an empty mailbox).
    559             - Check the transmission status of a CAN Frame
    560             - Cancel a transmit request
    561             
    562          @endverbatim
    563            * @{
    564            */
    565          
    566          /**
    567            * @brief  Initiates and transmits a CAN frame message.
    568            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    569            * @param  TxMessage: pointer to a structure which contains CAN Id, CAN DLC and CAN data.
    570            * @retval The number of the mailbox that is used for transmission or
    571            *         CAN_TxStatus_NoMailBox if there is no empty mailbox.
    572            */
    573          uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
    574          {
    575            uint8_t transmit_mailbox = 0;
    576            /* Check the parameters */
    577            assert_param(IS_CAN_ALL_PERIPH(CANx));
    578            assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
    579            assert_param(IS_CAN_RTR(TxMessage->RTR));
    580            assert_param(IS_CAN_DLC(TxMessage->DLC));
    581          
    582            /* Select one empty transmit mailbox */
    583            if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
    584            {
    585              transmit_mailbox = 0;
    586            }
    587            else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
    588            {
    589              transmit_mailbox = 1;
    590            }
    591            else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
    592            {
    593              transmit_mailbox = 2;
    594            }
    595            else
    596            {
    597              transmit_mailbox = CAN_TxStatus_NoMailBox;
    598            }
    599          
    600            if (transmit_mailbox != CAN_TxStatus_NoMailBox)
    601            {
    602              /* Set up the Id */
    603              CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
    604              if (TxMessage->IDE == CAN_Id_Standard)
    605              {
    606                assert_param(IS_CAN_STDID(TxMessage->StdId));  
    607                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
    608                                                            TxMessage->RTR);
    609              }
    610              else
    611              {
    612                assert_param(IS_CAN_EXTID(TxMessage->ExtId));
    613                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
    614                                                            TxMessage->IDE | \
    615                                                            TxMessage->RTR);
    616              }
    617              
    618              /* Set up the DLC */
    619              TxMessage->DLC &= (uint8_t)0x0000000F;
    620              CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
    621              CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
    622          
    623              /* Set up the data field */
    624              CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
    625                                                       ((uint32_t)TxMessage->Data[2] << 16) |
    626                                                       ((uint32_t)TxMessage->Data[1] << 8) | 
    627                                                       ((uint32_t)TxMessage->Data[0]));
    628              CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
    629                                                       ((uint32_t)TxMessage->Data[6] << 16) |
    630                                                       ((uint32_t)TxMessage->Data[5] << 8) |
    631                                                       ((uint32_t)TxMessage->Data[4]));
    632              /* Request transmission */
    633              CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
    634            }
    635            return transmit_mailbox;
    636          }
    637          
    638          /**
    639            * @brief  Checks the transmission status of a CAN Frame.
    640            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    641            * @param  TransmitMailbox: the number of the mailbox that is used for transmission.
    642            * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, 
    643            *         CAN_TxStatus_Failed in an other case.
    644            */
    645          uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
    646          {
    647            uint32_t state = 0;
    648          
    649            /* Check the parameters */
    650            assert_param(IS_CAN_ALL_PERIPH(CANx));
    651            assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
    652           
    653            switch (TransmitMailbox)
    654            {
    655              case (CAN_TXMAILBOX_0): 
    656                state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
    657                break;
    658              case (CAN_TXMAILBOX_1): 
    659                state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
    660                break;
    661              case (CAN_TXMAILBOX_2): 
    662                state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
    663                break;
    664              default:
    665                state = CAN_TxStatus_Failed;
    666                break;
    667            }
    668            switch (state)
    669            {
    670                /* transmit pending  */
    671              case (0x0): state = CAN_TxStatus_Pending;
    672                break;
    673                /* transmit failed  */
    674               case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
    675                break;
    676               case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
    677                break;
    678               case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
    679                break;
    680                /* transmit succeeded  */
    681              case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
    682                break;
    683              case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
    684                break;
    685              case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
    686                break;
    687              default: state = CAN_TxStatus_Failed;
    688                break;
    689            }
    690            return (uint8_t) state;
    691          }
    692          
    693          /**
    694            * @brief  Cancels a transmit request.
    695            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    696            * @param  Mailbox: Mailbox number.
    697            * @retval None
    698            */
    699          void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
    700          {
    701            /* Check the parameters */
    702            assert_param(IS_CAN_ALL_PERIPH(CANx));
    703            assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
    704            /* abort transmission */
    705            switch (Mailbox)
    706            {
    707              case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
    708                break;
    709              case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
    710                break;
    711              case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
    712                break;
    713              default:
    714                break;
    715            }
    716          }
    717          /**
    718            * @}
    719            */
    720          
    721          
    722          /** @defgroup CAN_Group3 CAN Frames Reception functions
    723           *  @brief    CAN Frames Reception functions 
    724           *
    725          @verbatim    
    726           ===============================================================================
    727                                CAN Frames Reception functions
    728           ===============================================================================  
    729            This section provides functions allowing to 
    730             -  Receive a correct CAN frame
    731             -  Release a specified receive FIFO (2 FIFOs are available)
    732             -  Return the number of the pending received CAN frames
    733             
    734          @endverbatim
    735            * @{
    736            */
    737          
    738          /**
    739            * @brief  Receives a correct CAN frame.
    740            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    741            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    742            * @param  RxMessage: pointer to a structure receive frame which contains CAN Id,
    743            *         CAN DLC, CAN data and FMI number.
    744            * @retval None
    745            */
    746          void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
    747          {
    748            /* Check the parameters */
    749            assert_param(IS_CAN_ALL_PERIPH(CANx));
    750            assert_param(IS_CAN_FIFO(FIFONumber));
    751            /* Get the Id */
    752            RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
    753            if (RxMessage->IDE == CAN_Id_Standard)
    754            {
    755              RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
    756            }
    757            else
    758            {
    759              RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
    760            }
    761            
    762            RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
    763            /* Get the DLC */
    764            RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
    765            /* Get the FMI */
    766            RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
    767            /* Get the data field */
    768            RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
    769            RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
    770            RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
    771            RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
    772            RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
    773            RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
    774            RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
    775            RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
    776            /* Release the FIFO */
    777            /* Release FIFO0 */
    778            if (FIFONumber == CAN_FIFO0)
    779            {
    780              CANx->RF0R |= CAN_RF0R_RFOM0;
    781            }
    782            /* Release FIFO1 */
    783            else /* FIFONumber == CAN_FIFO1 */
    784            {
    785              CANx->RF1R |= CAN_RF1R_RFOM1;
    786            }
    787          }
    788          
    789          /**
    790            * @brief  Releases the specified receive FIFO.
    791            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    792            * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
    793            * @retval None
    794            */
    795          void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
    796          {
    797            /* Check the parameters */
    798            assert_param(IS_CAN_ALL_PERIPH(CANx));
    799            assert_param(IS_CAN_FIFO(FIFONumber));
    800            /* Release FIFO0 */
    801            if (FIFONumber == CAN_FIFO0)
    802            {
    803              CANx->RF0R |= CAN_RF0R_RFOM0;
    804            }
    805            /* Release FIFO1 */
    806            else /* FIFONumber == CAN_FIFO1 */
    807            {
    808              CANx->RF1R |= CAN_RF1R_RFOM1;
    809            }
    810          }
    811          
    812          /**
    813            * @brief  Returns the number of pending received messages.
    814            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    815            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    816            * @retval NbMessage : which is the number of pending message.
    817            */
    818          uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
    819          {
    820            uint8_t message_pending=0;
    821            /* Check the parameters */
    822            assert_param(IS_CAN_ALL_PERIPH(CANx));
    823            assert_param(IS_CAN_FIFO(FIFONumber));
    824            if (FIFONumber == CAN_FIFO0)
    825            {
    826              message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
    827            }
    828            else if (FIFONumber == CAN_FIFO1)
    829            {
    830              message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
    831            }
    832            else
    833            {
    834              message_pending = 0;
    835            }
    836            return message_pending;
    837          }
    838          /**
    839            * @}
    840            */
    841          
    842          
    843          /** @defgroup CAN_Group4 CAN Operation modes functions
    844           *  @brief    CAN Operation modes functions 
    845           *
    846          @verbatim    
    847           ===============================================================================
    848                                CAN Operation modes functions
    849           ===============================================================================  
    850            This section provides functions allowing to select the CAN Operation modes
    851            - sleep mode
    852            - normal mode 
    853            - initialization mode
    854             
    855          @endverbatim
    856            * @{
    857            */
    858            
    859            
    860          /**
    861            * @brief  Selects the CAN Operation mode.
    862            * @param  CAN_OperatingMode: CAN Operating Mode.
    863            *         This parameter can be one of @ref CAN_OperatingMode_TypeDef enumeration.
    864            * @retval status of the requested mode which can be 
    865            *         - CAN_ModeStatus_Failed:  CAN failed entering the specific mode 
    866            *         - CAN_ModeStatus_Success: CAN Succeed entering the specific mode 
    867            */
    868          uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
    869          {
    870            uint8_t status = CAN_ModeStatus_Failed;
    871            
    872            /* Timeout for INAK or also for SLAK bits*/
    873            uint32_t timeout = INAK_TIMEOUT; 
    874          
    875            /* Check the parameters */
    876            assert_param(IS_CAN_ALL_PERIPH(CANx));
    877            assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
    878          
    879            if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
    880            {
    881              /* Request initialisation */
    882              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
    883          
    884              /* Wait the acknowledge */
    885              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
    886              {
    887                timeout--;
    888              }
    889              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
    890              {
    891                status = CAN_ModeStatus_Failed;
    892              }
    893              else
    894              {
    895                status = CAN_ModeStatus_Success;
    896              }
    897            }
    898            else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
    899            {
    900              /* Request leave initialisation and sleep mode  and enter Normal mode */
    901              CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
    902          
    903              /* Wait the acknowledge */
    904              while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
    905              {
    906                timeout--;
    907              }
    908              if ((CANx->MSR & CAN_MODE_MASK) != 0)
    909              {
    910                status = CAN_ModeStatus_Failed;
    911              }
    912              else
    913              {
    914                status = CAN_ModeStatus_Success;
    915              }
    916            }
    917            else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
    918            {
    919              /* Request Sleep mode */
    920              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
    921          
    922              /* Wait the acknowledge */
    923              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
    924              {
    925                timeout--;
    926              }
    927              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
    928              {
    929                status = CAN_ModeStatus_Failed;
    930              }
    931              else
    932              {
    933                status = CAN_ModeStatus_Success;
    934              }
    935            }
    936            else
    937            {
    938              status = CAN_ModeStatus_Failed;
    939            }
    940          
    941            return  (uint8_t) status;
    942          }
    943          
    944          /**
    945            * @brief  Enters the Sleep (low power) mode.
    946            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    947            * @retval CAN_Sleep_Ok if sleep entered, CAN_Sleep_Failed otherwise.
    948            */
    949          uint8_t CAN_Sleep(CAN_TypeDef* CANx)
    950          {
    951            uint8_t sleepstatus = CAN_Sleep_Failed;
    952            
    953            /* Check the parameters */
    954            assert_param(IS_CAN_ALL_PERIPH(CANx));
    955              
    956            /* Request Sleep mode */
    957             CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
    958             
    959            /* Sleep mode status */
    960            if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
    961            {
    962              /* Sleep mode not entered */
    963              sleepstatus =  CAN_Sleep_Ok;
    964            }
    965            /* return sleep mode status */
    966             return (uint8_t)sleepstatus;
    967          }
    968          
    969          /**
    970            * @brief  Wakes up the CAN peripheral from sleep mode .
    971            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    972            * @retval CAN_WakeUp_Ok if sleep mode left, CAN_WakeUp_Failed otherwise.
    973            */
    974          uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
    975          {
    976            uint32_t wait_slak = SLAK_TIMEOUT;
    977            uint8_t wakeupstatus = CAN_WakeUp_Failed;
    978            
    979            /* Check the parameters */
    980            assert_param(IS_CAN_ALL_PERIPH(CANx));
    981              
    982            /* Wake up request */
    983            CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
    984              
    985            /* Sleep mode status */
    986            while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
    987            {
    988             wait_slak--;
    989            }
    990            if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
    991            {
    992             /* wake up done : Sleep mode exited */
    993              wakeupstatus = CAN_WakeUp_Ok;
    994            }
    995            /* return wakeup status */
    996            return (uint8_t)wakeupstatus;
    997          }
    998          /**
    999            * @}
   1000            */
   1001          
   1002          
   1003          /** @defgroup CAN_Group5 CAN Bus Error management functions
   1004           *  @brief    CAN Bus Error management functions 
   1005           *
   1006          @verbatim    
   1007           ===============================================================================
   1008                                CAN Bus Error management functions
   1009           ===============================================================================  
   1010            This section provides functions allowing to 
   1011             -  Return the CANx's last error code (LEC)
   1012             -  Return the CANx Receive Error Counter (REC)
   1013             -  Return the LSB of the 9-bit CANx Transmit Error Counter(TEC).
   1014             
   1015             @note If TEC is greater than 255, The CAN is in bus-off state.
   1016             @note if REC or TEC are greater than 96, an Error warning flag occurs.
   1017             @note if REC or TEC are greater than 127, an Error Passive Flag occurs.
   1018                                  
   1019          @endverbatim
   1020            * @{
   1021            */
   1022            
   1023          /**
   1024            * @brief  Returns the CANx's last error code (LEC).
   1025            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
   1026            * @retval Error code: 
   1027            *          - CAN_ERRORCODE_NoErr: No Error  
   1028            *          - CAN_ERRORCODE_StuffErr: Stuff Error
   1029            *          - CAN_ERRORCODE_FormErr: Form Error
   1030            *          - CAN_ERRORCODE_ACKErr : Acknowledgment Error
   1031            *          - CAN_ERRORCODE_BitRecessiveErr: Bit Recessive Error
   1032            *          - CAN_ERRORCODE_BitDominantErr: Bit Dominant Error
   1033            *          - CAN_ERRORCODE_CRCErr: CRC Error
   1034            *          - CAN_ERRORCODE_SoftwareSetErr: Software Set Error  
   1035            */
   1036          uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
   1037          {
   1038            uint8_t errorcode=0;
   1039            
   1040            /* Check the parameters */
   1041            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1042            
   1043            /* Get the error code*/
   1044            errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
   1045            
   1046            /* Return the error code*/
   1047            return errorcode;
   1048          }
   1049          
   1050          /**
   1051            * @brief  Returns the CANx Receive Error Counter (REC).
   1052            * @note   In case of an error during reception, this counter is incremented 
   1053            *         by 1 or by 8 depending on the error condition as defined by the CAN 
   1054            *         standard. After every successful reception, the counter is 
   1055            *         decremented by 1 or reset to 120 if its value was higher than 128. 
   1056            *         When the counter value exceeds 127, the CAN controller enters the 
   1057            *         error passive state.  
   1058            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.  
   1059            * @retval CAN Receive Error Counter. 
   1060            */
   1061          uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
   1062          {
   1063            uint8_t counter=0;
   1064            
   1065            /* Check the parameters */
   1066            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1067            
   1068            /* Get the Receive Error Counter*/
   1069            counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
   1070            
   1071            /* Return the Receive Error Counter*/
   1072            return counter;
   1073          }
   1074          
   1075          
   1076          /**
   1077            * @brief  Returns the LSB of the 9-bit CANx Transmit Error Counter(TEC).
   1078            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1079            * @retval LSB of the 9-bit CAN Transmit Error Counter. 
   1080            */
   1081          uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
   1082          {
   1083            uint8_t counter=0;
   1084            
   1085            /* Check the parameters */
   1086            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1087            
   1088            /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1089            counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
   1090            
   1091            /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1092            return counter;
   1093          }
   1094          /**
   1095            * @}
   1096            */
   1097          
   1098          /** @defgroup CAN_Group6 Interrupts and flags management functions
   1099           *  @brief   Interrupts and flags management functions
   1100           *
   1101          @verbatim   
   1102           ===============================================================================
   1103                             Interrupts and flags management functions
   1104           ===============================================================================  
   1105          
   1106            This section provides functions allowing to configure the CAN Interrupts and 
   1107            to get the status and clear flags and Interrupts pending bits.
   1108            
   1109            The CAN provides 14 Interrupts sources and 15 Flags:
   1110          
   1111            ===============  
   1112                Flags :
   1113            ===============
   1114            The 15 flags can be divided on 4 groups: 
   1115          
   1116             A. Transmit Flags
   1117            -----------------------
   1118                  CAN_FLAG_RQCP0, 
   1119                  CAN_FLAG_RQCP1, 
   1120                  CAN_FLAG_RQCP2  : Request completed MailBoxes 0, 1 and 2  Flags
   1121                                    Set when when the last request (transmit or abort) has 
   1122                                    been performed. 
   1123          
   1124            B. Receive Flags
   1125            -----------------------
   1126          
   1127                  CAN_FLAG_FMP0,
   1128                  CAN_FLAG_FMP1   : FIFO 0 and 1 Message Pending Flags 
   1129                                    set to signal that messages are pending in the receive 
   1130                                    FIFO.
   1131                                    These Flags are cleared only by hardware. 
   1132          
   1133                  CAN_FLAG_FF0,
   1134                  CAN_FLAG_FF1    : FIFO 0 and 1 Full Flags
   1135                                    set when three messages are stored in the selected 
   1136                                    FIFO.                        
   1137          
   1138                  CAN_FLAG_FOV0              
   1139                  CAN_FLAG_FOV1   : FIFO 0 and 1 Overrun Flags
   1140                                    set when a new message has been received and passed 
   1141                                    the filter while the FIFO was full.         
   1142          
   1143            C. Operating Mode Flags
   1144            ----------------------- 
   1145                  CAN_FLAG_WKU    : Wake up Flag
   1146                                    set to signal that a SOF bit has been detected while 
   1147                                    the CAN hardware was in Sleep mode. 
   1148                  
   1149                  CAN_FLAG_SLAK   : Sleep acknowledge Flag
   1150                                    Set to signal that the CAN has entered Sleep Mode. 
   1151              
   1152            D. Error Flags
   1153            ----------------------- 
   1154                  CAN_FLAG_EWG    : Error Warning Flag
   1155                                    Set when the warning limit has been reached (Receive 
   1156                                    Error Counter or Transmit Error Counter greater than 96). 
   1157                                    This Flag is cleared only by hardware.
   1158                                      
   1159                  CAN_FLAG_EPV    : Error Passive Flag
   1160                                    Set when the Error Passive limit has been reached 
   1161                                    (Receive Error Counter or Transmit Error Counter 
   1162                                    greater than 127).
   1163                                    This Flag is cleared only by hardware.
   1164                                       
   1165                  CAN_FLAG_BOF    : Bus-Off Flag
   1166                                    set when CAN enters the bus-off state. The bus-off 
   1167                                    state is entered on TEC overflow, greater than 255.
   1168                                    This Flag is cleared only by hardware.
   1169                                             
   1170                  CAN_FLAG_LEC    : Last error code Flag
   1171                                    set If a message has been transferred (reception or
   1172                                    transmission) with error, and the error code is hold.              
   1173                                    
   1174            ===============  
   1175             Interrupts :
   1176            ===============
   1177            The 14 interrupts can be divided on 4 groups: 
   1178            
   1179             A. Transmit interrupt
   1180            -----------------------   
   1181                    CAN_IT_TME   :  Transmit mailbox empty Interrupt
   1182                                    if enabled, this interrupt source is pending when 
   1183                                    no transmit request are pending for Tx mailboxes.      
   1184          
   1185             B. Receive Interrupts
   1186            -----------------------          
   1187                  CAN_IT_FMP0,
   1188                  CAN_IT_FMP1    :  FIFO 0 and FIFO1 message pending Interrupts
   1189                                    if enabled, these interrupt sources are pending when 
   1190                                    messages are pending in the receive FIFO.
   1191                                    The corresponding interrupt pending bits are cleared 
   1192                                    only by hardware.
   1193                          
   1194                  CAN_IT_FF0,              
   1195                  CAN_IT_FF1     :  FIFO 0 and FIFO1 full Interrupts
   1196                                    if enabled, these interrupt sources are pending when
   1197                                    three messages are stored in the selected FIFO.
   1198                  
   1199                  CAN_IT_FOV0,        
   1200                  CAN_IT_FOV1    :  FIFO 0 and FIFO1 overrun Interrupts        
   1201                                    if enabled, these interrupt sources are pending when
   1202                                    a new message has been received and passed the filter
   1203                                    while the FIFO was full.
   1204          
   1205             C. Operating Mode Interrupts
   1206            -------------------------------          
   1207                  CAN_IT_WKU     :  Wake-up Interrupt
   1208                                    if enabled, this interrupt source is pending when 
   1209                                    a SOF bit has been detected while the CAN hardware was 
   1210                                    in Sleep mode.
   1211                                            
   1212                  CAN_IT_SLK     :  Sleep acknowledge Interrupt
   1213                                    if enabled, this interrupt source is pending when 
   1214                                    the CAN has entered Sleep Mode.       
   1215          
   1216             D. Error Interrupts 
   1217            -----------------------         
   1218                  CAN_IT_EWG     :  Error warning Interrupt 
   1219                                    if enabled, this interrupt source is pending when
   1220                                    the warning limit has been reached (Receive Error 
   1221                                    Counter or Transmit Error Counter=96). 
   1222                                         
   1223                  CAN_IT_EPV     :  Error passive Interrupt        
   1224                                    if enabled, this interrupt source is pending when
   1225                                    the Error Passive limit has been reached (Receive 
   1226                                    Error Counter or Transmit Error Counter>127).
   1227                                    
   1228                  CAN_IT_BOF     :  Bus-off Interrupt
   1229                                    if enabled, this interrupt source is pending when
   1230                                    CAN enters the bus-off state. The bus-off state is 
   1231                                    entered on TEC overflow, greater than 255.
   1232                                    This Flag is cleared only by hardware.
   1233                                            
   1234                  CAN_IT_LEC     :  Last error code Interrupt        
   1235                                    if enabled, this interrupt source is pending  when
   1236                                    a message has been transferred (reception or
   1237                                    transmission) with error, and the error code is hold.
   1238                                    
   1239                  CAN_IT_ERR     :  Error Interrupt
   1240                                    if enabled, this interrupt source is pending when 
   1241                                    an error condition is pending.      
   1242                                
   1243          
   1244            Managing the CAN controller events :
   1245            ------------------------------------ 
   1246            The user should identify which mode will be used in his application to manage 
   1247            the CAN controller events: Polling mode or Interrupt mode.
   1248            
   1249            1.  In the Polling Mode it is advised to use the following functions:
   1250                - CAN_GetFlagStatus() : to check if flags events occur. 
   1251                - CAN_ClearFlag()     : to clear the flags events.
   1252            
   1253          
   1254            
   1255            2.  In the Interrupt Mode it is advised to use the following functions:
   1256                - CAN_ITConfig()       : to enable or disable the interrupt source.
   1257                - CAN_GetITStatus()    : to check if Interrupt occurs.
   1258                - CAN_ClearITPendingBit() : to clear the Interrupt pending Bit (corresponding Flag).
   1259                @note  This function has no impact on CAN_IT_FMP0 and CAN_IT_FMP1 Interrupts 
   1260                       pending bits since there are cleared only by hardware. 
   1261            
   1262          @endverbatim
   1263            * @{
   1264            */ 
   1265          /**
   1266            * @brief  Enables or disables the specified CANx interrupts.
   1267            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1268            * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.
   1269            *          This parameter can be: 
   1270            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1271            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1272            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1273            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1274            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1275            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1276            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1277            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1278            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1279            *            @arg CAN_IT_EWG: Error warning Interrupt
   1280            *            @arg CAN_IT_EPV: Error passive Interrupt
   1281            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1282            *            @arg CAN_IT_LEC: Last error code Interrupt
   1283            *            @arg CAN_IT_ERR: Error Interrupt
   1284            * @param  NewState: new state of the CAN interrupts.
   1285            *          This parameter can be: ENABLE or DISABLE.
   1286            * @retval None
   1287            */
   1288          void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
   1289          {
   1290            /* Check the parameters */
   1291            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1292            assert_param(IS_CAN_IT(CAN_IT));
   1293            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1294          
   1295            if (NewState != DISABLE)
   1296            {
   1297              /* Enable the selected CANx interrupt */
   1298              CANx->IER |= CAN_IT;
   1299            }
   1300            else
   1301            {
   1302              /* Disable the selected CANx interrupt */
   1303              CANx->IER &= ~CAN_IT;
   1304            }
   1305          }
   1306          /**
   1307            * @brief  Checks whether the specified CAN flag is set or not.
   1308            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1309            * @param  CAN_FLAG: specifies the flag to check.
   1310            *          This parameter can be one of the following values:
   1311            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1312            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1313            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag
   1314            *            @arg CAN_FLAG_FMP0: FIFO 0 Message Pending Flag   
   1315            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1316            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag 
   1317            *            @arg CAN_FLAG_FMP1: FIFO 1 Message Pending Flag   
   1318            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1319            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1320            *            @arg CAN_FLAG_WKU: Wake up Flag
   1321            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag 
   1322            *            @arg CAN_FLAG_EWG: Error Warning Flag
   1323            *            @arg CAN_FLAG_EPV: Error Passive Flag  
   1324            *            @arg CAN_FLAG_BOF: Bus-Off Flag    
   1325            *            @arg CAN_FLAG_LEC: Last error code Flag      
   1326            * @retval The new state of CAN_FLAG (SET or RESET).
   1327            */
   1328          FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1329          {
   1330            FlagStatus bitstatus = RESET;
   1331            
   1332            /* Check the parameters */
   1333            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1334            assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
   1335            
   1336          
   1337            if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
   1338            { 
   1339              /* Check the status of the specified CAN flag */
   1340              if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1341              { 
   1342                /* CAN_FLAG is set */
   1343                bitstatus = SET;
   1344              }
   1345              else
   1346              { 
   1347                /* CAN_FLAG is reset */
   1348                bitstatus = RESET;
   1349              }
   1350            }
   1351            else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
   1352            { 
   1353              /* Check the status of the specified CAN flag */
   1354              if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1355              { 
   1356                /* CAN_FLAG is set */
   1357                bitstatus = SET;
   1358              }
   1359              else
   1360              { 
   1361                /* CAN_FLAG is reset */
   1362                bitstatus = RESET;
   1363              }
   1364            }
   1365            else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
   1366            { 
   1367              /* Check the status of the specified CAN flag */
   1368              if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1369              { 
   1370                /* CAN_FLAG is set */
   1371                bitstatus = SET;
   1372              }
   1373              else
   1374              { 
   1375                /* CAN_FLAG is reset */
   1376                bitstatus = RESET;
   1377              }
   1378            }
   1379            else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
   1380            { 
   1381              /* Check the status of the specified CAN flag */
   1382              if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1383              { 
   1384                /* CAN_FLAG is set */
   1385                bitstatus = SET;
   1386              }
   1387              else
   1388              { 
   1389                /* CAN_FLAG is reset */
   1390                bitstatus = RESET;
   1391              }
   1392            }
   1393            else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
   1394            { 
   1395              /* Check the status of the specified CAN flag */
   1396              if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1397              { 
   1398                /* CAN_FLAG is set */
   1399                bitstatus = SET;
   1400              }
   1401              else
   1402              { 
   1403                /* CAN_FLAG is reset */
   1404                bitstatus = RESET;
   1405              }
   1406            }
   1407            /* Return the CAN_FLAG status */
   1408            return  bitstatus;
   1409          }
   1410          
   1411          /**
   1412            * @brief  Clears the CAN's pending flags.
   1413            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1414            * @param  CAN_FLAG: specifies the flag to clear.
   1415            *          This parameter can be one of the following values:
   1416            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1417            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1418            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag 
   1419            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1420            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag  
   1421            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1422            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1423            *            @arg CAN_FLAG_WKU: Wake up Flag
   1424            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag    
   1425            *            @arg CAN_FLAG_LEC: Last error code Flag        
   1426            * @retval None
   1427            */
   1428          void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1429          {
   1430            uint32_t flagtmp=0;
   1431            /* Check the parameters */
   1432            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1433            assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
   1434            
   1435            if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
   1436            {
   1437              /* Clear the selected CAN flags */
   1438              CANx->ESR = (uint32_t)RESET;
   1439            }
   1440            else /* MSR or TSR or RF0R or RF1R */
   1441            {
   1442              flagtmp = CAN_FLAG & 0x000FFFFF;
   1443          
   1444              if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
   1445              {
   1446                /* Receive Flags */
   1447                CANx->RF0R = (uint32_t)(flagtmp);
   1448              }
   1449              else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
   1450              {
   1451                /* Receive Flags */
   1452                CANx->RF1R = (uint32_t)(flagtmp);
   1453              }
   1454              else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
   1455              {
   1456                /* Transmit Flags */
   1457                CANx->TSR = (uint32_t)(flagtmp);
   1458              }
   1459              else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
   1460              {
   1461                /* Operating mode Flags */
   1462                CANx->MSR = (uint32_t)(flagtmp);
   1463              }
   1464            }
   1465          }
   1466          
   1467          /**
   1468            * @brief  Checks whether the specified CANx interrupt has occurred or not.
   1469            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1470            * @param  CAN_IT: specifies the CAN interrupt source to check.
   1471            *          This parameter can be one of the following values:
   1472            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1473            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1474            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1475            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1476            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1477            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1478            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1479            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1480            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1481            *            @arg CAN_IT_EWG: Error warning Interrupt
   1482            *            @arg CAN_IT_EPV: Error passive Interrupt
   1483            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1484            *            @arg CAN_IT_LEC: Last error code Interrupt
   1485            *            @arg CAN_IT_ERR: Error Interrupt
   1486            * @retval The current state of CAN_IT (SET or RESET).
   1487            */
   1488          ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1489          {
   1490            ITStatus itstatus = RESET;
   1491            /* Check the parameters */
   1492            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1493            assert_param(IS_CAN_IT(CAN_IT));
   1494            
   1495            /* check the interrupt enable bit */
   1496           if((CANx->IER & CAN_IT) != RESET)
   1497           {
   1498             /* in case the Interrupt is enabled, .... */
   1499              switch (CAN_IT)
   1500              {
   1501                case CAN_IT_TME:
   1502                  /* Check CAN_TSR_RQCPx bits */
   1503                  itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
   1504                  break;
   1505                case CAN_IT_FMP0:
   1506                  /* Check CAN_RF0R_FMP0 bit */
   1507                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
   1508                  break;
   1509                case CAN_IT_FF0:
   1510                  /* Check CAN_RF0R_FULL0 bit */
   1511                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
   1512                  break;
   1513                case CAN_IT_FOV0:
   1514                  /* Check CAN_RF0R_FOVR0 bit */
   1515                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
   1516                  break;
   1517                case CAN_IT_FMP1:
   1518                  /* Check CAN_RF1R_FMP1 bit */
   1519                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
   1520                  break;
   1521                case CAN_IT_FF1:
   1522                  /* Check CAN_RF1R_FULL1 bit */
   1523                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
   1524                  break;
   1525                case CAN_IT_FOV1:
   1526                  /* Check CAN_RF1R_FOVR1 bit */
   1527                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
   1528                  break;
   1529                case CAN_IT_WKU:
   1530                  /* Check CAN_MSR_WKUI bit */
   1531                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
   1532                  break;
   1533                case CAN_IT_SLK:
   1534                  /* Check CAN_MSR_SLAKI bit */
   1535                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
   1536                  break;
   1537                case CAN_IT_EWG:
   1538                  /* Check CAN_ESR_EWGF bit */
   1539                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
   1540                  break;
   1541                case CAN_IT_EPV:
   1542                  /* Check CAN_ESR_EPVF bit */
   1543                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
   1544                  break;
   1545                case CAN_IT_BOF:
   1546                  /* Check CAN_ESR_BOFF bit */
   1547                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
   1548                  break;
   1549                case CAN_IT_LEC:
   1550                  /* Check CAN_ESR_LEC bit */
   1551                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
   1552                  break;
   1553                case CAN_IT_ERR:
   1554                  /* Check CAN_MSR_ERRI bit */ 
   1555                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
   1556                  break;
   1557                default:
   1558                  /* in case of error, return RESET */
   1559                  itstatus = RESET;
   1560                  break;
   1561              }
   1562            }
   1563            else
   1564            {
   1565             /* in case the Interrupt is not enabled, return RESET */
   1566              itstatus  = RESET;
   1567            }
   1568            
   1569            /* Return the CAN_IT status */
   1570            return  itstatus;
   1571          }
   1572          
   1573          /**
   1574            * @brief  Clears the CANx's interrupt pending bits.
   1575            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1576            * @param  CAN_IT: specifies the interrupt pending bit to clear.
   1577            *          This parameter can be one of the following values:
   1578            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt
   1579            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1580            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1581            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1582            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1583            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1584            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1585            *            @arg CAN_IT_EWG: Error warning Interrupt
   1586            *            @arg CAN_IT_EPV: Error passive Interrupt
   1587            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1588            *            @arg CAN_IT_LEC: Last error code Interrupt
   1589            *            @arg CAN_IT_ERR: Error Interrupt 
   1590            * @retval None
   1591            */
   1592          void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1593          {
   1594            /* Check the parameters */
   1595            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1596            assert_param(IS_CAN_CLEAR_IT(CAN_IT));
   1597          
   1598            switch (CAN_IT)
   1599            {
   1600              case CAN_IT_TME:
   1601                /* Clear CAN_TSR_RQCPx (rc_w1)*/
   1602                CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
   1603                break;
   1604              case CAN_IT_FF0:
   1605                /* Clear CAN_RF0R_FULL0 (rc_w1)*/
   1606                CANx->RF0R = CAN_RF0R_FULL0; 
   1607                break;
   1608              case CAN_IT_FOV0:
   1609                /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
   1610                CANx->RF0R = CAN_RF0R_FOVR0; 
   1611                break;
   1612              case CAN_IT_FF1:
   1613                /* Clear CAN_RF1R_FULL1 (rc_w1)*/
   1614                CANx->RF1R = CAN_RF1R_FULL1;  
   1615                break;
   1616              case CAN_IT_FOV1:
   1617                /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
   1618                CANx->RF1R = CAN_RF1R_FOVR1; 
   1619                break;
   1620              case CAN_IT_WKU:
   1621                /* Clear CAN_MSR_WKUI (rc_w1)*/
   1622                CANx->MSR = CAN_MSR_WKUI;  
   1623                break;
   1624              case CAN_IT_SLK:
   1625                /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
   1626                CANx->MSR = CAN_MSR_SLAKI;   
   1627                break;
   1628              case CAN_IT_EWG:
   1629                /* Clear CAN_MSR_ERRI (rc_w1) */
   1630                CANx->MSR = CAN_MSR_ERRI;
   1631                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
   1632                break;
   1633              case CAN_IT_EPV:
   1634                /* Clear CAN_MSR_ERRI (rc_w1) */
   1635                CANx->MSR = CAN_MSR_ERRI; 
   1636                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1637                break;
   1638              case CAN_IT_BOF:
   1639                /* Clear CAN_MSR_ERRI (rc_w1) */ 
   1640                CANx->MSR = CAN_MSR_ERRI; 
   1641                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1642                 break;
   1643              case CAN_IT_LEC:
   1644                /*  Clear LEC bits */
   1645                CANx->ESR = RESET; 
   1646                /* Clear CAN_MSR_ERRI (rc_w1) */
   1647                CANx->MSR = CAN_MSR_ERRI; 
   1648                break;
   1649              case CAN_IT_ERR:
   1650                /*Clear LEC bits */
   1651                CANx->ESR = RESET; 
   1652                /* Clear CAN_MSR_ERRI (rc_w1) */
   1653                CANx->MSR = CAN_MSR_ERRI; 
   1654                 /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
   1655                 break;
   1656              default:
   1657                 break;
   1658             }
   1659          }
   1660           /**
   1661            * @}
   1662            */
   1663          
   1664          /**
   1665            * @brief  Checks whether the CAN interrupt has occurred or not.
   1666            * @param  CAN_Reg: specifies the CAN interrupt register to check.
   1667            * @param  It_Bit: specifies the interrupt source bit to check.
   1668            * @retval The new state of the CAN Interrupt (SET or RESET).
   1669            */
   1670          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
   1671          {
   1672            ITStatus pendingbitstatus = RESET;
   1673            
   1674            if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
   1675            {
   1676              /* CAN_IT is set */
   1677              pendingbitstatus = SET;
   1678            }
   1679            else
   1680            {
   1681              /* CAN_IT is reset */
   1682              pendingbitstatus = RESET;
   1683            }
   1684            return pendingbitstatus;
   1685          }
   1686          
   1687          /**
   1688            * @}
   1689            */
   1690          
   1691          /**
   1692            * @}
   1693            */
   1694          
   1695          /**
   1696            * @}
   1697            */
   1698          
   1699          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CAN_CancelTransmit
       0   CAN_ClearFlag
       0   CAN_ClearITPendingBit
       0   CAN_DBGFreeze
       8   CAN_DeInit
         8   -> RCC_APB1PeriphResetCmd
       0   CAN_FIFORelease
      12   CAN_FilterInit
       0   CAN_GetFlagStatus
      16   CAN_GetITStatus
        16   -> CheckITStatus
       0   CAN_GetLSBTransmitErrorCounter
       0   CAN_GetLastErrorCode
       0   CAN_GetReceiveErrorCounter
       0   CAN_ITConfig
       8   CAN_Init
       0   CAN_MessagePending
       4   CAN_OperatingModeRequest
       0   CAN_Receive
       0   CAN_SlaveStartBank
       0   CAN_Sleep
       0   CAN_StructInit
       0   CAN_TTComModeCmd
       8   CAN_Transmit
       4   CAN_TransmitStatus
       0   CAN_WakeUp
       0   CheckITStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      48  CAN_CancelTransmit
      48  CAN_ClearFlag
     148  CAN_ClearITPendingBit
      28  CAN_DBGFreeze
      56  CAN_DeInit
      28  CAN_FIFORelease
     218  CAN_FilterInit
     104  CAN_GetFlagStatus
     238  CAN_GetITStatus
      12  CAN_GetLSBTransmitErrorCounter
      14  CAN_GetLastErrorCode
      12  CAN_GetReceiveErrorCounter
      24  CAN_ITConfig
     274  CAN_Init
      42  CAN_MessagePending
     180  CAN_OperatingModeRequest
     262  CAN_Receive
      44  CAN_SlaveStartBank
      34  CAN_Sleep
      46  CAN_StructInit
     100  CAN_TTComModeCmd
     318  CAN_Transmit
     142  CAN_TransmitStatus
      44  CAN_WakeUp
      18  CheckITStatus

 
 2'546 bytes in section .text
 
 2'546 bytes of CODE memory

Errors: none
Warnings: none
