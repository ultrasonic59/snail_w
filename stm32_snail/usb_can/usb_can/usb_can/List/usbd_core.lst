###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         05/Jun/2021  19:54:21
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can\common\usb\core\src\usbd_core.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EWF2B8.tmp
#        (D:\proj\velograph\snail\stm32_snail\usb_can\common\usb\core\src\usbd_core.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -D MSTEP_BRD -D
#        USE_USB_OTG_FS -lcN
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\.\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\dbg\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\core\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\drv\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\hdlc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\cdc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\src\my_grbl\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\List\usbd_core.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\Obj\usbd_core.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\usb_can\common\usb\core\src\usbd_core.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbd_core.c
      4            * @author  MCD Application Team
      5            * @version V1.2.0
      6            * @date    09-November-2015
      7            * @brief   This file provides all the USBD core functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "usbd_core.h"
     30          #include "usbd_req.h"
     31          #include "usbd_ioreq.h"
     32          #include "usb_dcd_int.h"
     33          #include "usb_bsp.h"
     34          
     35          
     36          /** @defgroup USBD_CORE_Private_FunctionPrototypes
     37          * @{
     38          */ 
     39          static uint8_t USBD_SetupStage(USB_OTG_CORE_HANDLE *pdev);
     40          static uint8_t USBD_DataOutStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum);
     41          static uint8_t USBD_DataInStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum);
     42          static uint8_t USBD_SOF(USB_OTG_CORE_HANDLE  *pdev);
     43          static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev);
     44          static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev);
     45          static uint8_t USBD_Resume(USB_OTG_CORE_HANDLE  *pdev);
     46          #ifdef VBUS_SENSING_ENABLED
     47          static uint8_t USBD_DevConnected(USB_OTG_CORE_HANDLE  *pdev);
     48          static uint8_t USBD_DevDisconnected(USB_OTG_CORE_HANDLE  *pdev);
     49          #endif
     50          static uint8_t USBD_IsoINIncomplete(USB_OTG_CORE_HANDLE  *pdev);
     51          static uint8_t USBD_IsoOUTIncomplete(USB_OTG_CORE_HANDLE  *pdev);
     52          static uint8_t  USBD_RunTestMode (USB_OTG_CORE_HANDLE  *pdev) ;
     53          /**
     54          * @}
     55          */ 
     56          
     57          /** @defgroup USBD_CORE_Private_Variables
     58          * @{
     59          */ 
     60          
     61          __IO USB_OTG_DCTL_TypeDef SET_TEST_MODE;
     62          
     63          USBD_DCD_INT_cb_TypeDef USBD_DCD_INT_cb = 
     64          {
     65            USBD_DataOutStage,
     66            USBD_DataInStage,
     67            USBD_SetupStage,
     68            USBD_SOF,
     69            USBD_Reset,
     70            USBD_Suspend,
     71            USBD_Resume,
     72            USBD_IsoINIncomplete,
     73            USBD_IsoOUTIncomplete,
     74          #ifdef VBUS_SENSING_ENABLED
     75            USBD_DevConnected, 
     76            USBD_DevDisconnected,    
     77          #endif  
     78          };
     79          
     80          USBD_DCD_INT_cb_TypeDef  *USBD_DCD_INT_fops = &USBD_DCD_INT_cb;
     81          /**
     82          * @}
     83          */ 
     84          
     85          /** @defgroup USBD_CORE_Private_Functions
     86          * @{
     87          */ 
     88          
     89          /**
     90          * @brief  USBD_Init
     91          *         Initializes the device stack and load the class driver
     92          * @param  pdev: device instance
     93          * @param  core_address: USB OTG core ID
     94          * @param  class_cb: Class callback structure address
     95          * @param  usr_cb: User callback structure address
     96          * @retval None
     97          */
     98          void USBD_Init(USB_OTG_CORE_HANDLE *pdev,
     99                         USB_OTG_CORE_ID_TypeDef coreID,
    100                         USBD_DEVICE *pDevice,                  
    101                         USBD_Class_cb_TypeDef *class_cb, 
    102                         USBD_Usr_cb_TypeDef *usr_cb)
    103          {
    104            /* Hardware Init */
    105            USB_OTG_BSP_Init(pdev);  
    106            
    107            USBD_DeInit(pdev);
    108            
    109            /*Register class and user callbacks */
    110            pdev->dev.class_cb = class_cb;
    111            pdev->dev.usr_cb = usr_cb;  
    112            pdev->dev.usr_device = pDevice;    
    113            
    114            /* set USB OTG core params */
    115            DCD_Init(pdev , coreID);
    116            
    117            /* Upon Init call usr callback */
    118            pdev->dev.usr_cb->Init();
    119            
    120            /* Enable Interrupts */
    121            USB_OTG_BSP_EnableInterrupt(pdev);
    122          }
    123          
    124          /**
    125          * @brief  USBD_DeInit 
    126          *         Re-Initialize the device library
    127          * @param  pdev: device instance
    128          * @retval status: status
    129          */
    130          USBD_Status USBD_DeInit(USB_OTG_CORE_HANDLE *pdev)
    131          {
    132            /* Software Init */
    133            
    134            return USBD_OK;
    135          }
    136          
    137          /**
    138          * @brief  USBD_SetupStage 
    139          *         Handle the setup stage
    140          * @param  pdev: device instance
    141          * @retval status
    142          */
    143          static uint8_t USBD_SetupStage(USB_OTG_CORE_HANDLE *pdev)
    144          {
    145            USB_SETUP_REQ req;
    146            
    147            USBD_ParseSetupRequest(pdev , &req);
    148            
    149            switch (req.bmRequest & 0x1F) 
    150            {
    151            case USB_REQ_RECIPIENT_DEVICE:   
    152              USBD_StdDevReq (pdev, &req);
    153              break;
    154              
    155            case USB_REQ_RECIPIENT_INTERFACE:     
    156              USBD_StdItfReq(pdev, &req);
    157              break;
    158              
    159            case USB_REQ_RECIPIENT_ENDPOINT:        
    160              USBD_StdEPReq(pdev, &req);   
    161              break;
    162              
    163            default:           
    164              DCD_EP_Stall(pdev , req.bmRequest & 0x80);
    165              break;
    166            }  
    167            return USBD_OK;
    168          }
    169          
    170          /**
    171          * @brief  USBD_DataOutStage 
    172          *         Handle data out stage
    173          * @param  pdev: device instance
    174          * @param  epnum: endpoint index
    175          * @retval status
    176          */
    177          static uint8_t USBD_DataOutStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
    178          {
    179            USB_OTG_EP *ep;
    180            
    181            if(epnum == 0) 
    182            {
    183              ep = &pdev->dev.out_ep[0];
    184              if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
    185              {
    186                if(ep->rem_data_len > ep->maxpacket)
    187                {
    188                  ep->rem_data_len -=  ep->maxpacket;
    189                  
    190                  if(pdev->cfg.dma_enable == 1)
    191                  {
    192                    /* in slave mode this, is handled by the RxSTSQLvl ISR */
    193                    ep->xfer_buff += ep->maxpacket; 
    194                  }        
    195                  USBD_CtlContinueRx (pdev, 
    196                                      ep->xfer_buff,
    197                                      MIN(ep->rem_data_len ,ep->maxpacket));
    198                }
    199                else
    200                {
    201                  if((pdev->dev.class_cb->EP0_RxReady != NULL)&&
    202                     (pdev->dev.device_status == USB_OTG_CONFIGURED))
    203                  {
    204                    pdev->dev.class_cb->EP0_RxReady(pdev); 
    205                  }
    206                  USBD_CtlSendStatus(pdev);
    207                }
    208              }
    209            }
    210            else if((pdev->dev.class_cb->DataOut != NULL)&&
    211                    (pdev->dev.device_status == USB_OTG_CONFIGURED))
    212            {
    213              pdev->dev.class_cb->DataOut(pdev, epnum); 
    214            } 
    215            
    216            else
    217            {
    218              /* Do Nothing */
    219            }
    220            return USBD_OK;
    221          }
    222          
    223          /**
    224          * @brief  USBD_DataInStage 
    225          *         Handle data in stage
    226          * @param  pdev: device instance
    227          * @param  epnum: endpoint index
    228          * @retval status
    229          */
    230          static uint8_t USBD_DataInStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
    231          {
    232            USB_OTG_EP *ep;
    233            
    234            if(epnum == 0) 
    235            {
    236              ep = &pdev->dev.in_ep[0];
    237              if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
    238              {
    239                if(ep->rem_data_len > ep->maxpacket)
    240                {
    241                  ep->rem_data_len -=  ep->maxpacket;
    242                  if(pdev->cfg.dma_enable == 1)
    243                  {
    244                    /* in slave mode this, is handled by the TxFifoEmpty ISR */
    245                    ep->xfer_buff += ep->maxpacket;
    246                  }
    247                  USBD_CtlContinueSendData (pdev, 
    248                                            ep->xfer_buff, 
    249                                            ep->rem_data_len);
    250                  
    251                  /* Start the transfer */  
    252                  DCD_EP_PrepareRx (pdev,
    253                                    0,
    254                                    NULL,
    255                                    0);
    256                }
    257                else
    258                { /* last packet is MPS multiple, so send ZLP packet */
    259                  if((ep->total_data_len % ep->maxpacket == 0) &&
    260                     (ep->total_data_len >= ep->maxpacket) &&
    261                       (ep->total_data_len < ep->ctl_data_len ))
    262                  {
    263                    
    264                    USBD_CtlContinueSendData(pdev , NULL, 0);
    265                    ep->ctl_data_len = 0;
    266                    
    267                    /* Start the transfer */  
    268                    DCD_EP_PrepareRx (pdev,
    269                                      0,
    270                                      NULL,
    271                                      0);
    272                  }
    273                  else
    274                  {
    275                    if((pdev->dev.class_cb->EP0_TxSent != NULL)&&
    276                       (pdev->dev.device_status == USB_OTG_CONFIGURED))
    277                    {
    278                      pdev->dev.class_cb->EP0_TxSent(pdev); 
    279                    }          
    280                    USBD_CtlReceiveStatus(pdev);
    281                  }
    282                }
    283              }
    284              if (pdev->dev.test_mode == 1)
    285              {
    286                USBD_RunTestMode(pdev); 
    287                pdev->dev.test_mode = 0;
    288              }
    289            }
    290            else if((pdev->dev.class_cb->DataIn != NULL)&& 
    291                    (pdev->dev.device_status == USB_OTG_CONFIGURED))
    292            {
    293              pdev->dev.class_cb->DataIn(pdev, epnum); 
    294            } 
    295            
    296            else
    297            {
    298              /* Do Nothing */
    299            }
    300            return USBD_OK;
    301          }
    302          
    303          
    304          
    305          
    306          /**
    307          * @brief  USBD_RunTestMode 
    308          *         Launch test mode process
    309          * @param  pdev: device instance
    310          * @retval status
    311          */
    312          static uint8_t  USBD_RunTestMode (USB_OTG_CORE_HANDLE  *pdev) 
    313          {
    314            USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, SET_TEST_MODE.d32);
    315            return USBD_OK;  
    316          }
    317          
    318          /**
    319          * @brief  USBD_Reset 
    320          *         Handle Reset event
    321          * @param  pdev: device instance
    322          * @retval status
    323          */
    324          
    325          static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev)
    326          {
    327            /* Open EP0 OUT */
    328            DCD_EP_Open(pdev,
    329                        0x00,
    330                        USB_OTG_MAX_EP0_SIZE,
    331                        EP_TYPE_CTRL);
    332            
    333            /* Open EP0 IN */
    334            DCD_EP_Open(pdev,
    335                        0x80,
    336                        USB_OTG_MAX_EP0_SIZE,
    337                        EP_TYPE_CTRL);
    338            
    339            /* Upon Reset call usr call back */
    340            pdev->dev.device_status = USB_OTG_DEFAULT;
    341            pdev->dev.usr_cb->DeviceReset(pdev->cfg.speed);
    342            
    343            return USBD_OK;
    344          }
    345          
    346          /**
    347          * @brief  USBD_Resume 
    348          *         Handle Resume event
    349          * @param  pdev: device instance
    350          * @retval status
    351          */
    352          
    353          static uint8_t USBD_Resume(USB_OTG_CORE_HANDLE  *pdev)
    354          {
    355            /* Upon Resume call usr call back */
    356            pdev->dev.usr_cb->DeviceResumed(); 
    357            pdev->dev.device_status = pdev->dev.device_old_status;  
    358            pdev->dev.device_status = USB_OTG_CONFIGURED;  
    359            return USBD_OK;
    360          }
    361          
    362          
    363          /**
    364          * @brief  USBD_Suspend 
    365          *         Handle Suspend event
    366          * @param  pdev: device instance
    367          * @retval status
    368          */
    369          
    370          static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev)
    371          {
    372            pdev->dev.device_old_status = pdev->dev.device_status;
    373            pdev->dev.device_status  = USB_OTG_SUSPENDED;
    374            /* Upon Resume call usr call back */
    375            pdev->dev.usr_cb->DeviceSuspended(); 
    376            return USBD_OK;
    377          }
    378          
    379          
    380          /**
    381          * @brief  USBD_SOF 
    382          *         Handle SOF event
    383          * @param  pdev: device instance
    384          * @retval status
    385          */
    386          
    387          static uint8_t USBD_SOF(USB_OTG_CORE_HANDLE  *pdev)
    388          {
    389            if(pdev->dev.class_cb->SOF)
    390            {
    391              pdev->dev.class_cb->SOF(pdev); 
    392            }
    393            return USBD_OK;
    394          }
    395          /**
    396          * @brief  USBD_SetCfg 
    397          *        Configure device and start the interface
    398          * @param  pdev: device instance
    399          * @param  cfgidx: configuration index
    400          * @retval status
    401          */
    402          
    403          USBD_Status USBD_SetCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
    404          {
    405            pdev->dev.class_cb->Init(pdev, cfgidx); 
    406            
    407            /* Upon set config call usr call back */
    408            pdev->dev.usr_cb->DeviceConfigured();
    409            return USBD_OK; 
    410          }
    411          
    412          /**
    413          * @brief  USBD_ClrCfg 
    414          *         Clear current configuration
    415          * @param  pdev: device instance
    416          * @param  cfgidx: configuration index
    417          * @retval status: USBD_Status
    418          */
    419          USBD_Status USBD_ClrCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
    420          {
    421            pdev->dev.class_cb->DeInit(pdev, cfgidx);   
    422            return USBD_OK;
    423          }
    424          
    425          /**
    426          * @brief  USBD_IsoINIncomplete 
    427          *         Handle iso in incomplete event
    428          * @param  pdev: device instance
    429          * @retval status
    430          */
    431          static uint8_t USBD_IsoINIncomplete(USB_OTG_CORE_HANDLE  *pdev)
    432          {
    433            pdev->dev.class_cb->IsoINIncomplete(pdev);   
    434            return USBD_OK;
    435          }
    436          
    437          /**
    438          * @brief  USBD_IsoOUTIncomplete 
    439          *         Handle iso out incomplete event
    440          * @param  pdev: device instance
    441          * @retval status
    442          */
    443          static uint8_t USBD_IsoOUTIncomplete(USB_OTG_CORE_HANDLE  *pdev)
    444          {
    445            pdev->dev.class_cb->IsoOUTIncomplete(pdev);   
    446            return USBD_OK;
    447          }
    448          
    449          #ifdef VBUS_SENSING_ENABLED
    450          /**
    451          * @brief  USBD_DevConnected 
    452          *         Handle device connection event
    453          * @param  pdev: device instance
    454          * @retval status
    455          */
    456          static uint8_t USBD_DevConnected(USB_OTG_CORE_HANDLE  *pdev)
    457          {
    458            pdev->dev.usr_cb->DeviceConnected();
    459            pdev->dev.connection_status = 1;  
    460            return USBD_OK;
    461          }
    462          
    463          /**
    464          * @brief  USBD_DevDisconnected 
    465          *         Handle device disconnection event
    466          * @param  pdev: device instance
    467          * @retval status
    468          */
    469          static uint8_t USBD_DevDisconnected(USB_OTG_CORE_HANDLE  *pdev)
    470          {
    471            pdev->dev.usr_cb->DeviceDisconnected();
    472            pdev->dev.class_cb->DeInit(pdev, 0);
    473            pdev->dev.connection_status = 0;    
    474            return USBD_OK;
    475          }
    476          #endif
    477          /**
    478          * @}
    479          */ 
    480          
    481          
    482          /**
    483          * @}
    484          */ 
    485          
    486          
    487          /**
    488          * @}
    489          */ 
    490          
    491          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    492          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USBD_ClrCfg
        16   -- Indirect call
      16   USBD_DataInStage
        16   -- Indirect call
        16   -> DCD_EP_PrepareRx
        16   -> USBD_CtlContinueSendData
        16   -> USBD_CtlReceiveStatus
        16   -> USBD_RunTestMode
      16   USBD_DataOutStage
        16   -- Indirect call
        16   -> USBD_CtlContinueRx
        16   -> USBD_CtlSendStatus
       0   USBD_DeInit
      24   USBD_Init
        24   -- Indirect call
        24   -> DCD_Init
        24   -> USBD_DeInit
        24   -> USB_OTG_BSP_EnableInterrupt
        24   -> USB_OTG_BSP_Init
       8   USBD_IsoINIncomplete
         8   -- Indirect call
       8   USBD_IsoOUTIncomplete
         8   -- Indirect call
       8   USBD_Reset
         8   -- Indirect call
         8   -> DCD_EP_Open
       8   USBD_Resume
         8   -- Indirect call
       0   USBD_RunTestMode
       8   USBD_SOF
         8   -- Indirect call
      16   USBD_SetCfg
        16   -- Indirect call
      16   USBD_SetupStage
        16   -> DCD_EP_Stall
        16   -> USBD_ParseSetupRequest
        16   -> USBD_StdDevReq
        16   -> USBD_StdEPReq
        16   -> USBD_StdItfReq
       8   USBD_Suspend
         8   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  SET_TEST_MODE
      24  USBD_ClrCfg
      44  USBD_DCD_INT_cb
       4  USBD_DCD_INT_fops
     236  USBD_DataInStage
     156  USBD_DataOutStage
       6  USBD_DeInit
      68  USBD_Init
      18  USBD_IsoINIncomplete
      18  USBD_IsoOUTIncomplete
      48  USBD_Reset
      30  USBD_Resume
      14  USBD_RunTestMode
      28  USBD_SOF
      32  USBD_SetCfg
      82  USBD_SetupStage
      30  USBD_Suspend

 
   4 bytes in section .bss
  48 bytes in section .data
 794 bytes in section .text
 
 794 bytes of CODE memory
  52 bytes of DATA memory

Errors: none
Warnings: none
