###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         09/May/2021  15:42:34
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can\common\grbl\gbrl_serial.c
#    Command line =
#        -f C:\Users\vagol\AppData\Local\Temp\EWE0CA.tmp
#        (D:\proj\velograph\snail\stm32_snail\usb_can\common\grbl\gbrl_serial.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -D MSTEP_BRD -D
#        USE_USB_OTG_FS -lcN
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\.\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\dbg\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\core\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\drv\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\hdlc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\cdc\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\List\gbrl_serial.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\Obj\gbrl_serial.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\usb_can\common\grbl\gbrl_serial.c
      1          /*
      2            serial.c - Low level functions for sending and recieving bytes via the serial port
      3            Part of Grbl
      4          
      5            Copyright (c) 2011-2016 Sungeun K. Jeon for Gnea Research LLC
      6            Copyright (c) 2009-2011 Simen Svale Skogsrud
      7          
      8            Grbl is free software: you can redistribute it and/or modify
      9            it under the terms of the GNU General Public License as published by
     10            the Free Software Foundation, either version 3 of the License, or
     11            (at your option) any later version.
     12          
     13            Grbl is distributed in the hope that it will be useful,
     14            but WITHOUT ANY WARRANTY; without even the implied warranty of
     15            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16            GNU General Public License for more details.
     17          
     18            You should have received a copy of the GNU General Public License
     19            along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
     20          */
     21          #include <stdint.h>
     22          
     23          ///#include "stm32f10x_map.h"
     24          
     25          #include "grbl.h"
     26          ////#include "stm32f10x.h"
     27          ////#include "core_cm3.h"
     28          #if 0
     29            #ifndef USEUSB
     30            #include "stm32f10x_usart.h"
     31            #else
     32            #include "usb_regs.h"
     33            #endif
     34          #endif
     35          
     36          #define RX_RING_BUFFER (RX_BUFFER_SIZE)
     37          #define TX_RING_BUFFER (TX_BUFFER_SIZE)
     38          
     39          uint8_t serial_rx_buffer[RX_RING_BUFFER];
     40          uint8_t serial_rx_buffer_head = 0;
     41          volatile uint8_t serial_rx_buffer_tail = 0;
     42          
     43          uint8_t serial_tx_buffer[TX_RING_BUFFER];
     44          uint8_t serial_tx_buffer_head = 0;
     45          volatile uint8_t serial_tx_buffer_tail = 0;
     46          
     47          
     48          // Returns the number of bytes available in the RX serial buffer.
     49          uint8_t serial_get_rx_buffer_available()
     50          {
     51            uint8_t rtail = serial_rx_buffer_tail; // Copy to limit multiple calls to volatile
     52            if (serial_rx_buffer_head >= rtail) { return(RX_BUFFER_SIZE - (serial_rx_buffer_head-rtail)); }
     53            return((rtail-serial_rx_buffer_head-1));
     54          }
     55          
     56          
     57          // Returns the number of bytes used in the RX serial buffer.
     58          // NOTE: Deprecated. Not used unless classic status reports are enabled in config.h.
     59          uint8_t serial_get_rx_buffer_count()
     60          {
     61            uint8_t rtail = serial_rx_buffer_tail; // Copy to limit multiple calls to volatile
     62            if (serial_rx_buffer_head >= rtail) { return(serial_rx_buffer_head-rtail); }
     63            return (RX_BUFFER_SIZE - (rtail-serial_rx_buffer_head));
     64          }
     65          
     66          
     67          // Returns the number of bytes used in the TX serial buffer.
     68          // NOTE: Not used except for debugging and ensuring no TX bottlenecks.
     69          uint8_t serial_get_tx_buffer_count()
     70          {
     71            uint8_t ttail = serial_tx_buffer_tail; // Copy to limit multiple calls to volatile
     72            if (serial_tx_buffer_head >= ttail) { return(serial_tx_buffer_head-ttail); }
     73            return (TX_RING_BUFFER - (ttail-serial_tx_buffer_head));
     74          }
     75          
     76          
     77          void serial_init()
     78          {
     79          }
     80          
     81          // Writes one byte to the TX serial buffer. Called by main program.
     82          void serial_write(uint8_t data) {
     83            // Calculate next head
     84            uint8_t next_head = serial_tx_buffer_head + 1;
     85          #ifndef USEUSB
     86          	USART_SendData(USART1, data);
     87          	while (!(USART1->SR & USART_FLAG_TXE));		 //�ȴ��������
     88              return;
     89          #endif
     90            if (next_head == TX_RING_BUFFER) { next_head = 0; }
     91          
     92            // Wait until there is space in the buffer
     93            while (next_head == serial_tx_buffer_tail) {
     94              // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.
     95              if (sys_rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
     96            }
     97          
     98            // Store data and advance head
     99            serial_tx_buffer[serial_tx_buffer_head] = data;
    100          
    101            serial_tx_buffer_head = next_head;
    102          }
    103          
    104          // Fetches the first byte in the serial read buffer. Called by main program.
    105          uint8_t serial_read()
    106          {
    107            uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
    108            if (serial_rx_buffer_head == tail) {
    109              return SERIAL_NO_DATA;
    110            } else {
    111              uint8_t data = serial_rx_buffer[tail];
    112          
    113              tail++;
    114              if (tail == RX_RING_BUFFER) { tail = 0; }
    115              serial_rx_buffer_tail = tail;
    116          
    117              return data;
    118            }
    119          }
    120          
    121          #ifdef USEUSB
    122          void OnUsbDataRx(uint8_t* dataIn, uint8_t length)
    123          {
    124          	//lcd_write_char(*dataIn);
    125          	uint8_t next_head;
    126              uint8_t data;
    127          
    128          	// Write data to buffer unless it is full.
    129          	while (length != 0)
    130          	{
    131                  data = *dataIn ++;
    132          #else
    133          /*----------------------------------------------------------------------------
    134            USART1_IRQHandler
    135            Handles USART1 global interrupt request.
    136           *----------------------------------------------------------------------------*/
    137          void USART1_IRQHandler (void) 
    138          {
    139              volatile unsigned int IIR;
    140              uint8_t data;
    141              uint8_t next_head;
    142          
    143              IIR = USART1->SR;
    144              if (IIR & USART_FLAG_RXNE) 
    145              {                  // read interrupt
    146                  data = USART1->DR & 0x1FF;
    147          #endif
    148            // Pick off realtime command characters directly from the serial stream. These characters are
    149            // not passed into the main buffer, but these set system state flag bits for realtime execution.
    150            switch (data) {
    151              case CMD_RESET:         mc_reset(); break; // Call motion control reset routine.
    152              case CMD_STATUS_REPORT: system_set_exec_state_flag(EXEC_STATUS_REPORT); break; // Set as true
    153              case CMD_CYCLE_START:   system_set_exec_state_flag(EXEC_CYCLE_START); break; // Set as true
    154              case CMD_FEED_HOLD:     system_set_exec_state_flag(EXEC_FEED_HOLD); break; // Set as true
    155              default :
    156                if (data > 0x7F) { // Real-time control characters are extended ACSII only.
    157                  switch(data) {
    158                    case CMD_SAFETY_DOOR:   system_set_exec_state_flag(EXEC_SAFETY_DOOR); break; // Set as true
    159                    case CMD_JOG_CANCEL:   
    160                      if (sys.state & STATE_JOG) { // Block all other states from invoking motion cancel.
    161                        system_set_exec_state_flag(EXEC_MOTION_CANCEL); 
    162                      }
    163                      break; 
    164                    #ifdef DEBUG
    165                     case CMD_DEBUG_REPORT: 
    166                       {
    167           ////???              uint8_t sreg = SREG; 
    168           ////???                cli(); 
    169            ////???               bit_true(sys_rt_exec_debug,EXEC_DEBUG_REPORT); 
    170            ////???               SREG = sreg;
    171                       } break;
    172                    #endif
    173                    case CMD_FEED_OVR_RESET: system_set_exec_motion_override_flag(EXEC_FEED_OVR_RESET); break;
    174                    case CMD_FEED_OVR_COARSE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_PLUS); break;
    175                    case CMD_FEED_OVR_COARSE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_MINUS); break;
    176                    case CMD_FEED_OVR_FINE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_PLUS); break;
    177                    case CMD_FEED_OVR_FINE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_MINUS); break;
    178                    case CMD_RAPID_OVR_RESET: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_RESET); break;
    179                    case CMD_RAPID_OVR_MEDIUM: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_MEDIUM); break;
    180                    case CMD_RAPID_OVR_LOW: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_LOW); break;
    181                    case CMD_SPINDLE_OVR_RESET: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_RESET); break;
    182                    case CMD_SPINDLE_OVR_COARSE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_PLUS); break;
    183                    case CMD_SPINDLE_OVR_COARSE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_MINUS); break;
    184                    case CMD_SPINDLE_OVR_FINE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_PLUS); break;
    185                    case CMD_SPINDLE_OVR_FINE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_MINUS); break;
    186                    case CMD_SPINDLE_OVR_STOP: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP); break;
    187                    case CMD_COOLANT_FLOOD_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_FLOOD_OVR_TOGGLE); break;
    188                    #ifdef ENABLE_M7
    189                      case CMD_COOLANT_MIST_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_MIST_OVR_TOGGLE); break;
    190                    #endif
    191                  }
    192                  // Throw away any unfound extended-ASCII character by not passing it to the serial buffer.
    193                } else { // Write character to buffer
    194                  next_head = serial_rx_buffer_head + 1;
    195                  if (next_head == RX_RING_BUFFER) { next_head = 0; }
    196          
    197                  // Write data to buffer unless it is full.
    198                  if (next_head != serial_rx_buffer_tail) {
    199                    serial_rx_buffer[serial_rx_buffer_head] = data;
    200                    serial_rx_buffer_head = next_head;
    201                  }
    202                }
    203            }
    204          #ifndef USEUSB
    205                  USART1->SR &= ~USART_FLAG_RXNE;	          // clear interrupt
    206          #else
    207              length--;
    208          #endif
    209             }
    210          }
    211          
    212          void serial_reset_read_buffer()
    213          {
    214            serial_rx_buffer_tail = serial_rx_buffer_head;
    215          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OnUsbDataRx
        24   -> mc_reset
        24   -> system_set_exec_accessory_override_flag
        24   -> system_set_exec_motion_override_flag
        24   -> system_set_exec_state_flag
       0   serial_get_rx_buffer_available
       0   serial_get_rx_buffer_count
       0   serial_get_tx_buffer_count
       0   serial_init
       0   serial_read
       0   serial_reset_read_buffer
       4   serial_write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
     346  OnUsbDataRx
      38  serial_get_rx_buffer_available
      36  serial_get_rx_buffer_count
      36  serial_get_tx_buffer_count
       2  serial_init
      48  serial_read
      10  serial_reset_read_buffer
     256  serial_rx_buffer
       1  serial_rx_buffer_head
       1  serial_rx_buffer_tail
     128  serial_tx_buffer
       1  serial_tx_buffer_head
       1  serial_tx_buffer_tail
      54  serial_write

 
 388 bytes in section .bss
 602 bytes in section .text
 
 602 bytes of CODE memory
 388 bytes of DATA memory

Errors: none
Warnings: none
