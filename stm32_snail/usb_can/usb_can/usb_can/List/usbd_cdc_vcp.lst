###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         07/Jun/2021  19:45:12
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can\common\usb\cdc_vcp\usbd_cdc_vcp.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EWE97D.tmp
#        (D:\proj\velograph\snail\stm32_snail\usb_can\common\usb\cdc_vcp\usbd_cdc_vcp.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -D MSTEP_BRD -D
#        USE_USB_OTG_FS -lcN
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\.\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\dbg\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\core\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\drv\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\hdlc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\cdc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\src\my_grbl\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\List\usbd_cdc_vcp.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\Obj\usbd_cdc_vcp.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\usb_can\common\usb\cdc_vcp\usbd_cdc_vcp.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbd_cdc_vcp.c
      4            * @author  MCD Application Team
      5            * @version V1.2.0
      6            * @date    09-November-2015
      7            * @brief   Generic media access Layer.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          #include <stdlib.h>
     28          #include <string.h>
     29          #include "usbd_conf.h"
     30          #include "usbd_desc.h"
     31          
     32          #include "FreeRTOS.h"
     33          #include "task.h"
     34          #include "semphr.h"
     35          ////#include "my_misc.h"
     36          #include "_hdlc.h"
     37          #include "printk.h"
     38          #include "min_max.h"
     39          #include "ring_buff.h"
     40          #include "can.h"
     41          extern int send_char_dbg(int ch); 
     42          
     43          #if (USB_CLASS == CDC_VCP)|| (USB_CLASS == MSC_CDC)    ///================================
     44          
     45          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED 
     46          #pragma     data_alignment = 4 
     47          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
     48          
     49          #include "usbd_cdc_vcp.h"
     50          hdlc_stat_t g_hdlc_vcp;
     51          #if 0
     52          /* Private typedef -----------------------------------------------------------*/
     53          /* Private define ------------------------------------------------------------*/
     54          /* Private macro -------------------------------------------------------------*/
     55          /* Private variables ---------------------------------------------------------*/
     56          LINE_CODING linecoding =
     57            {
     58              115200, /* baud rate*/
     59              0x00,   /* stop bits-1*/
     60              0x00,   /* parity - none*/
     61              0x08    /* nb. of bits 8*/
     62            };
     63          
     64          
     65          USART_InitTypeDef USART_InitStructure;
     66          #endif
     67          
     68          /* These are external variables imported from CDC core to be used for IN 
     69             transfer management. */
     70          extern uint8_t  APP_Rx_Buffer []; /* Write CDC received data in this buffer.
     71                                               These data will be sent over USB IN endpoint
     72                                               in the CDC core functions. */
     73          extern uint32_t APP_Rx_ptr_in;    /* Increment this pointer or roll it back to
     74                                               start address when writing received data
     75                                               in the buffer APP_Rx_Buffer. */
     76          
     77          /* Private function prototypes -----------------------------------------------*/
     78          static uint16_t VCP_Init     (void);
     79          static uint16_t VCP_DeInit   (void);
     80          static uint16_t VCP_Ctrl     (uint32_t Cmd, uint8_t* Buf, uint32_t Len);
     81          ////static uint16_t VCP_DataTx   (uint8_t* Buf, uint32_t Len);
     82          ////static 
     83          ////uint16_t VCP_DataRx   (uint8_t* Buf, uint32_t Len);
     84          
     85          ///static uint16_t VCP_COMConfig(uint8_t Conf);
     86          
     87          CDC_IF_Prop_TypeDef VCP_fops = 
     88          {
     89            VCP_Init,
     90            VCP_DeInit,
     91            VCP_Ctrl,
     92            0,
     93            0
     94          ///  VCP_DataTx,
     95          ///  VCP_DataRx
     96          };
     97          
     98          static uint16_t VCP_Init(void)
     99          {
    100            return USBD_OK;
    101          }
    102          static uint16_t VCP_DeInit(void)
    103          {
    104            return USBD_OK;
    105          }
    106          
    107          static uint16_t VCP_Ctrl (uint32_t Cmd, uint8_t* Buf, uint32_t Len)
    108          { 
    109            return USBD_OK;
    110          }
    111          #if 0
    112          /**
    113            * @brief  VCP_DataTx
    114            *         CDC received data to be send over USB IN endpoint are managed in 
    115            *         this function.
    116            * @param  Buf: Buffer of data to be sent
    117            * @param  Len: Number of data to be sent (in bytes)
    118            * @retval Result of the operation: USBD_OK if all operations are OK else VCP_FAIL
    119            */
    120          static uint16_t VCP_DataTx (uint8_t* Buf, uint32_t Len)
    121          {
    122            return USBD_OK;
    123          }
    124          #endif
    125          ///=========================================
    126          /*
    127           * VCP data Rx/Tx API
    128           */
    129          
    130          void VCP_MarkRead(unsigned sz)
    131          {
    132          	atomic_t a = atomic_begin();
    133          	USB_Rx_buff_tail = ring_wrap(USB_Rx_buff_size, USB_Rx_buff_tail + sz);
    134          	atomic_end(a);
    135          }
    136          
    137          void VCP_MarkWritten(unsigned sz)
    138          {
    139          	atomic_t a = atomic_begin();
    140          	USB_Tx_buff_head = ring_wrap(USB_TX_BUFF_SIZE, USB_Tx_buff_head + sz);
    141          	atomic_end(a);
    142          }
    143          
    144          unsigned VCP_DataAvail(void)
    145          {
    146          	atomic_t a = atomic_begin();
    147          	unsigned sz = ring_data_avail(USB_Rx_buff_size, USB_Rx_buff_head, USB_Rx_buff_tail);
    148          	atomic_end(a);
    149          	return sz;
    150          }
    151          
    152          unsigned VCP_SpaceAvail(void)
    153          {
    154          	atomic_t a = atomic_begin();
    155          	unsigned sz = ring_space_avail(USB_TX_BUFF_SIZE, USB_Tx_buff_head, USB_Tx_buff_tail);
    156          	atomic_end(a);
    157          	return sz;
    158          }
    159          
    160          unsigned VCP_DataAvailContig(void)
    161          {
    162          	atomic_t a = atomic_begin();
    163          	unsigned sz = ring_data_contig(USB_Rx_buff_size, USB_Rx_buff_head, USB_Rx_buff_tail);
    164          	atomic_end(a);
    165          	return sz;
    166          }
    167          
    168          unsigned VCP_SpaceAvailContig(void)
    169          {
    170          	atomic_t a = atomic_begin();
    171          	unsigned sz = ring_space_contig(USB_TX_BUFF_SIZE, USB_Tx_buff_head, USB_Tx_buff_tail);
    172          	atomic_end(a);
    173          	return sz;
    174          }
    175          
    176          unsigned VCP_GetContig(void* buff, unsigned max_len)
    177          {
    178          	unsigned avail = VCP_DataAvailContig();
    179          	unsigned sz = MIN_(avail, max_len);
    180          	if (sz) {
    181          		memcpy(buff, VCP_DataPtr(), sz);
    182          		VCP_MarkRead(sz);
    183          	}
    184          	return sz;
    185          }
    186          
    187          unsigned VCP_PutContig(void const* buff, unsigned len)
    188          {
    189          unsigned avail = VCP_SpaceAvailContig();
    190          unsigned sz = MIN_(avail, len);
    191          if (sz) 
    192            {
    193            memcpy(VCP_SpacePtr(), buff, sz);
    194            VCP_MarkWritten(sz);
    195            }
    196          return sz;
    197          }
    198          
    199          ///==========================================
    200          
    201          #if 0
    202          void hdlc_vcp_send_byte(u8 val)
    203          {
    204          ///u8 btmp = val;
    205          APP_Rx_Buffer[APP_Rx_ptr_in]=val;
    206          APP_Rx_ptr_in++;
    207          if(APP_Rx_ptr_in == APP_RX_DATA_SIZE)
    208            {
    209            APP_Rx_ptr_in = 0;
    210            }  
    211          ////xQueueSend(g_hdlc_bt.ua_snd_dat, &btmp, portMAX_DELAY);
    212          /////on_int_tx_uart_bt();
    213          ///_printk("[%x]",APP_Rx_ptr_in);
    214          
    215          }
    216          #else
    217          void hdlc_vcp_send_byte(u8 val)
    218          {
    219          int num;  
    220          u8 btmp=val;
    221          for(;;)
    222          {
    223           num= VCP_PutContig(&btmp,1);
    224           if(num)
    225             break;
    226           msleep(1);
    227          }
    228          }
    229          #endif
    230          
    231          #if 0
    232          uint8_t hdlc_vcp_send_frame(uint8_t *buff,uint16_t len)
    233          {
    234          #if 1
    235          uint16_t ii;
    236          
    237          for(ii=0;ii<len;ii++)
    238          {
    239          APP_Rx_Buffer[APP_Rx_ptr_in]=buff[ii]; 
    240          if(APP_Rx_ptr_in == APP_RX_DATA_SIZE)
    241            {
    242            APP_Rx_ptr_in = 0;
    243            }  
    244          
    245          }
    246          ///memcpy(APP_Rx_Buffer,buff,len);  
    247          #endif
    248          return 0;
    249          }
    250          #endif
    251          ///==========================================
    252          ////extern u16     hdlc_bt_get_req_dat(u8 num_req,u8 *buf);
    253          ////extern int hdlc_bt_set_rec_dat(u8 cmd, void *in_buf);
    254          ////extern int hdlc_bt_get_rez(u8 type_rez,void *obuf);
    255          ////extern TaskHandle_t  my_system_monitor_thread_handle;
    256          
    257          ////TaskHandle_t  vcp_rx_thread_handle;
    258          ///TaskHandle_t  vcp_tx_thread_handle;
    259          TaskHandle_t  vcp_thread_handle;
    260          
    261          ////static 
    262          uint16_t VCP_DataRx (uint8_t* Buf, uint32_t Len)
    263          {
    264          ///signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
    265          uint8_t ch;
    266          int ii;
    267          ///VCP_MarkRead(Len);
    268          for(ii=0;ii<Len;ii++)
    269            {
    270            ch = Buf[ii];
    271            if (hdlc1_on_bytein(&g_hdlc_vcp, ch) > 0)
    272              {
    273              xQueueSend(g_hdlc_vcp.ev_rsv_frame, &ch,TIMEOUT_SEND);
    274          ///    xQueueSendFromISR(g_hdlc_vcp.ev_rsv_frame, &ch, &xHigherPriorityTaskWoken);
    275              }
    276            }
    277          ////VCP_MarkRead(Len);
    278          return USBD_OK;
    279          }
    280          extern int serial_read_tx(void);
    281          extern uint8_t serial_get_tx_buffer_count(void);
    282          
    283          extern void OnUsbDataRx(uint8_t* data_in, uint16_t length);
    284          #define MAX_LEN_RD_DAT 256
    285          ////===================================
    286          void vcp_thread(void *pdata)
    287          {
    288          ///uint8_t on_sleep=0;
    289          uint8_t rd_dat[MAX_LEN_RD_DAT];  
    290          uint32_t ii; 
    291          uint32_t sz; 
    292          int t_dat;
    293          uint8_t rd_tdat;
    294          #if 1  
    295          for (;;) 
    296          {
    297          sz  = VCP_DataAvailContig();
    298          while (sz)
    299            {
    300            if (sz > MAX_LEN_RD_DAT)
    301              {
    302              VCP_GetContig(rd_dat,MAX_LEN_RD_DAT);
    303              OnUsbDataRx(rd_dat,MAX_LEN_RD_DAT); 
    304              sz-=MAX_LEN_RD_DAT;
    305              }
    306            else
    307              {
    308              VCP_GetContig(rd_dat,sz);
    309              OnUsbDataRx(rd_dat,sz); 
    310              sz=0;
    311              }
    312          #if 0  
    313            for(ii=0;ii<sz;ii++)
    314              {
    315              VCP_GetContig(&rd_dat,1);
    316           ////   rd_dat++;
    317              ////=====================================
    318              send_char_dbg(rd_dat);
    319              ////==========================================
    320             VCP_PutContig(&rd_dat,1);
    321              }
    322          #endif  
    323          //// on_sleep=0;
    324            }
    325          sz  =  serial_get_tx_buffer_count();
    326          if(sz)
    327          {
    328          for(ii=0;ii<sz;ii++)
    329            {
    330            t_dat=serial_read_tx();  
    331            if(t_dat>0)
    332              {
    333              rd_tdat=t_dat;
    334              VCP_PutContig(&rd_tdat,1);
    335              }
    336              
    337            }
    338          }
    339          #if 0
    340          if(CAN_RxRdy)
    341            {
    342              
    343            on_sleep=0;  
    344            }
    345          if(on_sleep)
    346            {
    347            msleep(1);
    348            }
    349          #endif
    350          }
    351          #endif
    352          }
    353          
    354          ////===================================
    355          
    356          extern u16	pc_get_req_dat(u8 num_req,u16 offs,u8 *buf);
    357          extern int      pc_set_rec_dat(u8 cmd,void *in_buf);
    358          ///u8 addr= *((u8*)pdata);
    359          volatile int vtmp;
    360          ///=======================
    361          #if 0
    362          void init_hdlc_vcp(void)
    363          {
    364          BaseType_t rez;  
    365          g_hdlc_vcp.fn_send_byte=hdlc_vcp_send_byte;
    366          ////g_hdlc_vcp.fn_send_frame=hdlc_vcp_send_frame;
    367          g_hdlc_vcp.fn_set_rec_dat=pc_set_rec_dat;////hdlc_bt_set_rec_dat;
    368          g_hdlc_vcp.fn_get_req_dat=pc_get_req_dat;////hdlc_bt_get_req_dat;
    369          g_hdlc_vcp.ua_snd_dat=xQueueCreate(512,sizeof(unsigned char));		//8192
    370          g_hdlc_vcp.ev_rsv_ack=xQueueCreate(1,1);
    371          g_hdlc_vcp.ev_rsv_dat=xQueueCreate(1,1);
    372          g_hdlc_vcp.ev_rsv_frame=xQueueCreate(1,1);
    373          g_hdlc_vcp.ev_snd_frame=xQueueCreate(16, sizeof(uint32_t));
    374          hdlc1_init(&g_hdlc_vcp);
    375          
    376          rez=xTaskCreate(vcp_thread, (const char*)"vcp_thread",VCP_TX_STACK_SIZE/2, 0, APP_PRIORITY, &vcp_thread_handle);
    377          
    378          rez=xTaskCreate(hdlc1_obr_frame, (const char*)"HDLC_vcp_rx",VCP_RX_STACK_SIZE, (void*)&g_hdlc_vcp, APP_PRIORITY, &vcp_rx_thread_handle);
    379          rez=xTaskCreate(hdlc1_snd_task, (const char*)"HDLC_vcp_tx", VCP_TX_STACK_SIZE, (void*)&g_hdlc_vcp, APP_PRIORITY, &vcp_tx_thread_handle);
    380          vtmp=rez;
    381          ///put_tst1(0);
    382          }
    383          #endif
    384          ///======================================  
    385          ////static uint8_t flg_usb_on=0;
    386          ///======================================  
    387          void on_off_usb_thr(uint8_t on_off)
    388          {
    389          
    390          #if 0  
    391          if(on_off&0x1)
    392            {
    393            if(flg_usb_on)
    394              return;
    395            flg_usb_on=1;
    396          ////  put_tst1(1);
    397           vTaskResume(vcp_rx_thread_handle);
    398           vTaskResume(vcp_tx_thread_handle);
    399           vTaskResume(vcp_thread_handle);
    400          
    401            }
    402          else
    403            {
    404            if(!flg_usb_on)
    405              return;
    406            flg_usb_on=0;
    407            vTaskSuspend(vcp_rx_thread_handle);
    408            vTaskSuspend(vcp_tx_thread_handle);
    409            vTaskSuspend(vcp_thread_handle);
    410          ///  put_tst1(0);
    411            }
    412          #endif
    413          }
    414          ///======================================  
    415          #endif ///(USB_CLASS == CDC_VCP)
    416          ///======================================  

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   VCP_Ctrl
      16   VCP_DataAvail
        16   -> atomic_begin
        16   -> atomic_end
        16   -> ring_data_avail
      16   VCP_DataAvailContig
        16   -> atomic_begin
        16   -> atomic_end
        16   -> ring_data_contig
       0   VCP_DataPtr
      24   VCP_DataRx
        24   -> hdlc1_on_bytein
        24   -> xQueueGenericSend
       0   VCP_DeInit
      32   VCP_GetContig
        32   -> VCP_DataAvailContig
        32   -> VCP_DataPtr
        32   -> VCP_MarkRead
        32   -> __aeabi_memcpy
       0   VCP_Init
      16   VCP_MarkRead
        16   -> atomic_begin
        16   -> atomic_end
        16   -> ring_wrap
      16   VCP_MarkWritten
        16   -> atomic_begin
        16   -> atomic_end
        16   -> ring_wrap
      32   VCP_PutContig
        32   -> VCP_MarkWritten
        32   -> VCP_SpaceAvailContig
        32   -> VCP_SpacePtr
        32   -> __aeabi_memcpy
      16   VCP_SpaceAvail
        16   -> atomic_begin
        16   -> atomic_end
        16   -> ring_space_avail
      16   VCP_SpaceAvailContig
        16   -> atomic_begin
        16   -> atomic_end
        16   -> ring_space_contig
       0   VCP_SpacePtr
       0   atomic_begin
       0   atomic_end
      16   hdlc_vcp_send_byte
        16   -> VCP_PutContig
        16   -> vTaskDelay
       0   on_off_usb_thr
       0   ring_data_avail
       0   ring_data_contig
      16   ring_space_avail
        16   -> ring_data_avail
       0   ring_space_contig
       0   ring_wrap
     288   vcp_thread
       288   -> OnUsbDataRx
       288   -> VCP_DataAvailContig
       288   -> VCP_GetContig
       288   -> VCP_PutContig
       288   -> serial_get_tx_buffer_count
       288   -> serial_read_tx


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       6  VCP_Ctrl
      36  VCP_DataAvail
      36  VCP_DataAvailContig
      10  VCP_DataPtr
      54  VCP_DataRx
       4  VCP_DeInit
      60  VCP_GetContig
       4  VCP_Init
      34  VCP_MarkRead
      34  VCP_MarkWritten
      60  VCP_PutContig
      36  VCP_SpaceAvail
      36  VCP_SpaceAvailContig
      10  VCP_SpacePtr
      20  VCP_fops
       8  atomic_begin
       6  atomic_end
      84  g_hdlc_vcp
      32  hdlc_vcp_send_byte
       2  on_off_usb_thr
      20  ring_data_avail
      18  ring_data_contig
      24  ring_space_avail
      26  ring_space_contig
      12  ring_wrap
     124  vcp_thread
       4  vcp_thread_handle
       4  vtmp

 
  92 bytes in section .bss
  20 bytes in section .data
 724 bytes in section .text
 
 724 bytes of CODE memory
 112 bytes of DATA memory

Errors: none
Warnings: none
