###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         03/Jun/2021  21:14:31
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can\common\usb\cdc_vcp\usbd_cdc_vcp.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EW9ECC.tmp
#        (D:\proj\velograph\snail\stm32_snail\usb_can\common\usb\cdc_vcp\usbd_cdc_vcp.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -D MSTEP_BRD -D
#        USE_USB_OTG_FS -lcN
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\.\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\dbg\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\core\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\drv\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\hdlc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\..\common\usb\cdc\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\List\usbd_cdc_vcp.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can\usb_can\usb_can\Obj\usbd_cdc_vcp.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\usb_can\common\usb\cdc_vcp\usbd_cdc_vcp.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbd_cdc_vcp.c
      4            * @author  MCD Application Team
      5            * @version V1.2.0
      6            * @date    09-November-2015
      7            * @brief   Generic media access Layer.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          #include <stdlib.h>
     28          #include <string.h>
     29          #include "usbd_conf.h"
     30          #include "usbd_desc.h"
     31          
     32          #include "FreeRTOS.h"
     33          #include "task.h"
     34          #include "semphr.h"
     35          ////#include "my_misc.h"
     36          #include "_hdlc.h"
     37          #include "printk.h"
     38          #include "min_max.h"
     39          #include "ring_buff.h"
     40          ////#include "atomic.h"
     41          
     42          #if (USB_CLASS == CDC_VCP)|| (USB_CLASS == MSC_CDC)    ///================================
     43          
     44          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED 
     45          #pragma     data_alignment = 4 
     46          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
     47          
     48          #include "usbd_cdc_vcp.h"
     49          hdlc_stat_t g_hdlc_vcp;
     50          #if 0
     51          /* Private typedef -----------------------------------------------------------*/
     52          /* Private define ------------------------------------------------------------*/
     53          /* Private macro -------------------------------------------------------------*/
     54          /* Private variables ---------------------------------------------------------*/
     55          LINE_CODING linecoding =
     56            {
     57              115200, /* baud rate*/
     58              0x00,   /* stop bits-1*/
     59              0x00,   /* parity - none*/
     60              0x08    /* nb. of bits 8*/
     61            };
     62          
     63          
     64          USART_InitTypeDef USART_InitStructure;
     65          #endif
     66          
     67          /* These are external variables imported from CDC core to be used for IN 
     68             transfer management. */
     69          extern uint8_t  APP_Rx_Buffer []; /* Write CDC received data in this buffer.
     70                                               These data will be sent over USB IN endpoint
     71                                               in the CDC core functions. */
     72          extern uint32_t APP_Rx_ptr_in;    /* Increment this pointer or roll it back to
     73                                               start address when writing received data
     74                                               in the buffer APP_Rx_Buffer. */
     75          
     76          /* Private function prototypes -----------------------------------------------*/
     77          static uint16_t VCP_Init     (void);
     78          static uint16_t VCP_DeInit   (void);
     79          static uint16_t VCP_Ctrl     (uint32_t Cmd, uint8_t* Buf, uint32_t Len);
     80          ////static uint16_t VCP_DataTx   (uint8_t* Buf, uint32_t Len);
     81          ////static 
     82          ////uint16_t VCP_DataRx   (uint8_t* Buf, uint32_t Len);
     83          
     84          ///static uint16_t VCP_COMConfig(uint8_t Conf);
     85          
     86          CDC_IF_Prop_TypeDef VCP_fops = 
     87          {
     88            VCP_Init,
     89            VCP_DeInit,
     90            VCP_Ctrl,
     91            0,
     92            0
     93          ///  VCP_DataTx,
     94          ///  VCP_DataRx
     95          };
     96          
     97          static uint16_t VCP_Init(void)
     98          {
     99            return USBD_OK;
    100          }
    101          static uint16_t VCP_DeInit(void)
    102          {
    103            return USBD_OK;
    104          }
    105          
    106          static uint16_t VCP_Ctrl (uint32_t Cmd, uint8_t* Buf, uint32_t Len)
    107          { 
    108            return USBD_OK;
    109          }
    110          #if 0
    111          /**
    112            * @brief  VCP_DataTx
    113            *         CDC received data to be send over USB IN endpoint are managed in 
    114            *         this function.
    115            * @param  Buf: Buffer of data to be sent
    116            * @param  Len: Number of data to be sent (in bytes)
    117            * @retval Result of the operation: USBD_OK if all operations are OK else VCP_FAIL
    118            */
    119          static uint16_t VCP_DataTx (uint8_t* Buf, uint32_t Len)
    120          {
    121            return USBD_OK;
    122          }
    123          #endif
    124          ///=========================================
    125          /*
    126           * VCP data Rx/Tx API
    127           */
    128          
    129          void VCP_MarkRead(unsigned sz)
    130          {
    131          	atomic_t a = atomic_begin();
    132          	USB_Rx_buff_tail = ring_wrap(USB_Rx_buff_size, USB_Rx_buff_tail + sz);
    133          	atomic_end(a);
    134          }
    135          
    136          void VCP_MarkWritten(unsigned sz)
    137          {
    138          	atomic_t a = atomic_begin();
    139          	USB_Tx_buff_head = ring_wrap(USB_TX_BUFF_SIZE, USB_Tx_buff_head + sz);
    140          	atomic_end(a);
    141          }
    142          
    143          unsigned VCP_DataAvail(void)
    144          {
    145          	atomic_t a = atomic_begin();
    146          	unsigned sz = ring_data_avail(USB_Rx_buff_size, USB_Rx_buff_head, USB_Rx_buff_tail);
    147          	atomic_end(a);
    148          	return sz;
    149          }
    150          
    151          unsigned VCP_SpaceAvail(void)
    152          {
    153          	atomic_t a = atomic_begin();
    154          	unsigned sz = ring_space_avail(USB_TX_BUFF_SIZE, USB_Tx_buff_head, USB_Tx_buff_tail);
    155          	atomic_end(a);
    156          	return sz;
    157          }
    158          
    159          unsigned VCP_DataAvailContig(void)
    160          {
    161          	atomic_t a = atomic_begin();
    162          	unsigned sz = ring_data_contig(USB_Rx_buff_size, USB_Rx_buff_head, USB_Rx_buff_tail);
    163          	atomic_end(a);
    164          	return sz;
    165          }
    166          
    167          unsigned VCP_SpaceAvailContig(void)
    168          {
    169          	atomic_t a = atomic_begin();
    170          	unsigned sz = ring_space_contig(USB_TX_BUFF_SIZE, USB_Tx_buff_head, USB_Tx_buff_tail);
    171          	atomic_end(a);
    172          	return sz;
    173          }
    174          
    175          unsigned VCP_GetContig(void* buff, unsigned max_len)
    176          {
    177          	unsigned avail = VCP_DataAvailContig();
    178          	unsigned sz = MIN_(avail, max_len);
    179          	if (sz) {
    180          		memcpy(buff, VCP_DataPtr(), sz);
    181          		VCP_MarkRead(sz);
    182          	}
    183          	return sz;
    184          }
    185          
    186          unsigned VCP_PutContig(void const* buff, unsigned len)
    187          {
    188          unsigned avail = VCP_SpaceAvailContig();
    189          unsigned sz = MIN_(avail, len);
    190          if (sz) 
    191            {
    192            memcpy(VCP_SpacePtr(), buff, sz);
    193            VCP_MarkWritten(sz);
    194            }
    195          return sz;
    196          }
    197          
    198          ///==========================================
    199          
    200          #if 0
    201          void hdlc_vcp_send_byte(u8 val)
    202          {
    203          ///u8 btmp = val;
    204          APP_Rx_Buffer[APP_Rx_ptr_in]=val;
    205          APP_Rx_ptr_in++;
    206          if(APP_Rx_ptr_in == APP_RX_DATA_SIZE)
    207            {
    208            APP_Rx_ptr_in = 0;
    209            }  
    210          ////xQueueSend(g_hdlc_bt.ua_snd_dat, &btmp, portMAX_DELAY);
    211          /////on_int_tx_uart_bt();
    212          ///_printk("[%x]",APP_Rx_ptr_in);
    213          
    214          }
    215          #else
    216          void hdlc_vcp_send_byte(u8 val)
    217          {
    218          int num;  
    219          u8 btmp=val;
    220          for(;;)
    221          {
    222           num= VCP_PutContig(&btmp,1);
    223           if(num)
    224             break;
    225           msleep(1);
    226          }
    227          }
    228          #endif
    229          
    230          #if 0
    231          uint8_t hdlc_vcp_send_frame(uint8_t *buff,uint16_t len)
    232          {
    233          #if 1
    234          uint16_t ii;
    235          
    236          for(ii=0;ii<len;ii++)
    237          {
    238          APP_Rx_Buffer[APP_Rx_ptr_in]=buff[ii]; 
    239          if(APP_Rx_ptr_in == APP_RX_DATA_SIZE)
    240            {
    241            APP_Rx_ptr_in = 0;
    242            }  
    243          
    244          }
    245          ///memcpy(APP_Rx_Buffer,buff,len);  
    246          #endif
    247          return 0;
    248          }
    249          #endif
    250          ///==========================================
    251          ////extern u16     hdlc_bt_get_req_dat(u8 num_req,u8 *buf);
    252          ////extern int hdlc_bt_set_rec_dat(u8 cmd, void *in_buf);
    253          ////extern int hdlc_bt_get_rez(u8 type_rez,void *obuf);
    254          ////extern TaskHandle_t  my_system_monitor_thread_handle;
    255          
    256          TaskHandle_t  vcp_rx_thread_handle;
    257          TaskHandle_t  vcp_tx_thread_handle;
    258          TaskHandle_t  vcp_thread_handle;
    259          
    260          ////static 
    261          uint16_t VCP_DataRx (uint8_t* Buf, uint32_t Len)
    262          {
    263          ///signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
    264          uint8_t ch;
    265          int ii;
    266          ///VCP_MarkRead(Len);
    267          for(ii=0;ii<Len;ii++)
    268            {
    269            ch = Buf[ii];
    270            if (hdlc1_on_bytein(&g_hdlc_vcp, ch) > 0)
    271              {
    272              xQueueSend(g_hdlc_vcp.ev_rsv_frame, &ch,TIMEOUT_SEND);
    273          ///    xQueueSendFromISR(g_hdlc_vcp.ev_rsv_frame, &ch, &xHigherPriorityTaskWoken);
    274              }
    275            }
    276          ////VCP_MarkRead(Len);
    277          return USBD_OK;
    278          }
    279          ////===================================
    280          void vcp_thread(void *pdata)
    281          {
    282          uint8_t rd_dat;  
    283          uint32_t ii;  
    284          #if 1  
    285          for (;;) 
    286          {
    287          unsigned sz  = VCP_DataAvailContig();
    288          if (sz)
    289            {
    290            for(ii=0;ii<sz;ii++)
    291              {
    292              VCP_GetContig(&rd_dat,1);
    293              VCP_PutContig(&rd_dat,1);
    294          #if 0    
    295              if (hdlc1_on_bytein(&g_hdlc_vcp, rd_dat) > 0)
    296                {
    297                xQueueSend(g_hdlc_vcp.ev_rsv_frame, &rd_dat,TIMEOUT_SEND);
    298                }
    299          #endif    
    300              }
    301            }
    302          ///else
    303          ///  {
    304            msleep(1);
    305          ///  }
    306          }
    307          #endif
    308          }
    309          
    310          ////===================================
    311          
    312          extern u16	pc_get_req_dat(u8 num_req,u16 offs,u8 *buf);
    313          extern int      pc_set_rec_dat(u8 cmd,void *in_buf);
    314          ///u8 addr= *((u8*)pdata);
    315          volatile int vtmp;
    316          ///=======================
    317          void init_hdlc_vcp(void)
    318          {
    319          BaseType_t rez;  
    320          g_hdlc_vcp.fn_send_byte=hdlc_vcp_send_byte;
    321          ////g_hdlc_vcp.fn_send_frame=hdlc_vcp_send_frame;
    322          g_hdlc_vcp.fn_set_rec_dat=pc_set_rec_dat;////hdlc_bt_set_rec_dat;
    323          g_hdlc_vcp.fn_get_req_dat=pc_get_req_dat;////hdlc_bt_get_req_dat;
    324          g_hdlc_vcp.ua_snd_dat=xQueueCreate(512,sizeof(unsigned char));		//8192
    325          g_hdlc_vcp.ev_rsv_ack=xQueueCreate(1,1);
    326          g_hdlc_vcp.ev_rsv_dat=xQueueCreate(1,1);
    327          g_hdlc_vcp.ev_rsv_frame=xQueueCreate(1,1);
    328          g_hdlc_vcp.ev_snd_frame=xQueueCreate(16, sizeof(uint32_t));
    329          hdlc1_init(&g_hdlc_vcp);
    330          
    331          rez=xTaskCreate(vcp_thread, (const char*)"vcp_thread",VCP_TX_STACK_SIZE/2, 0, APP_PRIORITY, &vcp_thread_handle);
    332          
    333          rez=xTaskCreate(hdlc1_obr_frame, (const char*)"HDLC_vcp_rx",VCP_RX_STACK_SIZE, (void*)&g_hdlc_vcp, APP_PRIORITY, &vcp_rx_thread_handle);
    334          rez=xTaskCreate(hdlc1_snd_task, (const char*)"HDLC_vcp_tx", VCP_TX_STACK_SIZE, (void*)&g_hdlc_vcp, APP_PRIORITY, &vcp_tx_thread_handle);
    335          vtmp=rez;
    336          ///put_tst1(0);
    337          }
    338          
    339          ///======================================  
    340          ////static uint8_t flg_usb_on=0;
    341          ///======================================  
    342          void on_off_usb_thr(uint8_t on_off)
    343          {
    344          
    345          #if 0  
    346          if(on_off&0x1)
    347            {
    348            if(flg_usb_on)
    349              return;
    350            flg_usb_on=1;
    351          ////  put_tst1(1);
    352           vTaskResume(vcp_rx_thread_handle);
    353           vTaskResume(vcp_tx_thread_handle);
    354           vTaskResume(vcp_thread_handle);
    355          
    356            }
    357          else
    358            {
    359            if(!flg_usb_on)
    360              return;
    361            flg_usb_on=0;
    362            vTaskSuspend(vcp_rx_thread_handle);
    363            vTaskSuspend(vcp_tx_thread_handle);
    364            vTaskSuspend(vcp_thread_handle);
    365          ///  put_tst1(0);
    366            }
    367          #endif
    368          }
    369          ///======================================  
    370          #endif ///(USB_CLASS == CDC_VCP)
    371          ///======================================  

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   VCP_Ctrl
      16   VCP_DataAvail
        16   -> atomic_begin
        16   -> atomic_end
        16   -> ring_data_avail
      16   VCP_DataAvailContig
        16   -> atomic_begin
        16   -> atomic_end
        16   -> ring_data_contig
       0   VCP_DataPtr
      24   VCP_DataRx
        24   -> hdlc1_on_bytein
        24   -> xQueueGenericSend
       0   VCP_DeInit
      32   VCP_GetContig
        32   -> VCP_DataAvailContig
        32   -> VCP_DataPtr
        32   -> VCP_MarkRead
        32   -> __aeabi_memcpy
       0   VCP_Init
      16   VCP_MarkRead
        16   -> atomic_begin
        16   -> atomic_end
        16   -> ring_wrap
      16   VCP_MarkWritten
        16   -> atomic_begin
        16   -> atomic_end
        16   -> ring_wrap
      32   VCP_PutContig
        32   -> VCP_MarkWritten
        32   -> VCP_SpaceAvailContig
        32   -> VCP_SpacePtr
        32   -> __aeabi_memcpy
      16   VCP_SpaceAvail
        16   -> atomic_begin
        16   -> atomic_end
        16   -> ring_space_avail
      16   VCP_SpaceAvailContig
        16   -> atomic_begin
        16   -> atomic_end
        16   -> ring_space_contig
       0   VCP_SpacePtr
       0   atomic_begin
       0   atomic_end
      16   hdlc_vcp_send_byte
        16   -> VCP_PutContig
        16   -> vTaskDelay
      24   init_hdlc_vcp
        24   -> hdlc1_init
        24   -> xQueueGenericCreate
        24   -> xTaskCreate
       0   on_off_usb_thr
       0   ring_data_avail
       0   ring_data_contig
      16   ring_space_avail
        16   -> ring_data_avail
       0   ring_space_contig
       0   ring_wrap
      24   vcp_thread
        24   -> VCP_DataAvailContig
        24   -> VCP_GetContig
        24   -> VCP_PutContig
        24   -> vTaskDelay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_18
       4  ??DataTable10_19
       4  ??DataTable10_2
       4  ??DataTable10_20
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      12  ?_0
      12  ?_1
      12  ?_2
       6  VCP_Ctrl
      36  VCP_DataAvail
      36  VCP_DataAvailContig
      10  VCP_DataPtr
      54  VCP_DataRx
       4  VCP_DeInit
      60  VCP_GetContig
       4  VCP_Init
      34  VCP_MarkRead
      34  VCP_MarkWritten
      60  VCP_PutContig
      36  VCP_SpaceAvail
      36  VCP_SpaceAvailContig
      10  VCP_SpacePtr
      20  VCP_fops
       8  atomic_begin
       6  atomic_end
      84  g_hdlc_vcp
      32  hdlc_vcp_send_byte
     160  init_hdlc_vcp
       2  on_off_usb_thr
      20  ring_data_avail
      18  ring_data_contig
      24  ring_space_avail
      26  ring_space_contig
      12  ring_wrap
       4  vcp_rx_thread_handle
      50  vcp_thread
       4  vcp_thread_handle
       4  vcp_tx_thread_handle
       4  vtmp

 
 100 bytes in section .bss
  20 bytes in section .data
  36 bytes in section .rodata
 862 bytes in section .text
 
 862 bytes of CODE  memory
  36 bytes of CONST memory
 120 bytes of DATA  memory

Errors: none
Warnings: none
