###############################################################################
#
# IAR ANSI C/C++ Compiler V9.10.2.313/W64 for ARM         27/May/2022  14:57:40
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\src\drv\can_drv.c
#    Command line      =
#        -f
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\step_x_dbg\List\drv\can_drv.lst.rsp
#        (D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\src\drv\can_drv.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D DIMA_BRD -D STEP_X -D STM32F205xx
#        -lcN
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\step_x_dbg\List\drv
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\step_x_dbg\Obj\drv
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\.\ -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\src\board\ -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\src\inc\ -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\dbg\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\usb\drv\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\board\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.0\arm\CMSIS\Core\Include\\" -I "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\CMSIS\DSP\Include\\")
#        --dependencies=n
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\step_x_dbg\Obj\drv\can_drv.o.d
#    Locale            =  C
#    List file         =
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\step_x_dbg\List\drv\can_drv.lst
#    Object file       =
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\step_x_dbg\Obj\drv\can_drv.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\src\drv\can_drv.c
      1          #include "stdint.h"
      2          #include "stm32f2xx.h"
      3          #include "stm32f2xx_rcc.h"
      4          #include "stm32f2xx_can.h"
      5          #include "misc.h"
      6          #include "board.h"
      7          #include "snail_can_cmds.h"
      8          #include "printk.h"
      9          ////=======================================================
     10          ////#define CANx CAN1
     11          #define MAX_CAN_DATA_LEN 8
     12          
     13          ////=======================================================
     14          typedef enum {FAILED = 0, PASSED = !FAILED} TestStatus;
     15          volatile TestStatus TestRx;
     16          __IO uint32_t ret=0;
     17          uint8_t  CAN_TxRdy = 0;              /* CAN HW ready to transmit message */
     18          uint8_t  CAN_RxRdy = 0;              /* CAN HW received a message        */
     19          CanRxMsg RxMessage;
     20          
     21          ////=============================================================
     22          void NVIC_can_Config(void)
     23          {
     24          NVIC_InitTypeDef NVIC_InitStructure;
     25          
     26          NVIC_InitStructure.NVIC_IRQChannel = CAN1_RX0_IRQn;
     27          NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     28          NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     29          NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
     30          NVIC_Init(&NVIC_InitStructure);
     31          }
     32          
     33          void can1_init(void)
     34          {
     35          CAN_InitTypeDef        CAN_InitStructure;
     36          CAN_FilterInitTypeDef  CAN_FilterInitStructure;
     37            
     38          GPIO_InitTypeDef GPIO_InitStructure;
     39          ////============== CAN1_INH ============================
     40          RCC_AHB1PeriphClockCmd(CAN1_INH_PIN_RCC, ENABLE);
     41          GPIO_InitStructure.GPIO_Pin = CAN1_INH_PIN;
     42          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     43          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
     44          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     45          GPIO_Init( CAN1_INH_PIN_GPIO, &GPIO_InitStructure );
     46          GPIO_ResetBits(CAN1_INH_PIN_GPIO, CAN1_INH_PIN);
     47          
     48          ////============== CAN1_RX ============================
     49          RCC_AHB1PeriphClockCmd(CAN1_RX_PIN_RCC, ENABLE);
     50          GPIO_InitStructure.GPIO_Pin = CAN1_RX_PIN;
     51          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     52          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     53          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     54          GPIO_Init(CAN1_RX_PIN_GPIO, &GPIO_InitStructure );
     55          GPIO_PinAFConfig(CAN1_RX_PIN_GPIO, CAN1_RX_PIN_SOURCE, GPIO_AF_CAN1);
     56          ////============== CAN1_TX ============================
     57          RCC_AHB1PeriphClockCmd(CAN1_TX_PIN_RCC, ENABLE);
     58          GPIO_InitStructure.GPIO_Pin = CAN1_TX_PIN;
     59          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     60          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     61          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     62          GPIO_Init(CAN1_TX_PIN_GPIO, &GPIO_InitStructure );
     63          GPIO_PinAFConfig(CAN1_TX_PIN_GPIO, CAN1_TX_PIN_SOURCE, GPIO_AF_CAN1);
     64          ////================================================================
     65          RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE);
     66          NVIC_can_Config();
     67          
     68            /* CAN register init */
     69            CAN_DeInit(CAN1);
     70          
     71            /* CAN cell init */
     72            CAN_InitStructure.CAN_TTCM = DISABLE;
     73            CAN_InitStructure.CAN_ABOM = DISABLE;
     74            CAN_InitStructure.CAN_AWUM = DISABLE;
     75            CAN_InitStructure.CAN_NART = DISABLE;
     76            CAN_InitStructure.CAN_RFLM = DISABLE;
     77            CAN_InitStructure.CAN_TXFP = DISABLE;
     78            CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;///CAN_Mode_LoopBack;
     79            CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;
     80            
     81            /* Baudrate = 500 Kbps */
     82            CAN_InitStructure.CAN_BS1 = CAN_BS1_6tq;
     83            CAN_InitStructure.CAN_BS2 = CAN_BS2_8tq;
     84            CAN_InitStructure.CAN_Prescaler = 4;
     85            CAN_Init(CAN1, &CAN_InitStructure);
     86          
     87            /* CAN filter init */
     88            CAN_FilterInitStructure.CAN_FilterNumber = 0;
     89            CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
     90            CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
     91            
     92          /////  CAN_FilterInitStructure.CAN_FilterIdHigh = CAN_FILTR_ID<<5;
     93            CAN_FilterInitStructure.CAN_FilterIdHigh = 0;
     94           CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000;
     95          /////  CAN_FilterInitStructure.CAN_FilterMaskIdHigh = CAN_FILTR_MASK<<5;///0x0000;
     96            CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0x0000;
     97            CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x0000;
     98            
     99            CAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_FIFO0;
    100            CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
    101            CAN_FilterInit(&CAN_FilterInitStructure);
    102          
    103            /* CAN FIFO0 message pending interrupt enable */ 
    104            CAN_ITConfig(CAN1, CAN_IT_FMP0, ENABLE);
    105          
    106          }
    107          ////==================================================================
    108          uint8_t can1_send(uint16_t id,uint8_t data_len,uint8_t *data)
    109          {
    110          CanTxMsg TxMessage;
    111          uint8_t ii ;
    112            /* transmit 1 message */
    113            TxMessage.StdId = 0;
    114            TxMessage.ExtId = id;
    115            TxMessage.IDE = CAN_ID_EXT;
    116            TxMessage.RTR = CAN_RTR_DATA;
    117            if(data_len>MAX_CAN_DATA_LEN)
    118              {
    119              data_len=MAX_CAN_DATA_LEN ; 
    120              }
    121            TxMessage.DLC = data_len;
    122            for(ii=0;ii<data_len;ii++)
    123              {
    124              TxMessage.Data[ii] = data[ii];
    125              }
    126            CAN_Transmit(CAN1, &TxMessage);
    127            return data_len;
    128          }
    129          
    130          TestStatus CAN_Interrupt(void)
    131          {
    132            CanTxMsg TxMessage;
    133            uint32_t i = 0;
    134          
    135          
    136            /* transmit 1 message */
    137            TxMessage.StdId = 0;
    138            TxMessage.ExtId = 0x1234;
    139            TxMessage.IDE = CAN_ID_EXT;
    140            TxMessage.RTR = CAN_RTR_DATA;
    141            TxMessage.DLC = 2;
    142            TxMessage.Data[0] = 0xDE;
    143            TxMessage.Data[1] = 0xCA;
    144            CAN_Transmit(CAN1, &TxMessage);
    145          
    146            /* initialize the value that will be returned */
    147            ret = 0xFF;
    148                 
    149            /* receive message with interrupt handling */
    150            i = 0;
    151            while((ret ==  0xFF) && (i < 0xFFF))
    152            {
    153              i++;
    154            }
    155            
    156            if (i ==  0xFFF)
    157            {
    158              ret = 0;  
    159            }
    160          
    161            /* disable interrupt handling */
    162            CAN_ITConfig(CAN1, CAN_IT_FMP0, DISABLE);
    163          
    164            return (TestStatus)ret;
    165          }
    166          
    167          ////==================================================================
    168          int can_main1(void)
    169          {
    170          RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE);
    171          NVIC_can_Config();
    172          ////=========================================
    173          __enable_irq();
    174          ////========================================
    175          #if 0
    176          TestRx = CAN_Polling();
    177          if (TestRx !=  FAILED)
    178            { /* OK */
    179            printk("\r\n CAN_Polling OK");
    180            }
    181            else
    182            { /* KO */
    183            printk("\r\n CAN_Polling BAD");
    184            }
    185          #endif
    186            TestRx = CAN_Interrupt();
    187          if (TestRx !=  FAILED)
    188            { /* OK */
    189          
    190             printk("\r\n Interrupt OK");
    191            }
    192            else
    193            { /* KO */
    194             printk("\r\n Interrupt BAD");
    195            }
    196          
    197            /* Infinite loop */
    198            while (1)
    199            {
    200              
    201            }
    202          
    203          return 0;
    204          }
    205          ///=============================================
    206          #define CAN_MAX_NUM_BYTES 8
    207          #define STANDARD_FORMAT  0
    208          #define EXTENDED_FORMAT  1
    209          
    210          #define DATA_FRAME       0
    211          #define REMOTE_FRAME     1
    212          
    213          typedef struct  CAN_msg_s_{
    214            unsigned int   id;                 // 29 bit identifier
    215            unsigned char  data[CAN_MAX_NUM_BYTES];            // Data field
    216            unsigned char  len;                // Length of data field in bytes
    217            unsigned char  format;             // 0 - STANDARD, 1- EXTENDED IDENTIFIER
    218            unsigned char  type;               // 0 - DATA FRAME, 1 - REMOTE FRAME
    219          } can_msg_t;
    220          can_msg_t       CAN_RxMsg;                  /* CAN message for receiving        */                        
    221          
    222          /*----------------------------------------------------------------------------
    223            read a message from CAN peripheral and release it
    224           *----------------------------------------------------------------------------*/
    225          void CAN_rdMsg (can_msg_t *msg)  {
    226                                                        /* Read identifier information  */
    227            if ((CAN1->sFIFOMailBox[0].RIR & CAN_ID_EXT) == 0) {
    228              msg->format = STANDARD_FORMAT;
    229              msg->id     = 0x000007FF & (CAN1->sFIFOMailBox[0].RIR >> 21);
    230            } else {
    231              msg->format = EXTENDED_FORMAT;
    232              msg->id     = 0x1FFFFFFF & (CAN1->sFIFOMailBox[0].RIR >> 3);
    233            }
    234                                                        /* Read type information        */
    235            if ((CAN1->sFIFOMailBox[0].RIR & CAN_RTR_REMOTE) == 0) {
    236              msg->type =   DATA_FRAME;
    237            } else {
    238              msg->type = REMOTE_FRAME;
    239            }
    240                                                        /* Read number of rec. bytes    */
    241            msg->len     = (CAN1->sFIFOMailBox[0].RDTR      ) & 0x0F;
    242                                                        /* Read data bytes              */
    243            msg->data[0] = (CAN1->sFIFOMailBox[0].RDLR      ) & 0xFF;
    244            msg->data[1] = (CAN1->sFIFOMailBox[0].RDLR >>  8) & 0xFF;
    245            msg->data[2] = (CAN1->sFIFOMailBox[0].RDLR >> 16) & 0xFF;
    246            msg->data[3] = (CAN1->sFIFOMailBox[0].RDLR >> 24) & 0xFF;
    247          
    248            msg->data[4] = (CAN1->sFIFOMailBox[0].RDHR      ) & 0xFF;
    249            msg->data[5] = (CAN1->sFIFOMailBox[0].RDHR >>  8) & 0xFF;
    250            msg->data[6] = (CAN1->sFIFOMailBox[0].RDHR >> 16) & 0xFF;
    251            msg->data[7] = (CAN1->sFIFOMailBox[0].RDHR >> 24) & 0xFF;
    252          
    253            CAN1->RF0R |= CAN_RF0R_RFOM0;             /* Release FIFO 0 output mailbox */
    254          }
    255          
    256          
    257          void CAN1_RX0_IRQHandler (void)
    258          {
    259          if (CAN1->RF0R & CAN_RF0R_FMP0)
    260            {			/* message pending ?              */
    261            CAN_rdMsg (&CAN_RxMsg);                 /* read the message               */
    262            CAN_RxRdy = 1;                          // set receive flag
    263            }
    264          }
    265          
    266          
    267          ////==================================================================
    268          void CAN_wrFilter (unsigned int id, unsigned char format)  {
    269            static unsigned short CAN_filterIdx = 0;
    270                   unsigned int   CAN_msgId     = 0;
    271            
    272            if (CAN_filterIdx > 13) {                 /* check if Filter Memory is full*/
    273              return;
    274            }
    275                                                      /* Setup identifier information  */
    276            if (format == STANDARD_FORMAT)  {         /*   Standard ID                 */
    277                CAN_msgId |= (uint32_t)(id << 21) | CAN_ID_STD;
    278            }  else  {                                /*   Extended ID                 */
    279                CAN_msgId |= (uint32_t)(id <<  3) | CAN_ID_EXT;
    280            }
    281          
    282            CAN1->FMR  |=   CAN_FMR_FINIT;            /* set initMode for filter banks */
    283            CAN1->FA1R &=  ~(1UL << CAN_filterIdx);   /* deactivate filter             */
    284          
    285                                                      /* initialize filter             */
    286            CAN1->FS1R |= (unsigned int)(1 << CAN_filterIdx);     /* set 32-bit scale configuration    */
    287            CAN1->FM1R |= (unsigned int)(1 << CAN_filterIdx);     /* set 2 32-bit identifier list mode */
    288          
    289            CAN1->sFilterRegister[CAN_filterIdx].FR1 = CAN_msgId; /*  32-bit identifier                */
    290            CAN1->sFilterRegister[CAN_filterIdx].FR2 = CAN_msgId; /*  32-bit identifier                */
    291              													   
    292            CAN1->FFA1R &= ~(unsigned int)(1 << CAN_filterIdx);   /* assign filter to FIFO 0           */
    293            CAN1->FA1R  |=  (unsigned int)(1 << CAN_filterIdx);   /* activate filter                   */
    294          
    295            CAN1->FMR &= ~CAN_FMR_FINIT;              /* reset initMode for filterBanks*/
    296          
    297            CAN_filterIdx += 1;                       /* increase filter index         */
    298          }
    299          
    300          void CAN_waitReady (void)  
    301          {
    302          while ((CAN1->TSR & CAN_TSR_TME0) == 0);  /* Transmit mailbox 0 is empty    */
    303          CAN_TxRdy = 1;
    304           
    305          }
    306          void CAN_setup (void)  
    307          {
    308          unsigned int brp;
    309          
    310            RCC->APB1ENR |= ( 1UL << 25);           /* enable clock for CAN             */
    311            NVIC_EnableIRQ(CAN1_TX_IRQn);    /* enable CAN TX interrupt          */
    312            NVIC_EnableIRQ(CAN1_RX0_IRQn);   /* enable CAN RX interrupt          */
    313          
    314            CAN1->MCR = (CAN_MCR_INRQ   |           /* initialisation request           */
    315                         CAN_MCR_NART    );         /* no automatic retransmission      */
    316                                                    /* only FIFO 0, tx mailbox 0 used!  */
    317            CAN1->IER = (CAN_IER_FMPIE0 |           /* enable FIFO 0 msg pending IRQ    */
    318                         CAN_IER_TMEIE    );        /* enable Transmit mbx empty IRQ    */
    319          
    320          brp = 4;//4;
    321                                                                                    
    322          CAN1->BTR &= ~(((        0x03) << 24) | ((        0x07) << 20) | ((         0x0F) << 16) | (          0x1FF)); 
    323          CAN1->BTR |=  ((((1-1) & 0x03) << 24) | (((8-1) & 0x07) << 20) | (((6-1) & 0x0F) << 16) | ((brp-1) & 0x1FF));
    324          }
    325          void CAN_start (void)  
    326          {
    327          CAN1->MCR &= ~CAN_MCR_INRQ;             /* normal operating mode, reset INRQ*/
    328          while (CAN1->MSR & CAN_MCR_INRQ);
    329          
    330          }
    331          
    332          ////================================================================================
    333          void CAN1_Init (void)
    334          {
    335          CAN_setup ();                                   /* setup CAN Controller     */
    336          
    337          CAN_wrFilter (0x0, STANDARD_FORMAT);
    338          ////CAN_wrFilter (0x080 + NODE, STANDARD_FORMAT);
    339          ////CAN_wrFilter (0x700 + NODE, STANDARD_FORMAT);
    340          	
    341          CAN_start ();                                   /* start CAN Controller   */
    342          	
    343          CAN_waitReady ();                               /* wait til tx mbx is empty */
    344          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CAN1_Init
         8   -> CAN_setup
         8   -> CAN_start
         8   -> CAN_waitReady
         8   -> CAN_wrFilter
       8   CAN1_RX0_IRQHandler
         8   -> CAN_rdMsg
      32   CAN_Interrupt
        32   -> CAN_ITConfig
        32   -> CAN_Transmit
       0   CAN_rdMsg
       8   CAN_setup
         8   -> __NVIC_EnableIRQ
       0   CAN_start
       0   CAN_waitReady
       8   CAN_wrFilter
       8   NVIC_can_Config
         8   -> NVIC_Init
       0   __NVIC_EnableIRQ
      40   can1_init
        40   -> CAN_DeInit
        40   -> CAN_FilterInit
        40   -> CAN_ITConfig
        40   -> CAN_Init
        40   -> GPIO_Init
        40   -> GPIO_PinAFConfig
        40   -> GPIO_ResetBits
        40   -> NVIC_can_Config
        40   -> RCC_AHB1PeriphClockCmd
        40   -> RCC_APB1PeriphClockCmd
      40   can1_send
        40   -> CAN_Transmit
       8   can_main1
         8   -> CAN_Interrupt
         8   -> NVIC_can_Config
         8   -> RCC_APB1PeriphClockCmd
         8   -> _printk


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_18
       4  ??DataTable10_19
       4  ??DataTable10_2
       4  ??DataTable10_20
       4  ??DataTable10_21
       4  ??DataTable10_22
       4  ??DataTable10_23
       4  ??DataTable10_24
       4  ??DataTable10_25
       4  ??DataTable10_26
       4  ??DataTable10_27
       4  ??DataTable10_28
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      16  ?_0
      20  ?_1
      24  CAN1_Init
      26  CAN1_RX0_IRQHandler
     116  CAN_Interrupt
      16  CAN_RxMsg
       1  CAN_RxRdy
       1  CAN_TxRdy
       2  CAN_filterIdx
     136  CAN_rdMsg
      74  CAN_setup
      22  CAN_start
      16  CAN_waitReady
     184  CAN_wrFilter
      34  NVIC_can_Config
      20  RxMessage
       1  TestRx
      32  __NVIC_EnableIRQ
     334  can1_init
      98  can1_send
      50  can_main1
       4  ret

 
    45 bytes in section .bss
    36 bytes in section .rodata
 1'262 bytes in section .text
 
 1'262 bytes of CODE  memory
    36 bytes of CONST memory
    45 bytes of DATA  memory

Errors: none
Warnings: 1
