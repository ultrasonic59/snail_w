###############################################################################
#
# IAR ANSI C/C++ Compiler V9.10.2.313/W64 for ARM         27/May/2022  14:57:38
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\src\board\dima_board.c
#    Command line      =
#        -f
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\step_x_dbg\List\Board\dima_board.lst.rsp
#        (D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\src\board\dima_board.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D DIMA_BRD -D STEP_X -D STM32F205xx
#        -lcN
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\step_x_dbg\List\Board
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\step_x_dbg\Obj\Board
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\.\ -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\src\board\ -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\src\inc\ -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\dbg\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\usb\drv\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\board\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.0\arm\CMSIS\Core\Include\\" -I "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\CMSIS\DSP\Include\\")
#        --dependencies=n
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\step_x_dbg\Obj\Board\dima_board.o.d
#    Locale            =  C
#    List file         =
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\step_x_dbg\List\Board\dima_board.lst
#    Object file       =
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\step_x_dbg\Obj\Board\dima_board.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\src\board\dima_board.c
      1          #include <string.h>
      2          #include "FreeRTOS.h"
      3          #include "queue.h"
      4          #include "semphr.h"
      5          ///#include "stm32f2xx_gpio.h"
      6          ///#include "stm32f2xx_rcc.h"
      7          
      8          ////#include "board.h"
      9          #include "board.h"
     10          #include "printk.h"
     11          
     12          extern void uDelay (const uint32_t usec);
     13          extern void  put_tst_pin(uint8_t idat);
     14          void mot_spi_wr(uint8_t addr,uint16_t idata);
     15          uint16_t mot_spi_rd(uint8_t addr);
     16          void CAN_Config(void);
     17          
     18          ///=============================
     19          int send_char_dbg (int c) 
     20          { 
     21          while (!(UART_DBG->SR & 0x0080));
     22          UART_DBG->DR = (c & 0x1FF);
     23          return (c);
     24          }
     25          void _putk(char ch)
     26          {
     27          send_char_dbg(ch);
     28          }
     29          
     30          int get_byte_dbg (void) 
     31          {
     32          while (!(UART_DBG->SR & USART_SR_RXNE));
     33          return (UART_DBG->DR);
     34          }
     35          int check_push_key_dbg(void)
     36          {
     37          return  (UART_DBG->SR & USART_SR_RXNE); 
     38          }
     39          
     40          void init_gpio(void)
     41          {
     42          ////RCC_AHBPeriphClockCmd(XEN_PIN_RCC_AHB,ENABLE);
     43          GPIO_InitTypeDef GPIO_InitStructure;
     44          ////=============== TST2 ============================
     45          RCC_AHB1PeriphClockCmd(TST2_PIN_RCC, ENABLE);
     46          GPIO_InitStructure.GPIO_Pin = TST2_PIN;
     47          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     48          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
     49          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     50          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
     51          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
     52          GPIO_Init( TST2_PIN_GPIO, &GPIO_InitStructure );
     53          ////=============== TST3 ============================
     54          RCC_AHB1PeriphClockCmd(TST3_PIN_RCC, ENABLE);
     55          GPIO_InitStructure.GPIO_Pin = TST3_PIN;
     56          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     57          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
     58          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     59          
     60          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     61          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
     62          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
     63          GPIO_Init( TST3_PIN_GPIO, &GPIO_InitStructure );
     64          GPIO_PinAFConfig(TST3_PIN_GPIO, TST3_PIN_NPIN, GPIO_AF_TIM1);
     65          
     66          ////=============== TST7 ============================
     67          RCC_AHB1PeriphClockCmd(TST7_PIN_RCC, ENABLE);
     68          GPIO_InitStructure.GPIO_Pin = TST7_PIN;
     69          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     70          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
     71          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     72          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     73          GPIO_Init( TST7_PIN_GPIO, &GPIO_InitStructure );
     74          GPIO_PinAFConfig(TST7_PIN_GPIO, TST7_PIN_NPIN, GPIO_AF_TIM8);
     75            
     76          ////=========== DBG_UART =================================================== 
     77          RCC_AHB1PeriphClockCmd(UART_DBG_TX_RCC, ENABLE);
     78          GPIO_InitStructure.GPIO_Pin = UART_DBG_TX_PIN;
     79          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     80          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     81          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     82          GPIO_Init( UART_DBG_TX_GPIO, &GPIO_InitStructure );
     83          
     84          RCC_AHB1PeriphClockCmd(UART_DBG_RX_RCC, ENABLE);
     85          GPIO_InitStructure.GPIO_Pin = UART_DBG_RX_PIN;
     86          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     87          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     88          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     89          GPIO_Init( UART_DBG_RX_GPIO, &GPIO_InitStructure );
     90            
     91          GPIO_PinAFConfig(UART_DBG_TX_GPIO, UART_DBG_TX_PIN_NPIN, UART_DBG_TX_AF);
     92          GPIO_PinAFConfig(UART_DBG_RX_GPIO, UART_DBG_RX_PIN_NPIN, UART_DBG_RX_AF);
     93          ////===================================================================
     94          ////=============== MOT_FAULT ============================
     95          RCC_AHB1PeriphClockCmd(MOT_FAULT_PIN_RCC, ENABLE);
     96          GPIO_InitStructure.GPIO_Pin = MOT_FAULT_PIN;
     97          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     98          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
     99          GPIO_Init( MOT_FAULT_PIN_GPIO, &GPIO_InitStructure );
    100          ////=============== MOT_STALLN ============================
    101          RCC_AHB1PeriphClockCmd(MOT_STALLN_PIN_RCC, ENABLE);
    102          GPIO_InitStructure.GPIO_Pin = MOT_STALLN_PIN;
    103          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    104          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    105          GPIO_Init( MOT_STALLN_PIN_GPIO, &GPIO_InitStructure );
    106          ////=============== CONC1 ============================
    107          RCC_AHB1PeriphClockCmd(CONC1_PIN_RCC, ENABLE);
    108          GPIO_InitStructure.GPIO_Pin = CONC1_PIN;
    109          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    110          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    111          GPIO_Init( CONC1_PIN_GPIO, &GPIO_InitStructure );
    112          ////=============== CONC0 ============================
    113          RCC_AHB1PeriphClockCmd(CONC0_PIN_RCC, ENABLE);
    114          GPIO_InitStructure.GPIO_Pin = CONC0_PIN;
    115          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    116          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    117          GPIO_Init( CONC0_PIN_GPIO, &GPIO_InitStructure );
    118          ////=============== MOT_RESET ============================
    119          RCC_AHB1PeriphClockCmd(MOT_RESET_PIN_RCC, ENABLE);
    120          GPIO_InitStructure.GPIO_Pin = MOT_RESET_PIN;
    121          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    122          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    123          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    124          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    125          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    126          GPIO_Init( MOT_RESET_PIN_GPIO, &GPIO_InitStructure );
    127          ////=============== MOT_SLEEP ============================
    128          RCC_AHB1PeriphClockCmd(MOT_SLEEP_PIN_RCC, ENABLE);
    129          GPIO_InitStructure.GPIO_Pin = MOT_SLEEP_PIN;
    130          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    131          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    132          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    133          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    134          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    135          GPIO_Init( MOT_SLEEP_PIN_GPIO, &GPIO_InitStructure );
    136          ////#define MOT_STEP_TIM  	        TIM12
    137          ////=============== MOT_STEP ============================
    138          RCC_AHB1PeriphClockCmd(MOT_STEP_PIN_RCC, ENABLE);
    139          GPIO_InitStructure.GPIO_Pin = MOT_STEP_PIN;
    140          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    141          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    142          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    143          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    144          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    145          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    146          GPIO_Init( MOT_STEP_PIN_GPIO, &GPIO_InitStructure );
    147          GPIO_PinAFConfig(MOT_STEP_PIN_GPIO, MOT_STEP_PIN_NPIN, GPIO_AF_TIM1);
    148          ////===================================================================
    149          
    150          ////=============== MOT_DIR ============================
    151          RCC_AHB1PeriphClockCmd(MOT_DIR_PIN_RCC, ENABLE);
    152          GPIO_InitStructure.GPIO_Pin = MOT_DIR_PIN;
    153          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    154          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    155          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    156          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    157          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    158          GPIO_Init( MOT_DIR_PIN_GPIO, &GPIO_InitStructure );
    159          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    160          
    161          ////=============== MOT_SPI_SCS ============================
    162          RCC_AHB1PeriphClockCmd(MOT_SPI_SCS_PIN_RCC, ENABLE);
    163          GPIO_InitStructure.GPIO_Pin = MOT_SPI_SCS_PIN;
    164          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    165          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    166          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    167          GPIO_Init( MOT_SPI_SCS_PIN_GPIO, &GPIO_InitStructure );
    168          ////============== CAN1_INH ============================
    169          RCC_AHB1PeriphClockCmd(CAN1_INH_PIN_RCC, ENABLE);
    170          GPIO_InitStructure.GPIO_Pin = CAN1_INH_PIN;
    171          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    172          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    173          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    174          GPIO_Init( CAN1_INH_PIN_GPIO, &GPIO_InitStructure );
    175          GPIO_ResetBits(CAN1_INH_PIN_GPIO, CAN1_INH_PIN);
    176          
    177          }
    178          ////=============================================
    179          void UART_DBG_Init(void)
    180          {
    181          ////GPIO_InitTypeDef GPIO_InitStructure;
    182          USART_InitTypeDef USART_InitStructure;
    183          UART_DBG_CLK_INIT(UART_DBG_CLK, ENABLE);
    184          USART_DeInit(UART_DBG);
    185          USART_InitStructure.USART_BaudRate = 115200;
    186          USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    187          USART_InitStructure.USART_StopBits = USART_StopBits_1 ;
    188          USART_InitStructure.USART_Parity = USART_Parity_No;
    189          USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    190          USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    191          USART_Init(UART_DBG, &USART_InitStructure);
    192          UART_DBG->CR1 |= USART_CR1_RXNEIE;
    193          USART_Cmd(UART_DBG, ENABLE);
    194          }
    195          
    196          ////==================================================
    197          
    198          void  set_sleep_mot(uint8_t idat)
    199          {
    200          if(idat&0x1)
    201            {
    202            GPIO_SetBits(MOT_SLEEP_PIN_GPIO, MOT_SLEEP_PIN);
    203            }
    204          else
    205            {
    206             GPIO_ResetBits(MOT_SLEEP_PIN_GPIO, MOT_SLEEP_PIN);
    207            }
    208          }
    209          void  set_dir_mot(uint8_t idat)
    210          {
    211          if(idat&0x1)
    212            {
    213            GPIO_SetBits(MOT_DIR_PIN_GPIO, MOT_DIR_PIN);
    214            }
    215          else
    216            {
    217             GPIO_ResetBits(MOT_DIR_PIN_GPIO, MOT_DIR_PIN);
    218            }
    219          }
    220          void  set_reset_mot(uint8_t idat)
    221          {
    222          if(idat&0x1)
    223            {
    224            GPIO_SetBits(MOT_RESET_PIN_GPIO, MOT_RESET_PIN);
    225            }
    226          else
    227            {
    228             GPIO_ResetBits(MOT_RESET_PIN_GPIO, MOT_RESET_PIN);
    229            }
    230          }
    231          
    232          ////==================================================
    233          
    234          volatile uint32_t num_step=0;
    235          
    236          void mot_step_tim_init(void)
    237          {
    238          NVIC_InitTypeDef NVIC_InitStructure; 
    239          
    240          RCC->APB2ENR |= MOT_STEP_TIM_RCC;
    241          MOT_STEP_TIM ->PSC = DEF_MOT_TIM_PRESC;
    242          MOT_STEP_TIM ->ARR = DEF_MOT_TIM_PERIOD;////
    243          MOT_STEP_TIM ->CCR1 = DEF_MOT_TIM_PERIOD/2;////30;
    244          MOT_STEP_TIM->CCER |= TIM_CCER_CC1E;////TIM_CCER_CC2NE;////| TIM_CCER_CC3NP;
    245          MOT_STEP_TIM->BDTR |= TIM_BDTR_MOE;
    246          MOT_STEP_TIM->CCMR1 = TIM_CCMR1_OC1M_0 | TIM_CCMR1_OC1M_1; 
    247          MOT_STEP_TIM->CR1 &= ~TIM_CR1_DIR;
    248          MOT_STEP_TIM->CR1 &= ~TIM_CR1_CMS;
    249          
    250          MOT_STEP_TIM ->DIER = TIM_DIER_CC1IE;
    251          TIM_ClearITPendingBit(MOT_STEP_TIM, TIM_IT_CC1);
    252          
    253          NVIC_InitStructure.NVIC_IRQChannel = MOT_TIM_IRQN;
    254          //// highest priority
    255          NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;
    256          
    257          NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    258          //// highest priority
    259          NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    260          NVIC_Init(&NVIC_InitStructure);
    261          
    262          }
    263          
    264          void stop_mot_step_tim(void)
    265          {
    266          TIM_Cmd(MOT_STEP_TIM, DISABLE);
    267          }
    268          void ena_mot(uint8_t ena_dis)
    269          {
    270          uint16_t tmp;
    271           
    272          tmp=mot_spi_rd(ADDR_MOT_CTRL);
    273          if(ena_dis&0x1)
    274          {
    275          tmp|=0x1;
    276          }
    277          else
    278          {
    279          tmp&= ~0x1;
    280          }
    281          mot_spi_wr(ADDR_MOT_CTRL,tmp);
    282          }
    283          void put_mot_nstep(uint32_t nstep)
    284          {
    285          ena_mot(1) ;
    286           num_step=nstep; 
    287          TIM_ITConfig(MOT_STEP_TIM, TIM_IT_CC1, ENABLE);
    288          TIM_Cmd(MOT_STEP_TIM, ENABLE);
    289          }
    290          volatile uint32_t gsr;
    291          ////=======================================================
    292          void MOT_STEP_TIM_IRQHandler(void)
    293          { 
    294          if(num_step)
    295            {
    296            num_step--;  
    297            if(num_step==0)
    298              {
    299              stop_mot_step_tim(); 
    300              ena_mot(0) ;
    301              }
    302            }
    303          ////TIM_ClearITPendingBit(MOT_STEP_TIM, TIM_IT_CC2);
    304          TIM_ClearITPendingBit(MOT_STEP_TIM, TIM_IT_CC1);
    305          }
    306          ////===============================================
    307          uint8_t get_conc0(void)
    308          {
    309          return GPIO_ReadInputDataBit(CONC0_PIN_GPIO, CONC0_PIN);
    310          }
    311          uint8_t get_conc1(void)
    312          {
    313          return GPIO_ReadInputDataBit(CONC1_PIN_GPIO, CONC1_PIN);
    314          }
    315          ////=============================================
    316          void hw_board_init(void)
    317          {
    318          NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );
    319          init_gpio();
    320          UART_DBG_Init(); 
    321          
    322          mot_step_tim_init();
    323          mot_spi_init();
    324          ////init_enc_tim();
    325          CAN_Config();
    326          
    327          }
    328          ////============================================
    329          ////==============================================
    330          void mot_spi_init(void)
    331          {
    332          GPIO_InitTypeDef GPIO_InitStructure;
    333          SPI_InitTypeDef  SPI_InitStructure;
    334            MOT_SPI_PeriphClockCmd(MOT_SPI_RCC, ENABLE);
    335            
    336          RCC_AHB1PeriphClockCmd(MOT_SPI_SCK_PIN_RCC,ENABLE);
    337          RCC_AHB1PeriphClockCmd(MOT_SPI_MISO_PIN_RCC,ENABLE);
    338          RCC_AHB1PeriphClockCmd(MOT_SPI_MOSI_PIN_RCC,ENABLE);
    339          ////RCC_AHB1PeriphClockCmd(MOT_SPI_SCS_PIN_RCC,ENABLE);
    340          
    341          GPIO_PinAFConfig(MOT_SPI_SCK_PIN_GPIO, MOT_SPI_SCK_PIN_NPIN, MOT_SPI_AF);
    342          GPIO_PinAFConfig(MOT_SPI_MISO_PIN_GPIO, MOT_SPI_MISO_PIN_NPIN, MOT_SPI_AF);
    343          GPIO_PinAFConfig(MOT_SPI_MOSI_PIN_GPIO, MOT_SPI_MOSI_PIN_NPIN, MOT_SPI_AF);
    344          ////GPIO_PinAFConfig(MOT_SPI_SCS_PIN_GPIO, MOT_SPI_SCS_PIN_NPIN, MOT_SPI_AF);
    345          
    346          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    347          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    348          ////GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    349          ///GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
    350          GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    351          GPIO_InitStructure.GPIO_Pin = MOT_SPI_MISO_PIN;
    352          GPIO_Init(MOT_SPI_MISO_PIN_GPIO, &GPIO_InitStructure);
    353          
    354          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    355          GPIO_InitStructure.GPIO_Pin = MOT_SPI_SCK_PIN;
    356          GPIO_Init(MOT_SPI_SCK_PIN_GPIO, &GPIO_InitStructure);
    357          ////GPIO_InitStructure.GPIO_Pin = MOT_SPI_MISO_PIN;
    358          /////GPIO_Init(MOT_SPI_MISO_PIN_GPIO, &GPIO_InitStructure);
    359          GPIO_InitStructure.GPIO_Pin = MOT_SPI_MOSI_PIN;
    360          GPIO_Init(MOT_SPI_MOSI_PIN_GPIO, &GPIO_InitStructure);
    361          
    362          ////GPIO_InitStructure.GPIO_Pin = MOT_SPI_SCS_PIN;
    363          /////GPIO_Init(MOT_SPI_SCS_PIN_GPIO, &GPIO_InitStructure);
    364          
    365          SPI_I2S_DeInit(MOT_SPI);
    366          SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
    367          SPI_InitStructure.SPI_DataSize = SPI_DataSize_16b;
    368          SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
    369          SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
    370          SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;///SPI_NSS_Hard;///SPI_NSS_Soft;///SPI_NSS_Hard;
    371          SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_64;
    372          SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
    373          SPI_InitStructure.SPI_CRCPolynomial = 7;
    374          SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
    375          SPI_Init(MOT_SPI, &SPI_InitStructure);
    376          SPI_Cmd(MOT_SPI, ENABLE);
    377          }
    378          uint16_t mot_spi_transfer(uint16_t i_data)
    379          {
    380          uint16_t rez=0; 
    381          GPIO_SetBits(MOT_SPI_SCS_PIN_GPIO, MOT_SPI_SCS_PIN);
    382          
    383          while (SPI_I2S_GetFlagStatus(MOT_SPI, SPI_I2S_FLAG_TXE) == RESET);
    384          SPI_I2S_SendData(MOT_SPI, i_data);
    385          while (SPI_I2S_GetFlagStatus(MOT_SPI, SPI_I2S_FLAG_RXNE) == RESET);
    386          while (SPI_I2S_GetFlagStatus(MOT_SPI, SPI_I2S_FLAG_TXE) == RESET);
    387          rez=SPI_I2S_ReceiveData(MOT_SPI);
    388          GPIO_ResetBits(MOT_SPI_SCS_PIN_GPIO, MOT_SPI_SCS_PIN);
    389          return rez;
    390          }
    391          ////==============================================
    392          void mot_spi_set_br(uint16_t br)
    393          {
    394          uint16_t tmpreg = 0;
    395          tmpreg = MOT_SPI->CR1& ~(0x7<<3);
    396          tmpreg |=	br&(0x7<<3);
    397          MOT_SPI->CR1=tmpreg;
    398          }
    399          
    400          void mot_spi_wr(uint8_t addr,uint16_t idata)
    401          {
    402          uint16_t tmp;
    403          tmp=(addr&0x7)<<12;
    404          tmp|= idata&0xfff;
    405          mot_spi_transfer(tmp);
    406          }
    407          void mot_spi_wrp(uint8_t addr,uint16_t *pdata)
    408          {
    409          uint16_t tmp;
    410          memcpy(&tmp,pdata,sizeof(uint16_t));
    411          mot_spi_wr(addr,tmp);       
    412          }
    413          uint16_t mot_spi_rd(uint8_t addr)
    414          {
    415          uint16_t rez;
    416          uint16_t tmp;
    417          tmp=(addr&0x7)<<12;
    418          tmp|= 0x8000;
    419          rez=mot_spi_transfer(tmp);
    420          return rez&0xfff;
    421          }
    422          ////========================================================  
    423          
    424          CTRL_Register_t 	G_CTRL_REG;
    425          TORQUE_Register_t 	G_TORQUE_REG;
    426           OFF_Register_t 	G_OFF_REG;
    427          BLANK_Register_t	G_BLANK_REG;
    428          DECAY_Register_t 	G_DECAY_REG;
    429          STALL_Register_t 	G_STALL_REG;
    430          DRIVE_Register_t 	G_DRIVE_REG;
    431          STATUS_Register_t 	G_STATUS_REG;
    432          
    433          void init_step_mot(void)
    434          {
    435            
    436          // CTRL Register
    437          
    438          G_CTRL_REG.DTIME 	= 0x03;
    439          G_CTRL_REG.ISGAIN 	= 0x03;
    440          G_CTRL_REG.EXSTALL 	= 0x00;
    441          G_CTRL_REG.MODE 	= 0;///0x03;
    442          G_CTRL_REG.RSTEP 	= 0x00;
    443          G_CTRL_REG.RDIR 	= 0x00;
    444          G_CTRL_REG.ENBL 	= 0x01;
    445          
    446          // TORQUE Register
    447          G_TORQUE_REG.SIMPLTH = 0x00;
    448          G_TORQUE_REG.TORQUE  = 0xBA;
    449          
    450          // OFF Register
    451          G_OFF_REG.PWMMODE 	= 0x00;
    452          G_OFF_REG.TOFF 		= 0x30;
    453          
    454          // BLANK Register
    455          G_BLANK_REG.ABT 	= 0x01;
    456          G_BLANK_REG.TBLANK 	= 0x08;
    457          
    458          // DECAY Register.
    459          G_DECAY_REG.DECMOD  = 0x03;
    460          G_DECAY_REG.TDECAY 	= 0x10;
    461          
    462          // STALL Register
    463          G_STALL_REG.VDIV 	= 0x03;
    464          G_STALL_REG.SDCNT 	= 0x03;
    465          G_STALL_REG.SDTHR 	= 0x40;
    466          
    467          // DRIVE Register
    468          G_DRIVE_REG.OCPTH 	= 0x01;
    469          G_DRIVE_REG.IDRIVEP = 0x00;
    470          G_DRIVE_REG.IDRIVEN = 0x00;
    471          G_DRIVE_REG.TDRIVEP = 0x01;
    472          G_DRIVE_REG.TDRIVEN = 0x01;
    473          G_DRIVE_REG.OCPDEG 	= 0x01;
    474          
    475          mot_spi_wrp(ADDR_MOT_CTRL,(uint16_t*)&G_CTRL_REG);
    476          mot_spi_wrp(ADDR_MOT_TORQUE,(uint16_t*)&G_TORQUE_REG);
    477          mot_spi_wrp(ADDR_MOT_OFF,(uint16_t*)&G_OFF_REG);
    478          mot_spi_wrp(ADDR_MOT_BLANK,(uint16_t*)&G_BLANK_REG);
    479          mot_spi_wrp(ADDR_MOT_DECAY,(uint16_t*)&G_DECAY_REG);
    480          mot_spi_wrp(ADDR_MOT_STALL,(uint16_t*)&G_STALL_REG);
    481          mot_spi_wrp(ADDR_MOT_DRIVE,(uint16_t*)&G_DRIVE_REG);
    482          
    483          }
    484          ////========================================================  
    485          void set_mot_rej(uint8_t rej)
    486          {
    487          uint16_t tmp;
    488          CTRL_Register_t *t_ctrl_reg=(CTRL_Register_t*)&tmp;
    489          tmp=mot_spi_rd(ADDR_MOT_CTRL);
    490          t_ctrl_reg->MODE=rej;
    491          mot_spi_wr(ADDR_MOT_CTRL,tmp);
    492          }
    493          ////============================================
    494          extern uint8_t can1_send(uint16_t id,uint8_t data_len,uint8_t *data);
    495          extern uint8_t  CAN_TxRdy;              /* CAN HW ready to transmit message */
    496          extern uint8_t  CAN_RxRdy;              /* CAN HW received a message        */
    497          extern CanRxMsg RxMessage;
    498          
    499          void set_mot_dir(uint8_t dir)
    500          {
    501            
    502          }
    503          
    504          void set_mot_step(uint8_t step)
    505          {
    506            
    507          }
    508          void reset_mot_step(void)
    509          {
    510            
    511          }
    512          void set_mot_per(uint16_t per)
    513          {
    514          if(per>MAX_PER)
    515            per=MAX_PER;
    516          else if(per<MIN_PER)
    517            per=MIN_PER;
    518          MOT_STEP_TIM ->ARR = per*2;////
    519          MOT_STEP_TIM ->CCR1 = per;////
    520          }
    521          ///=========================================================
    522          void CAN_Config(void)
    523          {
    524            GPIO_InitTypeDef  GPIO_InitStructure;
    525            CAN_InitTypeDef        CAN_InitStructure;
    526            CAN_FilterInitTypeDef  CAN_FilterInitStructure;
    527          ////=============== CAN1_INH ============================
    528          /////RCC_AHB1PeriphClockCmd(TST1_PIN_RCC, ENABLE);
    529          GPIO_InitStructure.GPIO_Pin = CAN1_INH_PIN;
    530          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    531          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    532          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    533          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    534          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    535          GPIO_Init( CAN1_INH_PIN_GPIO, &GPIO_InitStructure );
    536          GPIO_ResetBits(CAN1_INH_PIN_GPIO, CAN1_INH_PIN);
    537           
    538            
    539           /* CAN GPIOs configuration **************************************************/
    540            /* Enable GPIO clock */
    541          RCC_AHB1PeriphClockCmd(CAN1_GPIO_CLK, ENABLE);
    542          
    543            /* Connect CAN pins to AF9 */
    544            GPIO_PinAFConfig(CAN1_GPIO_PORT, CAN1_RX_SOURCE, CAN1_AF_PORT);
    545            GPIO_PinAFConfig(CAN1_GPIO_PORT, CAN1_TX_SOURCE, CAN1_AF_PORT);
    546          
    547            /* Configure CAN RX and TX pins */
    548            GPIO_InitStructure.GPIO_Pin = CAN1_RX_PIN | CAN1_TX_PIN;
    549            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    550            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    551            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    552            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    553            GPIO_Init(CAN1_GPIO_PORT, &GPIO_InitStructure);
    554            /* CAN configuration ********************************************************/
    555            /* Enable CAN clock */
    556            RCC_APB1PeriphClockCmd(CAN1_CLK, ENABLE);
    557            /* CAN register init */
    558            CAN_DeInit(CAN1);
    559          
    560            CAN_StructInit(&CAN_InitStructure);
    561          
    562            /* CAN cell init */
    563            CAN_InitStructure.CAN_TTCM = DISABLE;
    564            CAN_InitStructure.CAN_ABOM = DISABLE;
    565            CAN_InitStructure.CAN_AWUM = DISABLE;
    566            CAN_InitStructure.CAN_NART = DISABLE;
    567            CAN_InitStructure.CAN_RFLM = DISABLE;
    568            CAN_InitStructure.CAN_TXFP = DISABLE;
    569            CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;
    570            CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;
    571          
    572            /* CAN Baudrate = 1MBps (CAN clocked at 30 MHz) */
    573            
    574             /* Baudrate = 500 Kbps */
    575            CAN_InitStructure.CAN_BS1 = CAN_BS1_6tq;
    576            CAN_InitStructure.CAN_BS2 = CAN_BS2_8tq;
    577            CAN_InitStructure.CAN_Prescaler = 4;
    578            CAN_Init(CAN1, &CAN_InitStructure);
    579          
    580          
    581            CAN_FilterInitStructure.CAN_FilterNumber = 0;
    582            CAN_FilterInitStructure.CAN_FilterFIFOAssignment=CAN_Filter_FIFO0;
    583            CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
    584            CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
    585            CAN_FilterInitStructure.CAN_FilterIdHigh = 0x0000;
    586            CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000;
    587            CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0x0000;
    588            CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x0000;
    589            //CAN_FilterInitStructure.CAN_FilterFIFOAssignment = 0;
    590            CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
    591            CAN_FilterInit(&CAN_FilterInitStructure);
    592          
    593            CAN_FilterInitStructure.CAN_FilterNumber = 14;
    594            CAN_FilterInitStructure.CAN_FilterFIFOAssignment=CAN_Filter_FIFO1;
    595            CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
    596            CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
    597            CAN_FilterInitStructure.CAN_FilterIdHigh = 0x0000;
    598            CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000;
    599            CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0x0000;
    600            CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x0000;
    601            //CAN_FilterInitStructure.CAN_FilterFIFOAssignment = 0;
    602            CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
    603            CAN_FilterInit(&CAN_FilterInitStructure);
    604          
    605          //  CAN2TxMessage.StdId = 0x321;
    606          //  CAN2TxMessage.ExtId = 0x01;
    607          //  CAN2TxMessage.RTR = CAN_RTR_DATA;
    608          //  CAN2TxMessage.IDE = CAN_ID_STD;
    609          //  CAN2TxMessage.DLC = 8;
    610          
    611            /* Enable FIFO 0 message pending Interrupt */
    612            CAN_ITConfig(CAN1, CAN_IT_FMP0, ENABLE);
    613          
    614          }
    615          
    616          ////========================================================  
    617          void tst1_task( void *pvParameters )
    618          {
    619          ////uint8_t btst=0; 
    620          uint8_t ii=0; 
    621          printk("\n\r tst1_task"); 
    622          for(;;)
    623            {
    624            if( CAN_RxRdy)
    625              {
    626              CAN_RxRdy=0;
    627              printk("\n\r can_rx"); 
    628              printk("\n\r ExtId[%x]",RxMessage.ExtId);
    629              printk("\n\r DLC[%x]\n\r ",RxMessage.DLC);
    630              for(ii=0;ii<8;ii++)
    631                {
    632                printk("[%x] ",RxMessage.Data[ii]);
    633                }
    634              }
    635            else
    636            {
    637              msleep(10);
    638            }
    639            }
    640          }
    641          ////=======================================================
    642          	

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   CAN_Config
        40   -> CAN_DeInit
        40   -> CAN_FilterInit
        40   -> CAN_ITConfig
        40   -> CAN_Init
        40   -> CAN_StructInit
        40   -> GPIO_Init
        40   -> GPIO_PinAFConfig
        40   -> GPIO_ResetBits
        40   -> RCC_AHB1PeriphClockCmd
        40   -> RCC_APB1PeriphClockCmd
       8   TIM1_CC_IRQHandler
         8   -> TIM_ClearITPendingBit
         8   -> ena_mot
         8   -> stop_mot_step_tim
      24   UART_DBG_Init
        24   -> RCC_APB2PeriphClockCmd
        24   -> USART_Cmd
        24   -> USART_DeInit
        24   -> USART_Init
       8   _putk
         8   -> send_char_dbg
       0   check_push_key_dbg
      16   ena_mot
        16   -> mot_spi_rd
        16   -> mot_spi_wr
       0   get_byte_dbg
       8   get_conc0
         8   -> GPIO_ReadInputDataBit
       8   get_conc1
         8   -> GPIO_ReadInputDataBit
       8   hw_board_init
         8   -> CAN_Config
         8   -> NVIC_PriorityGroupConfig
         8   -> UART_DBG_Init
         8   -> init_gpio
         8   -> mot_spi_init
         8   -> mot_step_tim_init
      16   init_gpio
        16   -> GPIO_Init
        16   -> GPIO_PinAFConfig
        16   -> GPIO_ResetBits
        16   -> RCC_AHB1PeriphClockCmd
       8   init_step_mot
         8   -> mot_spi_wrp
      32   mot_spi_init
        32   -> GPIO_Init
        32   -> GPIO_PinAFConfig
        32   -> RCC_AHB1PeriphClockCmd
        32   -> RCC_APB1PeriphClockCmd
        32   -> SPI_Cmd
        32   -> SPI_I2S_DeInit
        32   -> SPI_Init
      16   mot_spi_rd
        16   -> mot_spi_transfer
       0   mot_spi_set_br
      16   mot_spi_transfer
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> SPI_I2S_GetFlagStatus
        16   -> SPI_I2S_ReceiveData
        16   -> SPI_I2S_SendData
      16   mot_spi_wr
        16   -> mot_spi_transfer
      32   mot_spi_wrp
        32   -> __aeabi_memcpy
        32   -> mot_spi_wr
       8   mot_step_tim_init
         8   -> NVIC_Init
         8   -> TIM_ClearITPendingBit
       8   put_mot_nstep
         8   -> TIM_Cmd
         8   -> TIM_ITConfig
         8   -> ena_mot
       0   reset_mot_step
       0   send_char_dbg
       8   set_dir_mot
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
       0   set_mot_dir
       0   set_mot_per
      16   set_mot_rej
        16   -> mot_spi_rd
        16   -> mot_spi_wr
       0   set_mot_step
       8   set_reset_mot
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
       8   set_sleep_mot
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
       8   stop_mot_step_tim
         8   -> TIM_Cmd
      16   tst1_task
        16   -> _printk
        16   -> vTaskDelay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_10
       4  ??DataTable20_11
       4  ??DataTable20_12
       4  ??DataTable20_13
       4  ??DataTable20_14
       4  ??DataTable20_15
       4  ??DataTable20_16
       4  ??DataTable20_17
       4  ??DataTable20_18
       4  ??DataTable20_19
       4  ??DataTable20_2
       4  ??DataTable20_20
       4  ??DataTable20_21
       4  ??DataTable20_22
       4  ??DataTable20_23
       4  ??DataTable20_24
       4  ??DataTable20_25
       4  ??DataTable20_26
       4  ??DataTable20_27
       4  ??DataTable20_28
       4  ??DataTable20_29
       4  ??DataTable20_3
       4  ??DataTable20_30
       4  ??DataTable20_31
       4  ??DataTable20_32
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
       4  ??DataTable20_9
      16  ?_0
      12  ?_1
      16  ?_2
      16  ?_3
       8  ?_4
     338  CAN_Config
       2  G_BLANK_REG
       2  G_CTRL_REG
       2  G_DECAY_REG
       2  G_DRIVE_REG
       2  G_OFF_REG
       2  G_STALL_REG
       2  G_STATUS_REG
       2  G_TORQUE_REG
      58  TIM1_CC_IRQHandler
      94  UART_DBG_Init
      14  _putk
      14  check_push_key_dbg
      40  ena_mot
      20  get_byte_dbg
      14  get_conc0
      14  get_conc1
       4  gsr
      32  hw_board_init
     666  init_gpio
     436  init_step_mot
     238  mot_spi_init
      32  mot_spi_rd
      28  mot_spi_set_br
     100  mot_spi_transfer
      32  mot_spi_wr
      40  mot_spi_wrp
     172  mot_step_tim_init
       4  num_step
      40  put_mot_nstep
       2  reset_mot_step
      24  send_char_dbg
      36  set_dir_mot
       2  set_mot_dir
      56  set_mot_per
      36  set_mot_rej
       2  set_mot_step
      36  set_reset_mot
      36  set_sleep_mot
      14  stop_mot_step_tim
      92  tst1_task

 
    24 bytes in section .bss
    68 bytes in section .rodata
 2'890 bytes in section .text
 
 2'890 bytes of CODE  memory
    68 bytes of CONST memory
    24 bytes of DATA  memory

Errors: none
Warnings: none
