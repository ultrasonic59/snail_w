###############################################################################
#
# IAR ANSI C/C++ Compiler V9.10.2.313/W64 for ARM         27/May/2022  14:57:38
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\src\motor_tsk.c
#    Command line      =
#        -f
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\step_x_dbg\List\Board\motor_tsk.lst.rsp
#        (D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\src\motor_tsk.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D DIMA_BRD -D STEP_X -D STM32F205xx
#        -lcN
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\step_x_dbg\List\Board
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\step_x_dbg\Obj\Board
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\.\ -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\src\board\ -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\src\inc\ -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\dbg\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\usb\drv\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\..\common\board\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.0\arm\CMSIS\Core\Include\\" -I "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\CMSIS\DSP\Include\\")
#        --dependencies=n
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\step_x_dbg\Obj\Board\motor_tsk.o.d
#    Locale            =  C
#    List file         =
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\step_x_dbg\List\Board\motor_tsk.lst
#    Object file       =
#        D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\step_x_dbg\Obj\Board\motor_tsk.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\proj\velograph\snail_w\stm32_snail\step_axis_dima\src\motor_tsk.c
      1          #include <string.h>
      2          #include "FreeRTOS.h"
      3          #include "queue.h"
      4          #include "semphr.h"
      5          
      6          ////#include "board.h"
      7          #include "board.h"
      8          #include "printk.h"
      9          
     10          #include "snail_can_cmds.h"
     11          
     12          cmd_t cur_cmd={0};
     13          
     14          void motor_task( void *pvParameters )
     15          {
     16          ///uint8_t btst=0; 
     17          uint8_t psk=0; 
     18          ///uint16_t tst;
     19          char key=0;
     20          int nstep=300;
     21          uint8_t dir=0;
     22          uint8_t mot_rej=0;
     23          printk("\n\r motor_task"); 
     24          
     25          set_sleep_mot(1);
     26          ////set_ena_mot(1);
     27          set_reset_mot(1);
     28          uDelay(1000);
     29          set_reset_mot(0);
     30          uDelay(20000);
     31          init_step_mot();
     32          ////set_ena_mot(0);
     33          ///tst=mot_spi_rd(0x0);
     34          ///tst|=0x1;
     35          ///mot_spi_wr(0x0,tst);
     36          #if 0      
     37          for(;;)
     38            {
     39          //// sendchar2 (0x33) ; 
     40            put_tst_pin(btst);
     41            btst++;  
     42            ////delay__ms(1);  
     43            uDelay(20000);
     44          ///  mot_spi_transfer(0x1234);
     45          tst=mot_spi_rd(0x0);
     46          printk("\n\r rd[%x]",tst); 
     47          
     48            }
     49          #endif 
     50          ena_mot(0) ;
     51          for(;;)
     52          {
     53          #if 0
     54          if(cur_cmd.cmd==0)
     55            msleep(10);
     56          else
     57            {
     58            switch(cur_cmd.cmd)
     59              {
     60              case STOP_X:
     61          ///      nstep += 20;
     62                break;
     63              case GOTO_X:
     64          ////      if(nstep)
     65          ////        nstep-= 20;
     66                  break;
     67              case SET_SPD_X:
     68          ////      if(nstep)
     69          ////        nstep-= 20;
     70                  break;
     71              }
     72            }
     73          #endif
     74          if(check_push_key_dbg())
     75            {
     76            key=get_byte_dbg() ;  
     77            switch(key)
     78              {
     79              case 'a':
     80                nstep += 20;
     81                break;
     82              case 's':
     83                if(nstep)
     84                  nstep-= 20;
     85                  break;
     86              case 'd':
     87                dir ++;
     88                dir&=0x1;
     89                break;
     90              case 'm':
     91                mot_rej ++;
     92                if(mot_rej>8)
     93                  mot_rej=0;
     94           ////     mot_rej&=0x7;
     95                break;
     96              case 'p':
     97               psk=1;
     98                break;
     99               
    100             }
    101            printk("\n\r nstep[%d] dir[%x] Mot_rej[%x]",nstep,dir,mot_rej); 
    102            set_dir_mot(dir);
    103            set_mot_rej(mot_rej);
    104            if(psk)
    105              {
    106              put_mot_nstep(nstep);
    107              psk=0;
    108              }
    109            
    110            }  
    111          }
    112          }
    113          #if 0
    114           for(;;)
    115            {
    116            key=get_byte_dbg() ;  
    117            switch(key)
    118              {
    119              case 'a':
    120                nstep += 20;
    121                break;
    122              case 's':
    123                if(nstep)
    124                  nstep-= 20;
    125                  break;
    126              case 'd':
    127                dir ++;
    128                dir&=0x1;
    129                break;
    130              case 'm':
    131                mot_rej ++;
    132                if(mot_rej>8)
    133                  mot_rej=0;
    134           ////     mot_rej&=0x7;
    135                break;
    136              case 'p':
    137               psk=1;
    138                break;
    139               
    140             }
    141            printk("\n\r nstep[%d] dir[%x] Mot_rej[%x]",nstep,dir,mot_rej); 
    142            set_dir_mot(dir);
    143            set_mot_rej(mot_rej);
    144            if(psk)
    145              {
    146              put_mot_nstep(nstep);
    147              psk=0;
    148              }
    149          ////  set_led_dutycycle (duty);
    150          
    151            } 
    152          }
    153          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   motor_task
        32   -> _printk
        32   -> check_push_key_dbg
        32   -> ena_mot
        32   -> get_byte_dbg
        32   -> init_step_mot
        32   -> put_mot_nstep
        32   -> set_dir_mot
        32   -> set_mot_rej
        32   -> set_reset_mot
        32   -> set_sleep_mot
        32   -> uDelay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?_0
      36  ?_1
       8  cur_cmd
     216  motor_task

 
   8 bytes in section .bss
  52 bytes in section .rodata
 216 bytes in section .text
 
 216 bytes of CODE  memory
  52 bytes of CONST memory
   8 bytes of DATA  memory

Errors: none
Warnings: none
