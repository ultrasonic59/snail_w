###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         01/Dec/2020  16:53:01
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\manta\contr\arm\manta_contr\src\board\bmc150.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EWBAD1.tmp
#        (D:\proj\velograph\manta\contr\arm\manta_contr\src\board\bmc150.c -D
#        VECT_TAB_FLASH -D IAR_ARM_CM3 -lcN
#        D:\proj\velograph\manta\contr\arm\manta_contr\manta_debug\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\manta\contr\arm\manta_contr\manta_debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\.\ -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\src\board\ -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\..\common\freertos\source\inc\
#        -I D:\proj\velograph\manta\contr\arm\manta_contr\src\inc\ -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I D:\proj\velograph\manta\contr\arm\manta_contr\..\common\dbg\ -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\..\common\inc\ -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\..\common\hdlc\ -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\manta\contr\arm\manta_contr\manta_debug\List\bmc150.lst
#    Object file  =
#        D:\proj\velograph\manta\contr\arm\manta_contr\manta_debug\Obj\bmc150.o
#
###############################################################################

D:\proj\velograph\manta\contr\arm\manta_contr\src\board\bmc150.c
      1          #include "manta_contr_brd.h"
      2          #include "bmc150.h"
      3          
      4          extern int I2C_Mem_Read(I2C_TypeDef* I2Cx, uint8_t sl_addr,uint8_t *buff,uint8_t rd_addr,uint16_t num);
      5          extern int I2C_Memory_Write(I2C_TypeDef* I2Cx, uint8_t sl_addr,uint8_t *buff,uint8_t wr_addr,uint16_t num);
      6          ////===============================================================================
      7          /*
      8           * From the BMC150 datasheet, page 125:
      9           * "The register address is automatically incremented and, therefore, more
     10           * than one byte can be sequentially read out. Once a new data read
     11           * transmission starts, the start address will be set to the register address
     12           * specified in the latest I2C write command."
     13           */
     14          static BMC150_error_t read_register(uint16_t addr, uint8_t reg, uint8_t *const data,
     15          			     uint32_t len)
     16          {
     17           ///	AIR_I2C_ComboRead(addr,&reg,1,data,len);
     18          if(I2C_Mem_Read(MAGN_I2C, addr,data,(0x00FF & reg),len)<0)  
     19          return BMC150_ERROR;
     20                  
     21          return BMC150_OK;
     22          }
     23          
     24          static BMC150_error_t write_register(uint16_t addr, uint8_t reg, uint8_t data)
     25          {
     26          ///	uint8_t writeData[2] = {reg, data};
     27          ///	AIR_I2C_Write(addr,writeData,2);
     28          uint8_t tdata=data;
     29          if(I2C_Memory_Write(MAGN_I2C,addr,&tdata,(0x00FF & reg),1)<0)
     30            return BMC150_ERROR;
     31          return BMC150_OK;
     32          }
     33          
     34          BMC150_error_t BMC150_read_accel(BMC150_accel_t *const accel)
     35          {
     36          	BMC150_error_t rc;
     37          	uint8_t raw_accel[6];
     38          
     39          	/* Reading the 6 registers at once. */
     40          	rc = read_register(ACC_ADDR, BMC150_REG_ACCEL_X_LSB, raw_accel,
     41          			   sizeof(raw_accel));
     42          	if (BMC150_OK != rc) {
     43          		return rc;
     44          	}
     45          
     46          	accel->x = EXTRACT_ACCEL(raw_accel[1], raw_accel[0]);
     47          	accel->y = EXTRACT_ACCEL(raw_accel[3], raw_accel[2]);
     48          	accel->z = EXTRACT_ACCEL(raw_accel[5], raw_accel[4]);
     49          
     50          	return BMC150_OK;
     51          }
     52          
     53          BMC150_error_t BMC150_set_accel_mode(BMC150_accel_mode_t mode)
     54          {
     55          	return write_register(ACC_ADDR, BMC150_REG_ACCEL_PMU_RANGE, mode);
     56          }
     57          
     58          BMC150_error_t BMC150_set_bandwidth(BMC150_bandwidth_t bw)
     59          {
     60          	return write_register(ACC_ADDR, BMC150_REG_ACCEL_PMU_BW, bw);
     61          }
     62          
     63          static BMC150_error_t read_dig_comp(struct compensation *const comp)
     64          {
     65          	uint8_t raw_comp[21];
     66          	BMC150_error_t rc;
     67          
     68          	rc = read_register(MAGN_ADDR, BMC150_REG_MAG_DIG_X1, raw_comp,
     69          			   sizeof(raw_comp));
     70          	if (BMC150_OK != rc) {
     71          		return rc;
     72          	}
     73          
     74          	comp->x1 = raw_comp[0];
     75          	comp->y1 = raw_comp[1];
     76          	comp->z4 = EXTRACT_UINT16(raw_comp[6], raw_comp[5]);
     77          	comp->x2 = raw_comp[7];
     78          	comp->y2 = raw_comp[8];
     79          	comp->z2 = EXTRACT_UINT16(raw_comp[12], raw_comp[11]);
     80          	comp->z1 = EXTRACT_UINT16(raw_comp[14], raw_comp[13]);
     81          	comp->xyz1 = EXTRACT_UINT16(raw_comp[16], raw_comp[15]);
     82          	comp->z3 = EXTRACT_UINT16(raw_comp[18], raw_comp[17]);
     83          	comp->xy2 = raw_comp[19];
     84          	comp->xy1 = raw_comp[20];
     85          
     86          	return BMC150_OK;
     87          }
     88          
     89          typedef enum {
     90          	AXIS_X,
     91          	AXIS_Y,
     92          } axis_t;
     93          
     94          static int compensate_xy(struct compensation *const comp, int16_t rhall,
     95          			 int16_t raw, axis_t axis)
     96          {
     97          	int inter = 0;
     98          	int value;
     99          
    100          	if (rhall != 0) {
    101          		inter = ((int)comp->xyz1 << 14) / rhall - (1 << 14);
    102          	}
    103          
    104          	if (BMC150_FLIP_OVERFLOW_ADCVAL == raw) {
    105          		return BMC150_OVERFLOW_OUTPUT;
    106          	}
    107          
    108          	value = comp->xy2 * ((inter * inter) >> 7);
    109          	value += inter * ((int)comp->xy1 << 7);
    110          	value >>= 9;
    111          	value += 1 << (8 + 12);
    112          	value *= (int)(AXIS_X == axis ? comp->x2 : comp->y2) + 160;
    113          	value >>= 12;
    114          	value *= raw;
    115          	value >>= 13;
    116          	value += (int)(AXIS_X == axis ? comp->x1 : comp->y1) << 3;
    117          
    118          	return value;
    119          }
    120          
    121          static int compensate_z(struct compensation *const comp, int rhall, int16_t raw)
    122          {
    123          	int dividend, divisor;
    124          	int value;
    125          
    126          	if (BMC150_HALL_OVERFLOW_ADCVAL == raw) {
    127          		return BMC150_OVERFLOW_OUTPUT;
    128          	}
    129          
    130          	dividend = (raw - (int)comp->z4) << 15;
    131          	dividend -= (comp->z3 * (rhall - (int)comp->xyz1)) >> 2;
    132          	/* add 1 << 15 to round to next integer. */
    133          	divisor = (int)comp->z1 * (rhall << 1) + (1 << 15);
    134          	divisor >>= 16;
    135          	divisor += (int)comp->z2;
    136          	value = dividend / divisor;
    137          	if (value > (1 << 15) || value < -(1 << 15)) {
    138          		value = BMC150_OVERFLOW_OUTPUT;
    139          	}
    140          
    141          	return value;
    142          }
    143          
    144          BMC150_error_t BMC150_read_mag(BMC150_mag_t *const mag)
    145          {
    146          	BMC150_error_t rc = BMC150_OK;
    147          	uint8_t raw_mag[8];
    148          	int16_t x, y, z, rhall;
    149          
    150          	if (!digital_comp.init) {
    151          		rc = read_dig_comp(&digital_comp);
    152          		if (BMC150_OK == rc) {
    153          			digital_comp.init = 1;
    154          		}
    155          	}
    156          
    157          	if (BMC150_OK != rc) {
    158          		return rc;
    159          	}
    160          
    161          	rc = read_register(MAGN_ADDR, BMC150_REG_MAG_X_LSB, raw_mag,
    162          			   sizeof(raw_mag));
    163          	if (BMC150_OK != rc) {
    164          		return rc;
    165          	}
    166          
    167          	x = EXTRACT_MAG_XY(raw_mag[1], raw_mag[0]);
    168          	y = EXTRACT_MAG_XY(raw_mag[3], raw_mag[2]);
    169          	z = EXTRACT_MAG_Z(raw_mag[5], raw_mag[4]);
    170          	rhall = EXTRACT_RHALL(raw_mag[7], raw_mag[6]);
    171          
    172          	mag->x = compensate_xy(&digital_comp, rhall, x, AXIS_X);
    173          	mag->y = compensate_xy(&digital_comp, rhall, y, AXIS_Y);
    174          	mag->z = compensate_z(&digital_comp, rhall, z);
    175          
    176          	return BMC150_OK;
    177          }
    178          
    179          BMC150_error_t BMC150_mag_set_power(BMC150_mag_power_t power)
    180          {
    181          	return write_register(MAGN_ADDR, BMC150_REG_MAG_POWER_MODES, power);
    182          }
    183          
    184          /*
    185           * These values used for the presets are from Table 6 (page 24) of the
    186           * BMC150 datasheet.
    187           */
    188          static const uint8_t operation_modes[] = {
    189              0,      /* 10 Hz */
    190              0,      /* 10 Hz */
    191              0,      /* 10 Hz */
    192              5 << 3, /* 20 Hz */
    193          };
    194          
    195          /* The formula here is repetions = 1 + 2*(mode) */
    196          static const uint8_t repetion_modes_xy[] = {
    197              1, 3, 7, 23,
    198          };
    199          
    200          /* The formula here is repetions = 1 + (mode) */
    201          static const uint8_t repetion_modes_z[] = {
    202              2, 14, 26, 82,
    203          };
    204          
    205          BMC150_error_t BMC150_mag_set_preset(BMC150_mag_preset_t preset)
    206          {
    207          BMC150_error_t rc;
    208          
    209          rc = write_register(MAGN_ADDR, BMC150_REG_MAG_OPERATION_MODES,
    210          			    operation_modes[preset]);
    211          if (BMC150_OK != rc) 
    212            {
    213          		return rc;
    214            }
    215          
    216          	rc = write_register(MAGN_ADDR, BMC150_REG_MAG_REPETION_XY,
    217          			    repetion_modes_xy[preset]);
    218          	if (BMC150_OK != rc) {
    219          		return rc;
    220          	}
    221          
    222          	rc = write_register(MAGN_ADDR, BMC150_REG_MAG_REPETION_Z,
    223          			    repetion_modes_z[preset]);
    224          	if (BMC150_OK != rc) {
    225          		return rc;
    226          	}
    227          
    228          	return BMC150_OK;
    229          }
    230          
    231          int bmc150_detect(void)
    232          {
    233          int rez=0;  
    234          uint8_t btmp;
    235          rez= I2C_Mem_Read(MAGN_I2C, ACC_ADDR,&btmp,BMC150_REG_ACCEL_CHIPID,1);
    236          if(rez<0)
    237            return rez;
    238          if(btmp==BMC150_ACCEL_CHIPID)
    239            return 0;
    240          else 
    241            return -12;
    242          }
    243          
    244          
    245          #if 1
    246          int BMC150_init(void)
    247          {
    248          //Setup Magnometer
    249          BMC150_mag_set_power(BMC150_MAG_POWER_ACTIVE);
    250          BMC150_mag_set_preset(AIR_BMC150_MAG_PRESET);
    251          //Setup Accelerometer
    252          BMC150_set_accel_mode(AIR_BMC150_ACCEL_MODE);
    253          BMC150_set_bandwidth(AIR_BMC150_BANDWIDTH);
    254          	
    255          return 0;
    256          }
    257          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   BMC150_init
         8   -> BMC150_mag_set_power
         8   -> BMC150_mag_set_preset
         8   -> BMC150_set_accel_mode
         8   -> BMC150_set_bandwidth
       8   BMC150_mag_set_power
         8   -> write_register
      16   BMC150_mag_set_preset
        16   -> write_register
      16   BMC150_read_accel
        16   -> read_register
      40   BMC150_read_mag
        40   -> compensate_xy
        40   -> compensate_z
        40   -> read_dig_comp
        40   -> read_register
       8   BMC150_set_accel_mode
         8   -> write_register
       8   BMC150_set_bandwidth
         8   -> write_register
      16   bmc150_detect
        16   -> I2C_Mem_Read
      12   compensate_xy
      12   compensate_z
      32   read_dig_comp
        32   -> read_register
      24   read_register
        24   -> I2C_Mem_Read
      24   write_register
        24   -> I2C_Memory_Write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
      30  BMC150_init
      18  BMC150_mag_set_power
     104  BMC150_mag_set_preset
      88  BMC150_read_accel
     210  BMC150_read_mag
      18  BMC150_set_accel_mode
      18  BMC150_set_bandwidth
      48  bmc150_detect
     134  compensate_xy
      86  compensate_z
      20  digital_comp
       4  operation_modes
     140  read_dig_comp
      46  read_register
       4  repetion_modes_xy
       4  repetion_modes_z
      46  write_register

 
    20 bytes in section .bss
    12 bytes in section .rodata
 1'014 bytes in section .text
 
 1'014 bytes of CODE  memory
    12 bytes of CONST memory
    20 bytes of DATA  memory

Errors: none
Warnings: none
