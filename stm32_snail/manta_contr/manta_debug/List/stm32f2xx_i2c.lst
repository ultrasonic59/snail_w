###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         01/Dec/2020  16:53:03
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\manta\contr\arm\common\libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_i2c.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EWC0CE.tmp
#        (D:\proj\velograph\manta\contr\arm\common\libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_i2c.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -lcN
#        D:\proj\velograph\manta\contr\arm\manta_contr\manta_debug\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\manta\contr\arm\manta_contr\manta_debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\.\ -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\src\board\ -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\..\common\freertos\source\inc\
#        -I D:\proj\velograph\manta\contr\arm\manta_contr\src\inc\ -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I D:\proj\velograph\manta\contr\arm\manta_contr\..\common\dbg\ -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\..\common\inc\ -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\..\common\hdlc\ -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\manta\contr\arm\manta_contr\manta_debug\List\stm32f2xx_i2c.lst
#    Object file  =
#        D:\proj\velograph\manta\contr\arm\manta_contr\manta_debug\Obj\stm32f2xx_i2c.o
#
###############################################################################

D:\proj\velograph\manta\contr\arm\common\libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_i2c.c
      4            * @author  MCD Application Team
      5            * @version V1.1.0
      6            * @date    07-October-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Inter-integrated circuit (I2C)
      9            *           - Initialization and Configuration
     10            *           - Data transfers
     11            *           - PEC management
     12            *           - DMA transfers management
     13            *           - Interrupts, events and flags management 
     14            *           
     15            *  @verbatim
     16            *    
     17            *          ===================================================================
     18            *                                 How to use this driver
     19            *          ===================================================================
     20            *          1. Enable peripheral clock using RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2Cx, ENABLE)
     21            *             function for I2C1, I2C2 or I2C3.
     22            *
     23            *          2. Enable SDA, SCL  and SMBA (when used) GPIO clocks using 
     24            *             RCC_AHBPeriphClockCmd() function. 
     25            *
     26            *          3. Peripherals alternate function: 
     27            *                 - Connect the pin to the desired peripherals' Alternate 
     28            *                   Function (AF) using GPIO_PinAFConfig() function
     29            *                 - Configure the desired pin in alternate function by:
     30            *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     31            *                 - Select the type, pull-up/pull-down and output speed via 
     32            *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
     33            *                 - Call GPIO_Init() function
     34            *                 Recommended configuration is Push-Pull, Pull-up, Open-Drain.
     35            *                 Add an external pull up if necessary (typically 4.7 KOhm).      
     36            *        
     37            *          4. Program the Mode, duty cycle , Own address, Ack, Speed and Acknowledged
     38            *             Address using the I2C_Init() function.
     39            *
     40            *          5. Optionally you can enable/configure the following parameters without
     41            *             re-initialization (i.e there is no need to call again I2C_Init() function):
     42            *              - Enable the acknowledge feature using I2C_AcknowledgeConfig() function
     43            *              - Enable the dual addressing mode using I2C_DualAddressCmd() function
     44            *              - Enable the general call using the I2C_GeneralCallCmd() function
     45            *              - Enable the clock stretching using I2C_StretchClockCmd() function
     46            *              - Enable the fast mode duty cycle using the I2C_FastModeDutyCycleConfig()
     47            *                function.
     48            *              - Configure the NACK position for Master Receiver mode in case of 
     49            *                2 bytes reception using the function I2C_NACKPositionConfig().  
     50            *              - Enable the PEC Calculation using I2C_CalculatePEC() function
     51            *              - For SMBus Mode: 
     52            *                   - Enable the Address Resolution Protocol (ARP) using I2C_ARPCmd() function
     53            *                   - Configure the SMBusAlert pin using I2C_SMBusAlertConfig() function
     54            *
     55            *          6. Enable the NVIC and the corresponding interrupt using the function 
     56            *             I2C_ITConfig() if you need to use interrupt mode. 
     57            *
     58            *          7. When using the DMA mode 
     59            *                   - Configure the DMA using DMA_Init() function
     60            *                   - Active the needed channel Request using I2C_DMACmd() or
     61            *                     I2C_DMALastTransferCmd() function.
     62            *              @note When using DMA mode, I2C interrupts may be used at the same time to
     63            *                    control the communication flow (Start/Stop/Ack... events and errors).
     64            * 
     65            *          8. Enable the I2C using the I2C_Cmd() function.
     66            * 
     67            *          9. Enable the DMA using the DMA_Cmd() function when using DMA mode in the 
     68            *             transfers. 
     69            *
     70            *  @endverbatim
     71            *  
     72            ******************************************************************************
     73            * @attention
     74            *
     75            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     76            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     77            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     78            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     79            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     80            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     81            *
     82            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     83            ******************************************************************************  
     84            */ 
     85          
     86          /* Includes ------------------------------------------------------------------*/
     87          #include "stm32f2xx_conf.h"
     88          #include "stm32f2xx_i2c.h"
     89          #include "stm32f2xx_rcc.h"
     90          
     91          /** @addtogroup STM32F2xx_StdPeriph_Driver
     92            * @{
     93            */
     94          
     95          /** @defgroup I2C 
     96            * @brief I2C driver modules
     97            * @{
     98            */ 
     99          
    100          /* Private typedef -----------------------------------------------------------*/
    101          /* Private define ------------------------------------------------------------*/
    102          
    103          #define CR1_CLEAR_MASK    ((uint16_t)0xFBF5)      /*<! I2C registers Masks */
    104          #define FLAG_MASK         ((uint32_t)0x00FFFFFF)  /*<! I2C FLAG mask */
    105          #define ITEN_MASK         ((uint32_t)0x07000000)  /*<! I2C Interrupt Enable mask */
    106          
    107          /* Private macro -------------------------------------------------------------*/
    108          /* Private variables ---------------------------------------------------------*/
    109          /* Private function prototypes -----------------------------------------------*/
    110          /* Private functions ---------------------------------------------------------*/
    111          
    112          /** @defgroup I2C_Private_Functions
    113            * @{
    114            */
    115          
    116          /** @defgroup I2C_Group1 Initialization and Configuration functions
    117           *  @brief   Initialization and Configuration functions 
    118           *
    119          @verbatim   
    120           ===============================================================================
    121                             Initialization and Configuration functions
    122           ===============================================================================  
    123          
    124          @endverbatim
    125            * @{
    126            */
    127          
    128          /**
    129            * @brief  Deinitialize the I2Cx peripheral registers to their default reset values.
    130            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    131            * @retval None
    132            */
    133          void I2C_DeInit(I2C_TypeDef* I2Cx)
    134          {
    135            /* Check the parameters */
    136            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    137          
    138            if (I2Cx == I2C1)
    139            {
    140              /* Enable I2C1 reset state */
    141              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
    142              /* Release I2C1 from reset state */
    143              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
    144            }
    145            else if (I2Cx == I2C2)
    146            {
    147              /* Enable I2C2 reset state */
    148              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
    149              /* Release I2C2 from reset state */
    150              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
    151            }
    152            else 
    153            {
    154              if (I2Cx == I2C3)
    155              {
    156                /* Enable I2C3 reset state */
    157                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
    158                /* Release I2C3 from reset state */
    159                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
    160              }
    161            }
    162          }
    163          
    164          /**
    165            * @brief  Initializes the I2Cx peripheral according to the specified 
    166            *         parameters in the I2C_InitStruct.
    167            *           
    168            * @note   To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency 
    169            *         (I2C peripheral input clock) must be a multiple of 10 MHz.  
    170            *           
    171            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    172            * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that contains 
    173            *         the configuration information for the specified I2C peripheral.
    174            * @retval None
    175            */
    176          void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
    177          {
    178            uint16_t tmpreg = 0, freqrange = 0;
    179            uint16_t result = 0x04;
    180            uint32_t pclk1 = 8000000;
    181            RCC_ClocksTypeDef  rcc_clocks;
    182            /* Check the parameters */
    183            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    184            assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
    185            assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
    186            assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
    187            assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
    188            assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
    189            assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
    190          
    191          /*---------------------------- I2Cx CR2 Configuration ------------------------*/
    192            /* Get the I2Cx CR2 value */
    193            tmpreg = I2Cx->CR2;
    194            /* Clear frequency FREQ[5:0] bits */
    195            tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
    196            /* Get pclk1 frequency value */
    197            RCC_GetClocksFreq(&rcc_clocks);
    198            pclk1 = rcc_clocks.PCLK1_Frequency;
    199            /* Set frequency bits depending on pclk1 value */
    200            freqrange = (uint16_t)(pclk1 / 1000000);
    201            tmpreg |= freqrange;
    202            /* Write to I2Cx CR2 */
    203            I2Cx->CR2 = tmpreg;
    204          
    205          /*---------------------------- I2Cx CCR Configuration ------------------------*/
    206            /* Disable the selected I2C peripheral to configure TRISE */
    207            I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
    208            /* Reset tmpreg value */
    209            /* Clear F/S, DUTY and CCR[11:0] bits */
    210            tmpreg = 0;
    211          
    212            /* Configure speed in standard mode */
    213            if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
    214            {
    215              /* Standard mode speed calculate */
    216              result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
    217              /* Test if CCR value is under 0x4*/
    218              if (result < 0x04)
    219              {
    220                /* Set minimum allowed value */
    221                result = 0x04;  
    222              }
    223              /* Set speed value for standard mode */
    224              tmpreg |= result;	  
    225              /* Set Maximum Rise Time for standard mode */
    226              I2Cx->TRISE = freqrange + 1; 
    227            }
    228            /* Configure speed in fast mode */
    229            /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
    230               input clock) must be a multiple of 10 MHz */
    231            else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
    232            {
    233              if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
    234              {
    235                /* Fast mode speed calculate: Tlow/Thigh = 2 */
    236                result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
    237              }
    238              else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    239              {
    240                /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
    241                result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
    242                /* Set DUTY bit */
    243                result |= I2C_DutyCycle_16_9;
    244              }
    245          
    246              /* Test if CCR value is under 0x1*/
    247              if ((result & I2C_CCR_CCR) == 0)
    248              {
    249                /* Set minimum allowed value */
    250                result |= (uint16_t)0x0001;  
    251              }
    252              /* Set speed value and set F/S bit for fast mode */
    253              tmpreg |= (uint16_t)(result | I2C_CCR_FS);
    254              /* Set Maximum Rise Time for fast mode */
    255              I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
    256            }
    257          
    258            /* Write to I2Cx CCR */
    259            I2Cx->CCR = tmpreg;
    260            /* Enable the selected I2C peripheral */
    261            I2Cx->CR1 |= I2C_CR1_PE;
    262          
    263          /*---------------------------- I2Cx CR1 Configuration ------------------------*/
    264            /* Get the I2Cx CR1 value */
    265            tmpreg = I2Cx->CR1;
    266            /* Clear ACK, SMBTYPE and  SMBUS bits */
    267            tmpreg &= CR1_CLEAR_MASK;
    268            /* Configure I2Cx: mode and acknowledgement */
    269            /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
    270            /* Set ACK bit according to I2C_Ack value */
    271            tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
    272            /* Write to I2Cx CR1 */
    273            I2Cx->CR1 = tmpreg;
    274          
    275          /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
    276            /* Set I2Cx Own Address1 and acknowledged address */
    277            I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
    278          }
    279          
    280          /**
    281            * @brief  Fills each I2C_InitStruct member with its default value.
    282            * @param  I2C_InitStruct: pointer to an I2C_InitTypeDef structure which will be initialized.
    283            * @retval None
    284            */
    285          void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
    286          {
    287          /*---------------- Reset I2C init structure parameters values ----------------*/
    288            /* initialize the I2C_ClockSpeed member */
    289            I2C_InitStruct->I2C_ClockSpeed = 5000;
    290            /* Initialize the I2C_Mode member */
    291            I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
    292            /* Initialize the I2C_DutyCycle member */
    293            I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
    294            /* Initialize the I2C_OwnAddress1 member */
    295            I2C_InitStruct->I2C_OwnAddress1 = 0;
    296            /* Initialize the I2C_Ack member */
    297            I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
    298            /* Initialize the I2C_AcknowledgedAddress member */
    299            I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
    300          }
    301          
    302          /**
    303            * @brief  Enables or disables the specified I2C peripheral.
    304            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    305            * @param  NewState: new state of the I2Cx peripheral. 
    306            *          This parameter can be: ENABLE or DISABLE.
    307            * @retval None
    308            */
    309          void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    310          {
    311            /* Check the parameters */
    312            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    313            assert_param(IS_FUNCTIONAL_STATE(NewState));
    314            if (NewState != DISABLE)
    315            {
    316              /* Enable the selected I2C peripheral */
    317              I2Cx->CR1 |= I2C_CR1_PE;
    318            }
    319            else
    320            {
    321              /* Disable the selected I2C peripheral */
    322              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
    323            }
    324          }
    325          
    326          /**
    327            * @brief  Generates I2Cx communication START condition.
    328            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    329            * @param  NewState: new state of the I2C START condition generation.
    330            *          This parameter can be: ENABLE or DISABLE.
    331            * @retval None.
    332            */
    333          void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
    334          {
    335            /* Check the parameters */
    336            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    337            assert_param(IS_FUNCTIONAL_STATE(NewState));
    338            if (NewState != DISABLE)
    339            {
    340              /* Generate a START condition */
    341              I2Cx->CR1 |= I2C_CR1_START;
    342            }
    343            else
    344            {
    345              /* Disable the START condition generation */
    346              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
    347            }
    348          }
    349          
    350          /**
    351            * @brief  Generates I2Cx communication STOP condition.
    352            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    353            * @param  NewState: new state of the I2C STOP condition generation.
    354            *          This parameter can be: ENABLE or DISABLE.
    355            * @retval None.
    356            */
    357          void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
    358          {
    359            /* Check the parameters */
    360            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    361            assert_param(IS_FUNCTIONAL_STATE(NewState));
    362            if (NewState != DISABLE)
    363            {
    364              /* Generate a STOP condition */
    365              I2Cx->CR1 |= I2C_CR1_STOP;
    366            }
    367            else
    368            {
    369              /* Disable the STOP condition generation */
    370              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
    371            }
    372          }
    373          
    374          /**
    375            * @brief  Transmits the address byte to select the slave device.
    376            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    377            * @param  Address: specifies the slave address which will be transmitted
    378            * @param  I2C_Direction: specifies whether the I2C device will be a Transmitter
    379            *         or a Receiver. 
    380            *          This parameter can be one of the following values
    381            *            @arg I2C_Direction_Transmitter: Transmitter mode
    382            *            @arg I2C_Direction_Receiver: Receiver mode
    383            * @retval None.
    384            */
    385          void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
    386          {
    387            /* Check the parameters */
    388            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    389            assert_param(IS_I2C_DIRECTION(I2C_Direction));
    390            /* Test on the direction to set/reset the read/write bit */
    391            if (I2C_Direction != I2C_Direction_Transmitter)
    392            {
    393              /* Set the address bit0 for read */
    394              Address |= I2C_OAR1_ADD0;
    395            }
    396            else
    397            {
    398              /* Reset the address bit0 for write */
    399              Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
    400            }
    401            /* Send the address */
    402            I2Cx->DR = Address;
    403          }
    404          
    405          /**
    406            * @brief  Enables or disables the specified I2C acknowledge feature.
    407            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    408            * @param  NewState: new state of the I2C Acknowledgement.
    409            *          This parameter can be: ENABLE or DISABLE.
    410            * @retval None.
    411            */
    412          void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
    413          {
    414            /* Check the parameters */
    415            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    416            assert_param(IS_FUNCTIONAL_STATE(NewState));
    417            if (NewState != DISABLE)
    418            {
    419              /* Enable the acknowledgement */
    420              I2Cx->CR1 |= I2C_CR1_ACK;
    421            }
    422            else
    423            {
    424              /* Disable the acknowledgement */
    425              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
    426            }
    427          }
    428          
    429          /**
    430            * @brief  Configures the specified I2C own address2.
    431            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    432            * @param  Address: specifies the 7bit I2C own address2.
    433            * @retval None.
    434            */
    435          void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
    436          {
    437            uint16_t tmpreg = 0;
    438          
    439            /* Check the parameters */
    440            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    441          
    442            /* Get the old register value */
    443            tmpreg = I2Cx->OAR2;
    444          
    445            /* Reset I2Cx Own address2 bit [7:1] */
    446            tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
    447          
    448            /* Set I2Cx Own address2 */
    449            tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
    450          
    451            /* Store the new register value */
    452            I2Cx->OAR2 = tmpreg;
    453          }
    454          
    455          /**
    456            * @brief  Enables or disables the specified I2C dual addressing mode.
    457            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    458            * @param  NewState: new state of the I2C dual addressing mode.
    459            *          This parameter can be: ENABLE or DISABLE.
    460            * @retval None
    461            */
    462          void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    463          {
    464            /* Check the parameters */
    465            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    466            assert_param(IS_FUNCTIONAL_STATE(NewState));
    467            if (NewState != DISABLE)
    468            {
    469              /* Enable dual addressing mode */
    470              I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
    471            }
    472            else
    473            {
    474              /* Disable dual addressing mode */
    475              I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
    476            }
    477          }
    478          
    479          /**
    480            * @brief  Enables or disables the specified I2C general call feature.
    481            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    482            * @param  NewState: new state of the I2C General call.
    483            *          This parameter can be: ENABLE or DISABLE.
    484            * @retval None
    485            */
    486          void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    487          {
    488            /* Check the parameters */
    489            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    490            assert_param(IS_FUNCTIONAL_STATE(NewState));
    491            if (NewState != DISABLE)
    492            {
    493              /* Enable generall call */
    494              I2Cx->CR1 |= I2C_CR1_ENGC;
    495            }
    496            else
    497            {
    498              /* Disable generall call */
    499              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
    500            }
    501          }
    502          
    503          /**
    504            * @brief  Enables or disables the specified I2C software reset.
    505            * @note   When software reset is enabled, the I2C IOs are released (this can
    506            *         be useful to recover from bus errors).  
    507            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    508            * @param  NewState: new state of the I2C software reset.
    509            *          This parameter can be: ENABLE or DISABLE.
    510            * @retval None
    511            */
    512          void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    513          {
    514            /* Check the parameters */
    515            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    516            assert_param(IS_FUNCTIONAL_STATE(NewState));
    517            if (NewState != DISABLE)
    518            {
    519              /* Peripheral under reset */
    520              I2Cx->CR1 |= I2C_CR1_SWRST;
    521            }
    522            else
    523            {
    524              /* Peripheral not under reset */
    525              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
    526            }
    527          }
    528          
    529          /**
    530            * @brief  Enables or disables the specified I2C Clock stretching.
    531            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    532            * @param  NewState: new state of the I2Cx Clock stretching.
    533            *          This parameter can be: ENABLE or DISABLE.
    534            * @retval None
    535            */
    536          void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    537          {
    538            /* Check the parameters */
    539            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    540            assert_param(IS_FUNCTIONAL_STATE(NewState));
    541            if (NewState == DISABLE)
    542            {
    543              /* Enable the selected I2C Clock stretching */
    544              I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
    545            }
    546            else
    547            {
    548              /* Disable the selected I2C Clock stretching */
    549              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
    550            }
    551          }
    552          
    553          /**
    554            * @brief  Selects the specified I2C fast mode duty cycle.
    555            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    556            * @param  I2C_DutyCycle: specifies the fast mode duty cycle.
    557            *          This parameter can be one of the following values:
    558            *            @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
    559            *            @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
    560            * @retval None
    561            */
    562          void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
    563          {
    564            /* Check the parameters */
    565            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    566            assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
    567            if (I2C_DutyCycle != I2C_DutyCycle_16_9)
    568            {
    569              /* I2C fast mode Tlow/Thigh=2 */
    570              I2Cx->CCR &= I2C_DutyCycle_2;
    571            }
    572            else
    573            {
    574              /* I2C fast mode Tlow/Thigh=16/9 */
    575              I2Cx->CCR |= I2C_DutyCycle_16_9;
    576            }
    577          }
    578          
    579          /**
    580            * @brief  Selects the specified I2C NACK position in master receiver mode.
    581            * @note   This function is useful in I2C Master Receiver mode when the number
    582            *         of data to be received is equal to 2. In this case, this function 
    583            *         should be called (with parameter I2C_NACKPosition_Next) before data 
    584            *         reception starts,as described in the 2-byte reception procedure 
    585            *         recommended in Reference Manual in Section: Master receiver.                
    586            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    587            * @param  I2C_NACKPosition: specifies the NACK position. 
    588            *          This parameter can be one of the following values:
    589            *            @arg I2C_NACKPosition_Next: indicates that the next byte will be the last
    590            *                                        received byte.  
    591            *            @arg I2C_NACKPosition_Current: indicates that current byte is the last 
    592            *                                           received byte.
    593            *            
    594            * @note    This function configures the same bit (POS) as I2C_PECPositionConfig() 
    595            *          but is intended to be used in I2C mode while I2C_PECPositionConfig() 
    596            *          is intended to used in SMBUS mode. 
    597            *            
    598            * @retval None
    599            */
    600          void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
    601          {
    602            /* Check the parameters */
    603            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    604            assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
    605            
    606            /* Check the input parameter */
    607            if (I2C_NACKPosition == I2C_NACKPosition_Next)
    608            {
    609              /* Next byte in shift register is the last received byte */
    610              I2Cx->CR1 |= I2C_NACKPosition_Next;
    611            }
    612            else
    613            {
    614              /* Current byte in shift register is the last received byte */
    615              I2Cx->CR1 &= I2C_NACKPosition_Current;
    616            }
    617          }
    618          
    619          /**
    620            * @brief  Drives the SMBusAlert pin high or low for the specified I2C.
    621            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    622            * @param  I2C_SMBusAlert: specifies SMBAlert pin level. 
    623            *          This parameter can be one of the following values:
    624            *            @arg I2C_SMBusAlert_Low: SMBAlert pin driven low
    625            *            @arg I2C_SMBusAlert_High: SMBAlert pin driven high
    626            * @retval None
    627            */
    628          void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
    629          {
    630            /* Check the parameters */
    631            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    632            assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
    633            if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
    634            {
    635              /* Drive the SMBusAlert pin Low */
    636              I2Cx->CR1 |= I2C_SMBusAlert_Low;
    637            }
    638            else
    639            {
    640              /* Drive the SMBusAlert pin High  */
    641              I2Cx->CR1 &= I2C_SMBusAlert_High;
    642            }
    643          }
    644          
    645          /**
    646            * @brief  Enables or disables the specified I2C ARP.
    647            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    648            * @param  NewState: new state of the I2Cx ARP. 
    649            *          This parameter can be: ENABLE or DISABLE.
    650            * @retval None
    651            */
    652          void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    653          {
    654            /* Check the parameters */
    655            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    656            assert_param(IS_FUNCTIONAL_STATE(NewState));
    657            if (NewState != DISABLE)
    658            {
    659              /* Enable the selected I2C ARP */
    660              I2Cx->CR1 |= I2C_CR1_ENARP;
    661            }
    662            else
    663            {
    664              /* Disable the selected I2C ARP */
    665              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
    666            }
    667          }
    668          /**
    669            * @}
    670            */
    671          
    672          /** @defgroup I2C_Group2 Data transfers functions
    673           *  @brief   Data transfers functions 
    674           *
    675          @verbatim   
    676           ===============================================================================
    677                                  Data transfers functions
    678           ===============================================================================  
    679          
    680          @endverbatim
    681            * @{
    682            */
    683          
    684          /**
    685            * @brief  Sends a data byte through the I2Cx peripheral.
    686            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    687            * @param  Data: Byte to be transmitted..
    688            * @retval None
    689            */
    690          void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
    691          {
    692            /* Check the parameters */
    693            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    694            /* Write in the DR register the data to be sent */
    695            I2Cx->DR = Data;
    696          }
    697          
    698          /**
    699            * @brief  Returns the most recent received data by the I2Cx peripheral.
    700            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    701            * @retval The value of the received data.
    702            */
    703          uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
    704          {
    705            /* Check the parameters */
    706            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    707            /* Return the data in the DR register */
    708            return (uint8_t)I2Cx->DR;
    709          }
    710          
    711          /**
    712            * @}
    713            */
    714          
    715          /** @defgroup I2C_Group3 PEC management functions
    716           *  @brief   PEC management functions 
    717           *
    718          @verbatim   
    719           ===============================================================================
    720                                   PEC management functions
    721           ===============================================================================  
    722          
    723          @endverbatim
    724            * @{
    725            */
    726          
    727          /**
    728            * @brief  Enables or disables the specified I2C PEC transfer.
    729            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    730            * @param  NewState: new state of the I2C PEC transmission.
    731            *          This parameter can be: ENABLE or DISABLE.
    732            * @retval None
    733            */
    734          void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
    735          {
    736            /* Check the parameters */
    737            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    738            assert_param(IS_FUNCTIONAL_STATE(NewState));
    739            if (NewState != DISABLE)
    740            {
    741              /* Enable the selected I2C PEC transmission */
    742              I2Cx->CR1 |= I2C_CR1_PEC;
    743            }
    744            else
    745            {
    746              /* Disable the selected I2C PEC transmission */
    747              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
    748            }
    749          }
    750          
    751          /**
    752            * @brief  Selects the specified I2C PEC position.
    753            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    754            * @param  I2C_PECPosition: specifies the PEC position. 
    755            *          This parameter can be one of the following values:
    756            *            @arg I2C_PECPosition_Next: indicates that the next byte is PEC
    757            *            @arg I2C_PECPosition_Current: indicates that current byte is PEC
    758            *       
    759            * @note    This function configures the same bit (POS) as I2C_NACKPositionConfig()
    760            *          but is intended to be used in SMBUS mode while I2C_NACKPositionConfig() 
    761            *          is intended to used in I2C mode.
    762            *                
    763            * @retval None
    764            */
    765          void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
    766          {
    767            /* Check the parameters */
    768            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    769            assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
    770            if (I2C_PECPosition == I2C_PECPosition_Next)
    771            {
    772              /* Next byte in shift register is PEC */
    773              I2Cx->CR1 |= I2C_PECPosition_Next;
    774            }
    775            else
    776            {
    777              /* Current byte in shift register is PEC */
    778              I2Cx->CR1 &= I2C_PECPosition_Current;
    779            }
    780          }
    781          
    782          /**
    783            * @brief  Enables or disables the PEC value calculation of the transferred bytes.
    784            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    785            * @param  NewState: new state of the I2Cx PEC value calculation.
    786            *          This parameter can be: ENABLE or DISABLE.
    787            * @retval None
    788            */
    789          void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
    790          {
    791            /* Check the parameters */
    792            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    793            assert_param(IS_FUNCTIONAL_STATE(NewState));
    794            if (NewState != DISABLE)
    795            {
    796              /* Enable the selected I2C PEC calculation */
    797              I2Cx->CR1 |= I2C_CR1_ENPEC;
    798            }
    799            else
    800            {
    801              /* Disable the selected I2C PEC calculation */
    802              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
    803            }
    804          }
    805          
    806          /**
    807            * @brief  Returns the PEC value for the specified I2C.
    808            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    809            * @retval The PEC value.
    810            */
    811          uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
    812          {
    813            /* Check the parameters */
    814            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    815            /* Return the selected I2C PEC value */
    816            return ((I2Cx->SR2) >> 8);
    817          }
    818          
    819          /**
    820            * @}
    821            */
    822          
    823          /** @defgroup I2C_Group4 DMA transfers management functions
    824           *  @brief   DMA transfers management functions 
    825           *
    826          @verbatim   
    827           ===============================================================================
    828                                   DMA transfers management functions
    829           ===============================================================================  
    830            This section provides functions allowing to configure the I2C DMA channels 
    831            requests.
    832            
    833          @endverbatim
    834            * @{
    835            */
    836          
    837          /**
    838            * @brief  Enables or disables the specified I2C DMA requests.
    839            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    840            * @param  NewState: new state of the I2C DMA transfer.
    841            *          This parameter can be: ENABLE or DISABLE.
    842            * @retval None
    843            */
    844          void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    845          {
    846            /* Check the parameters */
    847            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    848            assert_param(IS_FUNCTIONAL_STATE(NewState));
    849            if (NewState != DISABLE)
    850            {
    851              /* Enable the selected I2C DMA requests */
    852              I2Cx->CR2 |= I2C_CR2_DMAEN;
    853            }
    854            else
    855            {
    856              /* Disable the selected I2C DMA requests */
    857              I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
    858            }
    859          }
    860          
    861          /**
    862            * @brief  Specifies that the next DMA transfer is the last one.
    863            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    864            * @param  NewState: new state of the I2C DMA last transfer.
    865            *          This parameter can be: ENABLE or DISABLE.
    866            * @retval None
    867            */
    868          void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    869          {
    870            /* Check the parameters */
    871            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    872            assert_param(IS_FUNCTIONAL_STATE(NewState));
    873            if (NewState != DISABLE)
    874            {
    875              /* Next DMA transfer is the last transfer */
    876              I2Cx->CR2 |= I2C_CR2_LAST;
    877            }
    878            else
    879            {
    880              /* Next DMA transfer is not the last transfer */
    881              I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
    882            }
    883          }
    884          
    885          /**
    886            * @}
    887            */
    888          
    889          /** @defgroup I2C_Group5 Interrupts events and flags management functions
    890           *  @brief   Interrupts, events and flags management functions
    891           *
    892          @verbatim   
    893           ===============================================================================
    894                          Interrupts, events and flags management functions
    895           ===============================================================================  
    896            This section provides functions allowing to configure the I2C Interrupts 
    897            sources and check or clear the flags or pending bits status.
    898            The user should identify which mode will be used in his application to manage 
    899            the communication: Polling mode, Interrupt mode or DMA mode. 
    900          
    901           ===============================================================================
    902                                    I2C State Monitoring Functions                    
    903           ===============================================================================   
    904            This I2C driver provides three different ways for I2C state monitoring
    905            depending on the application requirements and constraints:
    906                   
    907             
    908               1. Basic state monitoring (Using I2C_CheckEvent() function)
    909               -----------------------------------------------------------
    910                  It compares the status registers (SR1 and SR2) content to a given event
    911                  (can be the combination of one or more flags).
    912                  It returns SUCCESS if the current status includes the given flags 
    913                  and returns ERROR if one or more flags are missing in the current status.
    914          
    915                    - When to use
    916                       - This function is suitable for most applications as well as for startup 
    917                         activity since the events are fully described in the product reference 
    918                         manual (RM0033).
    919                       - It is also suitable for users who need to define their own events.
    920          
    921                    - Limitations
    922                       - If an error occurs (ie. error flags are set besides to the monitored 
    923                         flags), the I2C_CheckEvent() function may return SUCCESS despite 
    924                         the communication hold or corrupted real state. 
    925                         In this case, it is advised to use error interrupts to monitor 
    926                         the error events and handle them in the interrupt IRQ handler.
    927                   
    928               @note 
    929                   For error management, it is advised to use the following functions:
    930                     - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
    931                     - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.
    932                       Where x is the peripheral instance (I2C1, I2C2 ...)
    933                     - I2C_GetFlagStatus() or I2C_GetITStatus()  to be called into the 
    934                       I2Cx_ER_IRQHandler() function in order to determine which error occurred.
    935                     - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd() 
    936                       and/or I2C_GenerateStop() in order to clear the error flag and source 
    937                       and return to correct  communication status.
    938                       
    939           
    940               2. Advanced state monitoring (Using the function I2C_GetLastEvent())
    941               -------------------------------------------------------------------- 
    942                  Using the function I2C_GetLastEvent() which returns the image of both status 
    943                  registers in a single word (uint32_t) (Status Register 2 value is shifted left 
    944                  by 16 bits and concatenated to Status Register 1).
    945          
    946                    - When to use
    947                       - This function is suitable for the same applications above but it 
    948                         allows to overcome the mentioned limitation of I2C_GetFlagStatus() 
    949                         function.
    950                       - The returned value could be compared to events already defined in 
    951                         the library (stm32f2xx_i2c.h) or to custom values defined by user.
    952                         This function is suitable when multiple flags are monitored at the 
    953                         same time.
    954                       - At the opposite of I2C_CheckEvent() function, this function allows 
    955                         user to choose when an event is accepted (when all events flags are 
    956                         set and no other flags are set or just when the needed flags are set 
    957                         like I2C_CheckEvent() function.
    958          
    959                    - Limitations
    960                       - User may need to define his own events.
    961                       - Same remark concerning the error management is applicable for this 
    962                         function if user decides to check only regular communication flags 
    963                         (and ignores error flags).
    964                
    965           
    966               3. Flag-based state monitoring (Using the function I2C_GetFlagStatus())
    967               -----------------------------------------------------------------------
    968               
    969                Using the function I2C_GetFlagStatus() which simply returns the status of 
    970                one single flag (ie. I2C_FLAG_RXNE ...). 
    971          
    972                    - When to use
    973                       - This function could be used for specific applications or in debug 
    974                         phase.
    975                       - It is suitable when only one flag checking is needed (most I2C 
    976                         events are monitored through multiple flags).
    977                    - Limitations: 
    978                       - When calling this function, the Status register is accessed. 
    979                         Some flags are cleared when the status register is accessed. 
    980                         So checking the status of one Flag, may clear other ones.
    981                       - Function may need to be called twice or more in order to monitor 
    982                         one single event.
    983           
    984             For detailed description of Events, please refer to section I2C_Events in 
    985             stm32f2xx_i2c.h file.
    986                 
    987          @endverbatim
    988            * @{
    989            */
    990             
    991          /**
    992            * @brief  Reads the specified I2C register and returns its value.
    993            * @param  I2C_Register: specifies the register to read.
    994            *          This parameter can be one of the following values:
    995            *            @arg I2C_Register_CR1:  CR1 register.
    996            *            @arg I2C_Register_CR2:   CR2 register.
    997            *            @arg I2C_Register_OAR1:  OAR1 register.
    998            *            @arg I2C_Register_OAR2:  OAR2 register.
    999            *            @arg I2C_Register_DR:    DR register.
   1000            *            @arg I2C_Register_SR1:   SR1 register.
   1001            *            @arg I2C_Register_SR2:   SR2 register.
   1002            *            @arg I2C_Register_CCR:   CCR register.
   1003            *            @arg I2C_Register_TRISE: TRISE register.
   1004            * @retval The value of the read register.
   1005            */
   1006          uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
   1007          {
   1008            __IO uint32_t tmp = 0;
   1009          
   1010            /* Check the parameters */
   1011            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1012            assert_param(IS_I2C_REGISTER(I2C_Register));
   1013          
   1014            tmp = (uint32_t) I2Cx;
   1015            tmp += I2C_Register;
   1016          
   1017            /* Return the selected register value */
   1018            return (*(__IO uint16_t *) tmp);
   1019          }
   1020          
   1021          /**
   1022            * @brief  Enables or disables the specified I2C interrupts.
   1023            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1024            * @param  I2C_IT: specifies the I2C interrupts sources to be enabled or disabled. 
   1025            *          This parameter can be any combination of the following values:
   1026            *            @arg I2C_IT_BUF: Buffer interrupt mask
   1027            *            @arg I2C_IT_EVT: Event interrupt mask
   1028            *            @arg I2C_IT_ERR: Error interrupt mask
   1029            * @param  NewState: new state of the specified I2C interrupts.
   1030            *          This parameter can be: ENABLE or DISABLE.
   1031            * @retval None
   1032            */
   1033          void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
   1034          {
   1035            /* Check the parameters */
   1036            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1037            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1038            assert_param(IS_I2C_CONFIG_IT(I2C_IT));
   1039            
   1040            if (NewState != DISABLE)
   1041            {
   1042              /* Enable the selected I2C interrupts */
   1043              I2Cx->CR2 |= I2C_IT;
   1044            }
   1045            else
   1046            {
   1047              /* Disable the selected I2C interrupts */
   1048              I2Cx->CR2 &= (uint16_t)~I2C_IT;
   1049            }
   1050          }
   1051          
   1052          /*
   1053           ===============================================================================
   1054                                    1. Basic state monitoring                    
   1055           ===============================================================================  
   1056           */
   1057          
   1058          /**
   1059            * @brief  Checks whether the last I2Cx Event is equal to the one passed
   1060            *         as parameter.
   1061            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1062            * @param  I2C_EVENT: specifies the event to be checked. 
   1063            *          This parameter can be one of the following values:
   1064            *            @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED: EV1
   1065            *            @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED: EV1
   1066            *            @arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED: EV1
   1067            *            @arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED: EV1
   1068            *            @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED: EV1
   1069            *            @arg I2C_EVENT_SLAVE_BYTE_RECEIVED: EV2
   1070            *            @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF): EV2
   1071            *            @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL): EV2
   1072            *            @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED: EV3
   1073            *            @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF): EV3
   1074            *            @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL): EV3
   1075            *            @arg I2C_EVENT_SLAVE_ACK_FAILURE: EV3_2
   1076            *            @arg I2C_EVENT_SLAVE_STOP_DETECTED: EV4
   1077            *            @arg I2C_EVENT_MASTER_MODE_SELECT: EV5
   1078            *            @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED: EV6     
   1079            *            @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED: EV6
   1080            *            @arg I2C_EVENT_MASTER_BYTE_RECEIVED: EV7
   1081            *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING: EV8
   1082            *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED: EV8_2
   1083            *            @arg I2C_EVENT_MASTER_MODE_ADDRESS10: EV9
   1084            *     
   1085            * @note   For detailed description of Events, please refer to section I2C_Events
   1086            *         in stm32f2xx_i2c.h file.
   1087            *    
   1088            * @retval An ErrorStatus enumeration value:
   1089            *           - SUCCESS: Last event is equal to the I2C_EVENT
   1090            *           - ERROR: Last event is different from the I2C_EVENT
   1091            */
   1092          ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
   1093          {
   1094            uint32_t lastevent = 0;
   1095            uint32_t flag1 = 0, flag2 = 0;
   1096            ErrorStatus status = ERROR;
   1097          
   1098            /* Check the parameters */
   1099            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1100            assert_param(IS_I2C_EVENT(I2C_EVENT));
   1101          
   1102            /* Read the I2Cx status register */
   1103            flag1 = I2Cx->SR1;
   1104            flag2 = I2Cx->SR2;
   1105            flag2 = flag2 << 16;
   1106          
   1107            /* Get the last event value from I2C status register */
   1108            lastevent = (flag1 | flag2) & FLAG_MASK;
   1109          
   1110            /* Check whether the last event contains the I2C_EVENT */
   1111            if ((lastevent & I2C_EVENT) == I2C_EVENT)
   1112            {
   1113              /* SUCCESS: last event is equal to I2C_EVENT */
   1114              status = SUCCESS;
   1115            }
   1116            else
   1117            {
   1118              /* ERROR: last event is different from I2C_EVENT */
   1119              status = ERROR;
   1120            }
   1121            /* Return status */
   1122            return status;
   1123          }
   1124          
   1125          /*
   1126           ===============================================================================
   1127                                    2. Advanced state monitoring                   
   1128           ===============================================================================  
   1129           */
   1130          
   1131          /**
   1132            * @brief  Returns the last I2Cx Event.
   1133            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1134            *     
   1135            * @note   For detailed description of Events, please refer to section I2C_Events
   1136            *         in stm32f2xx_i2c.h file.
   1137            *    
   1138            * @retval The last event
   1139            */
   1140          uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
   1141          {
   1142            uint32_t lastevent = 0;
   1143            uint32_t flag1 = 0, flag2 = 0;
   1144          
   1145            /* Check the parameters */
   1146            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1147          
   1148            /* Read the I2Cx status register */
   1149            flag1 = I2Cx->SR1;
   1150            flag2 = I2Cx->SR2;
   1151            flag2 = flag2 << 16;
   1152          
   1153            /* Get the last event value from I2C status register */
   1154            lastevent = (flag1 | flag2) & FLAG_MASK;
   1155          
   1156            /* Return status */
   1157            return lastevent;
   1158          }
   1159          
   1160          /*
   1161           ===============================================================================
   1162                                    3. Flag-based state monitoring                   
   1163           ===============================================================================  
   1164           */
   1165          
   1166          /**
   1167            * @brief  Checks whether the specified I2C flag is set or not.
   1168            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1169            * @param  I2C_FLAG: specifies the flag to check. 
   1170            *          This parameter can be one of the following values:
   1171            *            @arg I2C_FLAG_DUALF: Dual flag (Slave mode)
   1172            *            @arg I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
   1173            *            @arg I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
   1174            *            @arg I2C_FLAG_GENCALL: General call header flag (Slave mode)
   1175            *            @arg I2C_FLAG_TRA: Transmitter/Receiver flag
   1176            *            @arg I2C_FLAG_BUSY: Bus busy flag
   1177            *            @arg I2C_FLAG_MSL: Master/Slave flag
   1178            *            @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1179            *            @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1180            *            @arg I2C_FLAG_PECERR: PEC error in reception flag
   1181            *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1182            *            @arg I2C_FLAG_AF: Acknowledge failure flag
   1183            *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1184            *            @arg I2C_FLAG_BERR: Bus error flag
   1185            *            @arg I2C_FLAG_TXE: Data register empty flag (Transmitter)
   1186            *            @arg I2C_FLAG_RXNE: Data register not empty (Receiver) flag
   1187            *            @arg I2C_FLAG_STOPF: Stop detection flag (Slave mode)
   1188            *            @arg I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
   1189            *            @arg I2C_FLAG_BTF: Byte transfer finished flag
   1190            *            @arg I2C_FLAG_ADDR: Address sent flag (Master mode) "ADSL"
   1191            *                                Address matched flag (Slave mode)"ENDAD"
   1192            *            @arg I2C_FLAG_SB: Start bit flag (Master mode)
   1193            * @retval The new state of I2C_FLAG (SET or RESET).
   1194            */
   1195          FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
   1196          {
   1197            FlagStatus bitstatus = RESET;
   1198            __IO uint32_t i2creg = 0, i2cxbase = 0;
   1199          
   1200            /* Check the parameters */
   1201            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1202            assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
   1203          
   1204            /* Get the I2Cx peripheral base address */
   1205            i2cxbase = (uint32_t)I2Cx;
   1206            
   1207            /* Read flag register index */
   1208            i2creg = I2C_FLAG >> 28;
   1209            
   1210            /* Get bit[23:0] of the flag */
   1211            I2C_FLAG &= FLAG_MASK;
   1212            
   1213            if(i2creg != 0)
   1214            {
   1215              /* Get the I2Cx SR1 register address */
   1216              i2cxbase += 0x14;
   1217            }
   1218            else
   1219            {
   1220              /* Flag in I2Cx SR2 Register */
   1221              I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
   1222              /* Get the I2Cx SR2 register address */
   1223              i2cxbase += 0x18;
   1224            }
   1225            
   1226            if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
   1227            {
   1228              /* I2C_FLAG is set */
   1229              bitstatus = SET;
   1230            }
   1231            else
   1232            {
   1233              /* I2C_FLAG is reset */
   1234              bitstatus = RESET;
   1235            }
   1236            
   1237            /* Return the I2C_FLAG status */
   1238            return  bitstatus;
   1239          }
   1240          
   1241          /**
   1242            * @brief  Clears the I2Cx's pending flags.
   1243            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1244            * @param  I2C_FLAG: specifies the flag to clear. 
   1245            *          This parameter can be any combination of the following values:
   1246            *            @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1247            *            @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1248            *            @arg I2C_FLAG_PECERR: PEC error in reception flag
   1249            *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1250            *            @arg I2C_FLAG_AF: Acknowledge failure flag
   1251            *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1252            *            @arg I2C_FLAG_BERR: Bus error flag
   1253            *   
   1254            * @note   STOPF (STOP detection) is cleared by software sequence: a read operation 
   1255            *          to I2C_SR1 register (I2C_GetFlagStatus()) followed by a write operation 
   1256            *          to I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
   1257            * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read 
   1258            *          operation to I2C_SR1 (I2C_GetFlagStatus()) followed by writing the 
   1259            *          second byte of the address in DR register.
   1260            * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read 
   1261            *          operation to I2C_SR1 register (I2C_GetFlagStatus()) followed by a 
   1262            *          read/write to I2C_DR register (I2C_SendData()).
   1263            * @note   ADDR (Address sent) is cleared by software sequence: a read operation to 
   1264            *          I2C_SR1 register (I2C_GetFlagStatus()) followed by a read operation to 
   1265            *          I2C_SR2 register ((void)(I2Cx->SR2)).
   1266            * @note   SB (Start Bit) is cleared software sequence: a read operation to I2C_SR1
   1267            *          register (I2C_GetFlagStatus()) followed by a write operation to I2C_DR
   1268            *          register (I2C_SendData()).
   1269            *  
   1270            * @retval None
   1271            */
   1272          void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
   1273          {
   1274            uint32_t flagpos = 0;
   1275            /* Check the parameters */
   1276            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1277            assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
   1278            /* Get the I2C flag position */
   1279            flagpos = I2C_FLAG & FLAG_MASK;
   1280            /* Clear the selected I2C flag */
   1281            I2Cx->SR1 = (uint16_t)~flagpos;
   1282          }
   1283          
   1284          /**
   1285            * @brief  Checks whether the specified I2C interrupt has occurred or not.
   1286            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1287            * @param  I2C_IT: specifies the interrupt source to check. 
   1288            *          This parameter can be one of the following values:
   1289            *            @arg I2C_IT_SMBALERT: SMBus Alert flag
   1290            *            @arg I2C_IT_TIMEOUT: Timeout or Tlow error flag
   1291            *            @arg I2C_IT_PECERR: PEC error in reception flag
   1292            *            @arg I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
   1293            *            @arg I2C_IT_AF: Acknowledge failure flag
   1294            *            @arg I2C_IT_ARLO: Arbitration lost flag (Master mode)
   1295            *            @arg I2C_IT_BERR: Bus error flag
   1296            *            @arg I2C_IT_TXE: Data register empty flag (Transmitter)
   1297            *            @arg I2C_IT_RXNE: Data register not empty (Receiver) flag
   1298            *            @arg I2C_IT_STOPF: Stop detection flag (Slave mode)
   1299            *            @arg I2C_IT_ADD10: 10-bit header sent flag (Master mode)
   1300            *            @arg I2C_IT_BTF: Byte transfer finished flag
   1301            *            @arg I2C_IT_ADDR: Address sent flag (Master mode) "ADSL"
   1302            *                              Address matched flag (Slave mode)"ENDAD"
   1303            *            @arg I2C_IT_SB: Start bit flag (Master mode)
   1304            * @retval The new state of I2C_IT (SET or RESET).
   1305            */
   1306          ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
   1307          {
   1308            ITStatus bitstatus = RESET;
   1309            uint32_t enablestatus = 0;
   1310          
   1311            /* Check the parameters */
   1312            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1313            assert_param(IS_I2C_GET_IT(I2C_IT));
   1314          
   1315            /* Check if the interrupt source is enabled or not */
   1316            enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
   1317            
   1318            /* Get bit[23:0] of the flag */
   1319            I2C_IT &= FLAG_MASK;
   1320          
   1321            /* Check the status of the specified I2C flag */
   1322            if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
   1323            {
   1324              /* I2C_IT is set */
   1325              bitstatus = SET;
   1326            }
   1327            else
   1328            {
   1329              /* I2C_IT is reset */
   1330              bitstatus = RESET;
   1331            }
   1332            /* Return the I2C_IT status */
   1333            return  bitstatus;
   1334          }
   1335          
   1336          /**
   1337            * @brief  Clears the I2Cx's interrupt pending bits.
   1338            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1339            * @param  I2C_IT: specifies the interrupt pending bit to clear. 
   1340            *          This parameter can be any combination of the following values:
   1341            *            @arg I2C_IT_SMBALERT: SMBus Alert interrupt
   1342            *            @arg I2C_IT_TIMEOUT: Timeout or Tlow error interrupt
   1343            *            @arg I2C_IT_PECERR: PEC error in reception  interrupt
   1344            *            @arg I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode)
   1345            *            @arg I2C_IT_AF: Acknowledge failure interrupt
   1346            *            @arg I2C_IT_ARLO: Arbitration lost interrupt (Master mode)
   1347            *            @arg I2C_IT_BERR: Bus error interrupt
   1348            * 
   1349            * @note   STOPF (STOP detection) is cleared by software sequence: a read operation 
   1350            *          to I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
   1351            *          I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
   1352            * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read 
   1353            *          operation to I2C_SR1 (I2C_GetITStatus()) followed by writing the second 
   1354            *          byte of the address in I2C_DR register.
   1355            * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read 
   1356            *          operation to I2C_SR1 register (I2C_GetITStatus()) followed by a 
   1357            *          read/write to I2C_DR register (I2C_SendData()).
   1358            * @note   ADDR (Address sent) is cleared by software sequence: a read operation to 
   1359            *          I2C_SR1 register (I2C_GetITStatus()) followed by a read operation to 
   1360            *          I2C_SR2 register ((void)(I2Cx->SR2)).
   1361            * @note   SB (Start Bit) is cleared by software sequence: a read operation to 
   1362            *          I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
   1363            *          I2C_DR register (I2C_SendData()).
   1364            * @retval None
   1365            */
   1366          void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
   1367          {
   1368            uint32_t flagpos = 0;
   1369            /* Check the parameters */
   1370            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1371            assert_param(IS_I2C_CLEAR_IT(I2C_IT));
   1372          
   1373            /* Get the I2C flag position */
   1374            flagpos = I2C_IT & FLAG_MASK;
   1375          
   1376            /* Clear the selected I2C flag */
   1377            I2Cx->SR1 = (uint16_t)~flagpos;
   1378          }
   1379          
   1380          /**
   1381            * @}
   1382            */
   1383          
   1384          /**
   1385            * @}
   1386            */ 
   1387          
   1388          /**
   1389            * @}
   1390            */ 
   1391          
   1392          /**
   1393            * @}
   1394            */ 
   1395          
   1396          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   I2C_ARPCmd
       0   I2C_AcknowledgeConfig
       0   I2C_CalculatePEC
      20   I2C_CheckEvent
       4   I2C_ClearFlag
       4   I2C_ClearITPendingBit
       0   I2C_Cmd
       0   I2C_DMACmd
       0   I2C_DMALastTransferCmd
       8   I2C_DeInit
         8   -> RCC_APB1PeriphResetCmd
       0   I2C_DualAddressCmd
       0   I2C_FastModeDutyCycleConfig
       0   I2C_GeneralCallCmd
       0   I2C_GenerateSTART
       0   I2C_GenerateSTOP
       8   I2C_GetFlagStatus
       8   I2C_GetITStatus
      12   I2C_GetLastEvent
       0   I2C_GetPEC
       0   I2C_ITConfig
      48   I2C_Init
        48   -> RCC_GetClocksFreq
       0   I2C_NACKPositionConfig
       4   I2C_OwnAddress2Config
       0   I2C_PECPositionConfig
       4   I2C_ReadRegister
       0   I2C_ReceiveData
       0   I2C_SMBusAlertConfig
       0   I2C_Send7bitAddress
       0   I2C_SendData
       0   I2C_SoftwareResetCmd
       0   I2C_StretchClockCmd
       0   I2C_StructInit
       0   I2C_TransmitPEC


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
      30  I2C_ARPCmd
      30  I2C_AcknowledgeConfig
      30  I2C_CalculatePEC
      48  I2C_CheckEvent
      16  I2C_ClearFlag
      16  I2C_ClearITPendingBit
      30  I2C_Cmd
      30  I2C_DMACmd
      30  I2C_DMALastTransferCmd
      88  I2C_DeInit
      30  I2C_DualAddressCmd
      32  I2C_FastModeDutyCycleConfig
      30  I2C_GeneralCallCmd
      30  I2C_GenerateSTART
      30  I2C_GenerateSTOP
      68  I2C_GetFlagStatus
      44  I2C_GetITStatus
      28  I2C_GetLastEvent
      10  I2C_GetPEC
      24  I2C_ITConfig
     222  I2C_Init
      32  I2C_NACKPositionConfig
      28  I2C_OwnAddress2Config
      32  I2C_PECPositionConfig
      28  I2C_ReadRegister
       6  I2C_ReceiveData
      32  I2C_SMBusAlertConfig
      26  I2C_Send7bitAddress
       8  I2C_SendData
      28  I2C_SoftwareResetCmd
      30  I2C_StretchClockCmd
      32  I2C_StructInit
      30  I2C_TransmitPEC

 
 1'232 bytes in section .text
 
 1'232 bytes of CODE memory

Errors: none
Warnings: none
