###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         01/Dec/2020  16:53:02
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\manta\contr\arm\manta_contr\src\board\lsm6ds3.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EWBC6D.tmp
#        (D:\proj\velograph\manta\contr\arm\manta_contr\src\board\lsm6ds3.c -D
#        VECT_TAB_FLASH -D IAR_ARM_CM3 -lcN
#        D:\proj\velograph\manta\contr\arm\manta_contr\manta_debug\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\manta\contr\arm\manta_contr\manta_debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\.\ -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\src\board\ -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\..\common\freertos\source\inc\
#        -I D:\proj\velograph\manta\contr\arm\manta_contr\src\inc\ -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I D:\proj\velograph\manta\contr\arm\manta_contr\..\common\dbg\ -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\..\common\inc\ -I
#        D:\proj\velograph\manta\contr\arm\manta_contr\..\common\hdlc\ -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\manta\contr\arm\manta_contr\manta_debug\List\lsm6ds3.lst
#    Object file  =
#        D:\proj\velograph\manta\contr\arm\manta_contr\manta_debug\Obj\lsm6ds3.o
#
###############################################################################

D:\proj\velograph\manta\contr\arm\manta_contr\src\board\lsm6ds3.c
      1          #include "manta_contr_brd.h"
      2          #include "lsm6ds3.h"
      3          
      4          extern int I2C_Mem_Read(I2C_TypeDef* I2Cx, uint8_t sl_addr,uint8_t *buff,uint8_t rd_addr,uint16_t num);
      5          extern int I2C_Memory_Write(I2C_TypeDef* I2Cx, uint8_t sl_addr,uint8_t *buff,uint8_t wr_addr,uint16_t num);
      6          ////===============================================================================
      7          static int LSM6DS3_Verify_XL_Settings(uint8_t XL_Rate, uint8_t XL_Range, uint8_t XL_Filter) 
      8          {
      9          if((XL_Rate < XL_12_5Hz) || (XL_Rate > XL_6660Hz))
     10            return LSM6DS3_FAIL_PARAMETERS;
     11          ////else if((XL_Range < XL_RANGE_2G) || (XL_Range > XL_RANGE_8G))
     12          else if((XL_Range > XL_RANGE_8G))
     13            return LSM6DS3_FAIL_PARAMETERS;
     14          ///else if((XL_Filter < XL_FILTER_400Hz) || (XL_Filter > XL_FILTER_50Hz))
     15          else if( (XL_Filter > XL_FILTER_50Hz))
     16            return LSM6DS3_FAIL_PARAMETERS;
     17          return LSM6DS3_OK;
     18          }
     19          static int LSM6DS3_Verify_GS_Settings(uint8_t GS_Rate, uint8_t GS_Range) 
     20          {
     21          if((GS_Rate < GS_12_5Hz) || (GS_Rate > GS_1666Hz))
     22            return LSM6DS3_FAIL_PARAMETERS;
     23          ////else if((GS_Range < GS_RANGE_250dps) || (GS_Range > GS_RANGE_2000dps) || (GS_Range == 3) || (GS_Range == 5))
     24          else if( (GS_Range > GS_RANGE_2000dps) || (GS_Range == 3) || (GS_Range == 5))
     25            return LSM6DS3_FAIL_PARAMETERS;
     26          return LSM6DS3_OK;
     27          }
     28          ////==================================================
     29          
     30          int LSM6DS3_Detect(void)
     31          {
     32          int rez=0;  
     33          uint8_t btmp;
     34          rez= I2C_Mem_Read(GYRO_I2C, LSM6DS3_I2C_ADDRESS,&btmp,LSM6DS3_XL_GS_WHO_AM_I_REG,1);
     35          if(rez<0)
     36            return rez;
     37          if(btmp==LSM6DS3_WHO_I_AM_RESPONSE)
     38            return 0;
     39          else 
     40            return -11;
     41          }
     42          ////===============================================================================
     43          int LSM6DS3_rd_reg(uint16_t reg,uint8_t *data,uint16_t size)
     44          {
     45          return I2C_Mem_Read(GYRO_I2C, LSM6DS3_I2C_ADDRESS,data,(0x00FF & reg),size);  
     46          }
     47          int LSM6DS3_wr_and_verify(uint16_t reg, uint8_t* data, uint16_t size) 
     48          {
     49          uint8_t ii=0;  
     50          uint8_t compare[32] = {0xFF};
     51          if(size > sizeof(compare))
     52            return -1;
     53          if(I2C_Memory_Write(GYRO_I2C,LSM6DS3_I2C_ADDRESS,data,(0x00FF & reg),size)<0)
     54            return -2;
     55          if(I2C_Mem_Read(GYRO_I2C, LSM6DS3_I2C_ADDRESS,compare,(0x00FF & reg),size)<0)
     56            return -3;
     57          for(ii=0; ii < size; ii++) 
     58            {
     59            if(compare[ii] != data[ii])
     60              return -4;
     61            }
     62          return 0;
     63          }
     64          ////===================================================================
     65          int LSM6DS3_XL_Start(uint8_t XL_Rate, uint8_t XL_Scale, uint8_t XL_Filter) 
     66          {
     67          uint8_t byte = (XL_Rate << 4) | ((XL_Scale << 2) & 0x0F) | (XL_Filter & 0x03);
     68          
     69          if(LSM6DS3_Verify_XL_Settings(XL_Rate, XL_Scale, XL_Filter) !=  LSM6DS3_OK)
     70            return LSM6DS3_FAIL_PARAMETERS;
     71          if(LSM6DS3_wr_and_verify(LSM6DS3_XL_GS_CTRL1_XL, &byte, sizeof(byte)) ==  LSM6DS3_OK)
     72            return LSM6DS3_OK;
     73          return LSM6DS3_FAIL;
     74          }
     75          int LSM6DS3_XL_Stop(void) 
     76          {
     77          uint8_t byte = XL_POWER_DOWN;
     78          
     79          if(LSM6DS3_wr_and_verify(LSM6DS3_XL_GS_CTRL1_XL, &byte, sizeof(byte)) ==  LSM6DS3_OK)
     80            return LSM6DS3_OK;
     81          return LSM6DS3_FAIL;
     82          }
     83          
     84          ////===================================================================
     85          int LSM6DS3_XL_GetMeasurements(LSM6DS3_IMU_measurements *data) 
     86          {
     87          uint8_t bytes[6] = {0};
     88          
     89          if(LSM6DS3_rd_reg(LSM6DS3_XL_GS_OUTX_L_XL, bytes, sizeof(bytes)) == LSM6DS3_OK) 
     90            {
     91            data->XL_x = (int16_t) (bytes[1]<<8 | bytes[0]);
     92            data->XL_y = (int16_t) (bytes[3]<<8 | bytes[2]);
     93            data->XL_z = (int16_t) (bytes[5]<<8 | bytes[4]);
     94            return LSM6DS3_OK;
     95            }
     96          return LSM6DS3_FAIL;
     97          }
     98          
     99          
    100          /*
    101           * @brief  Start the gyroscope with desired settings
    102           * @param  GS_Rate: Output data rate
    103           * 					- GS_12_5Hz
    104           * 					- GS_26Hz
    105           * 					- GS_52Hz
    106           * 					- GS_104Hz
    107           * 					- GS_208Hz
    108           * 					- GS_416Hz
    109           * 					- GS_833Hz
    110           * 					- GS_1666Hz
    111           *		   GS_Range: Scale selection
    112           *		   			- GS_RANGE_125dps
    113           *		   			- GS_RANGE_250dps
    114           *		   			- GS_RANGE_500dps
    115           *		   			- GS_RANGE_1000dps
    116           *		   			- GS_RANGE_2000dps
    117           * @retval enum LSM6DS3_Result:
    118           * 					- LSM6DS3_OK    		   = 0,  Success
    119           * 					- LSM6DS3_FAIL  		   = 1,  Failed due to HAL
    120           * 					- LSM6DS3_FAIL_PARAMETERS  = 2,  Failed due to wrong parameters
    121          */
    122          int LSM6DS3_GS_Start(uint8_t GS_Rate, uint8_t GS_Range) {
    123          	uint8_t byte = (GS_Rate << 4) | ((GS_Range << 1) & 0x0F);
    124          
    125          	byte &= 0xFE; /* Always secure the LSB is 0 */
    126          	if(LSM6DS3_Verify_GS_Settings(GS_Rate, GS_Range) !=  LSM6DS3_OK)
    127          		return LSM6DS3_FAIL_PARAMETERS;
    128          	if(LSM6DS3_wr_and_verify(LSM6DS3_XL_GS_CTRL2_G, &byte, sizeof(byte)) ==  LSM6DS3_OK)
    129          		return LSM6DS3_OK;
    130          	return LSM6DS3_FAIL;
    131          }
    132          
    133          /*
    134           * @brief  Disable the gyroscope
    135           * @param  None
    136           * @retval enum LSM6DS3_Result:
    137           * 					- LSM6DS3_OK    		   = 0,  Success
    138           * 					- LSM6DS3_FAIL  		   = 1,  Failed due to HAL
    139          */
    140          int LSM6DS3_GS_Stop(void) 
    141          {
    142          uint8_t byte = GS_POWER_DOWN;
    143          
    144          if(LSM6DS3_wr_and_verify(LSM6DS3_XL_GS_CTRL2_G, &byte, sizeof(byte)) ==  LSM6DS3_OK)
    145            return LSM6DS3_OK;
    146          return LSM6DS3_FAIL;
    147          }
    148          /*
    149           * @brief  Refresh the Gyroscope data
    150           * @param  None
    151           * @retval enum LSM6DS3_Result:
    152          * 					- LSM6DS3_OK    		   = 0,  Success
    153           * 					- LSM6DS3_FAIL  		   = 1,  Failed due to HAL
    154          */
    155          int LSM6DS3_GS_GetMeasurements(LSM6DS3_IMU_measurements *data) 
    156          {
    157          uint8_t bytes[6] = {0};
    158          
    159          if(LSM6DS3_rd_reg(LSM6DS3_XL_GS_OUTX_L_GS, bytes, sizeof(bytes)) == LSM6DS3_OK) 
    160            {
    161            data->GS_x = (int16_t) (bytes[1]<<8 | bytes[0]);
    162            data->GS_y = (int16_t) (bytes[3]<<8 | bytes[2]);
    163            data->GS_z = (int16_t) (bytes[5]<<8 | bytes[4]);
    164            return LSM6DS3_OK;
    165            }
    166          return LSM6DS3_FAIL;
    167          }
    168          
    169          /*
    170           * @brief  Refresh the IMU values
    171           * @param  None
    172           * @retval enum LSM6DS3_Result:
    173          * 					- LSM6DS3_OK    		   = 0,  Success
    174           * 					- LSM6DS3_FAIL  		   = 1,  Failed due to HAL
    175          */
    176          int LSM6DS3_IMU_GetMeasurements(LSM6DS3_IMU_measurements *data) 
    177          {
    178          uint8_t bytes[14] = {0};
    179          
    180          if(LSM6DS3_rd_reg(LSM6DS3_XL_GS_OUT_TEMP_L, bytes, sizeof(bytes)) == LSM6DS3_OK) 
    181            {
    182            data->Temperature = (int16_t) (bytes[1]<<8  | bytes[0]);
    183            data->GS_x 		 = (int16_t) (bytes[3]<<8  | bytes[2]);
    184            data->GS_y 		 = (int16_t) (bytes[5]<<8  | bytes[4]);
    185            data->GS_z 		 = (int16_t) (bytes[7]<<8  | bytes[6]);
    186            data->XL_x 		 = (int16_t) (bytes[9]<<8  | bytes[8]);
    187            data->XL_y 		 = (int16_t) (bytes[11]<<8 | bytes[10]);
    188            data->XL_z 		 = (int16_t) (bytes[13]<<8 | bytes[12]);
    189            return LSM6DS3_OK;
    190            }
    191          return LSM6DS3_FAIL;
    192          }
    193          
    194          uint8_t LSM6DS3_check_chng(LSM6DS3_IMU_measurements *data_a
    195                                     ,LSM6DS3_IMU_measurements *data_b)
    196          {
    197          uint8_t rez=0; 
    198          if(data_a->XL_x != data_b->XL_x)
    199            rez|=(0x1<<0);
    200          if(data_a->XL_y != data_b->XL_y)
    201            rez|=(0x1<<1);
    202          if(data_a->XL_z != data_b->XL_z)
    203            rez|=(0x1<<2);
    204          if(data_a->GS_x != data_b->GS_x)
    205            rez|=(0x1<<3);
    206          if(data_a->GS_y != data_b->GS_y)
    207            rez|=(0x1<<4);
    208          if(data_a->GS_z != data_b->GS_z)
    209            rez|=(0x1<<5);
    210          if(data_a->Temperature != data_b->Temperature)
    211            rez|=(0x1<<6);
    212          return rez;
    213          }
    214          #if 0
    215          /*
    216           * @brief  Get the value of X axe (Accelerometer)
    217           * @param  units: Select the units to be returned
    218           * 					- 0:  Selected units are g
    219           * 					- 1:  Selected units are mg
    220           * 					- >1: Invalid. Will return zero
    221           * @retval float: Value of X axe on g or mg
    222          */
    223          float LSM6DS3_GetXL_X_Float(uint8_t units) {
    224          	float mg_lsb = 0;
    225          	switch(LSM6DS3_parameters.XL_range)
    226          	{
    227          		case XL_RANGE_2G:
    228          			mg_lsb = 0.061f;
    229          			break;
    230          		case XL_RANGE_4G:
    231          			mg_lsb = 0.122f;
    232          			break;
    233          		case XL_RANGE_8G:
    234          			mg_lsb = 0.244f;
    235          			break;
    236          		case XL_RANGE_16G:
    237          			mg_lsb = 0.488f;
    238          			break;
    239          		default:
    240          			mg_lsb = 0.000f; /* Should never comes here */
    241          			break;
    242          	}
    243          	if(units == LSM6DS3_UNITS_G)
    244          		return (LSM6DS3_data.XL_x * mg_lsb / 1000.0f);
    245          	else
    246          		return (LSM6DS3_data.XL_x * mg_lsb);
    247          }
    248          
    249          /*
    250           * @brief  Get the value of Y axe (Accelerometer)
    251           * @param  units: Select the units to be returned
    252           * 					- 0:  Selected units are g
    253           * 					- 1:  Selected units are mg
    254           * 					- >1: Invalid. Will return zero
    255           * @retval float: Value of Y axe on g or mg
    256          */
    257          float LSM6DS3_GetXL_Y_Float(uint8_t units) {
    258          	float mg_lsb = 0;
    259          
    260          	switch(LSM6DS3_parameters.XL_range)
    261          	{
    262          		case XL_RANGE_2G:
    263          			mg_lsb = 0.061f;
    264          			break;
    265          		case XL_RANGE_4G:
    266          			mg_lsb = 0.122f;
    267          			break;
    268          		case XL_RANGE_8G:
    269          			mg_lsb = 0.244f;
    270          			break;
    271          		case XL_RANGE_16G:
    272          			mg_lsb = 0.488f;
    273          			break;
    274          		default:
    275          			mg_lsb = 0.000f; /* Should never comes here */
    276          			break;
    277          	}
    278          	if(units == LSM6DS3_UNITS_G)
    279          		return (LSM6DS3_data.XL_y * mg_lsb / 1000.0f);
    280          	else
    281          		return (LSM6DS3_data.XL_y * mg_lsb);
    282          }
    283          
    284          /*
    285           * @brief  Get the value of Z axe (Accelerometer)
    286           * @param  units: Select the units to be returned
    287           * 					- 0:  Selected units are g
    288           * 					- 1:  Selected units are mg
    289           * 					- >1: Invalid. Will return zero
    290           * @retval float: Value of Z axe on g or mg
    291          */
    292          float LSM6DS3_GetXL_Z_Float(uint8_t units) {
    293          	float mg_lsb = 0;
    294          
    295          	switch(LSM6DS3_parameters.XL_range)
    296          	{
    297          		case XL_RANGE_2G:
    298          			mg_lsb = 0.061f;
    299          			break;
    300          		case XL_RANGE_4G:
    301          			mg_lsb = 0.122f;
    302          			break;
    303          		case XL_RANGE_8G:
    304          			mg_lsb = 0.244f;
    305          			break;
    306          		case XL_RANGE_16G:
    307          			mg_lsb = 0.488f;
    308          			break;
    309          		default:
    310          			mg_lsb = 0.000f; /* Should never comes here */
    311          			break;
    312          	}
    313          	if(units == LSM6DS3_UNITS_G)
    314          		return (LSM6DS3_data.XL_z * mg_lsb / 1000.0f);
    315          	else
    316          		return (LSM6DS3_data.XL_z * mg_lsb);
    317          }
    318          
    319          /*
    320           * @brief  Get the raw data of X axe (Gyroscope)
    321           * @param  None
    322           * @retval int16_t: Raw data of X axe
    323          */
    324          int16_t LSM6DS3_GetGS_X_Int16(void) {
    325          	return LSM6DS3_data.GS_x;
    326          }
    327          
    328          /*
    329           * @brief  Get the raw data of Y axe (Gyroscope)
    330           * @param  None
    331           * @retval int16_t: Raw data of Y axe
    332          */
    333          int16_t LSM6DS3_GetGS_Y_Int16(void) {
    334          	return LSM6DS3_data.GS_y;
    335          }
    336          
    337          /*
    338           * @brief  Get the raw data of Z axe (Gyroscope)
    339           * @param  None
    340           * @retval int16_t: Raw data of Z axe
    341          */
    342          int16_t LSM6DS3_GetGS_Z_Int16(void) {
    343          	return LSM6DS3_data.GS_z;
    344          }
    345          
    346          /*
    347           * @brief  Get the raw data of temperature
    348           * @param  None
    349           * @retval int16_t: Raw data of temperature
    350          */
    351          int16_t LSM6DS3_Temperature_Int16(void) {
    352          	return LSM6DS3_data.Temperature;
    353          }
    354          
    355          /*
    356           * @brief  Get the temperature
    357           * @param  None
    358           * @retval float: Temperature in C (Celsius)
    359          */
    360          float LSM6DS3_Temperature_Celsius(void) {
    361          	return ((float)LSM6DS3_data.Temperature / 16.0f + 25.0f);
    362          }
    363          
    364          /*
    365           * @brief  Get the value of X axe (Gyroscope)
    366           * @param  units: Select the units to be returned
    367           * 					- 0: Selected units are dps
    368           * 					- 1: Selected units are mdps
    369           * 					- >1: Invalid. Will return zero
    370           * @retval float: Value of X axe on dps or mdps
    371          */
    372          float LSM6DS3_GetGS_X_Float(uint8_t units) {
    373          	float mdps_lsb = 0;
    374          
    375          	switch(LSM6DS3_parameters.GS_range)
    376          	{
    377          		case GS_RANGE_125dps:
    378          			mdps_lsb = 4.375f;
    379          			break;
    380          		case GS_RANGE_250dps:
    381          			mdps_lsb = 8.75f;
    382          			break;
    383          		case GS_RANGE_500dps:
    384          			mdps_lsb = 17.50f;
    385          			break;
    386          		case GS_RANGE_1000dps:
    387          			mdps_lsb = 35.0f;
    388          			break;
    389          		case GS_RANGE_2000dps:
    390          			mdps_lsb = 70.f;
    391          			break;
    392          		default:
    393          			mdps_lsb = 0.000f; /* Should never comes here */
    394          			break;
    395          	}
    396          	if(units == LSM6DS3_UNITS_G)
    397          		return (LSM6DS3_data.GS_x * mdps_lsb / 1000.0f);
    398          	else
    399          		return (LSM6DS3_data.GS_x * mdps_lsb);
    400          }
    401          
    402          /*
    403           * @brief  Get the value of Y axe (Gyroscope)
    404           * @param  units: Select the units to be returned
    405           * 					- 0: Selected units are dps
    406           * 					- 1: Selected units are mdps
    407           * 					- >1: Invalid. Will return zero
    408           * @retval float: Value of Y axe on dps or mdps
    409          */
    410          float LSM6DS3_GetGS_Y_Float(uint8_t units) {
    411          	float mdps_lsb = 0;
    412          
    413          	switch(LSM6DS3_parameters.GS_range)
    414          	{
    415          		case GS_RANGE_125dps:
    416          			mdps_lsb = 4.375f;
    417          			break;
    418          		case GS_RANGE_250dps:
    419          			mdps_lsb = 8.75f;
    420          			break;
    421          		case GS_RANGE_500dps:
    422          			mdps_lsb = 17.50f;
    423          			break;
    424          		case GS_RANGE_1000dps:
    425          			mdps_lsb = 35.0f;
    426          			break;
    427          		case GS_RANGE_2000dps:
    428          			mdps_lsb = 70.f;
    429          			break;
    430          		default:
    431          			mdps_lsb = 0.000f; /* Should never comes here */
    432          			break;
    433          	}
    434          	if(units == LSM6DS3_UNITS_G)
    435          		return (LSM6DS3_data.GS_y * mdps_lsb / 1000.0f);
    436          	else
    437          		return (LSM6DS3_data.GS_y * mdps_lsb);
    438          }
    439          
    440          /*
    441           * @brief  Get the value of Z axe (Gyroscope)
    442           * @param  units: Select the units to be returned
    443           * 					- 0: Selected units are dps
    444           * 					- 1: Selected units are mdps
    445           * 					- >1: Invalid. Will return zero
    446           * @retval float: Value of Z axe on dps or mdps
    447          */
    448          float LSM6DS3_GetGS_Z_Float(uint8_t units) {
    449          	float mdps_lsb = 0;
    450          
    451          	switch(LSM6DS3_parameters.GS_range)
    452          	{
    453          		case GS_RANGE_125dps:
    454          			mdps_lsb = 4.375f;
    455          			break;
    456          		case GS_RANGE_250dps:
    457          			mdps_lsb = 8.75f;
    458          			break;
    459          		case GS_RANGE_500dps:
    460          			mdps_lsb = 17.50f;
    461          			break;
    462          		case GS_RANGE_1000dps:
    463          			mdps_lsb = 35.0f;
    464          			break;
    465          		case GS_RANGE_2000dps:
    466          			mdps_lsb = 70.f;
    467          			break;
    468          		default:
    469          			mdps_lsb = 0.000f; /* Should never comes here */
    470          			break;
    471          	}
    472          	if(units == LSM6DS3_UNITS_G)
    473          		return (LSM6DS3_data.GS_z * mdps_lsb / 1000.0f);
    474          	else
    475          		return (LSM6DS3_data.GS_z * mdps_lsb);
    476          }
    477          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   LSM6DS3_Detect
        16   -> I2C_Mem_Read
      16   LSM6DS3_GS_GetMeasurements
        16   -> LSM6DS3_rd_reg
        16   -> memset
      16   LSM6DS3_GS_Start
        16   -> LSM6DS3_Verify_GS_Settings
        16   -> LSM6DS3_wr_and_verify
       8   LSM6DS3_GS_Stop
         8   -> LSM6DS3_wr_and_verify
      24   LSM6DS3_IMU_GetMeasurements
        24   -> LSM6DS3_rd_reg
        24   -> memset
       0   LSM6DS3_Verify_GS_Settings
       0   LSM6DS3_Verify_XL_Settings
      16   LSM6DS3_XL_GetMeasurements
        16   -> LSM6DS3_rd_reg
        16   -> memset
      24   LSM6DS3_XL_Start
        24   -> LSM6DS3_Verify_XL_Settings
        24   -> LSM6DS3_wr_and_verify
       8   LSM6DS3_XL_Stop
         8   -> LSM6DS3_wr_and_verify
       4   LSM6DS3_check_chng
      24   LSM6DS3_rd_reg
        24   -> I2C_Mem_Read
      64   LSM6DS3_wr_and_verify
        64   -> I2C_Mem_Read
        64   -> I2C_Memory_Write
        64   -> __aeabi_memcpy4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
      32  ?_0
      48  LSM6DS3_Detect
      80  LSM6DS3_GS_GetMeasurements
      78  LSM6DS3_GS_Start
      32  LSM6DS3_GS_Stop
     128  LSM6DS3_IMU_GetMeasurements
      58  LSM6DS3_Verify_GS_Settings
      56  LSM6DS3_Verify_XL_Settings
      78  LSM6DS3_XL_GetMeasurements
      78  LSM6DS3_XL_Start
      32  LSM6DS3_XL_Stop
     124  LSM6DS3_check_chng
      30  LSM6DS3_rd_reg
     154  LSM6DS3_wr_and_verify

 
  32 bytes in section .rodata
 984 bytes in section .text
 
 984 bytes of CODE  memory
  32 bytes of CONST memory

Errors: none
Warnings: none
