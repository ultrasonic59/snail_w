###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         20/Jun/2020  14:38:26
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\common\libraries\src\stm32f2xx_tim.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EW145D.tmp
#        (D:\proj\velograph\snail\stm32_snail\common\libraries\src\stm32f2xx_tim.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -lcN
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\.\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\..\common\libraries\inc\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_rtos\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_rtos\..\common\dbg\ -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\List\stm32f2xx_tim.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\Obj\stm32f2xx_tim.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\common\libraries\src\stm32f2xx_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_tim.c
      4            * @author  MCD Application Team
      5            * @version V1.1.2
      6            * @date    05-March-2012 
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the TIM peripheral:
      9            *            - TimeBase management
     10            *            - Output Compare management
     11            *            - Input Capture management
     12            *            - Advanced-control timers (TIM1 and TIM8) specific features  
     13            *            - Interrupts, DMA and flags management
     14            *            - Clocks management
     15            *            - Synchronization management
     16            *            - Specific interface management
     17            *            - Specific remapping management      
     18            *              
     19            *  @verbatim
     20            *  
     21            *          ===================================================================
     22            *                                 How to use this driver
     23            *          ===================================================================
     24            *          This driver provides functions to configure and program the TIM 
     25            *          of all STM32F2xx devices.
     26            *          These functions are split in 9 groups: 
     27            *   
     28            *          1. TIM TimeBase management: this group includes all needed functions 
     29            *             to configure the TM Timebase unit:
     30            *                   - Set/Get Prescaler
     31            *                   - Set/Get Autoreload  
     32            *                   - Counter modes configuration
     33            *                   - Set Clock division  
     34            *                   - Select the One Pulse mode
     35            *                   - Update Request Configuration
     36            *                   - Update Disable Configuration
     37            *                   - Auto-Preload Configuration 
     38            *                   - Enable/Disable the counter     
     39            *                 
     40            *          2. TIM Output Compare management: this group includes all needed 
     41            *             functions to configure the Capture/Compare unit used in Output 
     42            *             compare mode: 
     43            *                   - Configure each channel, independently, in Output Compare mode
     44            *                   - Select the output compare modes
     45            *                   - Select the Polarities of each channel
     46            *                   - Set/Get the Capture/Compare register values
     47            *                   - Select the Output Compare Fast mode 
     48            *                   - Select the Output Compare Forced mode  
     49            *                   - Output Compare-Preload Configuration 
     50            *                   - Clear Output Compare Reference
     51            *                   - Select the OCREF Clear signal
     52            *                   - Enable/Disable the Capture/Compare Channels    
     53            *                   
     54            *          3. TIM Input Capture management: this group includes all needed 
     55            *             functions to configure the Capture/Compare unit used in 
     56            *             Input Capture mode:
     57            *                   - Configure each channel in input capture mode
     58            *                   - Configure Channel1/2 in PWM Input mode
     59            *                   - Set the Input Capture Prescaler
     60            *                   - Get the Capture/Compare values      
     61            *                   
     62            *          4. Advanced-control timers (TIM1 and TIM8) specific features
     63            *                   - Configures the Break input, dead time, Lock level, the OSSI,
     64            *                      the OSSR State and the AOE(automatic output enable)
     65            *                   - Enable/Disable the TIM peripheral Main Outputs
     66            *                   - Select the Commutation event
     67            *                   - Set/Reset the Capture Compare Preload Control bit
     68            *                              
     69            *          5. TIM interrupts, DMA and flags management
     70            *                   - Enable/Disable interrupt sources
     71            *                   - Get flags status
     72            *                   - Clear flags/ Pending bits
     73            *                   - Enable/Disable DMA requests 
     74            *                   - Configure DMA burst mode
     75            *                   - Select CaptureCompare DMA request  
     76            *              
     77            *          6. TIM clocks management: this group includes all needed functions 
     78            *             to configure the clock controller unit:
     79            *                   - Select internal/External clock
     80            *                   - Select the external clock mode: ETR(Mode1/Mode2), TIx or ITRx
     81            *         
     82            *          7. TIM synchronization management: this group includes all needed 
     83            *             functions to configure the Synchronization unit:
     84            *                   - Select Input Trigger  
     85            *                   - Select Output Trigger  
     86            *                   - Select Master Slave Mode 
     87            *                   - ETR Configuration when used as external trigger   
     88            *     
     89            *          8. TIM specific interface management, this group includes all 
     90            *             needed functions to use the specific TIM interface:
     91            *                   - Encoder Interface Configuration
     92            *                   - Select Hall Sensor   
     93            *         
     94            *          9. TIM specific remapping management includes the Remapping 
     95            *             configuration of specific timers               
     96            *   
     97            *  @endverbatim
     98            *    
     99            ******************************************************************************
    100            * @attention
    101            *
    102            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
    103            *
    104            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    105            * You may not use this file except in compliance with the License.
    106            * You may obtain a copy of the License at:
    107            *
    108            *        http://www.st.com/software_license_agreement_liberty_v2
    109            *
    110            * Unless required by applicable law or agreed to in writing, software 
    111            * distributed under the License is distributed on an "AS IS" BASIS, 
    112            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    113            * See the License for the specific language governing permissions and
    114            * limitations under the License.
    115            *
    116            ******************************************************************************
    117            */
    118          
    119          /* Includes ------------------------------------------------------------------*/
    120          ////#include "stm32f2xx_tim.h"
    121          ////#include "stm32f2xx_rcc.h"
    122          #include "stm32f2xx_conf.h"
    123          
    124          /** @addtogroup STM32F2xx_StdPeriph_Driver
    125            * @{
    126            */
    127          
    128          /** @defgroup TIM 
    129            * @brief TIM driver modules
    130            * @{
    131            */
    132          
    133          /* Private typedef -----------------------------------------------------------*/
    134          /* Private define ------------------------------------------------------------*/
    135          
    136          /* ---------------------- TIM registers bit mask ------------------------ */
    137          #define SMCR_ETR_MASK      ((uint16_t)0x00FF) 
    138          #define CCMR_OFFSET        ((uint16_t)0x0018)
    139          #define CCER_CCE_SET       ((uint16_t)0x0001)  
    140          #define	CCER_CCNE_SET      ((uint16_t)0x0004) 
    141          #define CCMR_OC13M_MASK    ((uint16_t)0xFF8F)
    142          #define CCMR_OC24M_MASK    ((uint16_t)0x8FFF) 
    143          
    144          /* Private macro -------------------------------------------------------------*/
    145          /* Private variables ---------------------------------------------------------*/
    146          /* Private function prototypes -----------------------------------------------*/
    147          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    148                                 uint16_t TIM_ICFilter);
    149          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    150                                 uint16_t TIM_ICFilter);
    151          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    152                                 uint16_t TIM_ICFilter);
    153          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    154                                 uint16_t TIM_ICFilter);
    155          
    156          /* Private functions ---------------------------------------------------------*/
    157          
    158          /** @defgroup TIM_Private_Functions
    159            * @{
    160            */
    161          
    162          /** @defgroup TIM_Group1 TimeBase management functions
    163           *  @brief   TimeBase management functions 
    164           *
    165          @verbatim   
    166           ===============================================================================
    167                                 TimeBase management functions
    168           ===============================================================================  
    169            
    170                 ===================================================================      
    171                        TIM Driver: how to use it in Timing(Time base) Mode
    172                 =================================================================== 
    173                 To use the Timer in Timing(Time base) mode, the following steps are mandatory:
    174                 
    175                 1. Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) function
    176                              
    177                 2. Fill the TIM_TimeBaseInitStruct with the desired parameters.
    178                 
    179                 3. Call TIM_TimeBaseInit(TIMx, &TIM_TimeBaseInitStruct) to configure the Time Base unit
    180                    with the corresponding configuration
    181                    
    182                 4. Enable the NVIC if you need to generate the update interrupt. 
    183                    
    184                 5. Enable the corresponding interrupt using the function TIM_ITConfig(TIMx, TIM_IT_Update) 
    185                 
    186                 6. Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
    187                       
    188                 Note1: All other functions can be used separately to modify, if needed,
    189                    a specific feature of the Timer. 
    190          
    191          @endverbatim
    192            * @{
    193            */
    194            
    195          /**
    196            * @brief  Deinitializes the TIMx peripheral registers to their default reset values.
    197            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    198            * @retval None
    199          
    200            */
    201          void TIM_DeInit(TIM_TypeDef* TIMx)
    202          {
    203            /* Check the parameters */
    204            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    205           
    206            if (TIMx == TIM1)
    207            {
    208              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
    209              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
    210            } 
    211            else if (TIMx == TIM2) 
    212            {     
    213              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
    214              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
    215            }  
    216            else if (TIMx == TIM3)
    217            { 
    218              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
    219              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
    220            }  
    221            else if (TIMx == TIM4)
    222            { 
    223              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
    224              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
    225            }  
    226            else if (TIMx == TIM5)
    227            {      
    228              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
    229              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
    230            }  
    231            else if (TIMx == TIM6)  
    232            {    
    233              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
    234              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
    235            }  
    236            else if (TIMx == TIM7)
    237            {      
    238              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
    239              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
    240            }  
    241            else if (TIMx == TIM8)
    242            {      
    243              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
    244              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
    245            }  
    246            else if (TIMx == TIM9)
    247            {      
    248              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
    249              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
    250             }  
    251            else if (TIMx == TIM10)
    252            {      
    253              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
    254              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
    255            }  
    256            else if (TIMx == TIM11) 
    257            {     
    258              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
    259              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
    260            }  
    261            else if (TIMx == TIM12)
    262            {      
    263              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
    264              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
    265            }  
    266            else if (TIMx == TIM13) 
    267            {       
    268              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
    269              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
    270            }  
    271            else
    272            { 
    273              if (TIMx == TIM14) 
    274              {     
    275                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
    276                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    277              }   
    278            }
    279          }
    280          
    281          /**
    282            * @brief  Initializes the TIMx Time Base Unit peripheral according to 
    283            *         the specified parameters in the TIM_TimeBaseInitStruct.
    284            * @param  TIMx: where x can be  1 to 14 to select the TIM peripheral.
    285            * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure
    286            *         that contains the configuration information for the specified TIM peripheral.
    287            * @retval None
    288            */
    289          void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    290          {
    291            uint16_t tmpcr1 = 0;
    292          
    293            /* Check the parameters */
    294            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    295            assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
    296            assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
    297          
    298            tmpcr1 = TIMx->CR1;  
    299          
    300            if((TIMx == TIM1) || (TIMx == TIM8)||
    301               (TIMx == TIM2) || (TIMx == TIM3)||
    302               (TIMx == TIM4) || (TIMx == TIM5)) 
    303            {
    304              /* Select the Counter Mode */
    305              tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
    306              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
    307            }
    308           
    309            if((TIMx != TIM6) && (TIMx != TIM7))
    310            {
    311              /* Set the clock division */
    312              tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
    313              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
    314            }
    315          
    316            TIMx->CR1 = tmpcr1;
    317          
    318            /* Set the Autoreload value */
    319            TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
    320           
    321            /* Set the Prescaler value */
    322            TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
    323              
    324            if ((TIMx == TIM1) || (TIMx == TIM8))  
    325            {
    326              /* Set the Repetition Counter value */
    327              TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
    328            }
    329          
    330            /* Generate an update event to reload the Prescaler 
    331               and the repetition counter(only for TIM1 and TIM8) value immediatly */
    332            TIMx->EGR = TIM_PSCReloadMode_Immediate;          
    333          }
    334          
    335          /**
    336            * @brief  Fills each TIM_TimeBaseInitStruct member with its default value.
    337            * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
    338            *         structure which will be initialized.
    339            * @retval None
    340            */
    341          void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    342          {
    343            /* Set the default configuration */
    344            TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
    345            TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
    346            TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
    347            TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
    348            TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
    349          }
    350          
    351          /**
    352            * @brief  Configures the TIMx Prescaler.
    353            * @param  TIMx: where x can be  1 to 14 to select the TIM peripheral.
    354            * @param  Prescaler: specifies the Prescaler Register value
    355            * @param  TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
    356            *          This parameter can be one of the following values:
    357            *            @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
    358            *            @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediatly.
    359            * @retval None
    360            */
    361          void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
    362          {
    363            /* Check the parameters */
    364            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    365            assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
    366            /* Set the Prescaler value */
    367            TIMx->PSC = Prescaler;
    368            /* Set or reset the UG Bit */
    369            TIMx->EGR = TIM_PSCReloadMode;
    370          }
    371          
    372          /**
    373            * @brief  Specifies the TIMx Counter Mode to be used.
    374            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    375            * @param  TIM_CounterMode: specifies the Counter Mode to be used
    376            *          This parameter can be one of the following values:
    377            *            @arg TIM_CounterMode_Up: TIM Up Counting Mode
    378            *            @arg TIM_CounterMode_Down: TIM Down Counting Mode
    379            *            @arg TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
    380            *            @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
    381            *            @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
    382            * @retval None
    383            */
    384          void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
    385          {
    386            uint16_t tmpcr1 = 0;
    387          
    388            /* Check the parameters */
    389            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    390            assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
    391          
    392            tmpcr1 = TIMx->CR1;
    393          
    394            /* Reset the CMS and DIR Bits */
    395            tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
    396          
    397            /* Set the Counter Mode */
    398            tmpcr1 |= TIM_CounterMode;
    399          
    400            /* Write to TIMx CR1 register */
    401            TIMx->CR1 = tmpcr1;
    402          }
    403          
    404          /**
    405            * @brief  Sets the TIMx Counter Register value
    406            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    407            * @param  Counter: specifies the Counter register new value.
    408            * @retval None
    409            */
    410          void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
    411          {
    412            /* Check the parameters */
    413             assert_param(IS_TIM_ALL_PERIPH(TIMx));
    414          
    415            /* Set the Counter Register value */
    416            TIMx->CNT = Counter;
    417          }
    418          
    419          /**
    420            * @brief  Sets the TIMx Autoreload Register value
    421            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    422            * @param  Autoreload: specifies the Autoreload register new value.
    423            * @retval None
    424            */
    425          void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
    426          {
    427            /* Check the parameters */
    428            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    429            
    430            /* Set the Autoreload Register value */
    431            TIMx->ARR = Autoreload;
    432          }
    433          
    434          /**
    435            * @brief  Gets the TIMx Counter value.
    436            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    437            * @retval Counter Register value
    438            */
    439          uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
    440          {
    441            /* Check the parameters */
    442            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    443          
    444            /* Get the Counter Register value */
    445            return TIMx->CNT;
    446          }
    447          
    448          /**
    449            * @brief  Gets the TIMx Prescaler value.
    450            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    451            * @retval Prescaler Register value.
    452            */
    453          uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
    454          {
    455            /* Check the parameters */
    456            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    457          
    458            /* Get the Prescaler Register value */
    459            return TIMx->PSC;
    460          }
    461          
    462          /**
    463            * @brief  Enables or Disables the TIMx Update event.
    464            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    465            * @param  NewState: new state of the TIMx UDIS bit
    466            *          This parameter can be: ENABLE or DISABLE.
    467            * @retval None
    468            */
    469          void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
    470          {
    471            /* Check the parameters */
    472            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    473            assert_param(IS_FUNCTIONAL_STATE(NewState));
    474          
    475            if (NewState != DISABLE)
    476            {
    477              /* Set the Update Disable Bit */
    478              TIMx->CR1 |= TIM_CR1_UDIS;
    479            }
    480            else
    481            {
    482              /* Reset the Update Disable Bit */
    483              TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
    484            }
    485          }
    486          
    487          /**
    488            * @brief  Configures the TIMx Update Request Interrupt source.
    489            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    490            * @param  TIM_UpdateSource: specifies the Update source.
    491            *          This parameter can be one of the following values:
    492            *            @arg TIM_UpdateSource_Global: Source of update is the counter
    493            *                 overflow/underflow or the setting of UG bit, or an update
    494            *                 generation through the slave mode controller.
    495            *            @arg TIM_UpdateSource_Regular: Source of update is counter overflow/underflow.
    496            * @retval None
    497            */
    498          void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
    499          {
    500            /* Check the parameters */
    501            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    502            assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
    503          
    504            if (TIM_UpdateSource != TIM_UpdateSource_Global)
    505            {
    506              /* Set the URS Bit */
    507              TIMx->CR1 |= TIM_CR1_URS;
    508            }
    509            else
    510            {
    511              /* Reset the URS Bit */
    512              TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
    513            }
    514          }
    515          
    516          /**
    517            * @brief  Enables or disables TIMx peripheral Preload register on ARR.
    518            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    519            * @param  NewState: new state of the TIMx peripheral Preload register
    520            *          This parameter can be: ENABLE or DISABLE.
    521            * @retval None
    522            */
    523          void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
    524          {
    525            /* Check the parameters */
    526            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    527            assert_param(IS_FUNCTIONAL_STATE(NewState));
    528          
    529            if (NewState != DISABLE)
    530            {
    531              /* Set the ARR Preload Bit */
    532              TIMx->CR1 |= TIM_CR1_ARPE;
    533            }
    534            else
    535            {
    536              /* Reset the ARR Preload Bit */
    537              TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
    538            }
    539          }
    540          
    541          /**
    542            * @brief  Selects the TIMx's One Pulse Mode.
    543            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    544            * @param  TIM_OPMode: specifies the OPM Mode to be used.
    545            *          This parameter can be one of the following values:
    546            *            @arg TIM_OPMode_Single
    547            *            @arg TIM_OPMode_Repetitive
    548            * @retval None
    549            */
    550          void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
    551          {
    552            /* Check the parameters */
    553            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    554            assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
    555          
    556            /* Reset the OPM Bit */
    557            TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
    558          
    559            /* Configure the OPM Mode */
    560            TIMx->CR1 |= TIM_OPMode;
    561          }
    562          
    563          /**
    564            * @brief  Sets the TIMx Clock Division value.
    565            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
    566            * @param  TIM_CKD: specifies the clock division value.
    567            *          This parameter can be one of the following value:
    568            *            @arg TIM_CKD_DIV1: TDTS = Tck_tim
    569            *            @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim
    570            *            @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim
    571            * @retval None
    572            */
    573          void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
    574          {
    575            /* Check the parameters */
    576            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
    577            assert_param(IS_TIM_CKD_DIV(TIM_CKD));
    578          
    579            /* Reset the CKD Bits */
    580            TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
    581          
    582            /* Set the CKD value */
    583            TIMx->CR1 |= TIM_CKD;
    584          }
    585          
    586          /**
    587            * @brief  Enables or disables the specified TIM peripheral.
    588            * @param  TIMx: where x can be 1 to 14 to select the TIMx peripheral.
    589            * @param  NewState: new state of the TIMx peripheral.
    590            *          This parameter can be: ENABLE or DISABLE.
    591            * @retval None
    592            */
    593          void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
    594          {
    595            /* Check the parameters */
    596            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    597            assert_param(IS_FUNCTIONAL_STATE(NewState));
    598            
    599            if (NewState != DISABLE)
    600            {
    601              /* Enable the TIM Counter */
    602              TIMx->CR1 |= TIM_CR1_CEN;
    603            }
    604            else
    605            {
    606              /* Disable the TIM Counter */
    607              TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
    608            }
    609          }
    610          /**
    611            * @}
    612            */
    613          
    614          /** @defgroup TIM_Group2 Output Compare management functions
    615           *  @brief    Output Compare management functions 
    616           *
    617          @verbatim   
    618           ===============================================================================
    619                                  Output Compare management functions
    620           ===============================================================================  
    621             
    622                 ===================================================================      
    623                        TIM Driver: how to use it in Output Compare Mode
    624                 =================================================================== 
    625                 To use the Timer in Output Compare mode, the following steps are mandatory:
    626                 
    627                 1. Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) function
    628                 
    629                 2. Configure the TIM pins by configuring the corresponding GPIO pins
    630                 
    631                 2. Configure the Time base unit as described in the first part of this driver, 
    632                    if needed, else the Timer will run with the default configuration:
    633                    - Autoreload value = 0xFFFF
    634                    - Prescaler value = 0x0000
    635                    - Counter mode = Up counting
    636                    - Clock Division = TIM_CKD_DIV1
    637                    
    638                 3. Fill the TIM_OCInitStruct with the desired parameters including:
    639                    - The TIM Output Compare mode: TIM_OCMode
    640                    - TIM Output State: TIM_OutputState
    641                    - TIM Pulse value: TIM_Pulse
    642                    - TIM Output Compare Polarity : TIM_OCPolarity
    643                 
    644                 4. Call TIM_OCxInit(TIMx, &TIM_OCInitStruct) to configure the desired channel with the 
    645                    corresponding configuration
    646                 
    647                 5. Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
    648                 
    649                 Note1: All other functions can be used separately to modify, if needed,
    650                        a specific feature of the Timer. 
    651                    
    652                 Note2: In case of PWM mode, this function is mandatory:
    653                        TIM_OCxPreloadConfig(TIMx, TIM_OCPreload_ENABLE); 
    654                        
    655                 Note3: If the corresponding interrupt or DMA request are needed, the user should:
    656                          1. Enable the NVIC (or the DMA) to use the TIM interrupts (or DMA requests). 
    657                          2. Enable the corresponding interrupt (or DMA request) using the function 
    658                             TIM_ITConfig(TIMx, TIM_IT_CCx) (or TIM_DMA_Cmd(TIMx, TIM_DMA_CCx))   
    659          
    660          @endverbatim
    661            * @{
    662            */
    663          
    664          /**
    665            * @brief  Initializes the TIMx Channel1 according to the specified parameters in
    666            *         the TIM_OCInitStruct.
    667            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
    668            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    669            *         the configuration information for the specified TIM peripheral.
    670            * @retval None
    671            */
    672          void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    673          {
    674            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    675             
    676            /* Check the parameters */
    677            assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
    678            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    679            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    680            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    681          
    682            /* Disable the Channel 1: Reset the CC1E Bit */
    683            TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
    684            
    685            /* Get the TIMx CCER register value */
    686            tmpccer = TIMx->CCER;
    687            /* Get the TIMx CR2 register value */
    688            tmpcr2 =  TIMx->CR2;
    689            
    690            /* Get the TIMx CCMR1 register value */
    691            tmpccmrx = TIMx->CCMR1;
    692              
    693            /* Reset the Output Compare Mode Bits */
    694            tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
    695            tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
    696            /* Select the Output Compare Mode */
    697            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    698            
    699            /* Reset the Output Polarity level */
    700            tmpccer &= (uint16_t)~TIM_CCER_CC1P;
    701            /* Set the Output Compare Polarity */
    702            tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
    703            
    704            /* Set the Output State */
    705            tmpccer |= TIM_OCInitStruct->TIM_OutputState;
    706              
    707            if((TIMx == TIM1) || (TIMx == TIM8))
    708            {
    709              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    710              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    711              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    712              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    713              
    714              /* Reset the Output N Polarity level */
    715              tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
    716              /* Set the Output N Polarity */
    717              tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
    718              /* Reset the Output N State */
    719              tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
    720              
    721              /* Set the Output N State */
    722              tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
    723              /* Reset the Output Compare and Output Compare N IDLE State */
    724              tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
    725              tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
    726              /* Set the Output Idle state */
    727              tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
    728              /* Set the Output N Idle state */
    729              tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
    730            }
    731            /* Write to TIMx CR2 */
    732            TIMx->CR2 = tmpcr2;
    733            
    734            /* Write to TIMx CCMR1 */
    735            TIMx->CCMR1 = tmpccmrx;
    736            
    737            /* Set the Capture Compare Register value */
    738            TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
    739            
    740            /* Write to TIMx CCER */
    741            TIMx->CCER = tmpccer;
    742          }
    743          
    744          /**
    745            * @brief  Initializes the TIMx Channel2 according to the specified parameters 
    746            *         in the TIM_OCInitStruct.
    747            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
    748            *         peripheral.
    749            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    750            *         the configuration information for the specified TIM peripheral.
    751            * @retval None
    752            */
    753          void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    754          {
    755            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    756             
    757            /* Check the parameters */
    758            assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
    759            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    760            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    761            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    762          
    763            /* Disable the Channel 2: Reset the CC2E Bit */
    764            TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
    765            
    766            /* Get the TIMx CCER register value */  
    767            tmpccer = TIMx->CCER;
    768            /* Get the TIMx CR2 register value */
    769            tmpcr2 =  TIMx->CR2;
    770            
    771            /* Get the TIMx CCMR1 register value */
    772            tmpccmrx = TIMx->CCMR1;
    773              
    774            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    775            tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
    776            tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
    777            
    778            /* Select the Output Compare Mode */
    779            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
    780            
    781            /* Reset the Output Polarity level */
    782            tmpccer &= (uint16_t)~TIM_CCER_CC2P;
    783            /* Set the Output Compare Polarity */
    784            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
    785            
    786            /* Set the Output State */
    787            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
    788              
    789            if((TIMx == TIM1) || (TIMx == TIM8))
    790            {
    791              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    792              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    793              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    794              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    795              
    796              /* Reset the Output N Polarity level */
    797              tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
    798              /* Set the Output N Polarity */
    799              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
    800              /* Reset the Output N State */
    801              tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
    802              
    803              /* Set the Output N State */
    804              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
    805              /* Reset the Output Compare and Output Compare N IDLE State */
    806              tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
    807              tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
    808              /* Set the Output Idle state */
    809              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
    810              /* Set the Output N Idle state */
    811              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
    812            }
    813            /* Write to TIMx CR2 */
    814            TIMx->CR2 = tmpcr2;
    815            
    816            /* Write to TIMx CCMR1 */
    817            TIMx->CCMR1 = tmpccmrx;
    818            
    819            /* Set the Capture Compare Register value */
    820            TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
    821            
    822            /* Write to TIMx CCER */
    823            TIMx->CCER = tmpccer;
    824          }
    825          
    826          /**
    827            * @brief  Initializes the TIMx Channel3 according to the specified parameters
    828            *         in the TIM_OCInitStruct.
    829            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    830            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    831            *         the configuration information for the specified TIM peripheral.
    832            * @retval None
    833            */
    834          void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    835          {
    836            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    837             
    838            /* Check the parameters */
    839            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
    840            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    841            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    842            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    843          
    844            /* Disable the Channel 3: Reset the CC2E Bit */
    845            TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
    846            
    847            /* Get the TIMx CCER register value */
    848            tmpccer = TIMx->CCER;
    849            /* Get the TIMx CR2 register value */
    850            tmpcr2 =  TIMx->CR2;
    851            
    852            /* Get the TIMx CCMR2 register value */
    853            tmpccmrx = TIMx->CCMR2;
    854              
    855            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    856            tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
    857            tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
    858            /* Select the Output Compare Mode */
    859            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    860            
    861            /* Reset the Output Polarity level */
    862            tmpccer &= (uint16_t)~TIM_CCER_CC3P;
    863            /* Set the Output Compare Polarity */
    864            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
    865            
    866            /* Set the Output State */
    867            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
    868              
    869            if((TIMx == TIM1) || (TIMx == TIM8))
    870            {
    871              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    872              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    873              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    874              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    875              
    876              /* Reset the Output N Polarity level */
    877              tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
    878              /* Set the Output N Polarity */
    879              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
    880              /* Reset the Output N State */
    881              tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
    882              
    883              /* Set the Output N State */
    884              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
    885              /* Reset the Output Compare and Output Compare N IDLE State */
    886              tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
    887              tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
    888              /* Set the Output Idle state */
    889              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
    890              /* Set the Output N Idle state */
    891              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
    892            }
    893            /* Write to TIMx CR2 */
    894            TIMx->CR2 = tmpcr2;
    895            
    896            /* Write to TIMx CCMR2 */
    897            TIMx->CCMR2 = tmpccmrx;
    898            
    899            /* Set the Capture Compare Register value */
    900            TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
    901            
    902            /* Write to TIMx CCER */
    903            TIMx->CCER = tmpccer;
    904          }
    905          
    906          /**
    907            * @brief  Initializes the TIMx Channel4 according to the specified parameters
    908            *         in the TIM_OCInitStruct.
    909            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    910            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    911            *         the configuration information for the specified TIM peripheral.
    912            * @retval None
    913            */
    914          void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    915          {
    916            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    917             
    918            /* Check the parameters */
    919            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
    920            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    921            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    922            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    923          
    924            /* Disable the Channel 4: Reset the CC4E Bit */
    925            TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
    926            
    927            /* Get the TIMx CCER register value */
    928            tmpccer = TIMx->CCER;
    929            /* Get the TIMx CR2 register value */
    930            tmpcr2 =  TIMx->CR2;
    931            
    932            /* Get the TIMx CCMR2 register value */
    933            tmpccmrx = TIMx->CCMR2;
    934              
    935            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    936            tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
    937            tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
    938            
    939            /* Select the Output Compare Mode */
    940            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
    941            
    942            /* Reset the Output Polarity level */
    943            tmpccer &= (uint16_t)~TIM_CCER_CC4P;
    944            /* Set the Output Compare Polarity */
    945            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
    946            
    947            /* Set the Output State */
    948            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
    949            
    950            if((TIMx == TIM1) || (TIMx == TIM8))
    951            {
    952              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    953              /* Reset the Output Compare IDLE State */
    954              tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
    955              /* Set the Output Idle state */
    956              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
    957            }
    958            /* Write to TIMx CR2 */
    959            TIMx->CR2 = tmpcr2;
    960            
    961            /* Write to TIMx CCMR2 */  
    962            TIMx->CCMR2 = tmpccmrx;
    963              
    964            /* Set the Capture Compare Register value */
    965            TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
    966            
    967            /* Write to TIMx CCER */
    968            TIMx->CCER = tmpccer;
    969          }
    970          
    971          /**
    972            * @brief  Fills each TIM_OCInitStruct member with its default value.
    973            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure which will
    974            *         be initialized.
    975            * @retval None
    976            */
    977          void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
    978          {
    979            /* Set the default configuration */
    980            TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
    981            TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
    982            TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
    983            TIM_OCInitStruct->TIM_Pulse = 0x00000000;
    984            TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
    985            TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
    986            TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
    987            TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
    988          }
    989          
    990          /**
    991            * @brief  Selects the TIM Output Compare Mode.
    992            * @note   This function disables the selected channel before changing the Output
    993            *         Compare Mode. If needed, user has to enable this channel using
    994            *         TIM_CCxCmd() and TIM_CCxNCmd() functions.
    995            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
    996            * @param  TIM_Channel: specifies the TIM Channel
    997            *          This parameter can be one of the following values:
    998            *            @arg TIM_Channel_1: TIM Channel 1
    999            *            @arg TIM_Channel_2: TIM Channel 2
   1000            *            @arg TIM_Channel_3: TIM Channel 3
   1001            *            @arg TIM_Channel_4: TIM Channel 4
   1002            * @param  TIM_OCMode: specifies the TIM Output Compare Mode.
   1003            *           This parameter can be one of the following values:
   1004            *            @arg TIM_OCMode_Timing
   1005            *            @arg TIM_OCMode_Active
   1006            *            @arg TIM_OCMode_Toggle
   1007            *            @arg TIM_OCMode_PWM1
   1008            *            @arg TIM_OCMode_PWM2
   1009            *            @arg TIM_ForcedAction_Active
   1010            *            @arg TIM_ForcedAction_InActive
   1011            * @retval None
   1012            */
   1013          void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
   1014          {
   1015            uint32_t tmp = 0;
   1016            uint16_t tmp1 = 0;
   1017          
   1018            /* Check the parameters */
   1019            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1020            assert_param(IS_TIM_CHANNEL(TIM_Channel));
   1021            assert_param(IS_TIM_OCM(TIM_OCMode));
   1022          
   1023            tmp = (uint32_t) TIMx;
   1024            tmp += CCMR_OFFSET;
   1025          
   1026            tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
   1027          
   1028            /* Disable the Channel: Reset the CCxE Bit */
   1029            TIMx->CCER &= (uint16_t) ~tmp1;
   1030          
   1031            if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
   1032            {
   1033              tmp += (TIM_Channel>>1);
   1034          
   1035              /* Reset the OCxM bits in the CCMRx register */
   1036              *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
   1037             
   1038              /* Configure the OCxM bits in the CCMRx register */
   1039              *(__IO uint32_t *) tmp |= TIM_OCMode;
   1040            }
   1041            else
   1042            {
   1043              tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
   1044          
   1045              /* Reset the OCxM bits in the CCMRx register */
   1046              *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
   1047              
   1048              /* Configure the OCxM bits in the CCMRx register */
   1049              *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
   1050            }
   1051          }
   1052          
   1053          /**
   1054            * @brief  Sets the TIMx Capture Compare1 Register value
   1055            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1056            * @param  Compare1: specifies the Capture Compare1 register new value.
   1057            * @retval None
   1058            */
   1059          void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
   1060          {
   1061            /* Check the parameters */
   1062            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1063          
   1064            /* Set the Capture Compare1 Register value */
   1065            TIMx->CCR1 = Compare1;
   1066          }
   1067          
   1068          /**
   1069            * @brief  Sets the TIMx Capture Compare2 Register value
   1070            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1071            *         peripheral.
   1072            * @param  Compare2: specifies the Capture Compare2 register new value.
   1073            * @retval None
   1074            */
   1075          void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
   1076          {
   1077            /* Check the parameters */
   1078            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1079          
   1080            /* Set the Capture Compare2 Register value */
   1081            TIMx->CCR2 = Compare2;
   1082          }
   1083          
   1084          /**
   1085            * @brief  Sets the TIMx Capture Compare3 Register value
   1086            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1087            * @param  Compare3: specifies the Capture Compare3 register new value.
   1088            * @retval None
   1089            */
   1090          void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
   1091          {
   1092            /* Check the parameters */
   1093            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1094          
   1095            /* Set the Capture Compare3 Register value */
   1096            TIMx->CCR3 = Compare3;
   1097          }
   1098          
   1099          /**
   1100            * @brief  Sets the TIMx Capture Compare4 Register value
   1101            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1102            * @param  Compare4: specifies the Capture Compare4 register new value.
   1103            * @retval None
   1104            */
   1105          void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
   1106          {
   1107            /* Check the parameters */
   1108            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1109          
   1110            /* Set the Capture Compare4 Register value */
   1111            TIMx->CCR4 = Compare4;
   1112          }
   1113          
   1114          /**
   1115            * @brief  Forces the TIMx output 1 waveform to active or inactive level.
   1116            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1117            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1118            *          This parameter can be one of the following values:
   1119            *            @arg TIM_ForcedAction_Active: Force active level on OC1REF
   1120            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
   1121            * @retval None
   1122            */
   1123          void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1124          {
   1125            uint16_t tmpccmr1 = 0;
   1126          
   1127            /* Check the parameters */
   1128            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1129            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1130            tmpccmr1 = TIMx->CCMR1;
   1131          
   1132            /* Reset the OC1M Bits */
   1133            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
   1134          
   1135            /* Configure The Forced output Mode */
   1136            tmpccmr1 |= TIM_ForcedAction;
   1137          
   1138            /* Write to TIMx CCMR1 register */
   1139            TIMx->CCMR1 = tmpccmr1;
   1140          }
   1141          
   1142          /**
   1143            * @brief  Forces the TIMx output 2 waveform to active or inactive level.
   1144            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1145            *         peripheral.
   1146            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1147            *          This parameter can be one of the following values:
   1148            *            @arg TIM_ForcedAction_Active: Force active level on OC2REF
   1149            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
   1150            * @retval None
   1151            */
   1152          void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1153          {
   1154            uint16_t tmpccmr1 = 0;
   1155          
   1156            /* Check the parameters */
   1157            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1158            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1159            tmpccmr1 = TIMx->CCMR1;
   1160          
   1161            /* Reset the OC2M Bits */
   1162            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
   1163          
   1164            /* Configure The Forced output Mode */
   1165            tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
   1166          
   1167            /* Write to TIMx CCMR1 register */
   1168            TIMx->CCMR1 = tmpccmr1;
   1169          }
   1170          
   1171          /**
   1172            * @brief  Forces the TIMx output 3 waveform to active or inactive level.
   1173            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1174            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1175            *          This parameter can be one of the following values:
   1176            *            @arg TIM_ForcedAction_Active: Force active level on OC3REF
   1177            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
   1178            * @retval None
   1179            */
   1180          void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1181          {
   1182            uint16_t tmpccmr2 = 0;
   1183          
   1184            /* Check the parameters */
   1185            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1186            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1187          
   1188            tmpccmr2 = TIMx->CCMR2;
   1189          
   1190            /* Reset the OC1M Bits */
   1191            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
   1192          
   1193            /* Configure The Forced output Mode */
   1194            tmpccmr2 |= TIM_ForcedAction;
   1195          
   1196            /* Write to TIMx CCMR2 register */
   1197            TIMx->CCMR2 = tmpccmr2;
   1198          }
   1199          
   1200          /**
   1201            * @brief  Forces the TIMx output 4 waveform to active or inactive level.
   1202            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1203            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1204            *          This parameter can be one of the following values:
   1205            *            @arg TIM_ForcedAction_Active: Force active level on OC4REF
   1206            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
   1207            * @retval None
   1208            */
   1209          void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1210          {
   1211            uint16_t tmpccmr2 = 0;
   1212          
   1213            /* Check the parameters */
   1214            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1215            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1216            tmpccmr2 = TIMx->CCMR2;
   1217          
   1218            /* Reset the OC2M Bits */
   1219            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
   1220          
   1221            /* Configure The Forced output Mode */
   1222            tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
   1223          
   1224            /* Write to TIMx CCMR2 register */
   1225            TIMx->CCMR2 = tmpccmr2;
   1226          }
   1227          
   1228          /**
   1229            * @brief  Enables or disables the TIMx peripheral Preload register on CCR1.
   1230            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1231            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1232            *          This parameter can be one of the following values:
   1233            *            @arg TIM_OCPreload_Enable
   1234            *            @arg TIM_OCPreload_Disable
   1235            * @retval None
   1236            */
   1237          void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1238          {
   1239            uint16_t tmpccmr1 = 0;
   1240          
   1241            /* Check the parameters */
   1242            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1243            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1244          
   1245            tmpccmr1 = TIMx->CCMR1;
   1246          
   1247            /* Reset the OC1PE Bit */
   1248            tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
   1249          
   1250            /* Enable or Disable the Output Compare Preload feature */
   1251            tmpccmr1 |= TIM_OCPreload;
   1252          
   1253            /* Write to TIMx CCMR1 register */
   1254            TIMx->CCMR1 = tmpccmr1;
   1255          }
   1256          
   1257          /**
   1258            * @brief  Enables or disables the TIMx peripheral Preload register on CCR2.
   1259            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1260            *         peripheral.
   1261            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1262            *          This parameter can be one of the following values:
   1263            *            @arg TIM_OCPreload_Enable
   1264            *            @arg TIM_OCPreload_Disable
   1265            * @retval None
   1266            */
   1267          void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1268          {
   1269            uint16_t tmpccmr1 = 0;
   1270          
   1271            /* Check the parameters */
   1272            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1273            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1274          
   1275            tmpccmr1 = TIMx->CCMR1;
   1276          
   1277            /* Reset the OC2PE Bit */
   1278            tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
   1279          
   1280            /* Enable or Disable the Output Compare Preload feature */
   1281            tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
   1282          
   1283            /* Write to TIMx CCMR1 register */
   1284            TIMx->CCMR1 = tmpccmr1;
   1285          }
   1286          
   1287          /**
   1288            * @brief  Enables or disables the TIMx peripheral Preload register on CCR3.
   1289            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1290            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1291            *          This parameter can be one of the following values:
   1292            *            @arg TIM_OCPreload_Enable
   1293            *            @arg TIM_OCPreload_Disable
   1294            * @retval None
   1295            */
   1296          void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1297          {
   1298            uint16_t tmpccmr2 = 0;
   1299          
   1300            /* Check the parameters */
   1301            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1302            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1303          
   1304            tmpccmr2 = TIMx->CCMR2;
   1305          
   1306            /* Reset the OC3PE Bit */
   1307            tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
   1308          
   1309            /* Enable or Disable the Output Compare Preload feature */
   1310            tmpccmr2 |= TIM_OCPreload;
   1311          
   1312            /* Write to TIMx CCMR2 register */
   1313            TIMx->CCMR2 = tmpccmr2;
   1314          }
   1315          
   1316          /**
   1317            * @brief  Enables or disables the TIMx peripheral Preload register on CCR4.
   1318            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1319            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1320            *          This parameter can be one of the following values:
   1321            *            @arg TIM_OCPreload_Enable
   1322            *            @arg TIM_OCPreload_Disable
   1323            * @retval None
   1324            */
   1325          void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1326          {
   1327            uint16_t tmpccmr2 = 0;
   1328          
   1329            /* Check the parameters */
   1330            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1331            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1332          
   1333            tmpccmr2 = TIMx->CCMR2;
   1334          
   1335            /* Reset the OC4PE Bit */
   1336            tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
   1337          
   1338            /* Enable or Disable the Output Compare Preload feature */
   1339            tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
   1340          
   1341            /* Write to TIMx CCMR2 register */
   1342            TIMx->CCMR2 = tmpccmr2;
   1343          }
   1344          
   1345          /**
   1346            * @brief  Configures the TIMx Output Compare 1 Fast feature.
   1347            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1348            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1349            *          This parameter can be one of the following values:
   1350            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1351            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1352            * @retval None
   1353            */
   1354          void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1355          {
   1356            uint16_t tmpccmr1 = 0;
   1357          
   1358            /* Check the parameters */
   1359            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1360            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1361          
   1362            /* Get the TIMx CCMR1 register value */
   1363            tmpccmr1 = TIMx->CCMR1;
   1364          
   1365            /* Reset the OC1FE Bit */
   1366            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
   1367          
   1368            /* Enable or Disable the Output Compare Fast Bit */
   1369            tmpccmr1 |= TIM_OCFast;
   1370          
   1371            /* Write to TIMx CCMR1 */
   1372            TIMx->CCMR1 = tmpccmr1;
   1373          }
   1374          
   1375          /**
   1376            * @brief  Configures the TIMx Output Compare 2 Fast feature.
   1377            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1378            *         peripheral.
   1379            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1380            *          This parameter can be one of the following values:
   1381            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1382            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1383            * @retval None
   1384            */
   1385          void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1386          {
   1387            uint16_t tmpccmr1 = 0;
   1388          
   1389            /* Check the parameters */
   1390            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1391            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1392          
   1393            /* Get the TIMx CCMR1 register value */
   1394            tmpccmr1 = TIMx->CCMR1;
   1395          
   1396            /* Reset the OC2FE Bit */
   1397            tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
   1398          
   1399            /* Enable or Disable the Output Compare Fast Bit */
   1400            tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
   1401          
   1402            /* Write to TIMx CCMR1 */
   1403            TIMx->CCMR1 = tmpccmr1;
   1404          }
   1405          
   1406          /**
   1407            * @brief  Configures the TIMx Output Compare 3 Fast feature.
   1408            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1409            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1410            *          This parameter can be one of the following values:
   1411            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1412            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1413            * @retval None
   1414            */
   1415          void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1416          {
   1417            uint16_t tmpccmr2 = 0;
   1418            
   1419            /* Check the parameters */
   1420            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1421            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1422          
   1423            /* Get the TIMx CCMR2 register value */
   1424            tmpccmr2 = TIMx->CCMR2;
   1425          
   1426            /* Reset the OC3FE Bit */
   1427            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
   1428          
   1429            /* Enable or Disable the Output Compare Fast Bit */
   1430            tmpccmr2 |= TIM_OCFast;
   1431          
   1432            /* Write to TIMx CCMR2 */
   1433            TIMx->CCMR2 = tmpccmr2;
   1434          }
   1435          
   1436          /**
   1437            * @brief  Configures the TIMx Output Compare 4 Fast feature.
   1438            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1439            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1440            *          This parameter can be one of the following values:
   1441            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1442            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1443            * @retval None
   1444            */
   1445          void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1446          {
   1447            uint16_t tmpccmr2 = 0;
   1448          
   1449            /* Check the parameters */
   1450            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1451            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1452          
   1453            /* Get the TIMx CCMR2 register value */
   1454            tmpccmr2 = TIMx->CCMR2;
   1455          
   1456            /* Reset the OC4FE Bit */
   1457            tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
   1458          
   1459            /* Enable or Disable the Output Compare Fast Bit */
   1460            tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
   1461          
   1462            /* Write to TIMx CCMR2 */
   1463            TIMx->CCMR2 = tmpccmr2;
   1464          }
   1465          
   1466          /**
   1467            * @brief  Clears or safeguards the OCREF1 signal on an external event
   1468            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1469            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1470            *          This parameter can be one of the following values:
   1471            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1472            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1473            * @retval None
   1474            */
   1475          void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1476          {
   1477            uint16_t tmpccmr1 = 0;
   1478          
   1479            /* Check the parameters */
   1480            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1481            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1482          
   1483            tmpccmr1 = TIMx->CCMR1;
   1484          
   1485            /* Reset the OC1CE Bit */
   1486            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
   1487          
   1488            /* Enable or Disable the Output Compare Clear Bit */
   1489            tmpccmr1 |= TIM_OCClear;
   1490          
   1491            /* Write to TIMx CCMR1 register */
   1492            TIMx->CCMR1 = tmpccmr1;
   1493          }
   1494          
   1495          /**
   1496            * @brief  Clears or safeguards the OCREF2 signal on an external event
   1497            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1498            *         peripheral.
   1499            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1500            *          This parameter can be one of the following values:
   1501            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1502            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1503            * @retval None
   1504            */
   1505          void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1506          {
   1507            uint16_t tmpccmr1 = 0;
   1508          
   1509            /* Check the parameters */
   1510            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1511            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1512          
   1513            tmpccmr1 = TIMx->CCMR1;
   1514          
   1515            /* Reset the OC2CE Bit */
   1516            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
   1517          
   1518            /* Enable or Disable the Output Compare Clear Bit */
   1519            tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
   1520          
   1521            /* Write to TIMx CCMR1 register */
   1522            TIMx->CCMR1 = tmpccmr1;
   1523          }
   1524          
   1525          /**
   1526            * @brief  Clears or safeguards the OCREF3 signal on an external event
   1527            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1528            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1529            *          This parameter can be one of the following values:
   1530            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1531            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1532            * @retval None
   1533            */
   1534          void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1535          {
   1536            uint16_t tmpccmr2 = 0;
   1537          
   1538            /* Check the parameters */
   1539            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1540            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1541          
   1542            tmpccmr2 = TIMx->CCMR2;
   1543          
   1544            /* Reset the OC3CE Bit */
   1545            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
   1546          
   1547            /* Enable or Disable the Output Compare Clear Bit */
   1548            tmpccmr2 |= TIM_OCClear;
   1549          
   1550            /* Write to TIMx CCMR2 register */
   1551            TIMx->CCMR2 = tmpccmr2;
   1552          }
   1553          
   1554          /**
   1555            * @brief  Clears or safeguards the OCREF4 signal on an external event
   1556            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1557            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1558            *          This parameter can be one of the following values:
   1559            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1560            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1561            * @retval None
   1562            */
   1563          void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1564          {
   1565            uint16_t tmpccmr2 = 0;
   1566          
   1567            /* Check the parameters */
   1568            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1569            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1570          
   1571            tmpccmr2 = TIMx->CCMR2;
   1572          
   1573            /* Reset the OC4CE Bit */
   1574            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
   1575          
   1576            /* Enable or Disable the Output Compare Clear Bit */
   1577            tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
   1578          
   1579            /* Write to TIMx CCMR2 register */
   1580            TIMx->CCMR2 = tmpccmr2;
   1581          }
   1582          
   1583          /**
   1584            * @brief  Configures the TIMx channel 1 polarity.
   1585            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1586            * @param  TIM_OCPolarity: specifies the OC1 Polarity
   1587            *          This parameter can be one of the following values:
   1588            *            @arg TIM_OCPolarity_High: Output Compare active high
   1589            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1590            * @retval None
   1591            */
   1592          void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1593          {
   1594            uint16_t tmpccer = 0;
   1595          
   1596            /* Check the parameters */
   1597            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1598            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1599          
   1600            tmpccer = TIMx->CCER;
   1601          
   1602            /* Set or Reset the CC1P Bit */
   1603            tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
   1604            tmpccer |= TIM_OCPolarity;
   1605          
   1606            /* Write to TIMx CCER register */
   1607            TIMx->CCER = tmpccer;
   1608          }
   1609          
   1610          /**
   1611            * @brief  Configures the TIMx Channel 1N polarity.
   1612            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1613            * @param  TIM_OCNPolarity: specifies the OC1N Polarity
   1614            *          This parameter can be one of the following values:
   1615            *            @arg TIM_OCNPolarity_High: Output Compare active high
   1616            *            @arg TIM_OCNPolarity_Low: Output Compare active low
   1617            * @retval None
   1618            */
   1619          void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1620          {
   1621            uint16_t tmpccer = 0;
   1622            /* Check the parameters */
   1623            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1624            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1625             
   1626            tmpccer = TIMx->CCER;
   1627          
   1628            /* Set or Reset the CC1NP Bit */
   1629            tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
   1630            tmpccer |= TIM_OCNPolarity;
   1631          
   1632            /* Write to TIMx CCER register */
   1633            TIMx->CCER = tmpccer;
   1634          }
   1635          
   1636          /**
   1637            * @brief  Configures the TIMx channel 2 polarity.
   1638            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1639            *         peripheral.
   1640            * @param  TIM_OCPolarity: specifies the OC2 Polarity
   1641            *          This parameter can be one of the following values:
   1642            *            @arg TIM_OCPolarity_High: Output Compare active high
   1643            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1644            * @retval None
   1645            */
   1646          void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1647          {
   1648            uint16_t tmpccer = 0;
   1649          
   1650            /* Check the parameters */
   1651            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1652            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1653          
   1654            tmpccer = TIMx->CCER;
   1655          
   1656            /* Set or Reset the CC2P Bit */
   1657            tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
   1658            tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
   1659          
   1660            /* Write to TIMx CCER register */
   1661            TIMx->CCER = tmpccer;
   1662          }
   1663          
   1664          /**
   1665            * @brief  Configures the TIMx Channel 2N polarity.
   1666            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1667            * @param  TIM_OCNPolarity: specifies the OC2N Polarity
   1668            *          This parameter can be one of the following values:
   1669            *            @arg TIM_OCNPolarity_High: Output Compare active high
   1670            *            @arg TIM_OCNPolarity_Low: Output Compare active low
   1671            * @retval None
   1672            */
   1673          void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1674          {
   1675            uint16_t tmpccer = 0;
   1676          
   1677            /* Check the parameters */
   1678            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1679            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1680            
   1681            tmpccer = TIMx->CCER;
   1682          
   1683            /* Set or Reset the CC2NP Bit */
   1684            tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
   1685            tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
   1686          
   1687            /* Write to TIMx CCER register */
   1688            TIMx->CCER = tmpccer;
   1689          }
   1690          
   1691          /**
   1692            * @brief  Configures the TIMx channel 3 polarity.
   1693            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1694            * @param  TIM_OCPolarity: specifies the OC3 Polarity
   1695            *          This parameter can be one of the following values:
   1696            *            @arg TIM_OCPolarity_High: Output Compare active high
   1697            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1698            * @retval None
   1699            */
   1700          void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1701          {
   1702            uint16_t tmpccer = 0;
   1703          
   1704            /* Check the parameters */
   1705            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1706            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1707          
   1708            tmpccer = TIMx->CCER;
   1709          
   1710            /* Set or Reset the CC3P Bit */
   1711            tmpccer &= (uint16_t)~TIM_CCER_CC3P;
   1712            tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
   1713          
   1714            /* Write to TIMx CCER register */
   1715            TIMx->CCER = tmpccer;
   1716          }
   1717          
   1718          /**
   1719            * @brief  Configures the TIMx Channel 3N polarity.
   1720            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1721            * @param  TIM_OCNPolarity: specifies the OC3N Polarity
   1722            *          This parameter can be one of the following values:
   1723            *            @arg TIM_OCNPolarity_High: Output Compare active high
   1724            *            @arg TIM_OCNPolarity_Low: Output Compare active low
   1725            * @retval None
   1726            */
   1727          void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1728          {
   1729            uint16_t tmpccer = 0;
   1730           
   1731            /* Check the parameters */
   1732            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1733            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1734              
   1735            tmpccer = TIMx->CCER;
   1736          
   1737            /* Set or Reset the CC3NP Bit */
   1738            tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
   1739            tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
   1740          
   1741            /* Write to TIMx CCER register */
   1742            TIMx->CCER = tmpccer;
   1743          }
   1744          
   1745          /**
   1746            * @brief  Configures the TIMx channel 4 polarity.
   1747            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1748            * @param  TIM_OCPolarity: specifies the OC4 Polarity
   1749            *          This parameter can be one of the following values:
   1750            *            @arg TIM_OCPolarity_High: Output Compare active high
   1751            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1752            * @retval None
   1753            */
   1754          void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1755          {
   1756            uint16_t tmpccer = 0;
   1757          
   1758            /* Check the parameters */
   1759            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1760            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1761          
   1762            tmpccer = TIMx->CCER;
   1763          
   1764            /* Set or Reset the CC4P Bit */
   1765            tmpccer &= (uint16_t)~TIM_CCER_CC4P;
   1766            tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
   1767          
   1768            /* Write to TIMx CCER register */
   1769            TIMx->CCER = tmpccer;
   1770          }
   1771          
   1772          /**
   1773            * @brief  Enables or disables the TIM Capture Compare Channel x.
   1774            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1775            * @param  TIM_Channel: specifies the TIM Channel
   1776            *          This parameter can be one of the following values:
   1777            *            @arg TIM_Channel_1: TIM Channel 1
   1778            *            @arg TIM_Channel_2: TIM Channel 2
   1779            *            @arg TIM_Channel_3: TIM Channel 3
   1780            *            @arg TIM_Channel_4: TIM Channel 4
   1781            * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
   1782            *          This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
   1783            * @retval None
   1784            */
   1785          void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
   1786          {
   1787            uint16_t tmp = 0;
   1788          
   1789            /* Check the parameters */
   1790            assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
   1791            assert_param(IS_TIM_CHANNEL(TIM_Channel));
   1792            assert_param(IS_TIM_CCX(TIM_CCx));
   1793          
   1794            tmp = CCER_CCE_SET << TIM_Channel;
   1795          
   1796            /* Reset the CCxE Bit */
   1797            TIMx->CCER &= (uint16_t)~ tmp;
   1798          
   1799            /* Set or reset the CCxE Bit */ 
   1800            TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
   1801          }
   1802          
   1803          /**
   1804            * @brief  Enables or disables the TIM Capture Compare Channel xN.
   1805            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1806            * @param  TIM_Channel: specifies the TIM Channel
   1807            *          This parameter can be one of the following values:
   1808            *            @arg TIM_Channel_1: TIM Channel 1
   1809            *            @arg TIM_Channel_2: TIM Channel 2
   1810            *            @arg TIM_Channel_3: TIM Channel 3
   1811            * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
   1812            *          This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
   1813            * @retval None
   1814            */
   1815          void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
   1816          {
   1817            uint16_t tmp = 0;
   1818          
   1819            /* Check the parameters */
   1820            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1821            assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
   1822            assert_param(IS_TIM_CCXN(TIM_CCxN));
   1823          
   1824            tmp = CCER_CCNE_SET << TIM_Channel;
   1825          
   1826            /* Reset the CCxNE Bit */
   1827            TIMx->CCER &= (uint16_t) ~tmp;
   1828          
   1829            /* Set or reset the CCxNE Bit */ 
   1830            TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
   1831          }
   1832          /**
   1833            * @}
   1834            */
   1835          
   1836          /** @defgroup TIM_Group3 Input Capture management functions
   1837           *  @brief    Input Capture management functions 
   1838           *
   1839          @verbatim   
   1840           ===============================================================================
   1841                                Input Capture management functions
   1842           ===============================================================================  
   1843             
   1844                 ===================================================================      
   1845                        TIM Driver: how to use it in Input Capture Mode
   1846                 =================================================================== 
   1847                 To use the Timer in Input Capture mode, the following steps are mandatory:
   1848                 
   1849                 1. Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) function
   1850                 
   1851                 2. Configure the TIM pins by configuring the corresponding GPIO pins
   1852                 
   1853                 2. Configure the Time base unit as described in the first part of this driver,
   1854                    if needed, else the Timer will run with the default configuration:
   1855                    - Autoreload value = 0xFFFF
   1856                    - Prescaler value = 0x0000
   1857                    - Counter mode = Up counting
   1858                    - Clock Division = TIM_CKD_DIV1
   1859                    
   1860                 3. Fill the TIM_ICInitStruct with the desired parameters including:
   1861                    - TIM Channel: TIM_Channel
   1862                    - TIM Input Capture polarity: TIM_ICPolarity
   1863                    - TIM Input Capture selection: TIM_ICSelection
   1864                    - TIM Input Capture Prescaler: TIM_ICPrescaler
   1865                    - TIM Input CApture filter value: TIM_ICFilter
   1866                 
   1867                 4. Call TIM_ICInit(TIMx, &TIM_ICInitStruct) to configure the desired channel with the 
   1868                    corresponding configuration and to measure only frequency or duty cycle of the input signal,
   1869                    or,
   1870                    Call TIM_PWMIConfig(TIMx, &TIM_ICInitStruct) to configure the desired channels with the 
   1871                    corresponding configuration and to measure the frequency and the duty cycle of the input signal
   1872                    
   1873                 5. Enable the NVIC or the DMA to read the measured frequency. 
   1874                    
   1875                 6. Enable the corresponding interrupt (or DMA request) to read the Captured value,
   1876                    using the function TIM_ITConfig(TIMx, TIM_IT_CCx) (or TIM_DMA_Cmd(TIMx, TIM_DMA_CCx)) 
   1877                 
   1878                 7. Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
   1879                 
   1880                 8. Use TIM_GetCapturex(TIMx); to read the captured value.
   1881                 
   1882                 Note1: All other functions can be used separately to modify, if needed,
   1883                        a specific feature of the Timer. 
   1884          
   1885          @endverbatim
   1886            * @{
   1887            */
   1888          
   1889          /**
   1890            * @brief  Initializes the TIM peripheral according to the specified parameters
   1891            *         in the TIM_ICInitStruct.
   1892            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1893            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
   1894            *         the configuration information for the specified TIM peripheral.
   1895            * @retval None
   1896            */
   1897          void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
   1898          {
   1899            /* Check the parameters */     
   1900            assert_param(IS_TIM_LIST1_PERIPH(TIMx));   
   1901            assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
   1902            assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
   1903            assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
   1904            assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
   1905            
   1906            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   1907            {
   1908              /* TI1 Configuration */
   1909              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1910                         TIM_ICInitStruct->TIM_ICSelection,
   1911                         TIM_ICInitStruct->TIM_ICFilter);
   1912              /* Set the Input Capture Prescaler value */
   1913              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1914            }
   1915            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
   1916            {
   1917              /* TI2 Configuration */
   1918              assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1919              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1920                         TIM_ICInitStruct->TIM_ICSelection,
   1921                         TIM_ICInitStruct->TIM_ICFilter);
   1922              /* Set the Input Capture Prescaler value */
   1923              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1924            }
   1925            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
   1926            {
   1927              /* TI3 Configuration */
   1928              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1929              TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
   1930                         TIM_ICInitStruct->TIM_ICSelection,
   1931                         TIM_ICInitStruct->TIM_ICFilter);
   1932              /* Set the Input Capture Prescaler value */
   1933              TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1934            }
   1935            else
   1936            {
   1937              /* TI4 Configuration */ 
   1938              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1939              TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1940                         TIM_ICInitStruct->TIM_ICSelection,
   1941                         TIM_ICInitStruct->TIM_ICFilter);
   1942              /* Set the Input Capture Prescaler value */
   1943              TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1944            }
   1945          }
   1946          
   1947          /**
   1948            * @brief  Fills each TIM_ICInitStruct member with its default value.
   1949            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure which will
   1950            *         be initialized.
   1951            * @retval None
   1952            */
   1953          void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
   1954          {
   1955            /* Set the default configuration */
   1956            TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
   1957            TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
   1958            TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
   1959            TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
   1960            TIM_ICInitStruct->TIM_ICFilter = 0x00;
   1961          }
   1962          
   1963          /**
   1964            * @brief  Configures the TIM peripheral according to the specified parameters
   1965            *         in the TIM_ICInitStruct to measure an external PWM signal.
   1966            * @param  TIMx: where x can be  1, 2, 3, 4, 5,8, 9 or 12 to select the TIM 
   1967            *         peripheral.
   1968            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
   1969            *         the configuration information for the specified TIM peripheral.
   1970            * @retval None
   1971            */
   1972          void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
   1973          {
   1974            uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
   1975            uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
   1976          
   1977            /* Check the parameters */
   1978            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1979          
   1980            /* Select the Opposite Input Polarity */
   1981            if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
   1982            {
   1983              icoppositepolarity = TIM_ICPolarity_Falling;
   1984            }
   1985            else
   1986            {
   1987              icoppositepolarity = TIM_ICPolarity_Rising;
   1988            }
   1989            /* Select the Opposite Input */
   1990            if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
   1991            {
   1992              icoppositeselection = TIM_ICSelection_IndirectTI;
   1993            }
   1994            else
   1995            {
   1996              icoppositeselection = TIM_ICSelection_DirectTI;
   1997            }
   1998            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   1999            {
   2000              /* TI1 Configuration */
   2001              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   2002                         TIM_ICInitStruct->TIM_ICFilter);
   2003              /* Set the Input Capture Prescaler value */
   2004              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2005              /* TI2 Configuration */
   2006              TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   2007              /* Set the Input Capture Prescaler value */
   2008              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2009            }
   2010            else
   2011            { 
   2012              /* TI2 Configuration */
   2013              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   2014                         TIM_ICInitStruct->TIM_ICFilter);
   2015              /* Set the Input Capture Prescaler value */
   2016              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2017              /* TI1 Configuration */
   2018              TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   2019              /* Set the Input Capture Prescaler value */
   2020              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2021            }
   2022          }
   2023          
   2024          /**
   2025            * @brief  Gets the TIMx Input Capture 1 value.
   2026            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   2027            * @retval Capture Compare 1 Register value.
   2028            */
   2029          uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
   2030          {
   2031            /* Check the parameters */
   2032            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2033          
   2034            /* Get the Capture 1 Register value */
   2035            return TIMx->CCR1;
   2036          }
   2037          
   2038          /**
   2039            * @brief  Gets the TIMx Input Capture 2 value.
   2040            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2041            *         peripheral.
   2042            * @retval Capture Compare 2 Register value.
   2043            */
   2044          uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
   2045          {
   2046            /* Check the parameters */
   2047            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2048          
   2049            /* Get the Capture 2 Register value */
   2050            return TIMx->CCR2;
   2051          }
   2052          
   2053          /**
   2054            * @brief  Gets the TIMx Input Capture 3 value.
   2055            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2056            * @retval Capture Compare 3 Register value.
   2057            */
   2058          uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
   2059          {
   2060            /* Check the parameters */
   2061            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
   2062          
   2063            /* Get the Capture 3 Register value */
   2064            return TIMx->CCR3;
   2065          }
   2066          
   2067          /**
   2068            * @brief  Gets the TIMx Input Capture 4 value.
   2069            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2070            * @retval Capture Compare 4 Register value.
   2071            */
   2072          uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
   2073          {
   2074            /* Check the parameters */
   2075            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2076          
   2077            /* Get the Capture 4 Register value */
   2078            return TIMx->CCR4;
   2079          }
   2080          
   2081          /**
   2082            * @brief  Sets the TIMx Input Capture 1 prescaler.
   2083            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   2084            * @param  TIM_ICPSC: specifies the Input Capture1 prescaler new value.
   2085            *          This parameter can be one of the following values:
   2086            *            @arg TIM_ICPSC_DIV1: no prescaler
   2087            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2088            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2089            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2090            * @retval None
   2091            */
   2092          void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2093          {
   2094            /* Check the parameters */
   2095            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2096            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2097          
   2098            /* Reset the IC1PSC Bits */
   2099            TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
   2100          
   2101            /* Set the IC1PSC value */
   2102            TIMx->CCMR1 |= TIM_ICPSC;
   2103          }
   2104          
   2105          /**
   2106            * @brief  Sets the TIMx Input Capture 2 prescaler.
   2107            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2108            *         peripheral.
   2109            * @param  TIM_ICPSC: specifies the Input Capture2 prescaler new value.
   2110            *          This parameter can be one of the following values:
   2111            *            @arg TIM_ICPSC_DIV1: no prescaler
   2112            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2113            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2114            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2115            * @retval None
   2116            */
   2117          void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2118          {
   2119            /* Check the parameters */
   2120            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2121            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2122          
   2123            /* Reset the IC2PSC Bits */
   2124            TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
   2125          
   2126            /* Set the IC2PSC value */
   2127            TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
   2128          }
   2129          
   2130          /**
   2131            * @brief  Sets the TIMx Input Capture 3 prescaler.
   2132            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2133            * @param  TIM_ICPSC: specifies the Input Capture3 prescaler new value.
   2134            *          This parameter can be one of the following values:
   2135            *            @arg TIM_ICPSC_DIV1: no prescaler
   2136            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2137            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2138            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2139            * @retval None
   2140            */
   2141          void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2142          {
   2143            /* Check the parameters */
   2144            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2145            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2146          
   2147            /* Reset the IC3PSC Bits */
   2148            TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
   2149          
   2150            /* Set the IC3PSC value */
   2151            TIMx->CCMR2 |= TIM_ICPSC;
   2152          }
   2153          
   2154          /**
   2155            * @brief  Sets the TIMx Input Capture 4 prescaler.
   2156            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2157            * @param  TIM_ICPSC: specifies the Input Capture4 prescaler new value.
   2158            *          This parameter can be one of the following values:
   2159            *            @arg TIM_ICPSC_DIV1: no prescaler
   2160            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2161            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2162            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2163            * @retval None
   2164            */
   2165          void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2166          {  
   2167            /* Check the parameters */
   2168            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2169            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2170          
   2171            /* Reset the IC4PSC Bits */
   2172            TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
   2173          
   2174            /* Set the IC4PSC value */
   2175            TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
   2176          }
   2177          /**
   2178            * @}
   2179            */
   2180          
   2181          /** @defgroup TIM_Group4 Advanced-control timers (TIM1 and TIM8) specific features
   2182           *  @brief   Advanced-control timers (TIM1 and TIM8) specific features
   2183           *
   2184          @verbatim   
   2185           ===============================================================================
   2186                    Advanced-control timers (TIM1 and TIM8) specific features
   2187           ===============================================================================  
   2188            
   2189                 ===================================================================      
   2190                        TIM Driver: how to use the Break feature
   2191                 =================================================================== 
   2192                 After configuring the Timer channel(s) in the appropriate Output Compare mode: 
   2193                                   
   2194                 1. Fill the TIM_BDTRInitStruct with the desired parameters for the Timer
   2195                    Break Polarity, dead time, Lock level, the OSSI/OSSR State and the 
   2196                    AOE(automatic output enable).
   2197                         
   2198                 2. Call TIM_BDTRConfig(TIMx, &TIM_BDTRInitStruct) to configure the Timer
   2199                    
   2200                 3. Enable the Main Output using TIM_CtrlPWMOutputs(TIM1, ENABLE) 
   2201                    
   2202                 4. Once the break even occurs, the Timer's output signals are put in reset
   2203                    state or in a known state (according to the configuration made in
   2204                    TIM_BDTRConfig() function).
   2205          
   2206          @endverbatim
   2207            * @{
   2208            */
   2209          
   2210          /**
   2211            * @brief  Configures the Break feature, dead time, Lock level, OSSI/OSSR State
   2212            *         and the AOE(automatic output enable).
   2213            * @param  TIMx: where x can be  1 or 8 to select the TIM 
   2214            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that
   2215            *         contains the BDTR Register configuration  information for the TIM peripheral.
   2216            * @retval None
   2217            */
   2218          void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
   2219          {
   2220            /* Check the parameters */
   2221            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   2222            assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
   2223            assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
   2224            assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
   2225            assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
   2226            assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
   2227            assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
   2228          
   2229            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
   2230               the OSSI State, the dead time value and the Automatic Output Enable Bit */
   2231            TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
   2232                       TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
   2233                       TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
   2234                       TIM_BDTRInitStruct->TIM_AutomaticOutput;
   2235          }
   2236          
   2237          /**
   2238            * @brief  Fills each TIM_BDTRInitStruct member with its default value.
   2239            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which
   2240            *         will be initialized.
   2241            * @retval None
   2242            */
   2243          void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
   2244          {
   2245            /* Set the default configuration */
   2246            TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
   2247            TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
   2248            TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
   2249            TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
   2250            TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
   2251            TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
   2252            TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
   2253          }
   2254          
   2255          /**
   2256            * @brief  Enables or disables the TIM peripheral Main Outputs.
   2257            * @param  TIMx: where x can be 1 or 8 to select the TIMx peripheral.
   2258            * @param  NewState: new state of the TIM peripheral Main Outputs.
   2259            *          This parameter can be: ENABLE or DISABLE.
   2260            * @retval None
   2261            */
   2262          void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
   2263          {
   2264            /* Check the parameters */
   2265            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   2266            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2267          
   2268            if (NewState != DISABLE)
   2269            {
   2270              /* Enable the TIM Main Output */
   2271              TIMx->BDTR |= TIM_BDTR_MOE;
   2272            }
   2273            else
   2274            {
   2275              /* Disable the TIM Main Output */
   2276              TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
   2277            }  
   2278          }
   2279          
   2280          /**
   2281            * @brief  Selects the TIM peripheral Commutation event.
   2282            * @param  TIMx: where x can be  1 or 8 to select the TIMx peripheral
   2283            * @param  NewState: new state of the Commutation event.
   2284            *          This parameter can be: ENABLE or DISABLE.
   2285            * @retval None
   2286            */
   2287          void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
   2288          {
   2289            /* Check the parameters */
   2290            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   2291            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2292          
   2293            if (NewState != DISABLE)
   2294            {
   2295              /* Set the COM Bit */
   2296              TIMx->CR2 |= TIM_CR2_CCUS;
   2297            }
   2298            else
   2299            {
   2300              /* Reset the COM Bit */
   2301              TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
   2302            }
   2303          }
   2304          
   2305          /**
   2306            * @brief  Sets or Resets the TIM peripheral Capture Compare Preload Control bit.
   2307            * @param  TIMx: where x can be  1 or 8 to select the TIMx peripheral
   2308            * @param  NewState: new state of the Capture Compare Preload Control bit
   2309            *          This parameter can be: ENABLE or DISABLE.
   2310            * @retval None
   2311            */
   2312          void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
   2313          { 
   2314            /* Check the parameters */
   2315            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   2316            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2317            if (NewState != DISABLE)
   2318            {
   2319              /* Set the CCPC Bit */
   2320              TIMx->CR2 |= TIM_CR2_CCPC;
   2321            }
   2322            else
   2323            {
   2324              /* Reset the CCPC Bit */
   2325              TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
   2326            }
   2327          }
   2328          /**
   2329            * @}
   2330            */
   2331          
   2332          /** @defgroup TIM_Group5 Interrupts DMA and flags management functions
   2333           *  @brief    Interrupts, DMA and flags management functions 
   2334           *
   2335          @verbatim   
   2336           ===============================================================================
   2337                           Interrupts, DMA and flags management functions
   2338           ===============================================================================  
   2339          
   2340          @endverbatim
   2341            * @{
   2342            */
   2343          
   2344          /**
   2345            * @brief  Enables or disables the specified TIM interrupts.
   2346            * @param  TIMx: where x can be 1 to 14 to select the TIMx peripheral.
   2347            * @param  TIM_IT: specifies the TIM interrupts sources to be enabled or disabled.
   2348            *          This parameter can be any combination of the following values:
   2349            *            @arg TIM_IT_Update: TIM update Interrupt source
   2350            *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2351            *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2352            *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2353            *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2354            *            @arg TIM_IT_COM: TIM Commutation Interrupt source
   2355            *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2356            *            @arg TIM_IT_Break: TIM Break Interrupt source
   2357            *  
   2358            * @note   For TIM6 and TIM7 only the parameter TIM_IT_Update can be used
   2359            * @note   For TIM9 and TIM12 only one of the following parameters can be used: TIM_IT_Update,
   2360            *          TIM_IT_CC1, TIM_IT_CC2 or TIM_IT_Trigger. 
   2361            * @note   For TIM10, TIM11, TIM13 and TIM14 only one of the following parameters can
   2362            *          be used: TIM_IT_Update or TIM_IT_CC1   
   2363            * @note   TIM_IT_COM and TIM_IT_Break can be used only with TIM1 and TIM8 
   2364            *        
   2365            * @param  NewState: new state of the TIM interrupts.
   2366            *          This parameter can be: ENABLE or DISABLE.
   2367            * @retval None
   2368            */
   2369          void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
   2370          {  
   2371            /* Check the parameters */
   2372            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2373            assert_param(IS_TIM_IT(TIM_IT));
   2374            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2375            
   2376            if (NewState != DISABLE)
   2377            {
   2378              /* Enable the Interrupt sources */
   2379              TIMx->DIER |= TIM_IT;
   2380            }
   2381            else
   2382            {
   2383              /* Disable the Interrupt sources */
   2384              TIMx->DIER &= (uint16_t)~TIM_IT;
   2385            }
   2386          }
   2387          
   2388          /**
   2389            * @brief  Configures the TIMx event to be generate by software.
   2390            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2391            * @param  TIM_EventSource: specifies the event source.
   2392            *          This parameter can be one or more of the following values:	   
   2393            *            @arg TIM_EventSource_Update: Timer update Event source
   2394            *            @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source
   2395            *            @arg TIM_EventSource_CC2: Timer Capture Compare 2 Event source
   2396            *            @arg TIM_EventSource_CC3: Timer Capture Compare 3 Event source
   2397            *            @arg TIM_EventSource_CC4: Timer Capture Compare 4 Event source
   2398            *            @arg TIM_EventSource_COM: Timer COM event source  
   2399            *            @arg TIM_EventSource_Trigger: Timer Trigger Event source
   2400            *            @arg TIM_EventSource_Break: Timer Break event source
   2401            * 
   2402            * @note   TIM6 and TIM7 can only generate an update event. 
   2403            * @note   TIM_EventSource_COM and TIM_EventSource_Break are used only with TIM1 and TIM8.
   2404            *        
   2405            * @retval None
   2406            */
   2407          void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
   2408          { 
   2409            /* Check the parameters */
   2410            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2411            assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
   2412           
   2413            /* Set the event sources */
   2414            TIMx->EGR = TIM_EventSource;
   2415          }
   2416          
   2417          /**
   2418            * @brief  Checks whether the specified TIM flag is set or not.
   2419            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2420            * @param  TIM_FLAG: specifies the flag to check.
   2421            *          This parameter can be one of the following values:
   2422            *            @arg TIM_FLAG_Update: TIM update Flag
   2423            *            @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2424            *            @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2425            *            @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2426            *            @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2427            *            @arg TIM_FLAG_COM: TIM Commutation Flag
   2428            *            @arg TIM_FLAG_Trigger: TIM Trigger Flag
   2429            *            @arg TIM_FLAG_Break: TIM Break Flag
   2430            *            @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 over capture Flag
   2431            *            @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 over capture Flag
   2432            *            @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 over capture Flag
   2433            *            @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 over capture Flag
   2434            *
   2435            * @note   TIM6 and TIM7 can have only one update flag. 
   2436            * @note   TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.    
   2437            *
   2438            * @retval The new state of TIM_FLAG (SET or RESET).
   2439            */
   2440          FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   2441          { 
   2442            ITStatus bitstatus = RESET;  
   2443            /* Check the parameters */
   2444            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2445            assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
   2446          
   2447            
   2448            if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
   2449            {
   2450              bitstatus = SET;
   2451            }
   2452            else
   2453            {
   2454              bitstatus = RESET;
   2455            }
   2456            return bitstatus;
   2457          }
   2458          
   2459          /**
   2460            * @brief  Clears the TIMx's pending flags.
   2461            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2462            * @param  TIM_FLAG: specifies the flag bit to clear.
   2463            *          This parameter can be any combination of the following values:
   2464            *            @arg TIM_FLAG_Update: TIM update Flag
   2465            *            @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2466            *            @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2467            *            @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2468            *            @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2469            *            @arg TIM_FLAG_COM: TIM Commutation Flag
   2470            *            @arg TIM_FLAG_Trigger: TIM Trigger Flag
   2471            *            @arg TIM_FLAG_Break: TIM Break Flag
   2472            *            @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 over capture Flag
   2473            *            @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 over capture Flag
   2474            *            @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 over capture Flag
   2475            *            @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 over capture Flag
   2476            *
   2477            * @note   TIM6 and TIM7 can have only one update flag. 
   2478            * @note   TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.
   2479            *    
   2480            * @retval None
   2481            */
   2482          void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   2483          {  
   2484            /* Check the parameters */
   2485            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2486             
   2487            /* Clear the flags */
   2488            TIMx->SR = (uint16_t)~TIM_FLAG;
   2489          }
   2490          
   2491          /**
   2492            * @brief  Checks whether the TIM interrupt has occurred or not.
   2493            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2494            * @param  TIM_IT: specifies the TIM interrupt source to check.
   2495            *          This parameter can be one of the following values:
   2496            *            @arg TIM_IT_Update: TIM update Interrupt source
   2497            *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2498            *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2499            *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2500            *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2501            *            @arg TIM_IT_COM: TIM Commutation Interrupt source
   2502            *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2503            *            @arg TIM_IT_Break: TIM Break Interrupt source
   2504            *
   2505            * @note   TIM6 and TIM7 can generate only an update interrupt.
   2506            * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
   2507            *     
   2508            * @retval The new state of the TIM_IT(SET or RESET).
   2509            */
   2510          ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2511          {
   2512            ITStatus bitstatus = RESET;  
   2513            uint16_t itstatus = 0x0, itenable = 0x0;
   2514            /* Check the parameters */
   2515            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2516            assert_param(IS_TIM_GET_IT(TIM_IT));
   2517             
   2518            itstatus = TIMx->SR & TIM_IT;
   2519            
   2520            itenable = TIMx->DIER & TIM_IT;
   2521            if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
   2522            {
   2523              bitstatus = SET;
   2524            }
   2525            else
   2526            {
   2527              bitstatus = RESET;
   2528            }
   2529            return bitstatus;
   2530          }
   2531          
   2532          /**
   2533            * @brief  Clears the TIMx's interrupt pending bits.
   2534            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2535            * @param  TIM_IT: specifies the pending bit to clear.
   2536            *          This parameter can be any combination of the following values:
   2537            *            @arg TIM_IT_Update: TIM1 update Interrupt source
   2538            *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2539            *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2540            *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2541            *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2542            *            @arg TIM_IT_COM: TIM Commutation Interrupt source
   2543            *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2544            *            @arg TIM_IT_Break: TIM Break Interrupt source
   2545            *
   2546            * @note   TIM6 and TIM7 can generate only an update interrupt.
   2547            * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
   2548            *      
   2549            * @retval None
   2550            */
   2551          void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2552          {
   2553            /* Check the parameters */
   2554            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2555          
   2556            /* Clear the IT pending Bit */
   2557            TIMx->SR = (uint16_t)~TIM_IT;
   2558          }
   2559          
   2560          /**
   2561            * @brief  Configures the TIMx's DMA interface.
   2562            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2563            * @param  TIM_DMABase: DMA Base address.
   2564            *          This parameter can be one of the following values:
   2565            *            @arg TIM_DMABase_CR1  
   2566            *            @arg TIM_DMABase_CR2
   2567            *            @arg TIM_DMABase_SMCR
   2568            *            @arg TIM_DMABase_DIER
   2569            *            @arg TIM1_DMABase_SR
   2570            *            @arg TIM_DMABase_EGR
   2571            *            @arg TIM_DMABase_CCMR1
   2572            *            @arg TIM_DMABase_CCMR2
   2573            *            @arg TIM_DMABase_CCER
   2574            *            @arg TIM_DMABase_CNT   
   2575            *            @arg TIM_DMABase_PSC   
   2576            *            @arg TIM_DMABase_ARR
   2577            *            @arg TIM_DMABase_RCR
   2578            *            @arg TIM_DMABase_CCR1
   2579            *            @arg TIM_DMABase_CCR2
   2580            *            @arg TIM_DMABase_CCR3  
   2581            *            @arg TIM_DMABase_CCR4
   2582            *            @arg TIM_DMABase_BDTR
   2583            *            @arg TIM_DMABase_DCR
   2584            * @param  TIM_DMABurstLength: DMA Burst length. This parameter can be one value
   2585            *         between: TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.
   2586            * @retval None
   2587            */
   2588          void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
   2589          {
   2590            /* Check the parameters */
   2591            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2592            assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
   2593            assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
   2594          
   2595            /* Set the DMA Base and the DMA Burst Length */
   2596            TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
   2597          }
   2598          
   2599          /**
   2600            * @brief  Enables or disables the TIMx's DMA Requests.
   2601            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the TIM peripheral.
   2602            * @param  TIM_DMASource: specifies the DMA Request sources.
   2603            *          This parameter can be any combination of the following values:
   2604            *            @arg TIM_DMA_Update: TIM update Interrupt source
   2605            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   2606            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   2607            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   2608            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   2609            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   2610            *            @arg TIM_DMA_Trigger: TIM Trigger DMA source
   2611            * @param  NewState: new state of the DMA Request sources.
   2612            *          This parameter can be: ENABLE or DISABLE.
   2613            * @retval None
   2614            */
   2615          void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
   2616          { 
   2617            /* Check the parameters */
   2618            assert_param(IS_TIM_LIST5_PERIPH(TIMx)); 
   2619            assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
   2620            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2621            
   2622            if (NewState != DISABLE)
   2623            {
   2624              /* Enable the DMA sources */
   2625              TIMx->DIER |= TIM_DMASource; 
   2626            }
   2627            else
   2628            {
   2629              /* Disable the DMA sources */
   2630              TIMx->DIER &= (uint16_t)~TIM_DMASource;
   2631            }
   2632          }
   2633          
   2634          /**
   2635            * @brief  Selects the TIMx peripheral Capture Compare DMA source.
   2636            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2637            * @param  NewState: new state of the Capture Compare DMA source
   2638            *          This parameter can be: ENABLE or DISABLE.
   2639            * @retval None
   2640            */
   2641          void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
   2642          {
   2643            /* Check the parameters */
   2644            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2645            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2646          
   2647            if (NewState != DISABLE)
   2648            {
   2649              /* Set the CCDS Bit */
   2650              TIMx->CR2 |= TIM_CR2_CCDS;
   2651            }
   2652            else
   2653            {
   2654              /* Reset the CCDS Bit */
   2655              TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
   2656            }
   2657          }
   2658          /**
   2659            * @}
   2660            */
   2661          
   2662          /** @defgroup TIM_Group6 Clocks management functions
   2663           *  @brief    Clocks management functions
   2664           *
   2665          @verbatim   
   2666           ===============================================================================
   2667                                   Clocks management functions
   2668           ===============================================================================  
   2669          
   2670          @endverbatim
   2671            * @{
   2672            */
   2673          
   2674          /**
   2675            * @brief  Configures the TIMx internal Clock
   2676            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2677            *         peripheral.
   2678            * @retval None
   2679            */
   2680          void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
   2681          {
   2682            /* Check the parameters */
   2683            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2684          
   2685            /* Disable slave mode to clock the prescaler directly with the internal clock */
   2686            TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
   2687          }
   2688          
   2689          /**
   2690            * @brief  Configures the TIMx Internal Trigger as External Clock
   2691            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2692            *         peripheral.
   2693            * @param  TIM_InputTriggerSource: Trigger source.
   2694            *          This parameter can be one of the following values:
   2695            *            @arg TIM_TS_ITR0: Internal Trigger 0
   2696            *            @arg TIM_TS_ITR1: Internal Trigger 1
   2697            *            @arg TIM_TS_ITR2: Internal Trigger 2
   2698            *            @arg TIM_TS_ITR3: Internal Trigger 3
   2699            * @retval None
   2700            */
   2701          void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
   2702          {
   2703            /* Check the parameters */
   2704            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2705            assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
   2706          
   2707            /* Select the Internal Trigger */
   2708            TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
   2709          
   2710            /* Select the External clock mode1 */
   2711            TIMx->SMCR |= TIM_SlaveMode_External1;
   2712          }
   2713          
   2714          /**
   2715            * @brief  Configures the TIMx Trigger as External Clock
   2716            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
   2717            *         to select the TIM peripheral.
   2718            * @param  TIM_TIxExternalCLKSource: Trigger source.
   2719            *          This parameter can be one of the following values:
   2720            *            @arg TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
   2721            *            @arg TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
   2722            *            @arg TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
   2723            * @param  TIM_ICPolarity: specifies the TIx Polarity.
   2724            *          This parameter can be one of the following values:
   2725            *            @arg TIM_ICPolarity_Rising
   2726            *            @arg TIM_ICPolarity_Falling
   2727            * @param  ICFilter: specifies the filter value.
   2728            *          This parameter must be a value between 0x0 and 0xF.
   2729            * @retval None
   2730            */
   2731          void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
   2732                                          uint16_t TIM_ICPolarity, uint16_t ICFilter)
   2733          {
   2734            /* Check the parameters */
   2735            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2736            assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
   2737            assert_param(IS_TIM_IC_FILTER(ICFilter));
   2738          
   2739            /* Configure the Timer Input Clock Source */
   2740            if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
   2741            {
   2742              TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   2743            }
   2744            else
   2745            {
   2746              TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   2747            }
   2748            /* Select the Trigger source */
   2749            TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
   2750            /* Select the External clock mode1 */
   2751            TIMx->SMCR |= TIM_SlaveMode_External1;
   2752          }
   2753          
   2754          /**
   2755            * @brief  Configures the External clock Mode1
   2756            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2757            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2758            *          This parameter can be one of the following values:
   2759            *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2760            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2761            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2762            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2763            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2764            *          This parameter can be one of the following values:
   2765            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   2766            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   2767            * @param  ExtTRGFilter: External Trigger Filter.
   2768            *          This parameter must be a value between 0x00 and 0x0F
   2769            * @retval None
   2770            */
   2771          void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
   2772                                      uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   2773          {
   2774            uint16_t tmpsmcr = 0;
   2775          
   2776            /* Check the parameters */
   2777            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2778            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   2779            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   2780            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   2781            /* Configure the ETR Clock source */
   2782            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   2783            
   2784            /* Get the TIMx SMCR register value */
   2785            tmpsmcr = TIMx->SMCR;
   2786          
   2787            /* Reset the SMS Bits */
   2788            tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
   2789          
   2790            /* Select the External clock mode1 */
   2791            tmpsmcr |= TIM_SlaveMode_External1;
   2792          
   2793            /* Select the Trigger selection : ETRF */
   2794            tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
   2795            tmpsmcr |= TIM_TS_ETRF;
   2796          
   2797            /* Write to TIMx SMCR */
   2798            TIMx->SMCR = tmpsmcr;
   2799          }
   2800          
   2801          /**
   2802            * @brief  Configures the External clock Mode2
   2803            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2804            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2805            *          This parameter can be one of the following values:
   2806            *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2807            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2808            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2809            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2810            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2811            *          This parameter can be one of the following values:
   2812            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   2813            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   2814            * @param  ExtTRGFilter: External Trigger Filter.
   2815            *          This parameter must be a value between 0x00 and 0x0F
   2816            * @retval None
   2817            */
   2818          void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
   2819                                       uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   2820          {
   2821            /* Check the parameters */
   2822            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2823            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   2824            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   2825            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   2826          
   2827            /* Configure the ETR Clock source */
   2828            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   2829          
   2830            /* Enable the External clock mode2 */
   2831            TIMx->SMCR |= TIM_SMCR_ECE;
   2832          }
   2833          /**
   2834            * @}
   2835            */
   2836          
   2837          /** @defgroup TIM_Group7 Synchronization management functions
   2838           *  @brief    Synchronization management functions 
   2839           *
   2840          @verbatim   
   2841           ===============================================================================
   2842                                 Synchronization management functions
   2843           ===============================================================================  
   2844                             
   2845                 ===================================================================      
   2846                        TIM Driver: how to use it in synchronization Mode
   2847                 =================================================================== 
   2848                 Case of two/several Timers
   2849                 **************************
   2850                 1. Configure the Master Timers using the following functions:
   2851                    - void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource); 
   2852                    - void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode);  
   2853                 2. Configure the Slave Timers using the following functions: 
   2854                    - void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);  
   2855                    - void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode); 
   2856                    
   2857                 Case of Timers and external trigger(ETR pin)
   2858                 ********************************************       
   2859                 1. Configure the External trigger using this function:
   2860                    - void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
   2861                                         uint16_t ExtTRGFilter);
   2862                 2. Configure the Slave Timers using the following functions: 
   2863                    - void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);  
   2864                    - void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode); 
   2865          
   2866          @endverbatim
   2867            * @{
   2868            */
   2869          
   2870          /**
   2871            * @brief  Selects the Input Trigger source
   2872            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
   2873            *         to select the TIM peripheral.
   2874            * @param  TIM_InputTriggerSource: The Input Trigger source.
   2875            *          This parameter can be one of the following values:
   2876            *            @arg TIM_TS_ITR0: Internal Trigger 0
   2877            *            @arg TIM_TS_ITR1: Internal Trigger 1
   2878            *            @arg TIM_TS_ITR2: Internal Trigger 2
   2879            *            @arg TIM_TS_ITR3: Internal Trigger 3
   2880            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   2881            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   2882            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   2883            *            @arg TIM_TS_ETRF: External Trigger input
   2884            * @retval None
   2885            */
   2886          void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
   2887          {
   2888            uint16_t tmpsmcr = 0;
   2889          
   2890            /* Check the parameters */
   2891            assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
   2892            assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
   2893          
   2894            /* Get the TIMx SMCR register value */
   2895            tmpsmcr = TIMx->SMCR;
   2896          
   2897            /* Reset the TS Bits */
   2898            tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
   2899          
   2900            /* Set the Input Trigger source */
   2901            tmpsmcr |= TIM_InputTriggerSource;
   2902          
   2903            /* Write to TIMx SMCR */
   2904            TIMx->SMCR = tmpsmcr;
   2905          }
   2906          
   2907          /**
   2908            * @brief  Selects the TIMx Trigger Output Mode.
   2909            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the TIM peripheral.
   2910            *     
   2911            * @param  TIM_TRGOSource: specifies the Trigger Output source.
   2912            *   This parameter can be one of the following values:
   2913            *
   2914            *  - For all TIMx
   2915            *            @arg TIM_TRGOSource_Reset:  The UG bit in the TIM_EGR register is used as the trigger output(TRGO)
   2916            *            @arg TIM_TRGOSource_Enable: The Counter Enable CEN is used as the trigger output(TRGO)
   2917            *            @arg TIM_TRGOSource_Update: The update event is selected as the trigger output(TRGO)
   2918            *
   2919            *  - For all TIMx except TIM6 and TIM7
   2920            *            @arg TIM_TRGOSource_OC1: The trigger output sends a positive pulse when the CC1IF flag
   2921            *                                     is to be set, as soon as a capture or compare match occurs(TRGO)
   2922            *            @arg TIM_TRGOSource_OC1Ref: OC1REF signal is used as the trigger output(TRGO)
   2923            *            @arg TIM_TRGOSource_OC2Ref: OC2REF signal is used as the trigger output(TRGO)
   2924            *            @arg TIM_TRGOSource_OC3Ref: OC3REF signal is used as the trigger output(TRGO)
   2925            *            @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output(TRGO)
   2926            *
   2927            * @retval None
   2928            */
   2929          void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
   2930          {
   2931            /* Check the parameters */
   2932            assert_param(IS_TIM_LIST5_PERIPH(TIMx));
   2933            assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
   2934          
   2935            /* Reset the MMS Bits */
   2936            TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
   2937            /* Select the TRGO source */
   2938            TIMx->CR2 |=  TIM_TRGOSource;
   2939          }
   2940          
   2941          /**
   2942            * @brief  Selects the TIMx Slave Mode.
   2943            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM peripheral.
   2944            * @param  TIM_SlaveMode: specifies the Timer Slave Mode.
   2945            *          This parameter can be one of the following values:
   2946            *            @arg TIM_SlaveMode_Reset: Rising edge of the selected trigger signal(TRGI) reinitialize 
   2947            *                                      the counter and triggers an update of the registers
   2948            *            @arg TIM_SlaveMode_Gated:     The counter clock is enabled when the trigger signal (TRGI) is high
   2949            *            @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI
   2950            *            @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter
   2951            * @retval None
   2952            */
   2953          void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
   2954          {
   2955            /* Check the parameters */
   2956            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2957            assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
   2958          
   2959            /* Reset the SMS Bits */
   2960            TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
   2961          
   2962            /* Select the Slave Mode */
   2963            TIMx->SMCR |= TIM_SlaveMode;
   2964          }
   2965          
   2966          /**
   2967            * @brief  Sets or Resets the TIMx Master/Slave Mode.
   2968            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM peripheral.
   2969            * @param  TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
   2970            *          This parameter can be one of the following values:
   2971            *            @arg TIM_MasterSlaveMode_Enable: synchronization between the current timer
   2972            *                                             and its slaves (through TRGO)
   2973            *            @arg TIM_MasterSlaveMode_Disable: No action
   2974            * @retval None
   2975            */
   2976          void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
   2977          {
   2978            /* Check the parameters */
   2979            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2980            assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
   2981          
   2982            /* Reset the MSM Bit */
   2983            TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
   2984            
   2985            /* Set or Reset the MSM Bit */
   2986            TIMx->SMCR |= TIM_MasterSlaveMode;
   2987          }
   2988          
   2989          /**
   2990            * @brief  Configures the TIMx External Trigger (ETR).
   2991            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2992            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2993            *          This parameter can be one of the following values:
   2994            *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2995            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2996            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2997            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2998            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2999            *          This parameter can be one of the following values:
   3000            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   3001            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   3002            * @param  ExtTRGFilter: External Trigger Filter.
   3003            *          This parameter must be a value between 0x00 and 0x0F
   3004            * @retval None
   3005            */
   3006          void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
   3007                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   3008          {
   3009            uint16_t tmpsmcr = 0;
   3010          
   3011            /* Check the parameters */
   3012            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   3013            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   3014            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   3015            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   3016          
   3017            tmpsmcr = TIMx->SMCR;
   3018          
   3019            /* Reset the ETR Bits */
   3020            tmpsmcr &= SMCR_ETR_MASK;
   3021          
   3022            /* Set the Prescaler, the Filter value and the Polarity */
   3023            tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
   3024          
   3025            /* Write to TIMx SMCR */
   3026            TIMx->SMCR = tmpsmcr;
   3027          }
   3028          /**
   3029            * @}
   3030            */
   3031          
   3032          /** @defgroup TIM_Group8 Specific interface management functions
   3033           *  @brief    Specific interface management functions 
   3034           *
   3035          @verbatim   
   3036           ===============================================================================
   3037                              Specific interface management functions
   3038           ===============================================================================  
   3039          
   3040          @endverbatim
   3041            * @{
   3042            */
   3043          
   3044          /**
   3045            * @brief  Configures the TIMx Encoder Interface.
   3046            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   3047            *         peripheral.
   3048            * @param  TIM_EncoderMode: specifies the TIMx Encoder Mode.
   3049            *          This parameter can be one of the following values:
   3050            *            @arg TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge depending on TI2FP2 level.
   3051            *            @arg TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge depending on TI1FP1 level.
   3052            *            @arg TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and TI2FP2 edges depending
   3053            *                                       on the level of the other input.
   3054            * @param  TIM_IC1Polarity: specifies the IC1 Polarity
   3055            *          This parameter can be one of the following values:
   3056            *            @arg TIM_ICPolarity_Falling: IC Falling edge.
   3057            *            @arg TIM_ICPolarity_Rising: IC Rising edge.
   3058            * @param  TIM_IC2Polarity: specifies the IC2 Polarity
   3059            *          This parameter can be one of the following values:
   3060            *            @arg TIM_ICPolarity_Falling: IC Falling edge.
   3061            *            @arg TIM_ICPolarity_Rising: IC Rising edge.
   3062            * @retval None
   3063            */
   3064          void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
   3065                                          uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
   3066          {
   3067            uint16_t tmpsmcr = 0;
   3068            uint16_t tmpccmr1 = 0;
   3069            uint16_t tmpccer = 0;
   3070              
   3071            /* Check the parameters */
   3072            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   3073            assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
   3074            assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
   3075            assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
   3076          
   3077            /* Get the TIMx SMCR register value */
   3078            tmpsmcr = TIMx->SMCR;
   3079          
   3080            /* Get the TIMx CCMR1 register value */
   3081            tmpccmr1 = TIMx->CCMR1;
   3082          
   3083            /* Get the TIMx CCER register value */
   3084            tmpccer = TIMx->CCER;
   3085          
   3086            /* Set the encoder Mode */
   3087            tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
   3088            tmpsmcr |= TIM_EncoderMode;
   3089          
   3090            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   3091            tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
   3092            tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
   3093          
   3094            /* Set the TI1 and the TI2 Polarities */
   3095            tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
   3096            tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
   3097          
   3098            /* Write to TIMx SMCR */
   3099            TIMx->SMCR = tmpsmcr;
   3100          
   3101            /* Write to TIMx CCMR1 */
   3102            TIMx->CCMR1 = tmpccmr1;
   3103          
   3104            /* Write to TIMx CCER */
   3105            TIMx->CCER = tmpccer;
   3106          }
   3107          
   3108          /**
   3109            * @brief  Enables or disables the TIMx's Hall sensor interface.
   3110            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   3111            *         peripheral.
   3112            * @param  NewState: new state of the TIMx Hall sensor interface.
   3113            *          This parameter can be: ENABLE or DISABLE.
   3114            * @retval None
   3115            */
   3116          void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
   3117          {
   3118            /* Check the parameters */
   3119            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   3120            assert_param(IS_FUNCTIONAL_STATE(NewState));
   3121          
   3122            if (NewState != DISABLE)
   3123            {
   3124              /* Set the TI1S Bit */
   3125              TIMx->CR2 |= TIM_CR2_TI1S;
   3126            }
   3127            else
   3128            {
   3129              /* Reset the TI1S Bit */
   3130              TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
   3131            }
   3132          }
   3133          /**
   3134            * @}
   3135            */
   3136          
   3137          /** @defgroup TIM_Group9 Specific remapping management function
   3138           *  @brief   Specific remapping management function
   3139           *
   3140          @verbatim   
   3141           ===============================================================================
   3142                               Specific remapping management function
   3143           ===============================================================================  
   3144          
   3145          @endverbatim
   3146            * @{
   3147            */
   3148          
   3149          /**
   3150            * @brief  Configures the TIM2, TIM5 and TIM11 Remapping input capabilities.
   3151            * @param  TIMx: where x can be 2, 5 or 11 to select the TIM peripheral.
   3152            * @param  TIM_Remap: specifies the TIM input remapping source.
   3153            *          This parameter can be one of the following values:
   3154            *            @arg TIM2_TIM8_TRGO: TIM2 ITR1 input is connected to TIM8 Trigger output(default)
   3155            *            @arg TIM2_ETH_PTP:   TIM2 ITR1 input is connected to ETH PTP trogger output.
   3156            *            @arg TIM2_USBFS_SOF: TIM2 ITR1 input is connected to USB FS SOF. 
   3157            *            @arg TIM2_USBHS_SOF: TIM2 ITR1 input is connected to USB HS SOF. 
   3158            *            @arg TIM5_GPIO:      TIM5 CH4 input is connected to dedicated Timer pin(default)
   3159            *            @arg TIM5_LSI:       TIM5 CH4 input is connected to LSI clock.
   3160            *            @arg TIM5_LSE:       TIM5 CH4 input is connected to LSE clock.
   3161            *            @arg TIM5_RTC:       TIM5 CH4 input is connected to RTC Output event.
   3162            *            @arg TIM11_GPIO:     TIM11 CH4 input is connected to dedicated Timer pin(default) 
   3163            *            @arg TIM11_HSE:      TIM11 CH4 input is connected to HSE_RTC clock
   3164            *                                 (HSE divided by a programmable prescaler)  
   3165            * @retval None
   3166            */
   3167          void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
   3168          {
   3169           /* Check the parameters */
   3170            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   3171            assert_param(IS_TIM_REMAP(TIM_Remap));
   3172          
   3173            /* Set the Timer remapping configuration */
   3174            TIMx->OR =  TIM_Remap;
   3175          }
   3176          /**
   3177            * @}
   3178            */
   3179          
   3180          /**
   3181            * @brief  Configure the TI1 as Input.
   3182            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14 
   3183            *         to select the TIM peripheral.
   3184            * @param  TIM_ICPolarity : The Input Polarity.
   3185            *          This parameter can be one of the following values:
   3186            *            @arg TIM_ICPolarity_Rising
   3187            *            @arg TIM_ICPolarity_Falling
   3188            *            @arg TIM_ICPolarity_BothEdge  
   3189            * @param  TIM_ICSelection: specifies the input to be used.
   3190            *          This parameter can be one of the following values:
   3191            *            @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
   3192            *            @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
   3193            *            @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
   3194            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3195            *          This parameter must be a value between 0x00 and 0x0F.
   3196            * @retval None
   3197            */
   3198          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3199                                 uint16_t TIM_ICFilter)
   3200          {
   3201            uint16_t tmpccmr1 = 0, tmpccer = 0;
   3202          
   3203            /* Disable the Channel 1: Reset the CC1E Bit */
   3204            TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
   3205            tmpccmr1 = TIMx->CCMR1;
   3206            tmpccer = TIMx->CCER;
   3207          
   3208            /* Select the Input and set the filter */
   3209            tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
   3210            tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   3211          
   3212            /* Select the Polarity and set the CC1E Bit */
   3213            tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   3214            tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
   3215          
   3216            /* Write to TIMx CCMR1 and CCER registers */
   3217            TIMx->CCMR1 = tmpccmr1;
   3218            TIMx->CCER = tmpccer;
   3219          }
   3220          
   3221          /**
   3222            * @brief  Configure the TI2 as Input.
   3223            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   3224            *         peripheral.
   3225            * @param  TIM_ICPolarity : The Input Polarity.
   3226            *          This parameter can be one of the following values:
   3227            *            @arg TIM_ICPolarity_Rising
   3228            *            @arg TIM_ICPolarity_Falling
   3229            *            @arg TIM_ICPolarity_BothEdge   
   3230            * @param  TIM_ICSelection: specifies the input to be used.
   3231            *          This parameter can be one of the following values:
   3232            *            @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
   3233            *            @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
   3234            *            @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
   3235            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3236            *          This parameter must be a value between 0x00 and 0x0F.
   3237            * @retval None
   3238            */
   3239          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3240                                 uint16_t TIM_ICFilter)
   3241          {
   3242            uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
   3243          
   3244            /* Disable the Channel 2: Reset the CC2E Bit */
   3245            TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
   3246            tmpccmr1 = TIMx->CCMR1;
   3247            tmpccer = TIMx->CCER;
   3248            tmp = (uint16_t)(TIM_ICPolarity << 4);
   3249          
   3250            /* Select the Input and set the filter */
   3251            tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
   3252            tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
   3253            tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
   3254          
   3255            /* Select the Polarity and set the CC2E Bit */
   3256            tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   3257            tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
   3258          
   3259            /* Write to TIMx CCMR1 and CCER registers */
   3260            TIMx->CCMR1 = tmpccmr1 ;
   3261            TIMx->CCER = tmpccer;
   3262          }
   3263          
   3264          /**
   3265            * @brief  Configure the TI3 as Input.
   3266            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   3267            * @param  TIM_ICPolarity : The Input Polarity.
   3268            *          This parameter can be one of the following values:
   3269            *            @arg TIM_ICPolarity_Rising
   3270            *            @arg TIM_ICPolarity_Falling
   3271            *            @arg TIM_ICPolarity_BothEdge         
   3272            * @param  TIM_ICSelection: specifies the input to be used.
   3273            *          This parameter can be one of the following values:
   3274            *            @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
   3275            *            @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
   3276            *            @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
   3277            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3278            *          This parameter must be a value between 0x00 and 0x0F.
   3279            * @retval None
   3280            */
   3281          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3282                                 uint16_t TIM_ICFilter)
   3283          {
   3284            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   3285          
   3286            /* Disable the Channel 3: Reset the CC3E Bit */
   3287            TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
   3288            tmpccmr2 = TIMx->CCMR2;
   3289            tmpccer = TIMx->CCER;
   3290            tmp = (uint16_t)(TIM_ICPolarity << 8);
   3291          
   3292            /* Select the Input and set the filter */
   3293            tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
   3294            tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   3295          
   3296            /* Select the Polarity and set the CC3E Bit */
   3297            tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   3298            tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
   3299          
   3300            /* Write to TIMx CCMR2 and CCER registers */
   3301            TIMx->CCMR2 = tmpccmr2;
   3302            TIMx->CCER = tmpccer;
   3303          }
   3304          
   3305          /**
   3306            * @brief  Configure the TI4 as Input.
   3307            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   3308            * @param  TIM_ICPolarity : The Input Polarity.
   3309            *          This parameter can be one of the following values:
   3310            *            @arg TIM_ICPolarity_Rising
   3311            *            @arg TIM_ICPolarity_Falling
   3312            *            @arg TIM_ICPolarity_BothEdge     
   3313            * @param  TIM_ICSelection: specifies the input to be used.
   3314            *          This parameter can be one of the following values:
   3315            *            @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
   3316            *            @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
   3317            *            @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
   3318            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3319            *          This parameter must be a value between 0x00 and 0x0F.
   3320            * @retval None
   3321            */
   3322          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3323                                 uint16_t TIM_ICFilter)
   3324          {
   3325            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   3326          
   3327            /* Disable the Channel 4: Reset the CC4E Bit */
   3328            TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
   3329            tmpccmr2 = TIMx->CCMR2;
   3330            tmpccer = TIMx->CCER;
   3331            tmp = (uint16_t)(TIM_ICPolarity << 12);
   3332          
   3333            /* Select the Input and set the filter */
   3334            tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
   3335            tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
   3336            tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
   3337          
   3338            /* Select the Polarity and set the CC4E Bit */
   3339            tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   3340            tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
   3341          
   3342            /* Write to TIMx CCMR2 and CCER registers */
   3343            TIMx->CCMR2 = tmpccmr2;
   3344            TIMx->CCER = tmpccer ;
   3345          }
   3346          
   3347          /**
   3348            * @}
   3349            */
   3350          
   3351          /**
   3352            * @}
   3353            */
   3354          
   3355          /**
   3356            * @}
   3357            */
   3358          
   3359          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   TI1_Config
      24   TI2_Config
      24   TI3_Config
      24   TI4_Config
       0   TIM_ARRPreloadConfig
       0   TIM_BDTRConfig
       0   TIM_BDTRStructInit
       0   TIM_CCPreloadControl
      12   TIM_CCxCmd
      12   TIM_CCxNCmd
       0   TIM_ClearFlag
       0   TIM_ClearITPendingBit
       4   TIM_ClearOC1Ref
       0   TIM_ClearOC2Ref
       4   TIM_ClearOC3Ref
       0   TIM_ClearOC4Ref
       0   TIM_Cmd
       4   TIM_CounterModeConfig
       0   TIM_CtrlPWMOutputs
       0   TIM_DMACmd
       0   TIM_DMAConfig
       8   TIM_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
      24   TIM_ETRClockMode1Config
        24   -> TIM_ETRConfig
      24   TIM_ETRClockMode2Config
        24   -> TIM_ETRConfig
      12   TIM_ETRConfig
      24   TIM_EncoderInterfaceConfig
       4   TIM_ForcedOC1Config
       4   TIM_ForcedOC2Config
       4   TIM_ForcedOC3Config
       4   TIM_ForcedOC4Config
       0   TIM_GenerateEvent
       0   TIM_GetCapture1
       0   TIM_GetCapture2
       0   TIM_GetCapture3
       0   TIM_GetCapture4
       0   TIM_GetCounter
       0   TIM_GetFlagStatus
      16   TIM_GetITStatus
       0   TIM_GetPrescaler
      16   TIM_ICInit
        16   -> TI1_Config
        16   -> TI2_Config
        16   -> TI3_Config
        16   -> TI4_Config
        16   -> TIM_SetIC1Prescaler
        16   -> TIM_SetIC2Prescaler
        16   -> TIM_SetIC3Prescaler
        16   -> TIM_SetIC4Prescaler
       0   TIM_ICStructInit
       0   TIM_ITConfig
      16   TIM_ITRxExternalClockConfig
        16   -> TIM_SelectInputTrigger
       0   TIM_InternalClockConfig
       4   TIM_OC1FastConfig
      16   TIM_OC1Init
       4   TIM_OC1NPolarityConfig
       4   TIM_OC1PolarityConfig
       4   TIM_OC1PreloadConfig
       4   TIM_OC2FastConfig
      16   TIM_OC2Init
       4   TIM_OC2NPolarityConfig
       4   TIM_OC2PolarityConfig
       4   TIM_OC2PreloadConfig
       4   TIM_OC3FastConfig
      16   TIM_OC3Init
       4   TIM_OC3NPolarityConfig
       4   TIM_OC3PolarityConfig
       4   TIM_OC3PreloadConfig
       4   TIM_OC4FastConfig
      16   TIM_OC4Init
       4   TIM_OC4PolarityConfig
       4   TIM_OC4PreloadConfig
       0   TIM_OCStructInit
      24   TIM_PWMIConfig
        24   -> TI1_Config
        24   -> TI2_Config
        24   -> TIM_SetIC1Prescaler
        24   -> TIM_SetIC2Prescaler
       0   TIM_PrescalerConfig
       0   TIM_RemapConfig
       0   TIM_SelectCCDMA
       0   TIM_SelectCOM
       0   TIM_SelectHallSensor
       4   TIM_SelectInputTrigger
       0   TIM_SelectMasterSlaveMode
      16   TIM_SelectOCxM
       0   TIM_SelectOnePulseMode
       0   TIM_SelectOutputTrigger
       0   TIM_SelectSlaveMode
       0   TIM_SetAutoreload
       0   TIM_SetClockDivision
       0   TIM_SetCompare1
       0   TIM_SetCompare2
       0   TIM_SetCompare3
       0   TIM_SetCompare4
       0   TIM_SetCounter
       0   TIM_SetIC1Prescaler
       0   TIM_SetIC2Prescaler
       0   TIM_SetIC3Prescaler
       0   TIM_SetIC4Prescaler
      24   TIM_TIxExternalClockConfig
        24   -> TI1_Config
        24   -> TI2_Config
        24   -> TIM_SelectInputTrigger
       4   TIM_TimeBaseInit
       0   TIM_TimeBaseStructInit
       0   TIM_UpdateDisableConfig
       0   TIM_UpdateRequestConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      60  TI1_Config
      82  TI2_Config
      82  TI3_Config
      82  TI4_Config
      30  TIM_ARRPreloadConfig
      32  TIM_BDTRConfig
      30  TIM_BDTRStructInit
      30  TIM_CCPreloadControl
      30  TIM_CCxCmd
      30  TIM_CCxNCmd
      10  TIM_ClearFlag
      10  TIM_ClearITPendingBit
      20  TIM_ClearOC1Ref
      16  TIM_ClearOC2Ref
      20  TIM_ClearOC3Ref
      16  TIM_ClearOC4Ref
      30  TIM_Cmd
      20  TIM_CounterModeConfig
      36  TIM_CtrlPWMOutputs
      24  TIM_DMACmd
      10  TIM_DMAConfig
     382  TIM_DeInit
      62  TIM_ETRClockMode1Config
      38  TIM_ETRClockMode2Config
      24  TIM_ETRConfig
      82  TIM_EncoderInterfaceConfig
      20  TIM_ForcedOC1Config
      22  TIM_ForcedOC2Config
      20  TIM_ForcedOC3Config
      22  TIM_ForcedOC4Config
       4  TIM_GenerateEvent
       4  TIM_GetCapture1
       4  TIM_GetCapture2
       4  TIM_GetCapture3
       4  TIM_GetCapture4
       4  TIM_GetCounter
      20  TIM_GetFlagStatus
      46  TIM_GetITStatus
       4  TIM_GetPrescaler
     112  TIM_ICInit
      22  TIM_ICStructInit
      24  TIM_ITConfig
      26  TIM_ITRxExternalClockConfig
      12  TIM_InternalClockConfig
      20  TIM_OC1FastConfig
     122  TIM_OC1Init
      20  TIM_OC1NPolarityConfig
      20  TIM_OC1PolarityConfig
      20  TIM_OC1PreloadConfig
      22  TIM_OC2FastConfig
     136  TIM_OC2Init
      22  TIM_OC2NPolarityConfig
      22  TIM_OC2PolarityConfig
      22  TIM_OC2PreloadConfig
      20  TIM_OC3FastConfig
     134  TIM_OC3Init
      22  TIM_OC3NPolarityConfig
      22  TIM_OC3PolarityConfig
      20  TIM_OC3PreloadConfig
      22  TIM_OC4FastConfig
     104  TIM_OC4Init
      22  TIM_OC4PolarityConfig
      22  TIM_OC4PreloadConfig
      34  TIM_OCStructInit
     132  TIM_PWMIConfig
       6  TIM_PrescalerConfig
       6  TIM_RemapConfig
      30  TIM_SelectCCDMA
      30  TIM_SelectCOM
      30  TIM_SelectHallSensor
      20  TIM_SelectInputTrigger
      18  TIM_SelectMasterSlaveMode
     102  TIM_SelectOCxM
      18  TIM_SelectOnePulseMode
      18  TIM_SelectOutputTrigger
      18  TIM_SelectSlaveMode
       4  TIM_SetAutoreload
      18  TIM_SetClockDivision
       4  TIM_SetCompare1
       4  TIM_SetCompare2
       4  TIM_SetCompare3
       4  TIM_SetCompare4
       4  TIM_SetCounter
      18  TIM_SetIC1Prescaler
      20  TIM_SetIC2Prescaler
      18  TIM_SetIC3Prescaler
      20  TIM_SetIC4Prescaler
      72  TIM_TIxExternalClockConfig
     106  TIM_TimeBaseInit
      24  TIM_TimeBaseStructInit
      30  TIM_UpdateDisableConfig
      30  TIM_UpdateRequestConfig

 
 3'370 bytes in section .text
 
 3'370 bytes of CODE memory

Errors: none
Warnings: none
