###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         20/Jun/2020  14:38:25
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\common\libraries\src\stm32f2xx_usart.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EW147D.tmp
#        (D:\proj\velograph\snail\stm32_snail\common\libraries\src\stm32f2xx_usart.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -lcN
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\.\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\..\common\libraries\inc\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_rtos\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_rtos\..\common\dbg\ -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\List\stm32f2xx_usart.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\Obj\stm32f2xx_usart.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\common\libraries\src\stm32f2xx_usart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_usart.c
      4            * @author  MCD Application Team
      5            * @version V1.1.2
      6            * @date    05-March-2012 
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Universal synchronous asynchronous receiver
      9            *          transmitter (USART):           
     10            *           - Initialization and Configuration
     11            *           - Data transfers
     12            *           - Multi-Processor Communication
     13            *           - LIN mode
     14            *           - Half-duplex mode
     15            *           - Smartcard mode
     16            *           - IrDA mode
     17            *           - DMA transfers management
     18            *           - Interrupts and flags management 
     19            *           
     20            *  @verbatim
     21            *      
     22            *          ===================================================================
     23            *                                 How to use this driver
     24            *          ===================================================================
     25            *          1. Enable peripheral clock using the follwoing functions
     26            *             RCC_APB2PeriphClockCmd(RCC_APB2Periph_USARTx, ENABLE) for USART1 and USART6 
     27            *             RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTx, ENABLE) for USART2, USART3, UART4 or UART5.
     28            *
     29            *          2.  According to the USART mode, enable the GPIO clocks using 
     30            *              RCC_AHB1PeriphClockCmd() function. (The I/O can be TX, RX, CTS, 
     31            *              or/and SCLK). 
     32            *
     33            *          3. Peripheral's alternate function: 
     34            *                 - Connect the pin to the desired peripherals' Alternate 
     35            *                   Function (AF) using GPIO_PinAFConfig() function
     36            *                 - Configure the desired pin in alternate function by:
     37            *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     38            *                 - Select the type, pull-up/pull-down and output speed via 
     39            *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
     40            *                 - Call GPIO_Init() function
     41            *        
     42            *          4. Program the Baud Rate, Word Length , Stop Bit, Parity, Hardware 
     43            *             flow control and Mode(Receiver/Transmitter) using the USART_Init()
     44            *             function.
     45            *
     46            *          5. For synchronous mode, enable the clock and program the polarity,
     47            *             phase and last bit using the USART_ClockInit() function.
     48            *
     49            *          5. Enable the NVIC and the corresponding interrupt using the function 
     50            *             USART_ITConfig() if you need to use interrupt mode. 
     51            *
     52            *          6. When using the DMA mode 
     53            *                   - Configure the DMA using DMA_Init() function
     54            *                   - Active the needed channel Request using USART_DMACmd() function
     55            * 
     56            *          7. Enable the USART using the USART_Cmd() function.
     57            * 
     58            *          8. Enable the DMA using the DMA_Cmd() function, when using DMA mode. 
     59            *
     60            *          Refer to Multi-Processor, LIN, half-duplex, Smartcard, IrDA sub-sections
     61            *          for more details
     62            *          
     63            *          In order to reach higher communication baudrates, it is possible to
     64            *          enable the oversampling by 8 mode using the function USART_OverSampling8Cmd().
     65            *          This function should be called after enabling the USART clock (RCC_APBxPeriphClockCmd())
     66            *          and before calling the function USART_Init().
     67            *          
     68            *  @endverbatim
     69            *        
     70            ******************************************************************************
     71            * @attention
     72            *
     73            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     74            *
     75            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     76            * You may not use this file except in compliance with the License.
     77            * You may obtain a copy of the License at:
     78            *
     79            *        http://www.st.com/software_license_agreement_liberty_v2
     80            *
     81            * Unless required by applicable law or agreed to in writing, software 
     82            * distributed under the License is distributed on an "AS IS" BASIS, 
     83            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     84            * See the License for the specific language governing permissions and
     85            * limitations under the License.
     86            *
     87            ******************************************************************************
     88            */
     89          
     90          /* Includes ------------------------------------------------------------------*/
     91          ///#include "stm32f2xx_usart.h"
     92          ///#include "stm32f2xx_rcc.h"
     93          #include "stm32f2xx_conf.h"
     94          
     95          /** @addtogroup STM32F2xx_StdPeriph_Driver
     96            * @{
     97            */
     98          
     99          /** @defgroup USART 
    100            * @brief USART driver modules
    101            * @{
    102            */
    103          
    104          /* Private typedef -----------------------------------------------------------*/
    105          /* Private define ------------------------------------------------------------*/
    106          
    107          /*!< USART CR1 register clear Mask ((~(uint16_t)0xE9F3)) */
    108          #define CR1_CLEAR_MASK            ((uint16_t)(USART_CR1_M | USART_CR1_PCE | \
    109                                                        USART_CR1_PS | USART_CR1_TE | \
    110                                                        USART_CR1_RE))
    111          
    112          /*!< USART CR2 register clock bits clear Mask ((~(uint16_t)0xF0FF)) */
    113          #define CR2_CLOCK_CLEAR_MASK      ((uint16_t)(USART_CR2_CLKEN | USART_CR2_CPOL | \
    114                                                        USART_CR2_CPHA | USART_CR2_LBCL))
    115          
    116          /*!< USART CR3 register clear Mask ((~(uint16_t)0xFCFF)) */
    117          #define CR3_CLEAR_MASK            ((uint16_t)(USART_CR3_RTSE | USART_CR3_CTSE))
    118          
    119          /*!< USART Interrupts mask */
    120          #define IT_MASK                   ((uint16_t)0x001F)
    121          
    122          /* Private macro -------------------------------------------------------------*/
    123          /* Private variables ---------------------------------------------------------*/
    124          /* Private function prototypes -----------------------------------------------*/
    125          /* Private functions ---------------------------------------------------------*/
    126          
    127          /** @defgroup USART_Private_Functions
    128            * @{
    129            */
    130          
    131          /** @defgroup USART_Group1 Initialization and Configuration functions
    132           *  @brief   Initialization and Configuration functions 
    133           *
    134          @verbatim   
    135           ===============================================================================
    136                            Initialization and Configuration functions
    137           ===============================================================================  
    138          
    139            This subsection provides a set of functions allowing to initialize the USART 
    140            in asynchronous and in synchronous modes.
    141             - For the asynchronous mode only these parameters can be configured: 
    142                  - Baud Rate
    143                  - Word Length 
    144                  - Stop Bit
    145                  - Parity: If the parity is enabled, then the MSB bit of the data written
    146                    in the data register is transmitted but is changed by the parity bit.
    147                    Depending on the frame length defined by the M bit (8-bits or 9-bits),
    148                    the possible USART frame formats are as listed in the following table:
    149             +-------------------------------------------------------------+     
    150             |   M bit |  PCE bit  |            USART frame                |
    151             |---------------------|---------------------------------------|             
    152             |    0    |    0      |    | SB | 8 bit data | STB |          |
    153             |---------|-----------|---------------------------------------|  
    154             |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    155             |---------|-----------|---------------------------------------|  
    156             |    1    |    0      |    | SB | 9 bit data | STB |          |
    157             |---------|-----------|---------------------------------------|  
    158             |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    159             +-------------------------------------------------------------+            
    160                  - Hardware flow control
    161                  - Receiver/transmitter modes
    162          
    163            The USART_Init() function follows the USART  asynchronous configuration procedure
    164            (details for the procedure are available in reference manual (RM0033)).
    165          
    166            - For the synchronous mode in addition to the asynchronous mode parameters these 
    167              parameters should be also configured:
    168                  - USART Clock Enabled
    169                  - USART polarity
    170                  - USART phase
    171                  - USART LastBit
    172            
    173            These parameters can be configured using the USART_ClockInit() function.
    174          
    175          @endverbatim
    176            * @{
    177            */
    178            
    179          /**
    180            * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
    181            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    182            *         UART peripheral.
    183            * @retval None
    184            */
    185          void USART_DeInit(USART_TypeDef* USARTx)
    186          {
    187            /* Check the parameters */
    188            assert_param(IS_USART_ALL_PERIPH(USARTx));
    189          
    190            if (USARTx == USART1)
    191            {
    192              RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
    193              RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
    194            }
    195            else if (USARTx == USART2)
    196            {
    197              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
    198              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
    199            }
    200            else if (USARTx == USART3)
    201            {
    202              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
    203              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
    204            }    
    205            else if (USARTx == UART4)
    206            {
    207              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
    208              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
    209            }
    210            else if (USARTx == UART5)
    211            {
    212              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
    213              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
    214            }     
    215            else
    216            {
    217              if (USARTx == USART6)
    218              { 
    219                RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
    220                RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
    221              }
    222            }
    223          }
    224          
    225          /**
    226            * @brief  Initializes the USARTx peripheral according to the specified
    227            *         parameters in the USART_InitStruct .
    228            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    229            *         UART peripheral.
    230            * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
    231            *         the configuration information for the specified USART peripheral.
    232            * @retval None
    233            */
    234          void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
    235          {
    236            uint32_t tmpreg = 0x00, apbclock = 0x00;
    237            uint32_t integerdivider = 0x00;
    238            uint32_t fractionaldivider = 0x00;
    239            RCC_ClocksTypeDef RCC_ClocksStatus;
    240          
    241            /* Check the parameters */
    242            assert_param(IS_USART_ALL_PERIPH(USARTx));
    243            assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
    244            assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
    245            assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
    246            assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
    247            assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
    248            assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
    249          
    250            /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
    251            if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
    252            {
    253              assert_param(IS_USART_1236_PERIPH(USARTx));
    254            }
    255          
    256          /*---------------------------- USART CR2 Configuration -----------------------*/
    257            tmpreg = USARTx->CR2;
    258          
    259            /* Clear STOP[13:12] bits */
    260            tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
    261          
    262            /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
    263                Set STOP[13:12] bits according to USART_StopBits value */
    264            tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
    265            
    266            /* Write to USART CR2 */
    267            USARTx->CR2 = (uint16_t)tmpreg;
    268          
    269          /*---------------------------- USART CR1 Configuration -----------------------*/
    270            tmpreg = USARTx->CR1;
    271          
    272            /* Clear M, PCE, PS, TE and RE bits */
    273            tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
    274          
    275            /* Configure the USART Word Length, Parity and mode: 
    276               Set the M bits according to USART_WordLength value 
    277               Set PCE and PS bits according to USART_Parity value
    278               Set TE and RE bits according to USART_Mode value */
    279            tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
    280                      USART_InitStruct->USART_Mode;
    281          
    282            /* Write to USART CR1 */
    283            USARTx->CR1 = (uint16_t)tmpreg;
    284          
    285          /*---------------------------- USART CR3 Configuration -----------------------*/  
    286            tmpreg = USARTx->CR3;
    287          
    288            /* Clear CTSE and RTSE bits */
    289            tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
    290          
    291            /* Configure the USART HFC : 
    292                Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
    293            tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
    294          
    295            /* Write to USART CR3 */
    296            USARTx->CR3 = (uint16_t)tmpreg;
    297          
    298          /*---------------------------- USART BRR Configuration -----------------------*/
    299            /* Configure the USART Baud Rate */
    300            RCC_GetClocksFreq(&RCC_ClocksStatus);
    301          
    302            if ((USARTx == USART1) || (USARTx == USART6))
    303            {
    304              apbclock = RCC_ClocksStatus.PCLK2_Frequency;
    305            }
    306            else
    307            {
    308              apbclock = RCC_ClocksStatus.PCLK1_Frequency;
    309            }
    310            
    311            /* Determine the integer part */
    312            if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
    313            {
    314              /* Integer part computing in case Oversampling mode is 8 Samples */
    315              integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
    316            }
    317            else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
    318            {
    319              /* Integer part computing in case Oversampling mode is 16 Samples */
    320              integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
    321            }
    322            tmpreg = (integerdivider / 100) << 4;
    323          
    324            /* Determine the fractional part */
    325            fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
    326          
    327            /* Implement the fractional part in the register */
    328            if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
    329            {
    330              tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
    331            }
    332            else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
    333            {
    334              tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
    335            }
    336            
    337            /* Write to USART BRR register */
    338            USARTx->BRR = (uint16_t)tmpreg;
    339          }
    340          
    341          /**
    342            * @brief  Fills each USART_InitStruct member with its default value.
    343            * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure which will
    344            *         be initialized.
    345            * @retval None
    346            */
    347          void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
    348          {
    349            /* USART_InitStruct members default value */
    350            USART_InitStruct->USART_BaudRate = 9600;
    351            USART_InitStruct->USART_WordLength = USART_WordLength_8b;
    352            USART_InitStruct->USART_StopBits = USART_StopBits_1;
    353            USART_InitStruct->USART_Parity = USART_Parity_No ;
    354            USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    355            USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
    356          }
    357          
    358          /**
    359            * @brief  Initializes the USARTx peripheral Clock according to the 
    360            *         specified parameters in the USART_ClockInitStruct .
    361            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART peripheral.
    362            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure that
    363            *         contains the configuration information for the specified  USART peripheral.
    364            * @note   The Smart Card and Synchronous modes are not available for UART4 and UART5.    
    365            * @retval None
    366            */
    367          void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
    368          {
    369            uint32_t tmpreg = 0x00;
    370            /* Check the parameters */
    371            assert_param(IS_USART_1236_PERIPH(USARTx));
    372            assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
    373            assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
    374            assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
    375            assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
    376            
    377          /*---------------------------- USART CR2 Configuration -----------------------*/
    378            tmpreg = USARTx->CR2;
    379            /* Clear CLKEN, CPOL, CPHA and LBCL bits */
    380            tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
    381            /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
    382            /* Set CLKEN bit according to USART_Clock value */
    383            /* Set CPOL bit according to USART_CPOL value */
    384            /* Set CPHA bit according to USART_CPHA value */
    385            /* Set LBCL bit according to USART_LastBit value */
    386            tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
    387                           USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
    388            /* Write to USART CR2 */
    389            USARTx->CR2 = (uint16_t)tmpreg;
    390          }
    391          
    392          /**
    393            * @brief  Fills each USART_ClockInitStruct member with its default value.
    394            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure
    395            *         which will be initialized.
    396            * @retval None
    397            */
    398          void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
    399          {
    400            /* USART_ClockInitStruct members default value */
    401            USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
    402            USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
    403            USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
    404            USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
    405          }
    406          
    407          /**
    408            * @brief  Enables or disables the specified USART peripheral.
    409            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    410            *         UART peripheral.
    411            * @param  NewState: new state of the USARTx peripheral.
    412            *          This parameter can be: ENABLE or DISABLE.
    413            * @retval None
    414            */
    415          void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
    416          {
    417            /* Check the parameters */
    418            assert_param(IS_USART_ALL_PERIPH(USARTx));
    419            assert_param(IS_FUNCTIONAL_STATE(NewState));
    420            
    421            if (NewState != DISABLE)
    422            {
    423              /* Enable the selected USART by setting the UE bit in the CR1 register */
    424              USARTx->CR1 |= USART_CR1_UE;
    425            }
    426            else
    427            {
    428              /* Disable the selected USART by clearing the UE bit in the CR1 register */
    429              USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
    430            }
    431          }
    432          
    433          /**
    434            * @brief  Sets the system clock prescaler.
    435            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    436            *         UART peripheral.
    437            * @param  USART_Prescaler: specifies the prescaler clock. 
    438            * @note   The function is used for IrDA mode with UART4 and UART5.   
    439            * @retval None
    440            */
    441          void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
    442          { 
    443            /* Check the parameters */
    444            assert_param(IS_USART_ALL_PERIPH(USARTx));
    445            
    446            /* Clear the USART prescaler */
    447            USARTx->GTPR &= USART_GTPR_GT;
    448            /* Set the USART prescaler */
    449            USARTx->GTPR |= USART_Prescaler;
    450          }
    451          
    452          /**
    453            * @brief  Enables or disables the USART's 8x oversampling mode.
    454            * @note   This function has to be called before calling USART_Init() function
    455            *         in order to have correct baudrate Divider value.
    456            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    457            *         UART peripheral.
    458            * @param  NewState: new state of the USART 8x oversampling mode.
    459            *          This parameter can be: ENABLE or DISABLE.
    460            * @retval None
    461            */
    462          void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
    463          {
    464            /* Check the parameters */
    465            assert_param(IS_USART_ALL_PERIPH(USARTx));
    466            assert_param(IS_FUNCTIONAL_STATE(NewState));
    467            
    468            if (NewState != DISABLE)
    469            {
    470              /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    471              USARTx->CR1 |= USART_CR1_OVER8;
    472            }
    473            else
    474            {
    475              /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
    476              USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
    477            }
    478          }  
    479          
    480          /**
    481            * @brief  Enables or disables the USART's one bit sampling method.
    482            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    483            *         UART peripheral.
    484            * @param  NewState: new state of the USART one bit sampling method.
    485            *          This parameter can be: ENABLE or DISABLE.
    486            * @retval None
    487            */
    488          void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    489          {
    490            /* Check the parameters */
    491            assert_param(IS_USART_ALL_PERIPH(USARTx));
    492            assert_param(IS_FUNCTIONAL_STATE(NewState));
    493            
    494            if (NewState != DISABLE)
    495            {
    496              /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    497              USARTx->CR3 |= USART_CR3_ONEBIT;
    498            }
    499            else
    500            {
    501              /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
    502              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
    503            }
    504          }
    505          
    506          /**
    507            * @}
    508            */
    509          
    510          /** @defgroup USART_Group2 Data transfers functions
    511           *  @brief   Data transfers functions 
    512           *
    513          @verbatim   
    514           ===============================================================================
    515                                      Data transfers functions
    516           ===============================================================================  
    517          
    518            This subsection provides a set of functions allowing to manage the USART data 
    519            transfers.
    520            
    521            During an USART reception, data shifts in least significant bit first through 
    522            the RX pin. In this mode, the USART_DR register consists of a buffer (RDR) 
    523            between the internal bus and the received shift register.
    524          
    525            When a transmission is taking place, a write instruction to the USART_DR register 
    526            stores the data in the TDR register and which is copied in the shift register 
    527            at the end of the current transmission.
    528          
    529            The read access of the USART_DR register can be done using the USART_ReceiveData()
    530            function and returns the RDR buffered value. Whereas a write access to the USART_DR 
    531            can be done using USART_SendData() function and stores the written data into 
    532            TDR buffer.
    533          
    534          @endverbatim
    535            * @{
    536            */
    537          
    538          /**
    539            * @brief  Transmits single data through the USARTx peripheral.
    540            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    541            *         UART peripheral.
    542            * @param  Data: the data to transmit.
    543            * @retval None
    544            */
    545          void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
    546          {
    547            /* Check the parameters */
    548            assert_param(IS_USART_ALL_PERIPH(USARTx));
    549            assert_param(IS_USART_DATA(Data)); 
    550              
    551            /* Transmit Data */
    552            USARTx->DR = (Data & (uint16_t)0x01FF);
    553          }
    554          
    555          /**
    556            * @brief  Returns the most recent received data by the USARTx peripheral.
    557            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    558            *         UART peripheral.
    559            * @retval The received data.
    560            */
    561          uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
    562          {
    563            /* Check the parameters */
    564            assert_param(IS_USART_ALL_PERIPH(USARTx));
    565            
    566            /* Receive Data */
    567            return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
    568          }
    569          
    570          /**
    571            * @}
    572            */
    573          
    574          /** @defgroup USART_Group3 MultiProcessor Communication functions
    575           *  @brief   Multi-Processor Communication functions 
    576           *
    577          @verbatim   
    578           ===============================================================================
    579                              Multi-Processor Communication functions
    580           ===============================================================================  
    581          
    582            This subsection provides a set of functions allowing to manage the USART 
    583            multiprocessor communication.
    584            
    585            For instance one of the USARTs can be the master, its TX output is connected to 
    586            the RX input of the other USART. The others are slaves, their respective TX outputs 
    587            are logically ANDed together and connected to the RX input of the master.
    588          
    589            USART multiprocessor communication is possible through the following procedure:
    590               1. Program the Baud rate, Word length = 9 bits, Stop bits, Parity, Mode transmitter 
    591                  or Mode receiver and hardware flow control values using the USART_Init()
    592                  function.
    593               2. Configures the USART address using the USART_SetAddress() function.
    594               3. Configures the wake up method (USART_WakeUp_IdleLine or USART_WakeUp_AddressMark)
    595                  using USART_WakeUpConfig() function only for the slaves.
    596               4. Enable the USART using the USART_Cmd() function.
    597               5. Enter the USART slaves in mute mode using USART_ReceiverWakeUpCmd() function.
    598          
    599            The USART Slave exit from mute mode when receive the wake up condition.
    600          
    601          @endverbatim
    602            * @{
    603            */
    604          
    605          /**
    606            * @brief  Sets the address of the USART node.
    607            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    608            *         UART peripheral.
    609            * @param  USART_Address: Indicates the address of the USART node.
    610            * @retval None
    611            */
    612          void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
    613          {
    614            /* Check the parameters */
    615            assert_param(IS_USART_ALL_PERIPH(USARTx));
    616            assert_param(IS_USART_ADDRESS(USART_Address)); 
    617              
    618            /* Clear the USART address */
    619            USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
    620            /* Set the USART address node */
    621            USARTx->CR2 |= USART_Address;
    622          }
    623          
    624          /**
    625            * @brief  Determines if the USART is in mute mode or not.
    626            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    627            *         UART peripheral.
    628            * @param  NewState: new state of the USART mute mode.
    629            *          This parameter can be: ENABLE or DISABLE.
    630            * @retval None
    631            */
    632          void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    633          {
    634            /* Check the parameters */
    635            assert_param(IS_USART_ALL_PERIPH(USARTx));
    636            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
    637            
    638            if (NewState != DISABLE)
    639            {
    640              /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
    641              USARTx->CR1 |= USART_CR1_RWU;
    642            }
    643            else
    644            {
    645              /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
    646              USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
    647            }
    648          }
    649          /**
    650            * @brief  Selects the USART WakeUp method.
    651            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    652            *         UART peripheral.
    653            * @param  USART_WakeUp: specifies the USART wakeup method.
    654            *          This parameter can be one of the following values:
    655            *            @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
    656            *            @arg USART_WakeUp_AddressMark: WakeUp by an address mark
    657            * @retval None
    658            */
    659          void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
    660          {
    661            /* Check the parameters */
    662            assert_param(IS_USART_ALL_PERIPH(USARTx));
    663            assert_param(IS_USART_WAKEUP(USART_WakeUp));
    664            
    665            USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
    666            USARTx->CR1 |= USART_WakeUp;
    667          }
    668          
    669          /**
    670            * @}
    671            */
    672          
    673          /** @defgroup USART_Group4 LIN mode functions
    674           *  @brief   LIN mode functions 
    675           *
    676          @verbatim   
    677           ===============================================================================
    678                                          LIN mode functions
    679           ===============================================================================  
    680          
    681            This subsection provides a set of functions allowing to manage the USART LIN 
    682            Mode communication.
    683            
    684            In LIN mode, 8-bit data format with 1 stop bit is required in accordance with 
    685            the LIN standard.
    686          
    687            Only this LIN Feature is supported by the USART IP:
    688              - LIN Master Synchronous Break send capability and LIN slave break detection
    689                capability :  13-bit break generation and 10/11 bit break detection
    690          
    691          
    692            USART LIN Master transmitter communication is possible through the following procedure:
    693               1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
    694                  Mode transmitter or Mode receiver and hardware flow control values using 
    695                  the USART_Init() function.
    696               2. Enable the USART using the USART_Cmd() function.
    697               3. Enable the LIN mode using the USART_LINCmd() function.
    698               4. Send the break character using USART_SendBreak() function.
    699          
    700            USART LIN Master receiver communication is possible through the following procedure:
    701               1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
    702                  Mode transmitter or Mode receiver and hardware flow control values using 
    703                  the USART_Init() function.
    704               2. Enable the USART using the USART_Cmd() function.
    705               3. Configures the break detection length using the USART_LINBreakDetectLengthConfig()
    706                  function.
    707               4. Enable the LIN mode using the USART_LINCmd() function.
    708          
    709          
    710          @note In LIN mode, the following bits must be kept cleared:
    711                  - CLKEN in the USART_CR2 register,
    712                  - STOP[1:0], SCEN, HDSEL and IREN in the USART_CR3 register.
    713          
    714          @endverbatim
    715            * @{
    716            */
    717          
    718          /**
    719            * @brief  Sets the USART LIN Break detection length.
    720            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    721            *         UART peripheral.
    722            * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
    723            *          This parameter can be one of the following values:
    724            *            @arg USART_LINBreakDetectLength_10b: 10-bit break detection
    725            *            @arg USART_LINBreakDetectLength_11b: 11-bit break detection
    726            * @retval None
    727            */
    728          void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
    729          {
    730            /* Check the parameters */
    731            assert_param(IS_USART_ALL_PERIPH(USARTx));
    732            assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
    733            
    734            USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
    735            USARTx->CR2 |= USART_LINBreakDetectLength;  
    736          }
    737          
    738          /**
    739            * @brief  Enables or disables the USART's LIN mode.
    740            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    741            *         UART peripheral.
    742            * @param  NewState: new state of the USART LIN mode.
    743            *          This parameter can be: ENABLE or DISABLE.
    744            * @retval None
    745            */
    746          void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    747          {
    748            /* Check the parameters */
    749            assert_param(IS_USART_ALL_PERIPH(USARTx));
    750            assert_param(IS_FUNCTIONAL_STATE(NewState));
    751            
    752            if (NewState != DISABLE)
    753            {
    754              /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    755              USARTx->CR2 |= USART_CR2_LINEN;
    756            }
    757            else
    758            {
    759              /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    760              USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
    761            }
    762          }
    763          
    764          /**
    765            * @brief  Transmits break characters.
    766            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    767            *         UART peripheral.
    768            * @retval None
    769            */
    770          void USART_SendBreak(USART_TypeDef* USARTx)
    771          {
    772            /* Check the parameters */
    773            assert_param(IS_USART_ALL_PERIPH(USARTx));
    774            
    775            /* Send break characters */
    776            USARTx->CR1 |= USART_CR1_SBK;
    777          }
    778          
    779          /**
    780            * @}
    781            */
    782          
    783          /** @defgroup USART_Group5 Halfduplex mode function
    784           *  @brief   Half-duplex mode function 
    785           *
    786          @verbatim   
    787           ===============================================================================
    788                                   Half-duplex mode function
    789           ===============================================================================  
    790          
    791            This subsection provides a set of functions allowing to manage the USART 
    792            Half-duplex communication.
    793            
    794            The USART can be configured to follow a single-wire half-duplex protocol where 
    795            the TX and RX lines are internally connected.
    796          
    797            USART Half duplex communication is possible through the following procedure:
    798               1. Program the Baud rate, Word length, Stop bits, Parity, Mode transmitter 
    799                  or Mode receiver and hardware flow control values using the USART_Init()
    800                  function.
    801               2. Configures the USART address using the USART_SetAddress() function.
    802               3. Enable the USART using the USART_Cmd() function.
    803               4. Enable the half duplex mode using USART_HalfDuplexCmd() function.
    804          
    805          
    806          @note The RX pin is no longer used
    807          @note In Half-duplex mode the following bits must be kept cleared:
    808                  - LINEN and CLKEN bits in the USART_CR2 register.
    809                  - SCEN and IREN bits in the USART_CR3 register.
    810          
    811          @endverbatim
    812            * @{
    813            */
    814          
    815          /**
    816            * @brief  Enables or disables the USART's Half Duplex communication.
    817            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    818            *         UART peripheral.
    819            * @param  NewState: new state of the USART Communication.
    820            *          This parameter can be: ENABLE or DISABLE.
    821            * @retval None
    822            */
    823          void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    824          {
    825            /* Check the parameters */
    826            assert_param(IS_USART_ALL_PERIPH(USARTx));
    827            assert_param(IS_FUNCTIONAL_STATE(NewState));
    828            
    829            if (NewState != DISABLE)
    830            {
    831              /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    832              USARTx->CR3 |= USART_CR3_HDSEL;
    833            }
    834            else
    835            {
    836              /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    837              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
    838            }
    839          }
    840          
    841          /**
    842            * @}
    843            */
    844          
    845          
    846          /** @defgroup USART_Group6 Smartcard mode functions
    847           *  @brief   Smartcard mode functions 
    848           *
    849          @verbatim   
    850           ===============================================================================
    851                                         Smartcard mode functions
    852           ===============================================================================  
    853          
    854            This subsection provides a set of functions allowing to manage the USART 
    855            Smartcard communication.
    856            
    857            The Smartcard interface is designed to support asynchronous protocol Smartcards as
    858            defined in the ISO 7816-3 standard.
    859          
    860            The USART can provide a clock to the smartcard through the SCLK output.
    861            In smartcard mode, SCLK is not associated to the communication but is simply derived 
    862            from the internal peripheral input clock through a 5-bit prescaler.
    863          
    864            Smartcard communication is possible through the following procedure:
    865               1. Configures the Smartcard Prescaler using the USART_SetPrescaler() function.
    866               2. Configures the Smartcard Guard Time using the USART_SetGuardTime() function.
    867               3. Program the USART clock using the USART_ClockInit() function as following:
    868                  - USART Clock enabled
    869                  - USART CPOL Low
    870                  - USART CPHA on first edge
    871                  - USART Last Bit Clock Enabled
    872               4. Program the Smartcard interface using the USART_Init() function as following:
    873                  - Word Length = 9 Bits
    874                  - 1.5 Stop Bit
    875                  - Even parity
    876                  - BaudRate = 12096 baud
    877                  - Hardware flow control disabled (RTS and CTS signals)
    878                  - Tx and Rx enabled
    879               5. Optionally you can enable the parity error interrupt using the USART_ITConfig()
    880                  function
    881               6. Enable the USART using the USART_Cmd() function.
    882               7. Enable the Smartcard NACK using the USART_SmartCardNACKCmd() function.
    883               8. Enable the Smartcard interface using the USART_SmartCardCmd() function.
    884          
    885            Please refer to the ISO 7816-3 specification for more details.
    886          
    887          
    888          @note It is also possible to choose 0.5 stop bit for receiving but it is recommended 
    889                to use 1.5 stop bits for both transmitting and receiving to avoid switching 
    890                between the two configurations.
    891          @note In smartcard mode, the following bits must be kept cleared:
    892                  - LINEN bit in the USART_CR2 register.
    893                  - HDSEL and IREN bits in the USART_CR3 register.
    894          @note Smartcard mode is available on USART peripherals only (not available on UART4 
    895                and UART5 peripherals).
    896          
    897          @endverbatim
    898            * @{
    899            */
    900          
    901          /**
    902            * @brief  Sets the specified USART guard time.
    903            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    904            *         UART peripheral.
    905            * @param  USART_GuardTime: specifies the guard time.   
    906            * @retval None
    907            */
    908          void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
    909          {    
    910            /* Check the parameters */
    911            assert_param(IS_USART_1236_PERIPH(USARTx));
    912            
    913            /* Clear the USART Guard time */
    914            USARTx->GTPR &= USART_GTPR_PSC;
    915            /* Set the USART guard time */
    916            USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
    917          }
    918          
    919          /**
    920            * @brief  Enables or disables the USART's Smart Card mode.
    921            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    922            *         UART peripheral.
    923            * @param  NewState: new state of the Smart Card mode.
    924            *          This parameter can be: ENABLE or DISABLE.      
    925            * @retval None
    926            */
    927          void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    928          {
    929            /* Check the parameters */
    930            assert_param(IS_USART_1236_PERIPH(USARTx));
    931            assert_param(IS_FUNCTIONAL_STATE(NewState));
    932            if (NewState != DISABLE)
    933            {
    934              /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    935              USARTx->CR3 |= USART_CR3_SCEN;
    936            }
    937            else
    938            {
    939              /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    940              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
    941            }
    942          }
    943          
    944          /**
    945            * @brief  Enables or disables NACK transmission.
    946            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    947            *         UART peripheral.
    948            * @param  NewState: new state of the NACK transmission.
    949            *          This parameter can be: ENABLE or DISABLE.  
    950            * @retval None
    951            */
    952          void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    953          {
    954            /* Check the parameters */
    955            assert_param(IS_USART_1236_PERIPH(USARTx)); 
    956            assert_param(IS_FUNCTIONAL_STATE(NewState));
    957            if (NewState != DISABLE)
    958            {
    959              /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    960              USARTx->CR3 |= USART_CR3_NACK;
    961            }
    962            else
    963            {
    964              /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    965              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
    966            }
    967          }
    968          
    969          /**
    970            * @}
    971            */
    972          
    973          /** @defgroup USART_Group7 IrDA mode functions
    974           *  @brief   IrDA mode functions 
    975           *
    976          @verbatim   
    977           ===============================================================================
    978                                          IrDA mode functions
    979           ===============================================================================  
    980          
    981            This subsection provides a set of functions allowing to manage the USART 
    982            IrDA communication.
    983            
    984            IrDA is a half duplex communication protocol. If the Transmitter is busy, any data
    985            on the IrDA receive line will be ignored by the IrDA decoder and if the Receiver 
    986            is busy, data on the TX from the USART to IrDA will not be encoded by IrDA.
    987            While receiving data, transmission should be avoided as the data to be transmitted
    988            could be corrupted.
    989          
    990            IrDA communication is possible through the following procedure:
    991               1. Program the Baud rate, Word length = 8 bits, Stop bits, Parity, Transmitter/Receiver 
    992                  modes and hardware flow control values using the USART_Init() function.
    993               2. Enable the USART using the USART_Cmd() function.
    994               3. Configures the IrDA pulse width by configuring the prescaler using  
    995                  the USART_SetPrescaler() function.
    996               4. Configures the IrDA  USART_IrDAMode_LowPower or USART_IrDAMode_Normal mode
    997                  using the USART_IrDAConfig() function.
    998               5. Enable the IrDA using the USART_IrDACmd() function.
    999          
   1000          @note A pulse of width less than two and greater than one PSC period(s) may or may
   1001                not be rejected.
   1002          @note The receiver set up time should be managed by software. The IrDA physical layer
   1003                specification specifies a minimum of 10 ms delay between transmission and 
   1004                reception (IrDA is a half duplex protocol).
   1005          @note In IrDA mode, the following bits must be kept cleared:
   1006                  - LINEN, STOP and CLKEN bits in the USART_CR2 register.
   1007                  - SCEN and HDSEL bits in the USART_CR3 register.
   1008          
   1009          @endverbatim
   1010            * @{
   1011            */
   1012          
   1013          /**
   1014            * @brief  Configures the USART's IrDA interface.
   1015            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1016            *         UART peripheral.
   1017            * @param  USART_IrDAMode: specifies the IrDA mode.
   1018            *          This parameter can be one of the following values:
   1019            *            @arg USART_IrDAMode_LowPower
   1020            *            @arg USART_IrDAMode_Normal
   1021            * @retval None
   1022            */
   1023          void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
   1024          {
   1025            /* Check the parameters */
   1026            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1027            assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
   1028              
   1029            USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
   1030            USARTx->CR3 |= USART_IrDAMode;
   1031          }
   1032          
   1033          /**
   1034            * @brief  Enables or disables the USART's IrDA interface.
   1035            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1036            *         UART peripheral.
   1037            * @param  NewState: new state of the IrDA mode.
   1038            *          This parameter can be: ENABLE or DISABLE.
   1039            * @retval None
   1040            */
   1041          void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
   1042          {
   1043            /* Check the parameters */
   1044            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1045            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1046              
   1047            if (NewState != DISABLE)
   1048            {
   1049              /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
   1050              USARTx->CR3 |= USART_CR3_IREN;
   1051            }
   1052            else
   1053            {
   1054              /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
   1055              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
   1056            }
   1057          }
   1058          
   1059          /**
   1060            * @}
   1061            */
   1062          
   1063          /** @defgroup USART_Group8 DMA transfers management functions
   1064           *  @brief   DMA transfers management functions
   1065           *
   1066          @verbatim   
   1067           ===============================================================================
   1068                                DMA transfers management functions
   1069           ===============================================================================  
   1070          
   1071          @endverbatim
   1072            * @{
   1073            */
   1074            
   1075          /**
   1076            * @brief  Enables or disables the USART's DMA interface.
   1077            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1078            *         UART peripheral.
   1079            * @param  USART_DMAReq: specifies the DMA request.
   1080            *          This parameter can be any combination of the following values:
   1081            *            @arg USART_DMAReq_Tx: USART DMA transmit request
   1082            *            @arg USART_DMAReq_Rx: USART DMA receive request
   1083            * @param  NewState: new state of the DMA Request sources.
   1084            *          This parameter can be: ENABLE or DISABLE.   
   1085            * @retval None
   1086            */
   1087          void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
   1088          {
   1089            /* Check the parameters */
   1090            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1091            assert_param(IS_USART_DMAREQ(USART_DMAReq));  
   1092            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
   1093          
   1094            if (NewState != DISABLE)
   1095            {
   1096              /* Enable the DMA transfer for selected requests by setting the DMAT and/or
   1097                 DMAR bits in the USART CR3 register */
   1098              USARTx->CR3 |= USART_DMAReq;
   1099            }
   1100            else
   1101            {
   1102              /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
   1103                 DMAR bits in the USART CR3 register */
   1104              USARTx->CR3 &= (uint16_t)~USART_DMAReq;
   1105            }
   1106          }
   1107          
   1108          /**
   1109            * @}
   1110            */
   1111            
   1112          /** @defgroup USART_Group9 Interrupts and flags management functions
   1113           *  @brief   Interrupts and flags management functions 
   1114           *
   1115          @verbatim   
   1116           ===============================================================================
   1117                             Interrupts and flags management functions
   1118           ===============================================================================  
   1119          
   1120            This subsection provides a set of functions allowing to configure the USART 
   1121            Interrupts sources, DMA channels requests and check or clear the flags or 
   1122            pending bits status.
   1123            The user should identify which mode will be used in his application to manage 
   1124            the communication: Polling mode, Interrupt mode or DMA mode. 
   1125              
   1126            Polling Mode
   1127            =============
   1128            In Polling Mode, the SPI communication can be managed by 10 flags:
   1129               1. USART_FLAG_TXE : to indicate the status of the transmit buffer register
   1130               2. USART_FLAG_RXNE : to indicate the status of the receive buffer register
   1131               3. USART_FLAG_TC : to indicate the status of the transmit operation
   1132               4. USART_FLAG_IDLE : to indicate the status of the Idle Line             
   1133               5. USART_FLAG_CTS : to indicate the status of the nCTS input
   1134               6. USART_FLAG_LBD : to indicate the status of the LIN break detection
   1135               7. USART_FLAG_NE : to indicate if a noise error occur
   1136               8. USART_FLAG_FE : to indicate if a frame error occur
   1137               9. USART_FLAG_PE : to indicate if a parity error occur
   1138               10. USART_FLAG_ORE : to indicate if an Overrun error occur
   1139          
   1140            In this Mode it is advised to use the following functions:
   1141                - FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
   1142                - void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
   1143          
   1144            Interrupt Mode
   1145            ===============
   1146            In Interrupt Mode, the USART communication can be managed by 8 interrupt sources
   1147            and 10 pending bits: 
   1148          
   1149            Pending Bits:
   1150            ------------- 
   1151               1. USART_IT_TXE : to indicate the status of the transmit buffer register
   1152               2. USART_IT_RXNE : to indicate the status of the receive buffer register
   1153               3. USART_IT_TC : to indicate the status of the transmit operation
   1154               4. USART_IT_IDLE : to indicate the status of the Idle Line             
   1155               5. USART_IT_CTS : to indicate the status of the nCTS input
   1156               6. USART_IT_LBD : to indicate the status of the LIN break detection
   1157               7. USART_IT_NE : to indicate if a noise error occur
   1158               8. USART_IT_FE : to indicate if a frame error occur
   1159               9. USART_IT_PE : to indicate if a parity error occur
   1160               10. USART_IT_ORE : to indicate if an Overrun error occur
   1161          
   1162            Interrupt Source:
   1163            -----------------
   1164               1. USART_IT_TXE : specifies the interrupt source for the Tx buffer empty 
   1165                                 interrupt. 
   1166               2. USART_IT_RXNE : specifies the interrupt source for the Rx buffer not 
   1167                                  empty interrupt.
   1168               3. USART_IT_TC : specifies the interrupt source for the Transmit complete 
   1169                                 interrupt. 
   1170               4. USART_IT_IDLE : specifies the interrupt source for the Idle Line interrupt.             
   1171               5. USART_IT_CTS : specifies the interrupt source for the CTS interrupt. 
   1172               6. USART_IT_LBD : specifies the interrupt source for the LIN break detection
   1173                                 interrupt. 
   1174               7. USART_IT_PE : specifies the interrupt source for the parity error interrupt. 
   1175               8. USART_IT_ERR :  specifies the interrupt source for the errors interrupt.
   1176          
   1177          @note Some parameters are coded in order to use them as interrupt source or as pending bits.
   1178          
   1179            In this Mode it is advised to use the following functions:
   1180               - void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
   1181               - ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
   1182               - void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
   1183          
   1184            DMA Mode
   1185            ========
   1186            In DMA Mode, the USART communication can be managed by 2 DMA Channel requests:
   1187               1. USART_DMAReq_Tx: specifies the Tx buffer DMA transfer request
   1188               2. USART_DMAReq_Rx: specifies the Rx buffer DMA transfer request
   1189          
   1190            In this Mode it is advised to use the following function:
   1191               - void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
   1192          
   1193          @endverbatim
   1194            * @{
   1195            */
   1196          
   1197          /**
   1198            * @brief  Enables or disables the specified USART interrupts.
   1199            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1200            *         UART peripheral.
   1201            * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
   1202            *          This parameter can be one of the following values:
   1203            *            @arg USART_IT_CTS:  CTS change interrupt
   1204            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1205            *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
   1206            *            @arg USART_IT_TC:   Transmission complete interrupt
   1207            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
   1208            *            @arg USART_IT_IDLE: Idle line detection interrupt
   1209            *            @arg USART_IT_PE:   Parity Error interrupt
   1210            *            @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
   1211            * @param  NewState: new state of the specified USARTx interrupts.
   1212            *          This parameter can be: ENABLE or DISABLE.
   1213            * @retval None
   1214            */
   1215          void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
   1216          {
   1217            uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
   1218            uint32_t usartxbase = 0x00;
   1219            /* Check the parameters */
   1220            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1221            assert_param(IS_USART_CONFIG_IT(USART_IT));
   1222            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1223          
   1224            /* The CTS interrupt is not available for UART4 and UART5 */
   1225            if (USART_IT == USART_IT_CTS)
   1226            {
   1227              assert_param(IS_USART_1236_PERIPH(USARTx));
   1228            } 
   1229              
   1230            usartxbase = (uint32_t)USARTx;
   1231          
   1232            /* Get the USART register index */
   1233            usartreg = (((uint8_t)USART_IT) >> 0x05);
   1234          
   1235            /* Get the interrupt position */
   1236            itpos = USART_IT & IT_MASK;
   1237            itmask = (((uint32_t)0x01) << itpos);
   1238              
   1239            if (usartreg == 0x01) /* The IT is in CR1 register */
   1240            {
   1241              usartxbase += 0x0C;
   1242            }
   1243            else if (usartreg == 0x02) /* The IT is in CR2 register */
   1244            {
   1245              usartxbase += 0x10;
   1246            }
   1247            else /* The IT is in CR3 register */
   1248            {
   1249              usartxbase += 0x14; 
   1250            }
   1251            if (NewState != DISABLE)
   1252            {
   1253              *(__IO uint32_t*)usartxbase  |= itmask;
   1254            }
   1255            else
   1256            {
   1257              *(__IO uint32_t*)usartxbase &= ~itmask;
   1258            }
   1259          }
   1260          
   1261          /**
   1262            * @brief  Checks whether the specified USART flag is set or not.
   1263            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1264            *         UART peripheral.
   1265            * @param  USART_FLAG: specifies the flag to check.
   1266            *          This parameter can be one of the following values:
   1267            *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
   1268            *            @arg USART_FLAG_LBD:  LIN Break detection flag
   1269            *            @arg USART_FLAG_TXE:  Transmit data register empty flag
   1270            *            @arg USART_FLAG_TC:   Transmission Complete flag
   1271            *            @arg USART_FLAG_RXNE: Receive data register not empty flag
   1272            *            @arg USART_FLAG_IDLE: Idle Line detection flag
   1273            *            @arg USART_FLAG_ORE:  OverRun Error flag
   1274            *            @arg USART_FLAG_NE:   Noise Error flag
   1275            *            @arg USART_FLAG_FE:   Framing Error flag
   1276            *            @arg USART_FLAG_PE:   Parity Error flag
   1277            * @retval The new state of USART_FLAG (SET or RESET).
   1278            */
   1279          FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
   1280          {
   1281            FlagStatus bitstatus = RESET;
   1282            /* Check the parameters */
   1283            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1284            assert_param(IS_USART_FLAG(USART_FLAG));
   1285          
   1286            /* The CTS flag is not available for UART4 and UART5 */
   1287            if (USART_FLAG == USART_FLAG_CTS)
   1288            {
   1289              assert_param(IS_USART_1236_PERIPH(USARTx));
   1290            } 
   1291              
   1292            if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
   1293            {
   1294              bitstatus = SET;
   1295            }
   1296            else
   1297            {
   1298              bitstatus = RESET;
   1299            }
   1300            return bitstatus;
   1301          }
   1302          
   1303          /**
   1304            * @brief  Clears the USARTx's pending flags.
   1305            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1306            *         UART peripheral.
   1307            * @param  USART_FLAG: specifies the flag to clear.
   1308            *          This parameter can be any combination of the following values:
   1309            *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
   1310            *            @arg USART_FLAG_LBD:  LIN Break detection flag.
   1311            *            @arg USART_FLAG_TC:   Transmission Complete flag.
   1312            *            @arg USART_FLAG_RXNE: Receive data register not empty flag.
   1313            *   
   1314            * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
   1315            *          error) and IDLE (Idle line detected) flags are cleared by software 
   1316            *          sequence: a read operation to USART_SR register (USART_GetFlagStatus()) 
   1317            *          followed by a read operation to USART_DR register (USART_ReceiveData()).
   1318            * @note   RXNE flag can be also cleared by a read to the USART_DR register 
   1319            *          (USART_ReceiveData()).
   1320            * @note   TC flag can be also cleared by software sequence: a read operation to 
   1321            *          USART_SR register (USART_GetFlagStatus()) followed by a write operation
   1322            *          to USART_DR register (USART_SendData()).
   1323            * @note   TXE flag is cleared only by a write to the USART_DR register 
   1324            *          (USART_SendData()).
   1325            *   
   1326            * @retval None
   1327            */
   1328          void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
   1329          {
   1330            /* Check the parameters */
   1331            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1332            assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
   1333          
   1334            /* The CTS flag is not available for UART4 and UART5 */
   1335            if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
   1336            {
   1337              assert_param(IS_USART_1236_PERIPH(USARTx));
   1338            } 
   1339                 
   1340            USARTx->SR = (uint16_t)~USART_FLAG;
   1341          }
   1342          
   1343          /**
   1344            * @brief  Checks whether the specified USART interrupt has occurred or not.
   1345            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1346            *         UART peripheral.
   1347            * @param  USART_IT: specifies the USART interrupt source to check.
   1348            *          This parameter can be one of the following values:
   1349            *            @arg USART_IT_CTS    : CTS change interrupt (not available for UART4 and UART5)
   1350            *            @arg USART_IT_LBD    : LIN Break detection interrupt
   1351            *            @arg USART_IT_TXE    : Transmit Data Register empty interrupt
   1352            *            @arg USART_IT_TC     : Transmission complete interrupt
   1353            *            @arg USART_IT_RXNE   : Receive Data register not empty interrupt
   1354            *            @arg USART_IT_IDLE   : Idle line detection interrupt
   1355            *            @arg USART_IT_ORE_RX : OverRun Error interrupt if the RXNEIE bit is set
   1356            *            @arg USART_IT_ORE_ER : OverRun Error interrupt if the EIE bit is set  
   1357            *            @arg USART_IT_NE     : Noise Error interrupt
   1358            *            @arg USART_IT_FE     : Framing Error interrupt
   1359            *            @arg USART_IT_PE     : Parity Error interrupt
   1360            * @retval The new state of USART_IT (SET or RESET).
   1361            */
   1362          ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
   1363          {
   1364            uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
   1365            ITStatus bitstatus = RESET;
   1366            /* Check the parameters */
   1367            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1368            assert_param(IS_USART_GET_IT(USART_IT)); 
   1369          
   1370            /* The CTS interrupt is not available for UART4 and UART5 */ 
   1371            if (USART_IT == USART_IT_CTS)
   1372            {
   1373              assert_param(IS_USART_1236_PERIPH(USARTx));
   1374            } 
   1375              
   1376            /* Get the USART register index */
   1377            usartreg = (((uint8_t)USART_IT) >> 0x05);
   1378            /* Get the interrupt position */
   1379            itmask = USART_IT & IT_MASK;
   1380            itmask = (uint32_t)0x01 << itmask;
   1381            
   1382            if (usartreg == 0x01) /* The IT  is in CR1 register */
   1383            {
   1384              itmask &= USARTx->CR1;
   1385            }
   1386            else if (usartreg == 0x02) /* The IT  is in CR2 register */
   1387            {
   1388              itmask &= USARTx->CR2;
   1389            }
   1390            else /* The IT  is in CR3 register */
   1391            {
   1392              itmask &= USARTx->CR3;
   1393            }
   1394            
   1395            bitpos = USART_IT >> 0x08;
   1396            bitpos = (uint32_t)0x01 << bitpos;
   1397            bitpos &= USARTx->SR;
   1398            if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
   1399            {
   1400              bitstatus = SET;
   1401            }
   1402            else
   1403            {
   1404              bitstatus = RESET;
   1405            }
   1406            
   1407            return bitstatus;  
   1408          }
   1409          
   1410          /**
   1411            * @brief  Clears the USARTx's interrupt pending bits.
   1412            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1413            *         UART peripheral.
   1414            * @param  USART_IT: specifies the interrupt pending bit to clear.
   1415            *          This parameter can be one of the following values:
   1416            *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
   1417            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1418            *            @arg USART_IT_TC:   Transmission complete interrupt. 
   1419            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt.
   1420            *
   1421            * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
   1422            *          error) and IDLE (Idle line detected) pending bits are cleared by 
   1423            *          software sequence: a read operation to USART_SR register 
   1424            *          (USART_GetITStatus()) followed by a read operation to USART_DR register 
   1425            *          (USART_ReceiveData()).
   1426            * @note   RXNE pending bit can be also cleared by a read to the USART_DR register 
   1427            *          (USART_ReceiveData()).
   1428            * @note   TC pending bit can be also cleared by software sequence: a read 
   1429            *          operation to USART_SR register (USART_GetITStatus()) followed by a write 
   1430            *          operation to USART_DR register (USART_SendData()).
   1431            * @note   TXE pending bit is cleared only by a write to the USART_DR register 
   1432            *          (USART_SendData()).
   1433            *  
   1434            * @retval None
   1435            */
   1436          void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
   1437          {
   1438            uint16_t bitpos = 0x00, itmask = 0x00;
   1439            /* Check the parameters */
   1440            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1441            assert_param(IS_USART_CLEAR_IT(USART_IT)); 
   1442          
   1443            /* The CTS interrupt is not available for UART4 and UART5 */
   1444            if (USART_IT == USART_IT_CTS)
   1445            {
   1446              assert_param(IS_USART_1236_PERIPH(USARTx));
   1447            } 
   1448              
   1449            bitpos = USART_IT >> 0x08;
   1450            itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
   1451            USARTx->SR = (uint16_t)~itmask;
   1452          }
   1453          
   1454          /**
   1455            * @}
   1456            */
   1457          
   1458          /**
   1459            * @}
   1460            */
   1461          
   1462          /**
   1463            * @}
   1464            */
   1465          
   1466          /**
   1467            * @}
   1468            */
   1469          
   1470          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   USART_ClearFlag
      12   USART_ClearITPendingBit
       8   USART_ClockInit
       0   USART_ClockStructInit
       0   USART_Cmd
       0   USART_DMACmd
       8   USART_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       0   USART_GetFlagStatus
      16   USART_GetITStatus
       0   USART_HalfDuplexCmd
      24   USART_ITConfig
      56   USART_Init
        56   -> RCC_GetClocksFreq
       0   USART_IrDACmd
       0   USART_IrDAConfig
       0   USART_LINBreakDetectLengthConfig
       0   USART_LINCmd
       0   USART_OneBitMethodCmd
       0   USART_OverSampling8Cmd
       0   USART_ReceiveData
       0   USART_ReceiverWakeUpCmd
       0   USART_SendBreak
       0   USART_SendData
       0   USART_SetAddress
       0   USART_SetGuardTime
       0   USART_SetPrescaler
       0   USART_SmartCardCmd
       0   USART_SmartCardNACKCmd
       0   USART_StructInit
       0   USART_WakeUpConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
      16  USART_ClearFlag
      38  USART_ClearITPendingBit
      32  USART_ClockInit
      18  USART_ClockStructInit
      30  USART_Cmd
      24  USART_DMACmd
     164  USART_DeInit
      28  USART_GetFlagStatus
     106  USART_GetITStatus
      30  USART_HalfDuplexCmd
     112  USART_ITConfig
     214  USART_Init
      30  USART_IrDACmd
      18  USART_IrDAConfig
      18  USART_LINBreakDetectLengthConfig
      30  USART_LINCmd
      30  USART_OneBitMethodCmd
      28  USART_OverSampling8Cmd
       8  USART_ReceiveData
      30  USART_ReceiverWakeUpCmd
      10  USART_SendBreak
       8  USART_SendData
      22  USART_SetAddress
      22  USART_SetGuardTime
      20  USART_SetPrescaler
      30  USART_SmartCardCmd
      30  USART_SmartCardNACKCmd
      28  USART_StructInit
      18  USART_WakeUpConfig

 
 1'220 bytes in section .text
 
 1'220 bytes of CODE memory

Errors: none
Warnings: none
