###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         30/May/2020  18:12:43
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\SPL\src\stm32f10x_tim.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EW75F4.tmp
#        (D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\SPL\src\stm32f10x_tim.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D STM32F10X_LD -D USEUSB -lcN
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\.\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\freertos\source\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\freertos\source\port\ARM_CM3\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\SPL\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\stm_usb_fs_lib\inc\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\usb\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\board\ -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\List\stm32f10x_tim.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\Obj\stm32f10x_tim.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\SPL\src\stm32f10x_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_tim.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    11-March-2011
      7            * @brief   This file provides all the TIM firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f10x_tim.h"
     24          #include "stm32f10x_rcc.h"
     25          #include "stm32f10x_conf.h"
     26          
     27          /** @addtogroup STM32F10x_StdPeriph_Driver
     28            * @{
     29            */
     30          
     31          /** @defgroup TIM 
     32            * @brief TIM driver modules
     33            * @{
     34            */
     35          
     36          /** @defgroup TIM_Private_TypesDefinitions
     37            * @{
     38            */
     39          
     40          /**
     41            * @}
     42            */
     43          
     44          /** @defgroup TIM_Private_Defines
     45            * @{
     46            */
     47          
     48          /* ---------------------- TIM registers bit mask ------------------------ */
     49          #define SMCR_ETR_Mask               ((uint16_t)0x00FF) 
     50          #define CCMR_Offset                 ((uint16_t)0x0018)
     51          #define CCER_CCE_Set                ((uint16_t)0x0001)  
     52          #define	CCER_CCNE_Set               ((uint16_t)0x0004) 
     53          
     54          /**
     55            * @}
     56            */
     57          
     58          /** @defgroup TIM_Private_Macros
     59            * @{
     60            */
     61          
     62          /**
     63            * @}
     64            */
     65          
     66          /** @defgroup TIM_Private_Variables
     67            * @{
     68            */
     69          
     70          /**
     71            * @}
     72            */
     73          
     74          /** @defgroup TIM_Private_FunctionPrototypes
     75            * @{
     76            */
     77          
     78          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
     79                                 uint16_t TIM_ICFilter);
     80          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
     81                                 uint16_t TIM_ICFilter);
     82          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
     83                                 uint16_t TIM_ICFilter);
     84          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
     85                                 uint16_t TIM_ICFilter);
     86          /**
     87            * @}
     88            */
     89          
     90          /** @defgroup TIM_Private_Macros
     91            * @{
     92            */
     93          
     94          /**
     95            * @}
     96            */
     97          
     98          /** @defgroup TIM_Private_Variables
     99            * @{
    100            */
    101          
    102          /**
    103            * @}
    104            */
    105          
    106          /** @defgroup TIM_Private_FunctionPrototypes
    107            * @{
    108            */
    109          
    110          /**
    111            * @}
    112            */
    113          
    114          /** @defgroup TIM_Private_Functions
    115            * @{
    116            */
    117          
    118          /**
    119            * @brief  Deinitializes the TIMx peripheral registers to their default reset values.
    120            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
    121            * @retval None
    122            */
    123          void TIM_DeInit(TIM_TypeDef* TIMx)
    124          {
    125            /* Check the parameters */
    126            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    127           
    128            if (TIMx == TIM1)
    129            {
    130              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
    131              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
    132            }     
    133            else if (TIMx == TIM2)
    134            {
    135              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
    136              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
    137            }
    138            else if (TIMx == TIM3)
    139            {
    140              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
    141              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
    142            }
    143            else if (TIMx == TIM4)
    144            {
    145              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
    146              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
    147            } 
    148            else if (TIMx == TIM5)
    149            {
    150              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
    151              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
    152            } 
    153            else if (TIMx == TIM6)
    154            {
    155              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
    156              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
    157            } 
    158            else if (TIMx == TIM7)
    159            {
    160              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
    161              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
    162            } 
    163            else if (TIMx == TIM8)
    164            {
    165              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
    166              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);
    167            }
    168            else if (TIMx == TIM9)
    169            {      
    170              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
    171              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
    172             }  
    173            else if (TIMx == TIM10)
    174            {      
    175              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
    176              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
    177            }  
    178            else if (TIMx == TIM11) 
    179            {     
    180              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
    181              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
    182            }  
    183            else if (TIMx == TIM12)
    184            {      
    185              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
    186              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
    187            }  
    188            else if (TIMx == TIM13) 
    189            {       
    190              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
    191              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
    192            }
    193            else if (TIMx == TIM14) 
    194            {       
    195              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
    196              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE);  
    197            }        
    198            else if (TIMx == TIM15)
    199            {
    200              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
    201              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);
    202            } 
    203            else if (TIMx == TIM16)
    204            {
    205              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
    206              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);
    207            } 
    208            else
    209            {
    210              if (TIMx == TIM17)
    211              {
    212                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
    213                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);
    214              }  
    215            }
    216          }
    217          
    218          /**
    219            * @brief  Initializes the TIMx Time Base Unit peripheral according to 
    220            *         the specified parameters in the TIM_TimeBaseInitStruct.
    221            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
    222            * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
    223            *         structure that contains the configuration information for the 
    224            *         specified TIM peripheral.
    225            * @retval None
    226            */
    227          void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    228          {
    229            uint16_t tmpcr1 = 0;
    230          
    231            /* Check the parameters */
    232            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    233            assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
    234            assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
    235          
    236            tmpcr1 = TIMx->CR1;  
    237          
    238            if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
    239               (TIMx == TIM4) || (TIMx == TIM5)) 
    240            {
    241              /* Select the Counter Mode */
    242              tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
    243              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
    244            }
    245           
    246            if((TIMx != TIM6) && (TIMx != TIM7))
    247            {
    248              /* Set the clock division */
    249              tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
    250              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
    251            }
    252          
    253            TIMx->CR1 = tmpcr1;
    254          
    255            /* Set the Autoreload value */
    256            TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
    257           
    258            /* Set the Prescaler value */
    259            TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
    260              
    261            if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
    262            {
    263              /* Set the Repetition Counter value */
    264              TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
    265            }
    266          
    267            /* Generate an update event to reload the Prescaler and the Repetition counter
    268               values immediately */
    269            TIMx->EGR = TIM_PSCReloadMode_Immediate;           
    270          }
    271          
    272          /**
    273            * @brief  Initializes the TIMx Channel1 according to the specified
    274            *         parameters in the TIM_OCInitStruct.
    275            * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
    276            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    277            *         that contains the configuration information for the specified TIM peripheral.
    278            * @retval None
    279            */
    280          void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    281          {
    282            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    283             
    284            /* Check the parameters */
    285            assert_param(IS_TIM_LIST8_PERIPH(TIMx));
    286            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    287            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    288            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    289           /* Disable the Channel 1: Reset the CC1E Bit */
    290            TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
    291            /* Get the TIMx CCER register value */
    292            tmpccer = TIMx->CCER;
    293            /* Get the TIMx CR2 register value */
    294            tmpcr2 =  TIMx->CR2;
    295            
    296            /* Get the TIMx CCMR1 register value */
    297            tmpccmrx = TIMx->CCMR1;
    298              
    299            /* Reset the Output Compare Mode Bits */
    300            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
    301            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
    302          
    303            /* Select the Output Compare Mode */
    304            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    305            
    306            /* Reset the Output Polarity level */
    307            tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
    308            /* Set the Output Compare Polarity */
    309            tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
    310            
    311            /* Set the Output State */
    312            tmpccer |= TIM_OCInitStruct->TIM_OutputState;
    313              
    314            if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)||
    315               (TIMx == TIM16)|| (TIMx == TIM17))
    316            {
    317              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    318              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    319              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    320              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    321              
    322              /* Reset the Output N Polarity level */
    323              tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
    324              /* Set the Output N Polarity */
    325              tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
    326              
    327              /* Reset the Output N State */
    328              tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));    
    329              /* Set the Output N State */
    330              tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
    331              
    332              /* Reset the Output Compare and Output Compare N IDLE State */
    333              tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
    334              tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
    335              
    336              /* Set the Output Idle state */
    337              tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
    338              /* Set the Output N Idle state */
    339              tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
    340            }
    341            /* Write to TIMx CR2 */
    342            TIMx->CR2 = tmpcr2;
    343            
    344            /* Write to TIMx CCMR1 */
    345            TIMx->CCMR1 = tmpccmrx;
    346          
    347            /* Set the Capture Compare Register value */
    348            TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse; 
    349           
    350            /* Write to TIMx CCER */
    351            TIMx->CCER = tmpccer;
    352          }
    353          
    354          /**
    355            * @brief  Initializes the TIMx Channel2 according to the specified
    356            *         parameters in the TIM_OCInitStruct.
    357            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select 
    358            *         the TIM peripheral.
    359            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    360            *         that contains the configuration information for the specified TIM peripheral.
    361            * @retval None
    362            */
    363          void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    364          {
    365            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    366             
    367            /* Check the parameters */
    368            assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
    369            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    370            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    371            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    372             /* Disable the Channel 2: Reset the CC2E Bit */
    373            TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
    374            
    375            /* Get the TIMx CCER register value */  
    376            tmpccer = TIMx->CCER;
    377            /* Get the TIMx CR2 register value */
    378            tmpcr2 =  TIMx->CR2;
    379            
    380            /* Get the TIMx CCMR1 register value */
    381            tmpccmrx = TIMx->CCMR1;
    382              
    383            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    384            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
    385            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
    386            
    387            /* Select the Output Compare Mode */
    388            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
    389            
    390            /* Reset the Output Polarity level */
    391            tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
    392            /* Set the Output Compare Polarity */
    393            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
    394            
    395            /* Set the Output State */
    396            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
    397              
    398            if((TIMx == TIM1) || (TIMx == TIM8))
    399            {
    400              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    401              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    402              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    403              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    404              
    405              /* Reset the Output N Polarity level */
    406              tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NP));
    407              /* Set the Output N Polarity */
    408              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
    409              
    410              /* Reset the Output N State */
    411              tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));    
    412              /* Set the Output N State */
    413              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
    414              
    415              /* Reset the Output Compare and Output Compare N IDLE State */
    416              tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
    417              tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
    418              
    419              /* Set the Output Idle state */
    420              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
    421              /* Set the Output N Idle state */
    422              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
    423            }
    424            /* Write to TIMx CR2 */
    425            TIMx->CR2 = tmpcr2;
    426            
    427            /* Write to TIMx CCMR1 */
    428            TIMx->CCMR1 = tmpccmrx;
    429          
    430            /* Set the Capture Compare Register value */
    431            TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
    432            
    433            /* Write to TIMx CCER */
    434            TIMx->CCER = tmpccer;
    435          }
    436          
    437          /**
    438            * @brief  Initializes the TIMx Channel3 according to the specified
    439            *         parameters in the TIM_OCInitStruct.
    440            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    441            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    442            *         that contains the configuration information for the specified TIM peripheral.
    443            * @retval None
    444            */
    445          void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    446          {
    447            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    448             
    449            /* Check the parameters */
    450            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
    451            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    452            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    453            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    454            /* Disable the Channel 2: Reset the CC2E Bit */
    455            TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
    456            
    457            /* Get the TIMx CCER register value */
    458            tmpccer = TIMx->CCER;
    459            /* Get the TIMx CR2 register value */
    460            tmpcr2 =  TIMx->CR2;
    461            
    462            /* Get the TIMx CCMR2 register value */
    463            tmpccmrx = TIMx->CCMR2;
    464              
    465            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    466            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
    467            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
    468            /* Select the Output Compare Mode */
    469            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    470            
    471            /* Reset the Output Polarity level */
    472            tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
    473            /* Set the Output Compare Polarity */
    474            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
    475            
    476            /* Set the Output State */
    477            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
    478              
    479            if((TIMx == TIM1) || (TIMx == TIM8))
    480            {
    481              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    482              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    483              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    484              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    485              
    486              /* Reset the Output N Polarity level */
    487              tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NP));
    488              /* Set the Output N Polarity */
    489              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
    490              /* Reset the Output N State */
    491              tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
    492              
    493              /* Set the Output N State */
    494              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
    495              /* Reset the Output Compare and Output Compare N IDLE State */
    496              tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
    497              tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
    498              /* Set the Output Idle state */
    499              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
    500              /* Set the Output N Idle state */
    501              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
    502            }
    503            /* Write to TIMx CR2 */
    504            TIMx->CR2 = tmpcr2;
    505            
    506            /* Write to TIMx CCMR2 */
    507            TIMx->CCMR2 = tmpccmrx;
    508          
    509            /* Set the Capture Compare Register value */
    510            TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
    511            
    512            /* Write to TIMx CCER */
    513            TIMx->CCER = tmpccer;
    514          }
    515          
    516          /**
    517            * @brief  Initializes the TIMx Channel4 according to the specified
    518            *         parameters in the TIM_OCInitStruct.
    519            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    520            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    521            *         that contains the configuration information for the specified TIM peripheral.
    522            * @retval None
    523            */
    524          void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    525          {
    526            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    527             
    528            /* Check the parameters */
    529            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
    530            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    531            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    532            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    533            /* Disable the Channel 2: Reset the CC4E Bit */
    534            TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
    535            
    536            /* Get the TIMx CCER register value */
    537            tmpccer = TIMx->CCER;
    538            /* Get the TIMx CR2 register value */
    539            tmpcr2 =  TIMx->CR2;
    540            
    541            /* Get the TIMx CCMR2 register value */
    542            tmpccmrx = TIMx->CCMR2;
    543              
    544            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    545            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
    546            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
    547            
    548            /* Select the Output Compare Mode */
    549            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
    550            
    551            /* Reset the Output Polarity level */
    552            tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
    553            /* Set the Output Compare Polarity */
    554            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
    555            
    556            /* Set the Output State */
    557            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
    558              
    559            if((TIMx == TIM1) || (TIMx == TIM8))
    560            {
    561              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    562              /* Reset the Output Compare IDLE State */
    563              tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));
    564              /* Set the Output Idle state */
    565              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
    566            }
    567            /* Write to TIMx CR2 */
    568            TIMx->CR2 = tmpcr2;
    569            
    570            /* Write to TIMx CCMR2 */  
    571            TIMx->CCMR2 = tmpccmrx;
    572          
    573            /* Set the Capture Compare Register value */
    574            TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
    575            
    576            /* Write to TIMx CCER */
    577            TIMx->CCER = tmpccer;
    578          }
    579          
    580          /**
    581            * @brief  Initializes the TIM peripheral according to the specified
    582            *         parameters in the TIM_ICInitStruct.
    583            * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
    584            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    585            *         that contains the configuration information for the specified TIM peripheral.
    586            * @retval None
    587            */
    588          void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
    589          {
    590            /* Check the parameters */
    591            assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));  
    592            assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
    593            assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
    594            assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
    595            
    596            if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
    597               (TIMx == TIM4) ||(TIMx == TIM5))
    598            {
    599              assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
    600            }
    601            else
    602            {
    603              assert_param(IS_TIM_IC_POLARITY_LITE(TIM_ICInitStruct->TIM_ICPolarity));
    604            }
    605            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
    606            {
    607              assert_param(IS_TIM_LIST8_PERIPH(TIMx));
    608              /* TI1 Configuration */
    609              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    610                         TIM_ICInitStruct->TIM_ICSelection,
    611                         TIM_ICInitStruct->TIM_ICFilter);
    612              /* Set the Input Capture Prescaler value */
    613              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    614            }
    615            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
    616            {
    617              assert_param(IS_TIM_LIST6_PERIPH(TIMx));
    618              /* TI2 Configuration */
    619              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    620                         TIM_ICInitStruct->TIM_ICSelection,
    621                         TIM_ICInitStruct->TIM_ICFilter);
    622              /* Set the Input Capture Prescaler value */
    623              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    624            }
    625            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
    626            {
    627              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    628              /* TI3 Configuration */
    629              TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
    630                         TIM_ICInitStruct->TIM_ICSelection,
    631                         TIM_ICInitStruct->TIM_ICFilter);
    632              /* Set the Input Capture Prescaler value */
    633              TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    634            }
    635            else
    636            {
    637              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    638              /* TI4 Configuration */
    639              TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    640                         TIM_ICInitStruct->TIM_ICSelection,
    641                         TIM_ICInitStruct->TIM_ICFilter);
    642              /* Set the Input Capture Prescaler value */
    643              TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    644            }
    645          }
    646          
    647          /**
    648            * @brief  Configures the TIM peripheral according to the specified
    649            *         parameters in the TIM_ICInitStruct to measure an external PWM signal.
    650            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
    651            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    652            *         that contains the configuration information for the specified TIM peripheral.
    653            * @retval None
    654            */
    655          void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
    656          {
    657            uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
    658            uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
    659            /* Check the parameters */
    660            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
    661            /* Select the Opposite Input Polarity */
    662            if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
    663            {
    664              icoppositepolarity = TIM_ICPolarity_Falling;
    665            }
    666            else
    667            {
    668              icoppositepolarity = TIM_ICPolarity_Rising;
    669            }
    670            /* Select the Opposite Input */
    671            if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
    672            {
    673              icoppositeselection = TIM_ICSelection_IndirectTI;
    674            }
    675            else
    676            {
    677              icoppositeselection = TIM_ICSelection_DirectTI;
    678            }
    679            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
    680            {
    681              /* TI1 Configuration */
    682              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
    683                         TIM_ICInitStruct->TIM_ICFilter);
    684              /* Set the Input Capture Prescaler value */
    685              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    686              /* TI2 Configuration */
    687              TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    688              /* Set the Input Capture Prescaler value */
    689              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    690            }
    691            else
    692            { 
    693              /* TI2 Configuration */
    694              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
    695                         TIM_ICInitStruct->TIM_ICFilter);
    696              /* Set the Input Capture Prescaler value */
    697              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    698              /* TI1 Configuration */
    699              TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    700              /* Set the Input Capture Prescaler value */
    701              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    702            }
    703          }
    704          
    705          /**
    706            * @brief  Configures the: Break feature, dead time, Lock level, the OSSI,
    707            *         the OSSR State and the AOE(automatic output enable).
    708            * @param  TIMx: where x can be  1 or 8 to select the TIM 
    709            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that
    710            *         contains the BDTR Register configuration  information for the TIM peripheral.
    711            * @retval None
    712            */
    713          void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
    714          {
    715            /* Check the parameters */
    716            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    717            assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
    718            assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
    719            assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
    720            assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
    721            assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
    722            assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
    723            /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
    724               the OSSI State, the dead time value and the Automatic Output Enable Bit */
    725            TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
    726                       TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
    727                       TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
    728                       TIM_BDTRInitStruct->TIM_AutomaticOutput;
    729          }
    730          
    731          /**
    732            * @brief  Fills each TIM_TimeBaseInitStruct member with its default value.
    733            * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
    734            *         structure which will be initialized.
    735            * @retval None
    736            */
    737          void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    738          {
    739            /* Set the default configuration */
    740            TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
    741            TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
    742            TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
    743            TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
    744            TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
    745          }
    746          
    747          /**
    748            * @brief  Fills each TIM_OCInitStruct member with its default value.
    749            * @param  TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure which will
    750            *         be initialized.
    751            * @retval None
    752            */
    753          void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
    754          {
    755            /* Set the default configuration */
    756            TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
    757            TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
    758            TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
    759            TIM_OCInitStruct->TIM_Pulse = 0x0000;
    760            TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
    761            TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
    762            TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
    763            TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
    764          }
    765          
    766          /**
    767            * @brief  Fills each TIM_ICInitStruct member with its default value.
    768            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure which will
    769            *         be initialized.
    770            * @retval None
    771            */
    772          void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
    773          {
    774            /* Set the default configuration */
    775            TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
    776            TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
    777            TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
    778            TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
    779            TIM_ICInitStruct->TIM_ICFilter = 0x00;
    780          }
    781          
    782          /**
    783            * @brief  Fills each TIM_BDTRInitStruct member with its default value.
    784            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which
    785            *         will be initialized.
    786            * @retval None
    787            */
    788          void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
    789          {
    790            /* Set the default configuration */
    791            TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
    792            TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
    793            TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
    794            TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
    795            TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
    796            TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
    797            TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
    798          }
    799          
    800          /**
    801            * @brief  Enables or disables the specified TIM peripheral.
    802            * @param  TIMx: where x can be 1 to 17 to select the TIMx peripheral.
    803            * @param  NewState: new state of the TIMx peripheral.
    804            *   This parameter can be: ENABLE or DISABLE.
    805            * @retval None
    806            */
    807          void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
    808          {
    809            /* Check the parameters */
    810            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    811            assert_param(IS_FUNCTIONAL_STATE(NewState));
    812            
    813            if (NewState != DISABLE)
    814            {
    815              /* Enable the TIM Counter */
    816              TIMx->CR1 |= TIM_CR1_CEN;
    817            }
    818            else
    819            {
    820              /* Disable the TIM Counter */
    821              TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
    822            }
    823          }
    824          
    825          /**
    826            * @brief  Enables or disables the TIM peripheral Main Outputs.
    827            * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIMx peripheral.
    828            * @param  NewState: new state of the TIM peripheral Main Outputs.
    829            *   This parameter can be: ENABLE or DISABLE.
    830            * @retval None
    831            */
    832          void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
    833          {
    834            /* Check the parameters */
    835            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    836            assert_param(IS_FUNCTIONAL_STATE(NewState));
    837            if (NewState != DISABLE)
    838            {
    839              /* Enable the TIM Main Output */
    840              TIMx->BDTR |= TIM_BDTR_MOE;
    841            }
    842            else
    843            {
    844              /* Disable the TIM Main Output */
    845              TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
    846            }  
    847          }
    848          
    849          /**
    850            * @brief  Enables or disables the specified TIM interrupts.
    851            * @param  TIMx: where x can be 1 to 17 to select the TIMx peripheral.
    852            * @param  TIM_IT: specifies the TIM interrupts sources to be enabled or disabled.
    853            *   This parameter can be any combination of the following values:
    854            *     @arg TIM_IT_Update: TIM update Interrupt source
    855            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
    856            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
    857            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
    858            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
    859            *     @arg TIM_IT_COM: TIM Commutation Interrupt source
    860            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
    861            *     @arg TIM_IT_Break: TIM Break Interrupt source
    862            * @note 
    863            *   - TIM6 and TIM7 can only generate an update interrupt.
    864            *   - TIM9, TIM12 and TIM15 can have only TIM_IT_Update, TIM_IT_CC1,
    865            *      TIM_IT_CC2 or TIM_IT_Trigger. 
    866            *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.   
    867            *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15. 
    868            *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.    
    869            * @param  NewState: new state of the TIM interrupts.
    870            *   This parameter can be: ENABLE or DISABLE.
    871            * @retval None
    872            */
    873          void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
    874          {  
    875            /* Check the parameters */
    876            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    877            assert_param(IS_TIM_IT(TIM_IT));
    878            assert_param(IS_FUNCTIONAL_STATE(NewState));
    879            
    880            if (NewState != DISABLE)
    881            {
    882              /* Enable the Interrupt sources */
    883              TIMx->DIER |= TIM_IT;
    884            }
    885            else
    886            {
    887              /* Disable the Interrupt sources */
    888              TIMx->DIER &= (uint16_t)~TIM_IT;
    889            }
    890          }
    891          
    892          /**
    893            * @brief  Configures the TIMx event to be generate by software.
    894            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
    895            * @param  TIM_EventSource: specifies the event source.
    896            *   This parameter can be one or more of the following values:	   
    897            *     @arg TIM_EventSource_Update: Timer update Event source
    898            *     @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source
    899            *     @arg TIM_EventSource_CC2: Timer Capture Compare 2 Event source
    900            *     @arg TIM_EventSource_CC3: Timer Capture Compare 3 Event source
    901            *     @arg TIM_EventSource_CC4: Timer Capture Compare 4 Event source
    902            *     @arg TIM_EventSource_COM: Timer COM event source  
    903            *     @arg TIM_EventSource_Trigger: Timer Trigger Event source
    904            *     @arg TIM_EventSource_Break: Timer Break event source
    905            * @note 
    906            *   - TIM6 and TIM7 can only generate an update event. 
    907            *   - TIM_EventSource_COM and TIM_EventSource_Break are used only with TIM1 and TIM8.      
    908            * @retval None
    909            */
    910          void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
    911          { 
    912            /* Check the parameters */
    913            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    914            assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
    915            
    916            /* Set the event sources */
    917            TIMx->EGR = TIM_EventSource;
    918          }
    919          
    920          /**
    921            * @brief  Configures the TIMx's DMA interface.
    922            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 15, 16 or 17 to select 
    923            *   the TIM peripheral.
    924            * @param  TIM_DMABase: DMA Base address.
    925            *   This parameter can be one of the following values:
    926            *     @arg TIM_DMABase_CR, TIM_DMABase_CR2, TIM_DMABase_SMCR,
    927            *          TIM_DMABase_DIER, TIM1_DMABase_SR, TIM_DMABase_EGR,
    928            *          TIM_DMABase_CCMR1, TIM_DMABase_CCMR2, TIM_DMABase_CCER,
    929            *          TIM_DMABase_CNT, TIM_DMABase_PSC, TIM_DMABase_ARR,
    930            *          TIM_DMABase_RCR, TIM_DMABase_CCR1, TIM_DMABase_CCR2,
    931            *          TIM_DMABase_CCR3, TIM_DMABase_CCR4, TIM_DMABase_BDTR,
    932            *          TIM_DMABase_DCR.
    933            * @param  TIM_DMABurstLength: DMA Burst length.
    934            *   This parameter can be one value between:
    935            *   TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.
    936            * @retval None
    937            */
    938          void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
    939          {
    940            /* Check the parameters */
    941            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
    942            assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
    943            assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
    944            /* Set the DMA Base and the DMA Burst Length */
    945            TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
    946          }
    947          
    948          /**
    949            * @brief  Enables or disables the TIMx's DMA Requests.
    950            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 6, 7, 8, 15, 16 or 17 
    951            *   to select the TIM peripheral. 
    952            * @param  TIM_DMASource: specifies the DMA Request sources.
    953            *   This parameter can be any combination of the following values:
    954            *     @arg TIM_DMA_Update: TIM update Interrupt source
    955            *     @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
    956            *     @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
    957            *     @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
    958            *     @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
    959            *     @arg TIM_DMA_COM: TIM Commutation DMA source
    960            *     @arg TIM_DMA_Trigger: TIM Trigger DMA source
    961            * @param  NewState: new state of the DMA Request sources.
    962            *   This parameter can be: ENABLE or DISABLE.
    963            * @retval None
    964            */
    965          void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
    966          { 
    967            /* Check the parameters */
    968            assert_param(IS_TIM_LIST9_PERIPH(TIMx));
    969            assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
    970            assert_param(IS_FUNCTIONAL_STATE(NewState));
    971            
    972            if (NewState != DISABLE)
    973            {
    974              /* Enable the DMA sources */
    975              TIMx->DIER |= TIM_DMASource; 
    976            }
    977            else
    978            {
    979              /* Disable the DMA sources */
    980              TIMx->DIER &= (uint16_t)~TIM_DMASource;
    981            }
    982          }
    983          
    984          /**
    985            * @brief  Configures the TIMx internal Clock
    986            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15
    987            *         to select the TIM peripheral.
    988            * @retval None
    989            */
    990          void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
    991          {
    992            /* Check the parameters */
    993            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
    994            /* Disable slave mode to clock the prescaler directly with the internal clock */
    995            TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
    996          }
    997          
    998          /**
    999            * @brief  Configures the TIMx Internal Trigger as External Clock
   1000            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 9, 12 or 15 to select the TIM peripheral.
   1001            * @param  TIM_ITRSource: Trigger source.
   1002            *   This parameter can be one of the following values:
   1003            * @param  TIM_TS_ITR0: Internal Trigger 0
   1004            * @param  TIM_TS_ITR1: Internal Trigger 1
   1005            * @param  TIM_TS_ITR2: Internal Trigger 2
   1006            * @param  TIM_TS_ITR3: Internal Trigger 3
   1007            * @retval None
   1008            */
   1009          void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
   1010          {
   1011            /* Check the parameters */
   1012            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1013            assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
   1014            /* Select the Internal Trigger */
   1015            TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
   1016            /* Select the External clock mode1 */
   1017            TIMx->SMCR |= TIM_SlaveMode_External1;
   1018          }
   1019          
   1020          /**
   1021            * @brief  Configures the TIMx Trigger as External Clock
   1022            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 9, 12 or 15 to select the TIM peripheral.
   1023            * @param  TIM_TIxExternalCLKSource: Trigger source.
   1024            *   This parameter can be one of the following values:
   1025            *     @arg TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
   1026            *     @arg TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
   1027            *     @arg TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
   1028            * @param  TIM_ICPolarity: specifies the TIx Polarity.
   1029            *   This parameter can be one of the following values:
   1030            *     @arg TIM_ICPolarity_Rising
   1031            *     @arg TIM_ICPolarity_Falling
   1032            * @param  ICFilter : specifies the filter value.
   1033            *   This parameter must be a value between 0x0 and 0xF.
   1034            * @retval None
   1035            */
   1036          void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
   1037                                          uint16_t TIM_ICPolarity, uint16_t ICFilter)
   1038          {
   1039            /* Check the parameters */
   1040            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1041            assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
   1042            assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
   1043            assert_param(IS_TIM_IC_FILTER(ICFilter));
   1044            /* Configure the Timer Input Clock Source */
   1045            if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
   1046            {
   1047              TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   1048            }
   1049            else
   1050            {
   1051              TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   1052            }
   1053            /* Select the Trigger source */
   1054            TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
   1055            /* Select the External clock mode1 */
   1056            TIMx->SMCR |= TIM_SlaveMode_External1;
   1057          }
   1058          
   1059          /**
   1060            * @brief  Configures the External clock Mode1
   1061            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1062            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1063            *   This parameter can be one of the following values:
   1064            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   1065            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   1066            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   1067            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   1068            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   1069            *   This parameter can be one of the following values:
   1070            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   1071            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   1072            * @param  ExtTRGFilter: External Trigger Filter.
   1073            *   This parameter must be a value between 0x00 and 0x0F
   1074            * @retval None
   1075            */
   1076          void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
   1077                                       uint16_t ExtTRGFilter)
   1078          {
   1079            uint16_t tmpsmcr = 0;
   1080            /* Check the parameters */
   1081            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1082            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1083            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1084            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1085            /* Configure the ETR Clock source */
   1086            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   1087            
   1088            /* Get the TIMx SMCR register value */
   1089            tmpsmcr = TIMx->SMCR;
   1090            /* Reset the SMS Bits */
   1091            tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
   1092            /* Select the External clock mode1 */
   1093            tmpsmcr |= TIM_SlaveMode_External1;
   1094            /* Select the Trigger selection : ETRF */
   1095            tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
   1096            tmpsmcr |= TIM_TS_ETRF;
   1097            /* Write to TIMx SMCR */
   1098            TIMx->SMCR = tmpsmcr;
   1099          }
   1100          
   1101          /**
   1102            * @brief  Configures the External clock Mode2
   1103            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1104            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1105            *   This parameter can be one of the following values:
   1106            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   1107            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   1108            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   1109            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   1110            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   1111            *   This parameter can be one of the following values:
   1112            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   1113            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   1114            * @param  ExtTRGFilter: External Trigger Filter.
   1115            *   This parameter must be a value between 0x00 and 0x0F
   1116            * @retval None
   1117            */
   1118          void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
   1119                                       uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   1120          {
   1121            /* Check the parameters */
   1122            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1123            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1124            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1125            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1126            /* Configure the ETR Clock source */
   1127            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   1128            /* Enable the External clock mode2 */
   1129            TIMx->SMCR |= TIM_SMCR_ECE;
   1130          }
   1131          
   1132          /**
   1133            * @brief  Configures the TIMx External Trigger (ETR).
   1134            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1135            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1136            *   This parameter can be one of the following values:
   1137            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   1138            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   1139            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   1140            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   1141            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   1142            *   This parameter can be one of the following values:
   1143            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   1144            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   1145            * @param  ExtTRGFilter: External Trigger Filter.
   1146            *   This parameter must be a value between 0x00 and 0x0F
   1147            * @retval None
   1148            */
   1149          void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
   1150                             uint16_t ExtTRGFilter)
   1151          {
   1152            uint16_t tmpsmcr = 0;
   1153            /* Check the parameters */
   1154            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1155            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1156            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1157            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1158            tmpsmcr = TIMx->SMCR;
   1159            /* Reset the ETR Bits */
   1160            tmpsmcr &= SMCR_ETR_Mask;
   1161            /* Set the Prescaler, the Filter value and the Polarity */
   1162            tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
   1163            /* Write to TIMx SMCR */
   1164            TIMx->SMCR = tmpsmcr;
   1165          }
   1166          
   1167          /**
   1168            * @brief  Configures the TIMx Prescaler.
   1169            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   1170            * @param  Prescaler: specifies the Prescaler Register value
   1171            * @param  TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
   1172            *   This parameter can be one of the following values:
   1173            *     @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
   1174            *     @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediately.
   1175            * @retval None
   1176            */
   1177          void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
   1178          {
   1179            /* Check the parameters */
   1180            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1181            assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
   1182            /* Set the Prescaler value */
   1183            TIMx->PSC = Prescaler;
   1184            /* Set or reset the UG Bit */
   1185            TIMx->EGR = TIM_PSCReloadMode;
   1186          }
   1187          
   1188          /**
   1189            * @brief  Specifies the TIMx Counter Mode to be used.
   1190            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1191            * @param  TIM_CounterMode: specifies the Counter Mode to be used
   1192            *   This parameter can be one of the following values:
   1193            *     @arg TIM_CounterMode_Up: TIM Up Counting Mode
   1194            *     @arg TIM_CounterMode_Down: TIM Down Counting Mode
   1195            *     @arg TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
   1196            *     @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
   1197            *     @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
   1198            * @retval None
   1199            */
   1200          void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
   1201          {
   1202            uint16_t tmpcr1 = 0;
   1203            /* Check the parameters */
   1204            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1205            assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
   1206            tmpcr1 = TIMx->CR1;
   1207            /* Reset the CMS and DIR Bits */
   1208            tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
   1209            /* Set the Counter Mode */
   1210            tmpcr1 |= TIM_CounterMode;
   1211            /* Write to TIMx CR1 register */
   1212            TIMx->CR1 = tmpcr1;
   1213          }
   1214          
   1215          /**
   1216            * @brief  Selects the Input Trigger source
   1217            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   1218            * @param  TIM_InputTriggerSource: The Input Trigger source.
   1219            *   This parameter can be one of the following values:
   1220            *     @arg TIM_TS_ITR0: Internal Trigger 0
   1221            *     @arg TIM_TS_ITR1: Internal Trigger 1
   1222            *     @arg TIM_TS_ITR2: Internal Trigger 2
   1223            *     @arg TIM_TS_ITR3: Internal Trigger 3
   1224            *     @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   1225            *     @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   1226            *     @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   1227            *     @arg TIM_TS_ETRF: External Trigger input
   1228            * @retval None
   1229            */
   1230          void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
   1231          {
   1232            uint16_t tmpsmcr = 0;
   1233            /* Check the parameters */
   1234            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1235            assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
   1236            /* Get the TIMx SMCR register value */
   1237            tmpsmcr = TIMx->SMCR;
   1238            /* Reset the TS Bits */
   1239            tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
   1240            /* Set the Input Trigger source */
   1241            tmpsmcr |= TIM_InputTriggerSource;
   1242            /* Write to TIMx SMCR */
   1243            TIMx->SMCR = tmpsmcr;
   1244          }
   1245          
   1246          /**
   1247            * @brief  Configures the TIMx Encoder Interface.
   1248            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1249            * @param  TIM_EncoderMode: specifies the TIMx Encoder Mode.
   1250            *   This parameter can be one of the following values:
   1251            *     @arg TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge depending on TI2FP2 level.
   1252            *     @arg TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge depending on TI1FP1 level.
   1253            *     @arg TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and TI2FP2 edges depending
   1254            *                                on the level of the other input.
   1255            * @param  TIM_IC1Polarity: specifies the IC1 Polarity
   1256            *   This parameter can be one of the following values:
   1257            *     @arg TIM_ICPolarity_Falling: IC Falling edge.
   1258            *     @arg TIM_ICPolarity_Rising: IC Rising edge.
   1259            * @param  TIM_IC2Polarity: specifies the IC2 Polarity
   1260            *   This parameter can be one of the following values:
   1261            *     @arg TIM_ICPolarity_Falling: IC Falling edge.
   1262            *     @arg TIM_ICPolarity_Rising: IC Rising edge.
   1263            * @retval None
   1264            */
   1265          void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
   1266                                          uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
   1267          {
   1268            uint16_t tmpsmcr = 0;
   1269            uint16_t tmpccmr1 = 0;
   1270            uint16_t tmpccer = 0;
   1271              
   1272            /* Check the parameters */
   1273            assert_param(IS_TIM_LIST5_PERIPH(TIMx));
   1274            assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
   1275            assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
   1276            assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
   1277          
   1278            /* Get the TIMx SMCR register value */
   1279            tmpsmcr = TIMx->SMCR;
   1280            
   1281            /* Get the TIMx CCMR1 register value */
   1282            tmpccmr1 = TIMx->CCMR1;
   1283            
   1284            /* Get the TIMx CCER register value */
   1285            tmpccer = TIMx->CCER;
   1286            
   1287            /* Set the encoder Mode */
   1288            tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
   1289            tmpsmcr |= TIM_EncoderMode;
   1290            
   1291            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   1292            tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
   1293            tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
   1294            
   1295            /* Set the TI1 and the TI2 Polarities */
   1296            tmpccer &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));
   1297            tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
   1298            
   1299            /* Write to TIMx SMCR */
   1300            TIMx->SMCR = tmpsmcr;
   1301            /* Write to TIMx CCMR1 */
   1302            TIMx->CCMR1 = tmpccmr1;
   1303            /* Write to TIMx CCER */
   1304            TIMx->CCER = tmpccer;
   1305          }
   1306          
   1307          /**
   1308            * @brief  Forces the TIMx output 1 waveform to active or inactive level.
   1309            * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
   1310            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1311            *   This parameter can be one of the following values:
   1312            *     @arg TIM_ForcedAction_Active: Force active level on OC1REF
   1313            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
   1314            * @retval None
   1315            */
   1316          void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1317          {
   1318            uint16_t tmpccmr1 = 0;
   1319            /* Check the parameters */
   1320            assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   1321            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1322            tmpccmr1 = TIMx->CCMR1;
   1323            /* Reset the OC1M Bits */
   1324            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
   1325            /* Configure The Forced output Mode */
   1326            tmpccmr1 |= TIM_ForcedAction;
   1327            /* Write to TIMx CCMR1 register */
   1328            TIMx->CCMR1 = tmpccmr1;
   1329          }
   1330          
   1331          /**
   1332            * @brief  Forces the TIMx output 2 waveform to active or inactive level.
   1333            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   1334            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1335            *   This parameter can be one of the following values:
   1336            *     @arg TIM_ForcedAction_Active: Force active level on OC2REF
   1337            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
   1338            * @retval None
   1339            */
   1340          void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1341          {
   1342            uint16_t tmpccmr1 = 0;
   1343            /* Check the parameters */
   1344            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1345            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1346            tmpccmr1 = TIMx->CCMR1;
   1347            /* Reset the OC2M Bits */
   1348            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
   1349            /* Configure The Forced output Mode */
   1350            tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
   1351            /* Write to TIMx CCMR1 register */
   1352            TIMx->CCMR1 = tmpccmr1;
   1353          }
   1354          
   1355          /**
   1356            * @brief  Forces the TIMx output 3 waveform to active or inactive level.
   1357            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1358            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1359            *   This parameter can be one of the following values:
   1360            *     @arg TIM_ForcedAction_Active: Force active level on OC3REF
   1361            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
   1362            * @retval None
   1363            */
   1364          void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1365          {
   1366            uint16_t tmpccmr2 = 0;
   1367            /* Check the parameters */
   1368            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1369            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1370            tmpccmr2 = TIMx->CCMR2;
   1371            /* Reset the OC1M Bits */
   1372            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
   1373            /* Configure The Forced output Mode */
   1374            tmpccmr2 |= TIM_ForcedAction;
   1375            /* Write to TIMx CCMR2 register */
   1376            TIMx->CCMR2 = tmpccmr2;
   1377          }
   1378          
   1379          /**
   1380            * @brief  Forces the TIMx output 4 waveform to active or inactive level.
   1381            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1382            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1383            *   This parameter can be one of the following values:
   1384            *     @arg TIM_ForcedAction_Active: Force active level on OC4REF
   1385            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
   1386            * @retval None
   1387            */
   1388          void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1389          {
   1390            uint16_t tmpccmr2 = 0;
   1391            /* Check the parameters */
   1392            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1393            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1394            tmpccmr2 = TIMx->CCMR2;
   1395            /* Reset the OC2M Bits */
   1396            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
   1397            /* Configure The Forced output Mode */
   1398            tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
   1399            /* Write to TIMx CCMR2 register */
   1400            TIMx->CCMR2 = tmpccmr2;
   1401          }
   1402          
   1403          /**
   1404            * @brief  Enables or disables TIMx peripheral Preload register on ARR.
   1405            * @param  TIMx: where x can be  1 to 17 to select the TIM peripheral.
   1406            * @param  NewState: new state of the TIMx peripheral Preload register
   1407            *   This parameter can be: ENABLE or DISABLE.
   1408            * @retval None
   1409            */
   1410          void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
   1411          {
   1412            /* Check the parameters */
   1413            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1414            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1415            if (NewState != DISABLE)
   1416            {
   1417              /* Set the ARR Preload Bit */
   1418              TIMx->CR1 |= TIM_CR1_ARPE;
   1419            }
   1420            else
   1421            {
   1422              /* Reset the ARR Preload Bit */
   1423              TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
   1424            }
   1425          }
   1426          
   1427          /**
   1428            * @brief  Selects the TIM peripheral Commutation event.
   1429            * @param  TIMx: where x can be  1, 8, 15, 16 or 17 to select the TIMx peripheral
   1430            * @param  NewState: new state of the Commutation event.
   1431            *   This parameter can be: ENABLE or DISABLE.
   1432            * @retval None
   1433            */
   1434          void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
   1435          {
   1436            /* Check the parameters */
   1437            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1438            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1439            if (NewState != DISABLE)
   1440            {
   1441              /* Set the COM Bit */
   1442              TIMx->CR2 |= TIM_CR2_CCUS;
   1443            }
   1444            else
   1445            {
   1446              /* Reset the COM Bit */
   1447              TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCUS);
   1448            }
   1449          }
   1450          
   1451          /**
   1452            * @brief  Selects the TIMx peripheral Capture Compare DMA source.
   1453            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 15, 16 or 17 to select 
   1454            *         the TIM peripheral.
   1455            * @param  NewState: new state of the Capture Compare DMA source
   1456            *   This parameter can be: ENABLE or DISABLE.
   1457            * @retval None
   1458            */
   1459          void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
   1460          {
   1461            /* Check the parameters */
   1462            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1463            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1464            if (NewState != DISABLE)
   1465            {
   1466              /* Set the CCDS Bit */
   1467              TIMx->CR2 |= TIM_CR2_CCDS;
   1468            }
   1469            else
   1470            {
   1471              /* Reset the CCDS Bit */
   1472              TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
   1473            }
   1474          }
   1475          
   1476          /**
   1477            * @brief  Sets or Resets the TIM peripheral Capture Compare Preload Control bit.
   1478            * @param  TIMx: where x can be   1, 2, 3, 4, 5, 8 or 15 
   1479            *         to select the TIMx peripheral
   1480            * @param  NewState: new state of the Capture Compare Preload Control bit
   1481            *   This parameter can be: ENABLE or DISABLE.
   1482            * @retval None
   1483            */
   1484          void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
   1485          { 
   1486            /* Check the parameters */
   1487            assert_param(IS_TIM_LIST5_PERIPH(TIMx));
   1488            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1489            if (NewState != DISABLE)
   1490            {
   1491              /* Set the CCPC Bit */
   1492              TIMx->CR2 |= TIM_CR2_CCPC;
   1493            }
   1494            else
   1495            {
   1496              /* Reset the CCPC Bit */
   1497              TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCPC);
   1498            }
   1499          }
   1500          
   1501          /**
   1502            * @brief  Enables or disables the TIMx peripheral Preload register on CCR1.
   1503            * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
   1504            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1505            *   This parameter can be one of the following values:
   1506            *     @arg TIM_OCPreload_Enable
   1507            *     @arg TIM_OCPreload_Disable
   1508            * @retval None
   1509            */
   1510          void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1511          {
   1512            uint16_t tmpccmr1 = 0;
   1513            /* Check the parameters */
   1514            assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   1515            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1516            tmpccmr1 = TIMx->CCMR1;
   1517            /* Reset the OC1PE Bit */
   1518            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
   1519            /* Enable or Disable the Output Compare Preload feature */
   1520            tmpccmr1 |= TIM_OCPreload;
   1521            /* Write to TIMx CCMR1 register */
   1522            TIMx->CCMR1 = tmpccmr1;
   1523          }
   1524          
   1525          /**
   1526            * @brief  Enables or disables the TIMx peripheral Preload register on CCR2.
   1527            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select 
   1528            *         the TIM peripheral.
   1529            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1530            *   This parameter can be one of the following values:
   1531            *     @arg TIM_OCPreload_Enable
   1532            *     @arg TIM_OCPreload_Disable
   1533            * @retval None
   1534            */
   1535          void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1536          {
   1537            uint16_t tmpccmr1 = 0;
   1538            /* Check the parameters */
   1539            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1540            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1541            tmpccmr1 = TIMx->CCMR1;
   1542            /* Reset the OC2PE Bit */
   1543            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
   1544            /* Enable or Disable the Output Compare Preload feature */
   1545            tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
   1546            /* Write to TIMx CCMR1 register */
   1547            TIMx->CCMR1 = tmpccmr1;
   1548          }
   1549          
   1550          /**
   1551            * @brief  Enables or disables the TIMx peripheral Preload register on CCR3.
   1552            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1553            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1554            *   This parameter can be one of the following values:
   1555            *     @arg TIM_OCPreload_Enable
   1556            *     @arg TIM_OCPreload_Disable
   1557            * @retval None
   1558            */
   1559          void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1560          {
   1561            uint16_t tmpccmr2 = 0;
   1562            /* Check the parameters */
   1563            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1564            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1565            tmpccmr2 = TIMx->CCMR2;
   1566            /* Reset the OC3PE Bit */
   1567            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
   1568            /* Enable or Disable the Output Compare Preload feature */
   1569            tmpccmr2 |= TIM_OCPreload;
   1570            /* Write to TIMx CCMR2 register */
   1571            TIMx->CCMR2 = tmpccmr2;
   1572          }
   1573          
   1574          /**
   1575            * @brief  Enables or disables the TIMx peripheral Preload register on CCR4.
   1576            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1577            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1578            *   This parameter can be one of the following values:
   1579            *     @arg TIM_OCPreload_Enable
   1580            *     @arg TIM_OCPreload_Disable
   1581            * @retval None
   1582            */
   1583          void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1584          {
   1585            uint16_t tmpccmr2 = 0;
   1586            /* Check the parameters */
   1587            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1588            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1589            tmpccmr2 = TIMx->CCMR2;
   1590            /* Reset the OC4PE Bit */
   1591            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
   1592            /* Enable or Disable the Output Compare Preload feature */
   1593            tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
   1594            /* Write to TIMx CCMR2 register */
   1595            TIMx->CCMR2 = tmpccmr2;
   1596          }
   1597          
   1598          /**
   1599            * @brief  Configures the TIMx Output Compare 1 Fast feature.
   1600            * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
   1601            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1602            *   This parameter can be one of the following values:
   1603            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1604            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1605            * @retval None
   1606            */
   1607          void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1608          {
   1609            uint16_t tmpccmr1 = 0;
   1610            /* Check the parameters */
   1611            assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   1612            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1613            /* Get the TIMx CCMR1 register value */
   1614            tmpccmr1 = TIMx->CCMR1;
   1615            /* Reset the OC1FE Bit */
   1616            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
   1617            /* Enable or Disable the Output Compare Fast Bit */
   1618            tmpccmr1 |= TIM_OCFast;
   1619            /* Write to TIMx CCMR1 */
   1620            TIMx->CCMR1 = tmpccmr1;
   1621          }
   1622          
   1623          /**
   1624            * @brief  Configures the TIMx Output Compare 2 Fast feature.
   1625            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select 
   1626            *         the TIM peripheral.
   1627            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1628            *   This parameter can be one of the following values:
   1629            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1630            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1631            * @retval None
   1632            */
   1633          void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1634          {
   1635            uint16_t tmpccmr1 = 0;
   1636            /* Check the parameters */
   1637            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1638            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1639            /* Get the TIMx CCMR1 register value */
   1640            tmpccmr1 = TIMx->CCMR1;
   1641            /* Reset the OC2FE Bit */
   1642            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
   1643            /* Enable or Disable the Output Compare Fast Bit */
   1644            tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
   1645            /* Write to TIMx CCMR1 */
   1646            TIMx->CCMR1 = tmpccmr1;
   1647          }
   1648          
   1649          /**
   1650            * @brief  Configures the TIMx Output Compare 3 Fast feature.
   1651            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1652            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1653            *   This parameter can be one of the following values:
   1654            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1655            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1656            * @retval None
   1657            */
   1658          void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1659          {
   1660            uint16_t tmpccmr2 = 0;
   1661            /* Check the parameters */
   1662            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1663            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1664            /* Get the TIMx CCMR2 register value */
   1665            tmpccmr2 = TIMx->CCMR2;
   1666            /* Reset the OC3FE Bit */
   1667            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
   1668            /* Enable or Disable the Output Compare Fast Bit */
   1669            tmpccmr2 |= TIM_OCFast;
   1670            /* Write to TIMx CCMR2 */
   1671            TIMx->CCMR2 = tmpccmr2;
   1672          }
   1673          
   1674          /**
   1675            * @brief  Configures the TIMx Output Compare 4 Fast feature.
   1676            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1677            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1678            *   This parameter can be one of the following values:
   1679            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1680            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1681            * @retval None
   1682            */
   1683          void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1684          {
   1685            uint16_t tmpccmr2 = 0;
   1686            /* Check the parameters */
   1687            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1688            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1689            /* Get the TIMx CCMR2 register value */
   1690            tmpccmr2 = TIMx->CCMR2;
   1691            /* Reset the OC4FE Bit */
   1692            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
   1693            /* Enable or Disable the Output Compare Fast Bit */
   1694            tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
   1695            /* Write to TIMx CCMR2 */
   1696            TIMx->CCMR2 = tmpccmr2;
   1697          }
   1698          
   1699          /**
   1700            * @brief  Clears or safeguards the OCREF1 signal on an external event
   1701            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1702            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1703            *   This parameter can be one of the following values:
   1704            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1705            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1706            * @retval None
   1707            */
   1708          void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1709          {
   1710            uint16_t tmpccmr1 = 0;
   1711            /* Check the parameters */
   1712            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1713            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1714          
   1715            tmpccmr1 = TIMx->CCMR1;
   1716          
   1717            /* Reset the OC1CE Bit */
   1718            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
   1719            /* Enable or Disable the Output Compare Clear Bit */
   1720            tmpccmr1 |= TIM_OCClear;
   1721            /* Write to TIMx CCMR1 register */
   1722            TIMx->CCMR1 = tmpccmr1;
   1723          }
   1724          
   1725          /**
   1726            * @brief  Clears or safeguards the OCREF2 signal on an external event
   1727            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1728            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1729            *   This parameter can be one of the following values:
   1730            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1731            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1732            * @retval None
   1733            */
   1734          void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1735          {
   1736            uint16_t tmpccmr1 = 0;
   1737            /* Check the parameters */
   1738            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1739            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1740            tmpccmr1 = TIMx->CCMR1;
   1741            /* Reset the OC2CE Bit */
   1742            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
   1743            /* Enable or Disable the Output Compare Clear Bit */
   1744            tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
   1745            /* Write to TIMx CCMR1 register */
   1746            TIMx->CCMR1 = tmpccmr1;
   1747          }
   1748          
   1749          /**
   1750            * @brief  Clears or safeguards the OCREF3 signal on an external event
   1751            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1752            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1753            *   This parameter can be one of the following values:
   1754            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1755            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1756            * @retval None
   1757            */
   1758          void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1759          {
   1760            uint16_t tmpccmr2 = 0;
   1761            /* Check the parameters */
   1762            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1763            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1764            tmpccmr2 = TIMx->CCMR2;
   1765            /* Reset the OC3CE Bit */
   1766            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
   1767            /* Enable or Disable the Output Compare Clear Bit */
   1768            tmpccmr2 |= TIM_OCClear;
   1769            /* Write to TIMx CCMR2 register */
   1770            TIMx->CCMR2 = tmpccmr2;
   1771          }
   1772          
   1773          /**
   1774            * @brief  Clears or safeguards the OCREF4 signal on an external event
   1775            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1776            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1777            *   This parameter can be one of the following values:
   1778            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1779            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1780            * @retval None
   1781            */
   1782          void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1783          {
   1784            uint16_t tmpccmr2 = 0;
   1785            /* Check the parameters */
   1786            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1787            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1788            tmpccmr2 = TIMx->CCMR2;
   1789            /* Reset the OC4CE Bit */
   1790            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
   1791            /* Enable or Disable the Output Compare Clear Bit */
   1792            tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
   1793            /* Write to TIMx CCMR2 register */
   1794            TIMx->CCMR2 = tmpccmr2;
   1795          }
   1796          
   1797          /**
   1798            * @brief  Configures the TIMx channel 1 polarity.
   1799            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   1800            * @param  TIM_OCPolarity: specifies the OC1 Polarity
   1801            *   This parameter can be one of the following values:
   1802            *     @arg TIM_OCPolarity_High: Output Compare active high
   1803            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1804            * @retval None
   1805            */
   1806          void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1807          {
   1808            uint16_t tmpccer = 0;
   1809            /* Check the parameters */
   1810            assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   1811            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1812            tmpccer = TIMx->CCER;
   1813            /* Set or Reset the CC1P Bit */
   1814            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
   1815            tmpccer |= TIM_OCPolarity;
   1816            /* Write to TIMx CCER register */
   1817            TIMx->CCER = tmpccer;
   1818          }
   1819          
   1820          /**
   1821            * @brief  Configures the TIMx Channel 1N polarity.
   1822            * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIM peripheral.
   1823            * @param  TIM_OCNPolarity: specifies the OC1N Polarity
   1824            *   This parameter can be one of the following values:
   1825            *     @arg TIM_OCNPolarity_High: Output Compare active high
   1826            *     @arg TIM_OCNPolarity_Low: Output Compare active low
   1827            * @retval None
   1828            */
   1829          void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1830          {
   1831            uint16_t tmpccer = 0;
   1832            /* Check the parameters */
   1833            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1834            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1835             
   1836            tmpccer = TIMx->CCER;
   1837            /* Set or Reset the CC1NP Bit */
   1838            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);
   1839            tmpccer |= TIM_OCNPolarity;
   1840            /* Write to TIMx CCER register */
   1841            TIMx->CCER = tmpccer;
   1842          }
   1843          
   1844          /**
   1845            * @brief  Configures the TIMx channel 2 polarity.
   1846            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   1847            * @param  TIM_OCPolarity: specifies the OC2 Polarity
   1848            *   This parameter can be one of the following values:
   1849            *     @arg TIM_OCPolarity_High: Output Compare active high
   1850            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1851            * @retval None
   1852            */
   1853          void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1854          {
   1855            uint16_t tmpccer = 0;
   1856            /* Check the parameters */
   1857            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   1858            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1859            tmpccer = TIMx->CCER;
   1860            /* Set or Reset the CC2P Bit */
   1861            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
   1862            tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
   1863            /* Write to TIMx CCER register */
   1864            TIMx->CCER = tmpccer;
   1865          }
   1866          
   1867          /**
   1868            * @brief  Configures the TIMx Channel 2N polarity.
   1869            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1870            * @param  TIM_OCNPolarity: specifies the OC2N Polarity
   1871            *   This parameter can be one of the following values:
   1872            *     @arg TIM_OCNPolarity_High: Output Compare active high
   1873            *     @arg TIM_OCNPolarity_Low: Output Compare active low
   1874            * @retval None
   1875            */
   1876          void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1877          {
   1878            uint16_t tmpccer = 0;
   1879            /* Check the parameters */
   1880            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1881            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1882            
   1883            tmpccer = TIMx->CCER;
   1884            /* Set or Reset the CC2NP Bit */
   1885            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);
   1886            tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
   1887            /* Write to TIMx CCER register */
   1888            TIMx->CCER = tmpccer;
   1889          }
   1890          
   1891          /**
   1892            * @brief  Configures the TIMx channel 3 polarity.
   1893            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1894            * @param  TIM_OCPolarity: specifies the OC3 Polarity
   1895            *   This parameter can be one of the following values:
   1896            *     @arg TIM_OCPolarity_High: Output Compare active high
   1897            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1898            * @retval None
   1899            */
   1900          void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1901          {
   1902            uint16_t tmpccer = 0;
   1903            /* Check the parameters */
   1904            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1905            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1906            tmpccer = TIMx->CCER;
   1907            /* Set or Reset the CC3P Bit */
   1908            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
   1909            tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
   1910            /* Write to TIMx CCER register */
   1911            TIMx->CCER = tmpccer;
   1912          }
   1913          
   1914          /**
   1915            * @brief  Configures the TIMx Channel 3N polarity.
   1916            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1917            * @param  TIM_OCNPolarity: specifies the OC3N Polarity
   1918            *   This parameter can be one of the following values:
   1919            *     @arg TIM_OCNPolarity_High: Output Compare active high
   1920            *     @arg TIM_OCNPolarity_Low: Output Compare active low
   1921            * @retval None
   1922            */
   1923          void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1924          {
   1925            uint16_t tmpccer = 0;
   1926           
   1927            /* Check the parameters */
   1928            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1929            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1930              
   1931            tmpccer = TIMx->CCER;
   1932            /* Set or Reset the CC3NP Bit */
   1933            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3NP);
   1934            tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
   1935            /* Write to TIMx CCER register */
   1936            TIMx->CCER = tmpccer;
   1937          }
   1938          
   1939          /**
   1940            * @brief  Configures the TIMx channel 4 polarity.
   1941            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1942            * @param  TIM_OCPolarity: specifies the OC4 Polarity
   1943            *   This parameter can be one of the following values:
   1944            *     @arg TIM_OCPolarity_High: Output Compare active high
   1945            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1946            * @retval None
   1947            */
   1948          void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1949          {
   1950            uint16_t tmpccer = 0;
   1951            /* Check the parameters */
   1952            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1953            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1954            tmpccer = TIMx->CCER;
   1955            /* Set or Reset the CC4P Bit */
   1956            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
   1957            tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
   1958            /* Write to TIMx CCER register */
   1959            TIMx->CCER = tmpccer;
   1960          }
   1961          
   1962          /**
   1963            * @brief  Enables or disables the TIM Capture Compare Channel x.
   1964            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   1965            * @param  TIM_Channel: specifies the TIM Channel
   1966            *   This parameter can be one of the following values:
   1967            *     @arg TIM_Channel_1: TIM Channel 1
   1968            *     @arg TIM_Channel_2: TIM Channel 2
   1969            *     @arg TIM_Channel_3: TIM Channel 3
   1970            *     @arg TIM_Channel_4: TIM Channel 4
   1971            * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
   1972            *   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
   1973            * @retval None
   1974            */
   1975          void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
   1976          {
   1977            uint16_t tmp = 0;
   1978          
   1979            /* Check the parameters */
   1980            assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   1981            assert_param(IS_TIM_CHANNEL(TIM_Channel));
   1982            assert_param(IS_TIM_CCX(TIM_CCx));
   1983          
   1984            tmp = CCER_CCE_Set << TIM_Channel;
   1985          
   1986            /* Reset the CCxE Bit */
   1987            TIMx->CCER &= (uint16_t)~ tmp;
   1988          
   1989            /* Set or reset the CCxE Bit */ 
   1990            TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
   1991          }
   1992          
   1993          /**
   1994            * @brief  Enables or disables the TIM Capture Compare Channel xN.
   1995            * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIM peripheral.
   1996            * @param  TIM_Channel: specifies the TIM Channel
   1997            *   This parameter can be one of the following values:
   1998            *     @arg TIM_Channel_1: TIM Channel 1
   1999            *     @arg TIM_Channel_2: TIM Channel 2
   2000            *     @arg TIM_Channel_3: TIM Channel 3
   2001            * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
   2002            *   This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
   2003            * @retval None
   2004            */
   2005          void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
   2006          {
   2007            uint16_t tmp = 0;
   2008          
   2009            /* Check the parameters */
   2010            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2011            assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
   2012            assert_param(IS_TIM_CCXN(TIM_CCxN));
   2013          
   2014            tmp = CCER_CCNE_Set << TIM_Channel;
   2015          
   2016            /* Reset the CCxNE Bit */
   2017            TIMx->CCER &= (uint16_t) ~tmp;
   2018          
   2019            /* Set or reset the CCxNE Bit */ 
   2020            TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
   2021          }
   2022          
   2023          /**
   2024            * @brief  Selects the TIM Output Compare Mode.
   2025            * @note   This function disables the selected channel before changing the Output
   2026            *         Compare Mode.
   2027            *         User has to enable this channel using TIM_CCxCmd and TIM_CCxNCmd functions.
   2028            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   2029            * @param  TIM_Channel: specifies the TIM Channel
   2030            *   This parameter can be one of the following values:
   2031            *     @arg TIM_Channel_1: TIM Channel 1
   2032            *     @arg TIM_Channel_2: TIM Channel 2
   2033            *     @arg TIM_Channel_3: TIM Channel 3
   2034            *     @arg TIM_Channel_4: TIM Channel 4
   2035            * @param  TIM_OCMode: specifies the TIM Output Compare Mode.
   2036            *   This parameter can be one of the following values:
   2037            *     @arg TIM_OCMode_Timing
   2038            *     @arg TIM_OCMode_Active
   2039            *     @arg TIM_OCMode_Toggle
   2040            *     @arg TIM_OCMode_PWM1
   2041            *     @arg TIM_OCMode_PWM2
   2042            *     @arg TIM_ForcedAction_Active
   2043            *     @arg TIM_ForcedAction_InActive
   2044            * @retval None
   2045            */
   2046          void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
   2047          {
   2048            uint32_t tmp = 0;
   2049            uint16_t tmp1 = 0;
   2050          
   2051            /* Check the parameters */
   2052            assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   2053            assert_param(IS_TIM_CHANNEL(TIM_Channel));
   2054            assert_param(IS_TIM_OCM(TIM_OCMode));
   2055          
   2056            tmp = (uint32_t) TIMx;
   2057            tmp += CCMR_Offset;
   2058          
   2059            tmp1 = CCER_CCE_Set << (uint16_t)TIM_Channel;
   2060          
   2061            /* Disable the Channel: Reset the CCxE Bit */
   2062            TIMx->CCER &= (uint16_t) ~tmp1;
   2063          
   2064            if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
   2065            {
   2066              tmp += (TIM_Channel>>1);
   2067          
   2068              /* Reset the OCxM bits in the CCMRx register */
   2069              *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
   2070             
   2071              /* Configure the OCxM bits in the CCMRx register */
   2072              *(__IO uint32_t *) tmp |= TIM_OCMode;
   2073            }
   2074            else
   2075            {
   2076              tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
   2077          
   2078              /* Reset the OCxM bits in the CCMRx register */
   2079              *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
   2080              
   2081              /* Configure the OCxM bits in the CCMRx register */
   2082              *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
   2083            }
   2084          }
   2085          
   2086          /**
   2087            * @brief  Enables or Disables the TIMx Update event.
   2088            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2089            * @param  NewState: new state of the TIMx UDIS bit
   2090            *   This parameter can be: ENABLE or DISABLE.
   2091            * @retval None
   2092            */
   2093          void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
   2094          {
   2095            /* Check the parameters */
   2096            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2097            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2098            if (NewState != DISABLE)
   2099            {
   2100              /* Set the Update Disable Bit */
   2101              TIMx->CR1 |= TIM_CR1_UDIS;
   2102            }
   2103            else
   2104            {
   2105              /* Reset the Update Disable Bit */
   2106              TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
   2107            }
   2108          }
   2109          
   2110          /**
   2111            * @brief  Configures the TIMx Update Request Interrupt source.
   2112            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2113            * @param  TIM_UpdateSource: specifies the Update source.
   2114            *   This parameter can be one of the following values:
   2115            *     @arg TIM_UpdateSource_Regular: Source of update is the counter overflow/underflow
   2116                                                 or the setting of UG bit, or an update generation
   2117                                                 through the slave mode controller.
   2118            *     @arg TIM_UpdateSource_Global: Source of update is counter overflow/underflow.
   2119            * @retval None
   2120            */
   2121          void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
   2122          {
   2123            /* Check the parameters */
   2124            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2125            assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
   2126            if (TIM_UpdateSource != TIM_UpdateSource_Global)
   2127            {
   2128              /* Set the URS Bit */
   2129              TIMx->CR1 |= TIM_CR1_URS;
   2130            }
   2131            else
   2132            {
   2133              /* Reset the URS Bit */
   2134              TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
   2135            }
   2136          }
   2137          
   2138          /**
   2139            * @brief  Enables or disables the TIMx's Hall sensor interface.
   2140            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2141            * @param  NewState: new state of the TIMx Hall sensor interface.
   2142            *   This parameter can be: ENABLE or DISABLE.
   2143            * @retval None
   2144            */
   2145          void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
   2146          {
   2147            /* Check the parameters */
   2148            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2149            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2150            if (NewState != DISABLE)
   2151            {
   2152              /* Set the TI1S Bit */
   2153              TIMx->CR2 |= TIM_CR2_TI1S;
   2154            }
   2155            else
   2156            {
   2157              /* Reset the TI1S Bit */
   2158              TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
   2159            }
   2160          }
   2161          
   2162          /**
   2163            * @brief  Selects the TIMx's One Pulse Mode.
   2164            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2165            * @param  TIM_OPMode: specifies the OPM Mode to be used.
   2166            *   This parameter can be one of the following values:
   2167            *     @arg TIM_OPMode_Single
   2168            *     @arg TIM_OPMode_Repetitive
   2169            * @retval None
   2170            */
   2171          void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
   2172          {
   2173            /* Check the parameters */
   2174            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2175            assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
   2176            /* Reset the OPM Bit */
   2177            TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
   2178            /* Configure the OPM Mode */
   2179            TIMx->CR1 |= TIM_OPMode;
   2180          }
   2181          
   2182          /**
   2183            * @brief  Selects the TIMx Trigger Output Mode.
   2184            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 6, 7, 8, 9, 12 or 15 to select the TIM peripheral.
   2185            * @param  TIM_TRGOSource: specifies the Trigger Output source.
   2186            *   This paramter can be one of the following values:
   2187            *
   2188            *  - For all TIMx
   2189            *     @arg TIM_TRGOSource_Reset:  The UG bit in the TIM_EGR register is used as the trigger output (TRGO).
   2190            *     @arg TIM_TRGOSource_Enable: The Counter Enable CEN is used as the trigger output (TRGO).
   2191            *     @arg TIM_TRGOSource_Update: The update event is selected as the trigger output (TRGO).
   2192            *
   2193            *  - For all TIMx except TIM6 and TIM7
   2194            *     @arg TIM_TRGOSource_OC1: The trigger output sends a positive pulse when the CC1IF flag
   2195            *                              is to be set, as soon as a capture or compare match occurs (TRGO).
   2196            *     @arg TIM_TRGOSource_OC1Ref: OC1REF signal is used as the trigger output (TRGO).
   2197            *     @arg TIM_TRGOSource_OC2Ref: OC2REF signal is used as the trigger output (TRGO).
   2198            *     @arg TIM_TRGOSource_OC3Ref: OC3REF signal is used as the trigger output (TRGO).
   2199            *     @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output (TRGO).
   2200            *
   2201            * @retval None
   2202            */
   2203          void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
   2204          {
   2205            /* Check the parameters */
   2206            assert_param(IS_TIM_LIST7_PERIPH(TIMx));
   2207            assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
   2208            /* Reset the MMS Bits */
   2209            TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
   2210            /* Select the TRGO source */
   2211            TIMx->CR2 |=  TIM_TRGOSource;
   2212          }
   2213          
   2214          /**
   2215            * @brief  Selects the TIMx Slave Mode.
   2216            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   2217            * @param  TIM_SlaveMode: specifies the Timer Slave Mode.
   2218            *   This parameter can be one of the following values:
   2219            *     @arg TIM_SlaveMode_Reset: Rising edge of the selected trigger signal (TRGI) re-initializes
   2220            *                               the counter and triggers an update of the registers.
   2221            *     @arg TIM_SlaveMode_Gated:     The counter clock is enabled when the trigger signal (TRGI) is high.
   2222            *     @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI.
   2223            *     @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter.
   2224            * @retval None
   2225            */
   2226          void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
   2227          {
   2228            /* Check the parameters */
   2229            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2230            assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
   2231           /* Reset the SMS Bits */
   2232            TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
   2233            /* Select the Slave Mode */
   2234            TIMx->SMCR |= TIM_SlaveMode;
   2235          }
   2236          
   2237          /**
   2238            * @brief  Sets or Resets the TIMx Master/Slave Mode.
   2239            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   2240            * @param  TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
   2241            *   This parameter can be one of the following values:
   2242            *     @arg TIM_MasterSlaveMode_Enable: synchronization between the current timer
   2243            *                                      and its slaves (through TRGO).
   2244            *     @arg TIM_MasterSlaveMode_Disable: No action
   2245            * @retval None
   2246            */
   2247          void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
   2248          {
   2249            /* Check the parameters */
   2250            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2251            assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
   2252            /* Reset the MSM Bit */
   2253            TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
   2254            
   2255            /* Set or Reset the MSM Bit */
   2256            TIMx->SMCR |= TIM_MasterSlaveMode;
   2257          }
   2258          
   2259          /**
   2260            * @brief  Sets the TIMx Counter Register value
   2261            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2262            * @param  Counter: specifies the Counter register new value.
   2263            * @retval None
   2264            */
   2265          void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)
   2266          {
   2267            /* Check the parameters */
   2268            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2269            /* Set the Counter Register value */
   2270            TIMx->CNT = Counter;
   2271          }
   2272          
   2273          /**
   2274            * @brief  Sets the TIMx Autoreload Register value
   2275            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2276            * @param  Autoreload: specifies the Autoreload register new value.
   2277            * @retval None
   2278            */
   2279          void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)
   2280          {
   2281            /* Check the parameters */
   2282            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2283            /* Set the Autoreload Register value */
   2284            TIMx->ARR = Autoreload;
   2285          }
   2286          
   2287          /**
   2288            * @brief  Sets the TIMx Capture Compare1 Register value
   2289            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   2290            * @param  Compare1: specifies the Capture Compare1 register new value.
   2291            * @retval None
   2292            */
   2293          void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)
   2294          {
   2295            /* Check the parameters */
   2296            assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   2297            /* Set the Capture Compare1 Register value */
   2298            TIMx->CCR1 = Compare1;
   2299          }
   2300          
   2301          /**
   2302            * @brief  Sets the TIMx Capture Compare2 Register value
   2303            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   2304            * @param  Compare2: specifies the Capture Compare2 register new value.
   2305            * @retval None
   2306            */
   2307          void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)
   2308          {
   2309            /* Check the parameters */
   2310            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2311            /* Set the Capture Compare2 Register value */
   2312            TIMx->CCR2 = Compare2;
   2313          }
   2314          
   2315          /**
   2316            * @brief  Sets the TIMx Capture Compare3 Register value
   2317            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2318            * @param  Compare3: specifies the Capture Compare3 register new value.
   2319            * @retval None
   2320            */
   2321          void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3)
   2322          {
   2323            /* Check the parameters */
   2324            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2325            /* Set the Capture Compare3 Register value */
   2326            TIMx->CCR3 = Compare3;
   2327          }
   2328          
   2329          /**
   2330            * @brief  Sets the TIMx Capture Compare4 Register value
   2331            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2332            * @param  Compare4: specifies the Capture Compare4 register new value.
   2333            * @retval None
   2334            */
   2335          void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4)
   2336          {
   2337            /* Check the parameters */
   2338            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2339            /* Set the Capture Compare4 Register value */
   2340            TIMx->CCR4 = Compare4;
   2341          }
   2342          
   2343          /**
   2344            * @brief  Sets the TIMx Input Capture 1 prescaler.
   2345            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   2346            * @param  TIM_ICPSC: specifies the Input Capture1 prescaler new value.
   2347            *   This parameter can be one of the following values:
   2348            *     @arg TIM_ICPSC_DIV1: no prescaler
   2349            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2350            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2351            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2352            * @retval None
   2353            */
   2354          void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2355          {
   2356            /* Check the parameters */
   2357            assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   2358            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2359            /* Reset the IC1PSC Bits */
   2360            TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
   2361            /* Set the IC1PSC value */
   2362            TIMx->CCMR1 |= TIM_ICPSC;
   2363          }
   2364          
   2365          /**
   2366            * @brief  Sets the TIMx Input Capture 2 prescaler.
   2367            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   2368            * @param  TIM_ICPSC: specifies the Input Capture2 prescaler new value.
   2369            *   This parameter can be one of the following values:
   2370            *     @arg TIM_ICPSC_DIV1: no prescaler
   2371            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2372            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2373            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2374            * @retval None
   2375            */
   2376          void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2377          {
   2378            /* Check the parameters */
   2379            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2380            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2381            /* Reset the IC2PSC Bits */
   2382            TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
   2383            /* Set the IC2PSC value */
   2384            TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
   2385          }
   2386          
   2387          /**
   2388            * @brief  Sets the TIMx Input Capture 3 prescaler.
   2389            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2390            * @param  TIM_ICPSC: specifies the Input Capture3 prescaler new value.
   2391            *   This parameter can be one of the following values:
   2392            *     @arg TIM_ICPSC_DIV1: no prescaler
   2393            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2394            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2395            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2396            * @retval None
   2397            */
   2398          void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2399          {
   2400            /* Check the parameters */
   2401            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2402            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2403            /* Reset the IC3PSC Bits */
   2404            TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
   2405            /* Set the IC3PSC value */
   2406            TIMx->CCMR2 |= TIM_ICPSC;
   2407          }
   2408          
   2409          /**
   2410            * @brief  Sets the TIMx Input Capture 4 prescaler.
   2411            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2412            * @param  TIM_ICPSC: specifies the Input Capture4 prescaler new value.
   2413            *   This parameter can be one of the following values:
   2414            *     @arg TIM_ICPSC_DIV1: no prescaler
   2415            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2416            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2417            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2418            * @retval None
   2419            */
   2420          void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2421          {  
   2422            /* Check the parameters */
   2423            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2424            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2425            /* Reset the IC4PSC Bits */
   2426            TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
   2427            /* Set the IC4PSC value */
   2428            TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
   2429          }
   2430          
   2431          /**
   2432            * @brief  Sets the TIMx Clock Division value.
   2433            * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select 
   2434            *   the TIM peripheral.
   2435            * @param  TIM_CKD: specifies the clock division value.
   2436            *   This parameter can be one of the following value:
   2437            *     @arg TIM_CKD_DIV1: TDTS = Tck_tim
   2438            *     @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim
   2439            *     @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim
   2440            * @retval None
   2441            */
   2442          void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
   2443          {
   2444            /* Check the parameters */
   2445            assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   2446            assert_param(IS_TIM_CKD_DIV(TIM_CKD));
   2447            /* Reset the CKD Bits */
   2448            TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
   2449            /* Set the CKD value */
   2450            TIMx->CR1 |= TIM_CKD;
   2451          }
   2452          
   2453          /**
   2454            * @brief  Gets the TIMx Input Capture 1 value.
   2455            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   2456            * @retval Capture Compare 1 Register value.
   2457            */
   2458          uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx)
   2459          {
   2460            /* Check the parameters */
   2461            assert_param(IS_TIM_LIST8_PERIPH(TIMx));
   2462            /* Get the Capture 1 Register value */
   2463            return TIMx->CCR1;
   2464          }
   2465          
   2466          /**
   2467            * @brief  Gets the TIMx Input Capture 2 value.
   2468            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   2469            * @retval Capture Compare 2 Register value.
   2470            */
   2471          uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)
   2472          {
   2473            /* Check the parameters */
   2474            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2475            /* Get the Capture 2 Register value */
   2476            return TIMx->CCR2;
   2477          }
   2478          
   2479          /**
   2480            * @brief  Gets the TIMx Input Capture 3 value.
   2481            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2482            * @retval Capture Compare 3 Register value.
   2483            */
   2484          uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
   2485          {
   2486            /* Check the parameters */
   2487            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
   2488            /* Get the Capture 3 Register value */
   2489            return TIMx->CCR3;
   2490          }
   2491          
   2492          /**
   2493            * @brief  Gets the TIMx Input Capture 4 value.
   2494            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2495            * @retval Capture Compare 4 Register value.
   2496            */
   2497          uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
   2498          {
   2499            /* Check the parameters */
   2500            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2501            /* Get the Capture 4 Register value */
   2502            return TIMx->CCR4;
   2503          }
   2504          
   2505          /**
   2506            * @brief  Gets the TIMx Counter value.
   2507            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2508            * @retval Counter Register value.
   2509            */
   2510          uint16_t TIM_GetCounter(TIM_TypeDef* TIMx)
   2511          {
   2512            /* Check the parameters */
   2513            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2514            /* Get the Counter Register value */
   2515            return TIMx->CNT;
   2516          }
   2517          
   2518          /**
   2519            * @brief  Gets the TIMx Prescaler value.
   2520            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2521            * @retval Prescaler Register value.
   2522            */
   2523          uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
   2524          {
   2525            /* Check the parameters */
   2526            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2527            /* Get the Prescaler Register value */
   2528            return TIMx->PSC;
   2529          }
   2530          
   2531          /**
   2532            * @brief  Checks whether the specified TIM flag is set or not.
   2533            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2534            * @param  TIM_FLAG: specifies the flag to check.
   2535            *   This parameter can be one of the following values:
   2536            *     @arg TIM_FLAG_Update: TIM update Flag
   2537            *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2538            *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2539            *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2540            *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2541            *     @arg TIM_FLAG_COM: TIM Commutation Flag
   2542            *     @arg TIM_FLAG_Trigger: TIM Trigger Flag
   2543            *     @arg TIM_FLAG_Break: TIM Break Flag
   2544            *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
   2545            *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
   2546            *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
   2547            *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
   2548            * @note
   2549            *   - TIM6 and TIM7 can have only one update flag. 
   2550            *   - TIM9, TIM12 and TIM15 can have only TIM_FLAG_Update, TIM_FLAG_CC1,
   2551            *      TIM_FLAG_CC2 or TIM_FLAG_Trigger. 
   2552            *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_FLAG_Update or TIM_FLAG_CC1.   
   2553            *   - TIM_FLAG_Break is used only with TIM1, TIM8 and TIM15. 
   2554            *   - TIM_FLAG_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.    
   2555            * @retval The new state of TIM_FLAG (SET or RESET).
   2556            */
   2557          FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   2558          { 
   2559            ITStatus bitstatus = RESET;  
   2560            /* Check the parameters */
   2561            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2562            assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
   2563            
   2564            if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
   2565            {
   2566              bitstatus = SET;
   2567            }
   2568            else
   2569            {
   2570              bitstatus = RESET;
   2571            }
   2572            return bitstatus;
   2573          }
   2574          
   2575          /**
   2576            * @brief  Clears the TIMx's pending flags.
   2577            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2578            * @param  TIM_FLAG: specifies the flag bit to clear.
   2579            *   This parameter can be any combination of the following values:
   2580            *     @arg TIM_FLAG_Update: TIM update Flag
   2581            *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2582            *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2583            *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2584            *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2585            *     @arg TIM_FLAG_COM: TIM Commutation Flag
   2586            *     @arg TIM_FLAG_Trigger: TIM Trigger Flag
   2587            *     @arg TIM_FLAG_Break: TIM Break Flag
   2588            *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
   2589            *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
   2590            *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
   2591            *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
   2592            * @note
   2593            *   - TIM6 and TIM7 can have only one update flag. 
   2594            *   - TIM9, TIM12 and TIM15 can have only TIM_FLAG_Update, TIM_FLAG_CC1,
   2595            *      TIM_FLAG_CC2 or TIM_FLAG_Trigger. 
   2596            *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_FLAG_Update or TIM_FLAG_CC1.   
   2597            *   - TIM_FLAG_Break is used only with TIM1, TIM8 and TIM15. 
   2598            *   - TIM_FLAG_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.   
   2599            * @retval None
   2600            */
   2601          void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   2602          {  
   2603            /* Check the parameters */
   2604            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2605            assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
   2606             
   2607            /* Clear the flags */
   2608            TIMx->SR = (uint16_t)~TIM_FLAG;
   2609          }
   2610          
   2611          /**
   2612            * @brief  Checks whether the TIM interrupt has occurred or not.
   2613            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2614            * @param  TIM_IT: specifies the TIM interrupt source to check.
   2615            *   This parameter can be one of the following values:
   2616            *     @arg TIM_IT_Update: TIM update Interrupt source
   2617            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2618            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2619            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2620            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2621            *     @arg TIM_IT_COM: TIM Commutation Interrupt source
   2622            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2623            *     @arg TIM_IT_Break: TIM Break Interrupt source
   2624            * @note
   2625            *   - TIM6 and TIM7 can generate only an update interrupt.
   2626            *   - TIM9, TIM12 and TIM15 can have only TIM_IT_Update, TIM_IT_CC1,
   2627            *      TIM_IT_CC2 or TIM_IT_Trigger. 
   2628            *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.   
   2629            *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15. 
   2630            *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.  
   2631            * @retval The new state of the TIM_IT(SET or RESET).
   2632            */
   2633          ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2634          {
   2635            ITStatus bitstatus = RESET;  
   2636            uint16_t itstatus = 0x0, itenable = 0x0;
   2637            /* Check the parameters */
   2638            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2639            assert_param(IS_TIM_GET_IT(TIM_IT));
   2640             
   2641            itstatus = TIMx->SR & TIM_IT;
   2642            
   2643            itenable = TIMx->DIER & TIM_IT;
   2644            if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
   2645            {
   2646              bitstatus = SET;
   2647            }
   2648            else
   2649            {
   2650              bitstatus = RESET;
   2651            }
   2652            return bitstatus;
   2653          }
   2654          
   2655          /**
   2656            * @brief  Clears the TIMx's interrupt pending bits.
   2657            * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
   2658            * @param  TIM_IT: specifies the pending bit to clear.
   2659            *   This parameter can be any combination of the following values:
   2660            *     @arg TIM_IT_Update: TIM1 update Interrupt source
   2661            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2662            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2663            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2664            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2665            *     @arg TIM_IT_COM: TIM Commutation Interrupt source
   2666            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2667            *     @arg TIM_IT_Break: TIM Break Interrupt source
   2668            * @note
   2669            *   - TIM6 and TIM7 can generate only an update interrupt.
   2670            *   - TIM9, TIM12 and TIM15 can have only TIM_IT_Update, TIM_IT_CC1,
   2671            *      TIM_IT_CC2 or TIM_IT_Trigger. 
   2672            *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.   
   2673            *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15. 
   2674            *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.    
   2675            * @retval None
   2676            */
   2677          void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2678          {
   2679            /* Check the parameters */
   2680            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2681            assert_param(IS_TIM_IT(TIM_IT));
   2682            /* Clear the IT pending Bit */
   2683            TIMx->SR = (uint16_t)~TIM_IT;
   2684          }
   2685          
   2686          /**
   2687            * @brief  Configure the TI1 as Input.
   2688            * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
   2689            * @param  TIM_ICPolarity : The Input Polarity.
   2690            *   This parameter can be one of the following values:
   2691            *     @arg TIM_ICPolarity_Rising
   2692            *     @arg TIM_ICPolarity_Falling
   2693            * @param  TIM_ICSelection: specifies the input to be used.
   2694            *   This parameter can be one of the following values:
   2695            *     @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
   2696            *     @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
   2697            *     @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
   2698            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2699            *   This parameter must be a value between 0x00 and 0x0F.
   2700            * @retval None
   2701            */
   2702          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2703                                 uint16_t TIM_ICFilter)
   2704          {
   2705            uint16_t tmpccmr1 = 0, tmpccer = 0;
   2706            /* Disable the Channel 1: Reset the CC1E Bit */
   2707            TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
   2708            tmpccmr1 = TIMx->CCMR1;
   2709            tmpccer = TIMx->CCER;
   2710            /* Select the Input and set the filter */
   2711            tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
   2712            tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   2713            
   2714            if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
   2715               (TIMx == TIM4) ||(TIMx == TIM5))
   2716            {
   2717              /* Select the Polarity and set the CC1E Bit */
   2718              tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P));
   2719              tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
   2720            }
   2721            else
   2722            {
   2723              /* Select the Polarity and set the CC1E Bit */
   2724              tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
   2725              tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
   2726            }
   2727          
   2728            /* Write to TIMx CCMR1 and CCER registers */
   2729            TIMx->CCMR1 = tmpccmr1;
   2730            TIMx->CCER = tmpccer;
   2731          }
   2732          
   2733          /**
   2734            * @brief  Configure the TI2 as Input.
   2735            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
   2736            * @param  TIM_ICPolarity : The Input Polarity.
   2737            *   This parameter can be one of the following values:
   2738            *     @arg TIM_ICPolarity_Rising
   2739            *     @arg TIM_ICPolarity_Falling
   2740            * @param  TIM_ICSelection: specifies the input to be used.
   2741            *   This parameter can be one of the following values:
   2742            *     @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
   2743            *     @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
   2744            *     @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
   2745            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2746            *   This parameter must be a value between 0x00 and 0x0F.
   2747            * @retval None
   2748            */
   2749          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2750                                 uint16_t TIM_ICFilter)
   2751          {
   2752            uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
   2753            /* Disable the Channel 2: Reset the CC2E Bit */
   2754            TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
   2755            tmpccmr1 = TIMx->CCMR1;
   2756            tmpccer = TIMx->CCER;
   2757            tmp = (uint16_t)(TIM_ICPolarity << 4);
   2758            /* Select the Input and set the filter */
   2759            tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
   2760            tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
   2761            tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
   2762            
   2763            if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
   2764               (TIMx == TIM4) ||(TIMx == TIM5))
   2765            {
   2766              /* Select the Polarity and set the CC2E Bit */
   2767              tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P));
   2768              tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
   2769            }
   2770            else
   2771            {
   2772              /* Select the Polarity and set the CC2E Bit */
   2773              tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
   2774              tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC2E);
   2775            }
   2776            
   2777            /* Write to TIMx CCMR1 and CCER registers */
   2778            TIMx->CCMR1 = tmpccmr1 ;
   2779            TIMx->CCER = tmpccer;
   2780          }
   2781          
   2782          /**
   2783            * @brief  Configure the TI3 as Input.
   2784            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2785            * @param  TIM_ICPolarity : The Input Polarity.
   2786            *   This parameter can be one of the following values:
   2787            *     @arg TIM_ICPolarity_Rising
   2788            *     @arg TIM_ICPolarity_Falling
   2789            * @param  TIM_ICSelection: specifies the input to be used.
   2790            *   This parameter can be one of the following values:
   2791            *     @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
   2792            *     @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
   2793            *     @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
   2794            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2795            *   This parameter must be a value between 0x00 and 0x0F.
   2796            * @retval None
   2797            */
   2798          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2799                                 uint16_t TIM_ICFilter)
   2800          {
   2801            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   2802            /* Disable the Channel 3: Reset the CC3E Bit */
   2803            TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
   2804            tmpccmr2 = TIMx->CCMR2;
   2805            tmpccer = TIMx->CCER;
   2806            tmp = (uint16_t)(TIM_ICPolarity << 8);
   2807            /* Select the Input and set the filter */
   2808            tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
   2809            tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   2810              
   2811            if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
   2812               (TIMx == TIM4) ||(TIMx == TIM5))
   2813            {
   2814              /* Select the Polarity and set the CC3E Bit */
   2815              tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P));
   2816              tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
   2817            }
   2818            else
   2819            {
   2820              /* Select the Polarity and set the CC3E Bit */
   2821              tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC3NP));
   2822              tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC3E);
   2823            }
   2824            
   2825            /* Write to TIMx CCMR2 and CCER registers */
   2826            TIMx->CCMR2 = tmpccmr2;
   2827            TIMx->CCER = tmpccer;
   2828          }
   2829          
   2830          /**
   2831            * @brief  Configure the TI4 as Input.
   2832            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2833            * @param  TIM_ICPolarity : The Input Polarity.
   2834            *   This parameter can be one of the following values:
   2835            *     @arg TIM_ICPolarity_Rising
   2836            *     @arg TIM_ICPolarity_Falling
   2837            * @param  TIM_ICSelection: specifies the input to be used.
   2838            *   This parameter can be one of the following values:
   2839            *     @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
   2840            *     @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
   2841            *     @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
   2842            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2843            *   This parameter must be a value between 0x00 and 0x0F.
   2844            * @retval None
   2845            */
   2846          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2847                                 uint16_t TIM_ICFilter)
   2848          {
   2849            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   2850          
   2851             /* Disable the Channel 4: Reset the CC4E Bit */
   2852            TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
   2853            tmpccmr2 = TIMx->CCMR2;
   2854            tmpccer = TIMx->CCER;
   2855            tmp = (uint16_t)(TIM_ICPolarity << 12);
   2856            /* Select the Input and set the filter */
   2857            tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
   2858            tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
   2859            tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
   2860            
   2861            if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
   2862               (TIMx == TIM4) ||(TIMx == TIM5))
   2863            {
   2864              /* Select the Polarity and set the CC4E Bit */
   2865              tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P));
   2866              tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
   2867            }
   2868            else
   2869            {
   2870              /* Select the Polarity and set the CC4E Bit */
   2871              tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC4NP));
   2872              tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC4E);
   2873            }
   2874            /* Write to TIMx CCMR2 and CCER registers */
   2875            TIMx->CCMR2 = tmpccmr2;
   2876            TIMx->CCER = tmpccer;
   2877          }
   2878          
   2879          /**
   2880            * @}
   2881            */
   2882          
   2883          /**
   2884            * @}
   2885            */
   2886          
   2887          /**
   2888            * @}
   2889            */
   2890          
   2891          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   TI1_Config
      24   TI2_Config
      24   TI3_Config
      24   TI4_Config
       0   TIM_ARRPreloadConfig
       0   TIM_BDTRConfig
       0   TIM_BDTRStructInit
       0   TIM_CCPreloadControl
      12   TIM_CCxCmd
      12   TIM_CCxNCmd
       0   TIM_ClearFlag
       0   TIM_ClearITPendingBit
       4   TIM_ClearOC1Ref
       0   TIM_ClearOC2Ref
       4   TIM_ClearOC3Ref
       0   TIM_ClearOC4Ref
       0   TIM_Cmd
       4   TIM_CounterModeConfig
       0   TIM_CtrlPWMOutputs
       0   TIM_DMACmd
       0   TIM_DMAConfig
       8   TIM_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
      24   TIM_ETRClockMode1Config
        24   -> TIM_ETRConfig
      24   TIM_ETRClockMode2Config
        24   -> TIM_ETRConfig
      12   TIM_ETRConfig
      24   TIM_EncoderInterfaceConfig
       4   TIM_ForcedOC1Config
       4   TIM_ForcedOC2Config
       4   TIM_ForcedOC3Config
       4   TIM_ForcedOC4Config
       0   TIM_GenerateEvent
       0   TIM_GetCapture1
       0   TIM_GetCapture2
       0   TIM_GetCapture3
       0   TIM_GetCapture4
       0   TIM_GetCounter
       0   TIM_GetFlagStatus
      16   TIM_GetITStatus
       0   TIM_GetPrescaler
      16   TIM_ICInit
        16   -> TI1_Config
        16   -> TI2_Config
        16   -> TI3_Config
        16   -> TI4_Config
        16   -> TIM_SetIC1Prescaler
        16   -> TIM_SetIC2Prescaler
        16   -> TIM_SetIC3Prescaler
        16   -> TIM_SetIC4Prescaler
       0   TIM_ICStructInit
       0   TIM_ITConfig
      16   TIM_ITRxExternalClockConfig
        16   -> TIM_SelectInputTrigger
       0   TIM_InternalClockConfig
       4   TIM_OC1FastConfig
      16   TIM_OC1Init
       4   TIM_OC1NPolarityConfig
       4   TIM_OC1PolarityConfig
       4   TIM_OC1PreloadConfig
       4   TIM_OC2FastConfig
      16   TIM_OC2Init
       4   TIM_OC2NPolarityConfig
       4   TIM_OC2PolarityConfig
       4   TIM_OC2PreloadConfig
       4   TIM_OC3FastConfig
      16   TIM_OC3Init
       4   TIM_OC3NPolarityConfig
       4   TIM_OC3PolarityConfig
       4   TIM_OC3PreloadConfig
       4   TIM_OC4FastConfig
      16   TIM_OC4Init
       4   TIM_OC4PolarityConfig
       4   TIM_OC4PreloadConfig
       0   TIM_OCStructInit
      24   TIM_PWMIConfig
        24   -> TI1_Config
        24   -> TI2_Config
        24   -> TIM_SetIC1Prescaler
        24   -> TIM_SetIC2Prescaler
       0   TIM_PrescalerConfig
       0   TIM_SelectCCDMA
       0   TIM_SelectCOM
       0   TIM_SelectHallSensor
       4   TIM_SelectInputTrigger
       0   TIM_SelectMasterSlaveMode
      16   TIM_SelectOCxM
       0   TIM_SelectOnePulseMode
       0   TIM_SelectOutputTrigger
       0   TIM_SelectSlaveMode
       0   TIM_SetAutoreload
       0   TIM_SetClockDivision
       0   TIM_SetCompare1
       0   TIM_SetCompare2
       0   TIM_SetCompare3
       0   TIM_SetCompare4
       0   TIM_SetCounter
       0   TIM_SetIC1Prescaler
       0   TIM_SetIC2Prescaler
       0   TIM_SetIC3Prescaler
       0   TIM_SetIC4Prescaler
      24   TIM_TIxExternalClockConfig
        24   -> TI1_Config
        24   -> TI2_Config
        24   -> TIM_SelectInputTrigger
       4   TIM_TimeBaseInit
       0   TIM_TimeBaseStructInit
       0   TIM_UpdateDisableConfig
       0   TIM_UpdateRequestConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable9
     104  TI1_Config
     116  TI2_Config
     114  TI3_Config
     116  TI4_Config
      30  TIM_ARRPreloadConfig
      32  TIM_BDTRConfig
      30  TIM_BDTRStructInit
      30  TIM_CCPreloadControl
      30  TIM_CCxCmd
      30  TIM_CCxNCmd
      10  TIM_ClearFlag
      10  TIM_ClearITPendingBit
      20  TIM_ClearOC1Ref
      16  TIM_ClearOC2Ref
      20  TIM_ClearOC3Ref
      16  TIM_ClearOC4Ref
      30  TIM_Cmd
      20  TIM_CounterModeConfig
      36  TIM_CtrlPWMOutputs
      24  TIM_DMACmd
      10  TIM_DMAConfig
     480  TIM_DeInit
      62  TIM_ETRClockMode1Config
      38  TIM_ETRClockMode2Config
      24  TIM_ETRConfig
      82  TIM_EncoderInterfaceConfig
      20  TIM_ForcedOC1Config
      22  TIM_ForcedOC2Config
      20  TIM_ForcedOC3Config
      22  TIM_ForcedOC4Config
       4  TIM_GenerateEvent
       4  TIM_GetCapture1
       4  TIM_GetCapture2
       4  TIM_GetCapture3
       6  TIM_GetCapture4
       4  TIM_GetCounter
      20  TIM_GetFlagStatus
      46  TIM_GetITStatus
       4  TIM_GetPrescaler
     152  TIM_ICInit
      22  TIM_ICStructInit
      24  TIM_ITConfig
      26  TIM_ITRxExternalClockConfig
      12  TIM_InternalClockConfig
      20  TIM_OC1FastConfig
     148  TIM_OC1Init
      20  TIM_OC1NPolarityConfig
      20  TIM_OC1PolarityConfig
      20  TIM_OC1PreloadConfig
      22  TIM_OC2FastConfig
     138  TIM_OC2Init
      22  TIM_OC2NPolarityConfig
      22  TIM_OC2PolarityConfig
      22  TIM_OC2PreloadConfig
      20  TIM_OC3FastConfig
     136  TIM_OC3Init
      22  TIM_OC3NPolarityConfig
      22  TIM_OC3PolarityConfig
      20  TIM_OC3PreloadConfig
      22  TIM_OC4FastConfig
     108  TIM_OC4Init
      22  TIM_OC4PolarityConfig
      22  TIM_OC4PreloadConfig
      34  TIM_OCStructInit
     132  TIM_PWMIConfig
       6  TIM_PrescalerConfig
      30  TIM_SelectCCDMA
      30  TIM_SelectCOM
      30  TIM_SelectHallSensor
      20  TIM_SelectInputTrigger
      18  TIM_SelectMasterSlaveMode
      98  TIM_SelectOCxM
      18  TIM_SelectOnePulseMode
      18  TIM_SelectOutputTrigger
      18  TIM_SelectSlaveMode
       4  TIM_SetAutoreload
      18  TIM_SetClockDivision
       4  TIM_SetCompare1
       4  TIM_SetCompare2
       4  TIM_SetCompare3
       6  TIM_SetCompare4
       4  TIM_SetCounter
      18  TIM_SetIC1Prescaler
      20  TIM_SetIC2Prescaler
      18  TIM_SetIC3Prescaler
      20  TIM_SetIC4Prescaler
      72  TIM_TIxExternalClockConfig
     138  TIM_TimeBaseInit
      24  TIM_TimeBaseStructInit
      30  TIM_UpdateDisableConfig
      30  TIM_UpdateRequestConfig

 
 3'744 bytes in section .text
 
 3'744 bytes of CODE memory

Errors: none
Warnings: none
