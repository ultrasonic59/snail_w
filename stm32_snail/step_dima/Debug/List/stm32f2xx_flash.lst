###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         20/Jun/2020  14:38:25
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\common\libraries\src\stm32f2xx_flash.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EW134F.tmp
#        (D:\proj\velograph\snail\stm32_snail\common\libraries\src\stm32f2xx_flash.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -lcN
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\.\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_rtos\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\..\common\libraries\inc\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_rtos\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_rtos\..\common\dbg\ -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\List\stm32f2xx_flash.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\mstep_rtos\Debug\Obj\stm32f2xx_flash.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\common\libraries\src\stm32f2xx_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_flash.c
      4            * @author  MCD Application Team
      5            * @version V1.1.2
      6            * @date    05-March-2012 
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the FLASH peripheral:
      9            *            - FLASH Interface configuration
     10            *            - FLASH Memory Programming
     11            *            - Option Bytes Programming
     12            *            - Interrupts and flags management
     13            *  
     14            *  @verbatim
     15            *  
     16            *          ===================================================================
     17            *                                 How to use this driver
     18            *          ===================================================================
     19            *                           
     20            *          This driver provides functions to configure and program the FLASH 
     21            *          memory of all STM32F2xx devices.
     22            *          These functions are split in 4 groups:
     23            * 
     24            *           1. FLASH Interface configuration functions: this group includes the
     25            *              management of the following features:
     26            *                    - Set the latency
     27            *                    - Enable/Disable the prefetch buffer
     28            *                    - Enable/Disable the Instruction cache and the Data cache
     29            *                    - Reset the Instruction cache and the Data cache
     30            *  
     31            *           2. FLASH Memory Programming functions: this group includes all needed
     32            *              functions to erase and program the main memory:
     33            *                    - Lock and Unlock the FLASH interface
     34            *                    - Erase function: Erase sector, erase all sectors
     35            *                    - Program functions: byte, half word, word and double word
     36            *  
     37            *           3. Option Bytes Programming functions: this group includes all needed
     38            *              functions to manage the Option Bytes:
     39            *                    - Set/Reset the write protection
     40            *                    - Set the Read protection Level
     41            *                    - Set the BOR level
     42            *                    - Program the user Option Bytes
     43            *                    - Launch the Option Bytes loader
     44            *  
     45            *           4. Interrupts and flags management functions: this group 
     46            *              includes all needed functions to:
     47            *                    - Enable/Disable the FLASH interrupt sources
     48            *                    - Get flags status
     49            *                    - Clear flags
     50            *                    - Get FLASH operation status
     51            *                    - Wait for last FLASH operation
     52            * 
     53            *  @endverbatim
     54            *                      
     55            ******************************************************************************
     56            * @attention
     57            *
     58            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     59            *
     60            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     61            * You may not use this file except in compliance with the License.
     62            * You may obtain a copy of the License at:
     63            *
     64            *        http://www.st.com/software_license_agreement_liberty_v2
     65            *
     66            * Unless required by applicable law or agreed to in writing, software 
     67            * distributed under the License is distributed on an "AS IS" BASIS, 
     68            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     69            * See the License for the specific language governing permissions and
     70            * limitations under the License.
     71            *
     72            ******************************************************************************
     73            */
     74          
     75          /* Includes ------------------------------------------------------------------*/
     76          ///#include "stm32f2xx_flash.h"
     77          #include "stm32f2xx_conf.h"
     78          
     79          /** @addtogroup STM32F2xx_StdPeriph_Driver
     80            * @{
     81            */
     82          
     83          /** @defgroup FLASH 
     84            * @brief FLASH driver modules
     85            * @{
     86            */ 
     87          
     88          /* Private typedef -----------------------------------------------------------*/
     89          /* Private define ------------------------------------------------------------*/ 
     90          #define SECTOR_MASK               ((uint32_t)0xFFFFFF07)
     91          
     92          /* Private macro -------------------------------------------------------------*/
     93          /* Private variables ---------------------------------------------------------*/
     94          /* Private function prototypes -----------------------------------------------*/
     95          /* Private functions ---------------------------------------------------------*/
     96          
     97          /** @defgroup FLASH_Private_Functions
     98            * @{
     99            */ 
    100          
    101          /** @defgroup FLASH_Group1 FLASH Interface configuration functions
    102            *  @brief   FLASH Interface configuration functions 
    103           *
    104          
    105          @verbatim   
    106           ===============================================================================
    107                                 FLASH Interface configuration functions
    108           ===============================================================================
    109          
    110             This group includes the following functions:
    111              - void FLASH_SetLatency(uint32_t FLASH_Latency)
    112                 To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    113                 must be correctly programmed according to the frequency of the CPU clock 
    114                (HCLK) and the supply voltage of the device.
    115           +-------------------------------------------------------------------------------------+     
    116           | Latency       |                HCLK clock frequency (MHz)                           |
    117           |               |---------------------------------------------------------------------|     
    118           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    119           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    120           |---------------|----------------|----------------|-----------------|-----------------|              
    121           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 18   |0 < HCLK <= 16   |
    122           |---------------|----------------|----------------|-----------------|-----------------|   
    123           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |18 < HCLK <= 36  |16 < HCLK <= 32  | 
    124           |---------------|----------------|----------------|-----------------|-----------------|   
    125           |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |36 < HCLK <= 54  |32 < HCLK <= 48  |
    126           |---------------|----------------|----------------|-----------------|-----------------| 
    127           |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |54 < HCLK <= 72  |48 < HCLK <= 64  |
    128           |---------------|----------------|----------------|-----------------|-----------------| 
    129           |4WS(5CPU cycle)|      NA        |96 < HCLK <= 120|72 < HCLK <= 90  |64 < HCLK <= 80  |
    130           |---------------|----------------|----------------|-----------------|-----------------| 
    131           |5WS(6CPU cycle)|      NA        |      NA        |90 < HCLK <= 108 |80 < HCLK <= 96  | 
    132           |---------------|----------------|----------------|-----------------|-----------------| 
    133           |6WS(7CPU cycle)|      NA        |      NA        |108 < HCLK <= 120|96 < HCLK <= 112 | 
    134           |---------------|----------------|----------------|-----------------|-----------------| 
    135           |7WS(8CPU cycle)|      NA        |      NA        |     NA          |112 < HCLK <= 120| 
    136           |***************|****************|****************|*****************|*****************|*****************************+
    137           |               | voltage range  | voltage range  | voltage range   | voltage range   | voltage range 2.7 V - 3.6 V |
    138           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   | with External Vpp = 9V      |
    139           |---------------|----------------|----------------|-----------------|-----------------|-----------------------------| 
    140           |Max Parallelism|      x32       |               x16                |       x8        |          x64                |              
    141           |---------------|----------------|----------------|-----------------|-----------------|-----------------------------|   
    142           |PSIZE[1:0]     |      10        |               01                 |       00        |           11                |
    143           +-------------------------------------------------------------------------------------------------------------------+  
    144              
    145              - void FLASH_PrefetchBufferCmd(FunctionalState NewState)
    146              - void FLASH_InstructionCacheCmd(FunctionalState NewState)
    147              - void FLASH_DataCacheCmd(FunctionalState NewState)
    148              - void FLASH_InstructionCacheReset(void)
    149              - void FLASH_DataCacheReset(void)
    150             
    151             The unlock sequence is not needed for these functions.
    152           
    153          @endverbatim
    154            * @{
    155            */
    156           
    157          /**
    158            * @brief  Sets the code latency value.
    159            * @param  FLASH_Latency: specifies the FLASH Latency value.
    160            *          This parameter can be one of the following values:
    161            *            @arg FLASH_Latency_0: FLASH Zero Latency cycle
    162            *            @arg FLASH_Latency_1: FLASH One Latency cycle
    163            *            @arg FLASH_Latency_2: FLASH Two Latency cycles
    164            *            @arg FLASH_Latency_3: FLASH Three Latency cycles
    165            *            @arg FLASH_Latency_4: FLASH Four Latency cycles 
    166            *            @arg FLASH_Latency_5: FLASH Five Latency cycles 
    167            *            @arg FLASH_Latency_6: FLASH Six Latency cycles
    168            *            @arg FLASH_Latency_7: FLASH Seven Latency cycles      
    169            * @retval None
    170            */
    171          void FLASH_SetLatency(uint32_t FLASH_Latency)
    172          {
    173            /* Check the parameters */
    174            assert_param(IS_FLASH_LATENCY(FLASH_Latency));
    175            
    176            /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
    177            *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
    178          }
    179          
    180          /**
    181            * @brief  Enables or disables the Prefetch Buffer.
    182            * @param  NewState: new state of the Prefetch Buffer.
    183            *          This parameter  can be: ENABLE or DISABLE.
    184            * @retval None
    185            */
    186          void FLASH_PrefetchBufferCmd(FunctionalState NewState)
    187          {
    188            /* Check the parameters */
    189            assert_param(IS_FUNCTIONAL_STATE(NewState));
    190            
    191            /* Enable or disable the Prefetch Buffer */
    192            if(NewState != DISABLE)
    193            {
    194              FLASH->ACR |= FLASH_ACR_PRFTEN;
    195            }
    196            else
    197            {
    198              FLASH->ACR &= (~FLASH_ACR_PRFTEN);
    199            }
    200          }
    201          
    202          /**
    203            * @brief  Enables or disables the Instruction Cache feature.
    204            * @param  NewState: new state of the Instruction Cache.
    205            *          This parameter  can be: ENABLE or DISABLE.
    206            * @retval None
    207            */
    208          void FLASH_InstructionCacheCmd(FunctionalState NewState)
    209          {
    210            /* Check the parameters */
    211            assert_param(IS_FUNCTIONAL_STATE(NewState));
    212            
    213            if(NewState != DISABLE)
    214            {
    215              FLASH->ACR |= FLASH_ACR_ICEN;
    216            }
    217            else
    218            {
    219              FLASH->ACR &= (~FLASH_ACR_ICEN);
    220            }
    221          }
    222          
    223          /**
    224            * @brief  Enables or disables the Data Cache feature.
    225            * @param  NewState: new state of the Data Cache.
    226            *          This parameter  can be: ENABLE or DISABLE.
    227            * @retval None
    228            */
    229          void FLASH_DataCacheCmd(FunctionalState NewState)
    230          {
    231            /* Check the parameters */
    232            assert_param(IS_FUNCTIONAL_STATE(NewState));
    233            
    234            if(NewState != DISABLE)
    235            {
    236              FLASH->ACR |= FLASH_ACR_DCEN;
    237            }
    238            else
    239            {
    240              FLASH->ACR &= (~FLASH_ACR_DCEN);
    241            }
    242          }
    243          
    244          /**
    245            * @brief  Resets the Instruction Cache.
    246            * @note   This function must be used only when the Instruction Cache is disabled.  
    247            * @param  None
    248            * @retval None
    249            */
    250          void FLASH_InstructionCacheReset(void)
    251          {
    252            FLASH->ACR |= FLASH_ACR_ICRST;
    253          }
    254          
    255          /**
    256            * @brief  Resets the Data Cache.
    257            * @note   This function must be used only when the Data Cache is disabled.  
    258            * @param  None
    259            * @retval None
    260            */
    261          void FLASH_DataCacheReset(void)
    262          {
    263            FLASH->ACR |= FLASH_ACR_DCRST;
    264          }
    265          
    266          /**
    267            * @}
    268            */
    269          
    270          /** @defgroup FLASH_Group2 FLASH Memory Programming functions
    271           *  @brief   FLASH Memory Programming functions
    272           *
    273          @verbatim   
    274           ===============================================================================
    275                                FLASH Memory Programming functions
    276           ===============================================================================   
    277          
    278             This group includes the following functions:
    279              - void FLASH_Unlock(void)
    280              - void FLASH_Lock(void)
    281              - FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
    282              - FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
    283              - FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
    284              - FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    285              - FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
    286              - FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    287             
    288             Any operation of erase or program should follow these steps:
    289             1. Call the FLASH_Unlock() function to enable the FLASH control register access
    290          
    291             2. Call the desired function to erase sector(s) or program data
    292          
    293             3. Call the FLASH_Lock() function to disable the FLASH control register access
    294                (recommended to protect the FLASH memory against possible unwanted operation)
    295              
    296          @endverbatim
    297            * @{
    298            */
    299          
    300          /**
    301            * @brief  Unlocks the FLASH control register access
    302            * @param  None
    303            * @retval None
    304            */
    305          void FLASH_Unlock(void)
    306          {
    307            if((FLASH->CR & FLASH_CR_LOCK) != RESET)
    308            {
    309              /* Authorize the FLASH Registers access */
    310              FLASH->KEYR = FLASH_KEY1;
    311              FLASH->KEYR = FLASH_KEY2;
    312            }  
    313          }
    314          
    315          /**
    316            * @brief  Locks the FLASH control register access
    317            * @param  None
    318            * @retval None
    319            */
    320          void FLASH_Lock(void)
    321          {
    322            /* Set the LOCK Bit to lock the FLASH Registers access */
    323            FLASH->CR |= FLASH_CR_LOCK;
    324          }
    325          
    326          /**
    327            * @brief  Erases a specified FLASH Sector.
    328            *   
    329            * @param  FLASH_Sector: The Sector number to be erased.
    330            *          This parameter can be a value between FLASH_Sector_0 and FLASH_Sector_11
    331            *    
    332            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    333            *          This parameter can be one of the following values:
    334            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    335            *                                  the operation will be done by byte (8-bit) 
    336            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    337            *                                  the operation will be done by half word (16-bit)
    338            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    339            *                                  the operation will be done by word (32-bit)
    340            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    341            *                                  the operation will be done by double word (64-bit)
    342            *       
    343            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    344            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    345            */
    346          FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
    347          {
    348            uint32_t tmp_psize = 0x0;
    349            FLASH_Status status = FLASH_COMPLETE;
    350          
    351            /* Check the parameters */
    352            assert_param(IS_FLASH_SECTOR(FLASH_Sector));
    353            assert_param(IS_VOLTAGERANGE(VoltageRange));
    354            
    355            if(VoltageRange == VoltageRange_1)
    356            {
    357               tmp_psize = FLASH_PSIZE_BYTE;
    358            }
    359            else if(VoltageRange == VoltageRange_2)
    360            {
    361              tmp_psize = FLASH_PSIZE_HALF_WORD;
    362            }
    363            else if(VoltageRange == VoltageRange_3)
    364            {
    365              tmp_psize = FLASH_PSIZE_WORD;
    366            }
    367            else
    368            {
    369              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
    370            }
    371            /* Wait for last operation to be completed */
    372            status = FLASH_WaitForLastOperation();
    373            
    374            if(status == FLASH_COMPLETE)
    375            { 
    376              /* if the previous operation is completed, proceed to erase the sector */
    377              FLASH->CR &= CR_PSIZE_MASK;
    378              FLASH->CR |= tmp_psize;
    379              FLASH->CR &= SECTOR_MASK;
    380              FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
    381              FLASH->CR |= FLASH_CR_STRT;
    382              
    383              /* Wait for last operation to be completed */
    384              status = FLASH_WaitForLastOperation();
    385              
    386              /* if the erase operation is completed, disable the SER Bit */
    387              FLASH->CR &= (~FLASH_CR_SER);
    388              FLASH->CR &= SECTOR_MASK; 
    389            }
    390            /* Return the Erase Status */
    391            return status;
    392          }
    393          
    394          /**
    395            * @brief  Erases all FLASH Sectors.
    396            *    
    397            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    398            *          This parameter can be one of the following values:
    399            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    400            *                                  the operation will be done by byte (8-bit) 
    401            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    402            *                                  the operation will be done by half word (16-bit)
    403            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    404            *                                  the operation will be done by word (32-bit)
    405            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    406            *                                  the operation will be done by double word (64-bit)
    407            *       
    408            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    409            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    410            */
    411          FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
    412          {
    413            uint32_t tmp_psize = 0x0;
    414            FLASH_Status status = FLASH_COMPLETE;
    415            
    416            /* Wait for last operation to be completed */
    417            status = FLASH_WaitForLastOperation();
    418            assert_param(IS_VOLTAGERANGE(VoltageRange));
    419            
    420            if(VoltageRange == VoltageRange_1)
    421            {
    422               tmp_psize = FLASH_PSIZE_BYTE;
    423            }
    424            else if(VoltageRange == VoltageRange_2)
    425            {
    426              tmp_psize = FLASH_PSIZE_HALF_WORD;
    427            }
    428            else if(VoltageRange == VoltageRange_3)
    429            {
    430              tmp_psize = FLASH_PSIZE_WORD;
    431            }
    432            else
    433            {
    434              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
    435            }  
    436            if(status == FLASH_COMPLETE)
    437            {
    438              /* if the previous operation is completed, proceed to erase all sectors */
    439               FLASH->CR &= CR_PSIZE_MASK;
    440               FLASH->CR |= tmp_psize;
    441               FLASH->CR |= FLASH_CR_MER;
    442               FLASH->CR |= FLASH_CR_STRT;
    443              
    444              /* Wait for last operation to be completed */
    445              status = FLASH_WaitForLastOperation();
    446          
    447              /* if the erase operation is completed, disable the MER Bit */
    448              FLASH->CR &= (~FLASH_CR_MER);
    449          
    450            }   
    451            /* Return the Erase Status */
    452            return status;
    453          }
    454          
    455          /**
    456            * @brief  Programs a double word (64-bit) at a specified address.
    457            * @note   This function must be used when the device voltage range is from
    458            *         2.7V to 3.6V and an External Vpp is present.           
    459            * @param  Address: specifies the address to be programmed.
    460            * @param  Data: specifies the data to be programmed.
    461            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    462            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    463            */
    464          FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
    465          {
    466            FLASH_Status status = FLASH_COMPLETE;
    467          
    468            /* Check the parameters */
    469            assert_param(IS_FLASH_ADDRESS(Address));
    470          
    471            /* Wait for last operation to be completed */
    472            status = FLASH_WaitForLastOperation();
    473            
    474            if(status == FLASH_COMPLETE)
    475            {
    476              /* if the previous operation is completed, proceed to program the new data */
    477              FLASH->CR &= CR_PSIZE_MASK;
    478              FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
    479              FLASH->CR |= FLASH_CR_PG;
    480            
    481              *(__IO uint64_t*)Address = Data;
    482                  
    483              /* Wait for last operation to be completed */
    484              status = FLASH_WaitForLastOperation();
    485          
    486              /* if the program operation is completed, disable the PG Bit */
    487              FLASH->CR &= (~FLASH_CR_PG);
    488            } 
    489            /* Return the Program Status */
    490            return status;
    491          }
    492          
    493          /**
    494            * @brief  Programs a word (32-bit) at a specified address.
    495            * @param  Address: specifies the address to be programmed.
    496            *         This parameter can be any address in Program memory zone or in OTP zone.  
    497            * @note   This function must be used when the device voltage range is from 2.7V to 3.6V. 
    498            * @param  Data: specifies the data to be programmed.
    499            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    500            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    501            */
    502          FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    503          {
    504            FLASH_Status status = FLASH_COMPLETE;
    505          
    506            /* Check the parameters */
    507            assert_param(IS_FLASH_ADDRESS(Address));
    508          
    509            /* Wait for last operation to be completed */
    510            status = FLASH_WaitForLastOperation();
    511            
    512            if(status == FLASH_COMPLETE)
    513            {
    514              /* if the previous operation is completed, proceed to program the new data */
    515              FLASH->CR &= CR_PSIZE_MASK;
    516              FLASH->CR |= FLASH_PSIZE_WORD;
    517              FLASH->CR |= FLASH_CR_PG;
    518            
    519              *(__IO uint32_t*)Address = Data;
    520                  
    521              /* Wait for last operation to be completed */
    522              status = FLASH_WaitForLastOperation();
    523          
    524              /* if the program operation is completed, disable the PG Bit */
    525              FLASH->CR &= (~FLASH_CR_PG);
    526            } 
    527            /* Return the Program Status */
    528            return status;
    529          }
    530          
    531          /**
    532            * @brief  Programs a half word (16-bit) at a specified address. 
    533            * @note   This function must be used when the device voltage range is from 2.1V to 3.6V.               
    534            * @param  Address: specifies the address to be programmed.
    535            *         This parameter can be any address in Program memory zone or in OTP zone.  
    536            * @param  Data: specifies the data to be programmed.
    537            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    538            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    539            */
    540          FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
    541          {
    542            FLASH_Status status = FLASH_COMPLETE;
    543          
    544            /* Check the parameters */
    545            assert_param(IS_FLASH_ADDRESS(Address));
    546          
    547            /* Wait for last operation to be completed */
    548            status = FLASH_WaitForLastOperation();
    549            
    550            if(status == FLASH_COMPLETE)
    551            {
    552              /* if the previous operation is completed, proceed to program the new data */
    553              FLASH->CR &= CR_PSIZE_MASK;
    554              FLASH->CR |= FLASH_PSIZE_HALF_WORD;
    555              FLASH->CR |= FLASH_CR_PG;
    556            
    557              *(__IO uint16_t*)Address = Data;
    558                  
    559              /* Wait for last operation to be completed */
    560              status = FLASH_WaitForLastOperation();
    561          
    562              /* if the program operation is completed, disable the PG Bit */
    563              FLASH->CR &= (~FLASH_CR_PG);
    564            } 
    565            /* Return the Program Status */
    566            return status;
    567          }
    568          
    569          /**
    570            * @brief  Programs a byte (8-bit) at a specified address.
    571            * @note   This function can be used within all the device supply voltage ranges.               
    572            * @param  Address: specifies the address to be programmed.
    573            *         This parameter can be any address in Program memory zone or in OTP zone.  
    574            * @param  Data: specifies the data to be programmed.
    575            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    576            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    577            */
    578          FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    579          {
    580            FLASH_Status status = FLASH_COMPLETE;
    581          
    582            /* Check the parameters */
    583            assert_param(IS_FLASH_ADDRESS(Address));
    584          
    585            /* Wait for last operation to be completed */
    586            status = FLASH_WaitForLastOperation();
    587            
    588            if(status == FLASH_COMPLETE)
    589            {
    590              /* if the previous operation is completed, proceed to program the new data */
    591              FLASH->CR &= CR_PSIZE_MASK;
    592              FLASH->CR |= FLASH_PSIZE_BYTE;
    593              FLASH->CR |= FLASH_CR_PG;
    594            
    595              *(__IO uint8_t*)Address = Data;
    596                  
    597              /* Wait for last operation to be completed */
    598              status = FLASH_WaitForLastOperation();
    599          
    600              /* if the program operation is completed, disable the PG Bit */
    601              FLASH->CR &= (~FLASH_CR_PG);
    602            } 
    603          
    604            /* Return the Program Status */
    605            return status;
    606          }
    607          
    608          /**
    609            * @}
    610            */
    611          
    612          /** @defgroup FLASH_Group3 Option Bytes Programming functions
    613           *  @brief   Option Bytes Programming functions 
    614           *
    615          @verbatim   
    616           ===============================================================================
    617                                  Option Bytes Programming functions
    618           ===============================================================================  
    619           
    620             This group includes the following functions:
    621             - void FLASH_OB_Unlock(void)
    622             - void FLASH_OB_Lock(void)
    623             - void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
    624             - void FLASH_OB_RDPConfig(uint8_t OB_RDP)
    625             - void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
    626             - void FLASH_OB_BORConfig(uint8_t OB_BOR)
    627             - FLASH_Status FLASH_ProgramOTP(uint32_t Address, uint32_t Data)							
    628             - FLASH_Status FLASH_OB_Launch(void)
    629             - uint32_t FLASH_OB_GetUser(void)						
    630             - uint8_t FLASH_OB_GetWRP(void)						
    631             - uint8_t FLASH_OB_GetRDP(void)							
    632             - uint8_t FLASH_OB_GetBOR(void)
    633             
    634             Any operation of erase or program should follow these steps:
    635             1. Call the FLASH_OB_Unlock() function to enable the FLASH option control register access
    636          
    637             2. Call one or several functions to program the desired Option Bytes:
    638                - void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState) => to Enable/Disable 
    639                  the desired sector write protection
    640                - void FLASH_OB_RDPConfig(uint8_t OB_RDP) => to set the desired read Protection Level
    641                - void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY) => to configure 
    642                  the user Option Bytes.
    643                - void FLASH_OB_BORConfig(uint8_t OB_BOR) => to set the BOR Level 			 
    644          
    645             3. Once all needed Option Bytes to be programmed are correctly written, call the
    646                FLASH_OB_Launch() function to launch the Option Bytes programming process.
    647               
    648               @note When changing the IWDG mode from HW to SW or from SW to HW, a system 
    649                     reset is needed to make the change effective.  
    650          
    651             4. Call the FLASH_OB_Lock() function to disable the FLASH option control register
    652                access (recommended to protect the Option Bytes against possible unwanted operations)
    653              
    654          @endverbatim
    655            * @{
    656            */
    657          
    658          /**
    659            * @brief  Unlocks the FLASH Option Control Registers access.
    660            * @param  None
    661            * @retval None
    662            */
    663          void FLASH_OB_Unlock(void)
    664          {
    665            if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
    666            {
    667              /* Authorizes the Option Byte register programming */
    668              FLASH->OPTKEYR = FLASH_OPT_KEY1;
    669              FLASH->OPTKEYR = FLASH_OPT_KEY2;
    670            }  
    671          }
    672          
    673          /**
    674            * @brief  Locks the FLASH Option Control Registers access.
    675            * @param  None
    676            * @retval None
    677            */
    678          void FLASH_OB_Lock(void)
    679          {
    680            /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
    681            FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
    682          }
    683          
    684          /**
    685            * @brief  Enables or disables the write protection of the desired sectors
    686            * @param  OB_WRP: specifies the sector(s) to be write protected or unprotected.
    687            *          This parameter can be one of the following values:
    688            *            @arg OB_WRP: A value between OB_WRP_Sector0 and OB_WRP_Sector11                      
    689            *            @arg OB_WRP_Sector_All
    690            * @param  Newstate: new state of the Write Protection.
    691            *          This parameter can be: ENABLE or DISABLE.
    692            * @retval None  
    693            */
    694          void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
    695          { 
    696            FLASH_Status status = FLASH_COMPLETE;
    697            
    698            /* Check the parameters */
    699            assert_param(IS_OB_WRP(OB_WRP));
    700            assert_param(IS_FUNCTIONAL_STATE(NewState));
    701              
    702            status = FLASH_WaitForLastOperation();
    703          
    704            if(status == FLASH_COMPLETE)
    705            { 
    706              if(NewState != DISABLE)
    707              {
    708                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
    709              }
    710              else
    711              {
    712                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
    713              }
    714            }
    715          }
    716          
    717          /**
    718            * @brief  Sets the read protection level.
    719            * @param  OB_RDP: specifies the read protection level.
    720            *          This parameter can be one of the following values:
    721            *            @arg OB_RDP_Level_0: No protection
    722            *            @arg OB_RDP_Level_1: Read protection of the memory
    723            *            @arg OB_RDP_Level_2: Full chip protection
    724            *   
    725            * !!!Warning!!! When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0
    726            *    
    727            * @retval None
    728            */
    729          void FLASH_OB_RDPConfig(uint8_t OB_RDP)
    730          {
    731            FLASH_Status status = FLASH_COMPLETE;
    732          
    733            /* Check the parameters */
    734            assert_param(IS_OB_RDP(OB_RDP));
    735          
    736            status = FLASH_WaitForLastOperation();
    737          
    738            if(status == FLASH_COMPLETE)
    739            {
    740              *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
    741          
    742            }
    743          }
    744          
    745          /**
    746            * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.    
    747            * @param  OB_IWDG: Selects the IWDG mode
    748            *          This parameter can be one of the following values:
    749            *            @arg OB_IWDG_SW: Software IWDG selected
    750            *            @arg OB_IWDG_HW: Hardware IWDG selected
    751            * @param  OB_STOP: Reset event when entering STOP mode.
    752            *          This parameter  can be one of the following values:
    753            *            @arg OB_STOP_NoRST: No reset generated when entering in STOP
    754            *            @arg OB_STOP_RST: Reset generated when entering in STOP
    755            * @param  OB_STDBY: Reset event when entering Standby mode.
    756            *          This parameter  can be one of the following values:
    757            *            @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
    758            *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY
    759            * @retval None
    760            */
    761          void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
    762          {
    763            uint8_t optiontmp = 0xFF;
    764            FLASH_Status status = FLASH_COMPLETE; 
    765          
    766            /* Check the parameters */
    767            assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
    768            assert_param(IS_OB_STOP_SOURCE(OB_STOP));
    769            assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
    770          
    771            /* Wait for last operation to be completed */
    772            status = FLASH_WaitForLastOperation();
    773            
    774            if(status == FLASH_COMPLETE)
    775            { 
    776              /* Mask OPTLOCK, OPTSTRT and BOR_LEV bits */
    777              optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0F); 
    778          
    779              /* Update User Option Byte */
    780              *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = OB_IWDG | (uint8_t)(OB_STDBY | (uint8_t)(OB_STOP | ((uint8_t)optiontmp))); 
    781            }  
    782          }
    783          
    784          /**
    785            * @brief  Sets the BOR Level. 
    786            * @param  OB_BOR: specifies the Option Bytes BOR Reset Level.
    787            *          This parameter can be one of the following values:
    788            *            @arg OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
    789            *            @arg OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
    790            *            @arg OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
    791            *            @arg OB_BOR_OFF: Supply voltage ranges from 1.62 to 2.1 V
    792            * @retval None
    793            */
    794          void FLASH_OB_BORConfig(uint8_t OB_BOR)
    795          {
    796            /* Check the parameters */
    797            assert_param(IS_OB_BOR(OB_BOR));
    798          
    799            /* Set the BOR Level */
    800            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
    801            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
    802          
    803          }
    804          
    805          /**
    806            * @brief  Launch the option byte loading.
    807            * @param  None
    808            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    809            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    810            */
    811          FLASH_Status FLASH_OB_Launch(void)
    812          {
    813            FLASH_Status status = FLASH_COMPLETE;
    814          
    815            /* Set the OPTSTRT bit in OPTCR register */
    816            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
    817          
    818            /* Wait for last operation to be completed */
    819            status = FLASH_WaitForLastOperation();
    820          
    821            return status;
    822          }
    823          
    824          /**
    825            * @brief  Returns the FLASH User Option Bytes values.
    826            * @param  None
    827            * @retval The FLASH User Option Bytes values: IWDG_SW(Bit0), RST_STOP(Bit1)
    828            *         and RST_STDBY(Bit2).
    829            */
    830          uint8_t FLASH_OB_GetUser(void)
    831          {
    832            /* Return the User Option Byte */
    833            return (uint8_t)(FLASH->OPTCR >> 5);
    834          }
    835          
    836          /**
    837            * @brief  Returns the FLASH Write Protection Option Bytes value.
    838            * @param  None
    839            * @retval The FLASH Write Protection  Option Bytes value
    840            */
    841          uint16_t FLASH_OB_GetWRP(void)
    842          {
    843            /* Return the FLASH write protection Register value */
    844            return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
    845          }
    846          
    847          /**
    848            * @brief  Returns the FLASH Read Protection level.
    849            * @param  None
    850            * @retval FLASH ReadOut Protection Status:
    851            *           - SET, when OB_RDP_Level_1 or OB_RDP_Level_2 is set
    852            *           - RESET, when OB_RDP_Level_0 is set
    853            */
    854          FlagStatus FLASH_OB_GetRDP(void)
    855          {
    856            FlagStatus readstatus = RESET;
    857          
    858            if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
    859            {
    860              readstatus = SET;
    861            }
    862            else
    863            {
    864              readstatus = RESET;
    865            }
    866            return readstatus;
    867          }
    868          
    869          /**
    870            * @brief  Returns the FLASH BOR level.
    871            * @param  None
    872            * @retval The FLASH BOR level:
    873            *           - OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
    874            *           - OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
    875            *           - OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
    876            *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V  
    877            */
    878          uint8_t FLASH_OB_GetBOR(void)
    879          {
    880            /* Return the FLASH BOR level */
    881            return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
    882          }
    883          
    884          /**
    885            * @}
    886            */
    887          
    888          /** @defgroup FLASH_Group4 Interrupts and flags management functions
    889           *  @brief   Interrupts and flags management functions
    890           *
    891          @verbatim   
    892           ===============================================================================
    893                            Interrupts and flags management functions
    894           ===============================================================================  
    895          
    896          @endverbatim
    897            * @{
    898            */
    899          
    900          /**
    901            * @brief  Enables or disables the specified FLASH interrupts.
    902            * @param  FLASH_IT: specifies the FLASH interrupt sources to be enabled or disabled.
    903            *          This parameter can be any combination of the following values:
    904            *            @arg FLASH_IT_ERR: FLASH Error Interrupt
    905            *            @arg FLASH_IT_EOP: FLASH end of operation Interrupt
    906            * @retval None 
    907            */
    908          void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
    909          {
    910            /* Check the parameters */
    911            assert_param(IS_FLASH_IT(FLASH_IT)); 
    912            assert_param(IS_FUNCTIONAL_STATE(NewState));
    913          
    914            if(NewState != DISABLE)
    915            {
    916              /* Enable the interrupt sources */
    917              FLASH->CR |= FLASH_IT;
    918            }
    919            else
    920            {
    921              /* Disable the interrupt sources */
    922              FLASH->CR &= ~(uint32_t)FLASH_IT;
    923            }
    924          }
    925          
    926          /**
    927            * @brief  Checks whether the specified FLASH flag is set or not.
    928            * @param  FLASH_FLAG: specifies the FLASH flag to check.
    929            *          This parameter can be one of the following values:
    930            *            @arg FLASH_FLAG_EOP: FLASH End of Operation flag 
    931            *            @arg FLASH_FLAG_OPERR: FLASH operation Error flag 
    932            *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
    933            *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag
    934            *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
    935            *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
    936            *            @arg FLASH_FLAG_BSY: FLASH Busy flag
    937            * @retval The new state of FLASH_FLAG (SET or RESET).
    938            */
    939          FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
    940          {
    941            FlagStatus bitstatus = RESET;
    942            /* Check the parameters */
    943            assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));
    944          
    945            if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
    946            {
    947              bitstatus = SET;
    948            }
    949            else
    950            {
    951              bitstatus = RESET;
    952            }
    953            /* Return the new state of FLASH_FLAG (SET or RESET) */
    954            return bitstatus; 
    955          }
    956          
    957          /**
    958            * @brief  Clears the FLASH's pending flags.
    959            * @param  FLASH_FLAG: specifies the FLASH flags to clear.
    960            *          This parameter can be any combination of the following values:
    961            *            @arg FLASH_FLAG_EOP: FLASH End of Operation flag 
    962            *            @arg FLASH_FLAG_OPERR: FLASH operation Error flag 
    963            *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
    964            *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag 
    965            *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
    966            *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
    967            * @retval None
    968            */
    969          void FLASH_ClearFlag(uint32_t FLASH_FLAG)
    970          {
    971            /* Check the parameters */
    972            assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
    973            
    974            /* Clear the flags */
    975            FLASH->SR = FLASH_FLAG;
    976          }
    977          
    978          /**
    979            * @brief  Returns the FLASH Status.
    980            * @param  None
    981            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    982            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    983            */
    984          FLASH_Status FLASH_GetStatus(void)
    985          {
    986            FLASH_Status flashstatus = FLASH_COMPLETE;
    987            
    988            if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
    989            {
    990              flashstatus = FLASH_BUSY;
    991            }
    992            else 
    993            {  
    994              if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
    995              { 
    996                flashstatus = FLASH_ERROR_WRP;
    997              }
    998              else 
    999              {
   1000                if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
   1001                {
   1002                  flashstatus = FLASH_ERROR_PROGRAM; 
   1003                }
   1004                else
   1005                {
   1006                  if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
   1007                  {
   1008                    flashstatus = FLASH_ERROR_OPERATION;
   1009                  }
   1010                  else
   1011                  {
   1012                    flashstatus = FLASH_COMPLETE;
   1013                  }
   1014                }
   1015              }
   1016            }
   1017            /* Return the FLASH Status */
   1018            return flashstatus;
   1019          }
   1020          
   1021          /**
   1022            * @brief  Waits for a FLASH operation to complete.
   1023            * @param  None
   1024            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
   1025            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
   1026            */
   1027          FLASH_Status FLASH_WaitForLastOperation(void)
   1028          { 
   1029            __IO FLASH_Status status = FLASH_COMPLETE;
   1030             
   1031            /* Check for the FLASH Status */
   1032            status = FLASH_GetStatus();
   1033          
   1034            /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
   1035               Even if the FLASH operation fails, the BUSY flag will be reset and an error
   1036               flag will be set */
   1037            while(status == FLASH_BUSY)
   1038            {
   1039              status = FLASH_GetStatus();
   1040            }
   1041            /* Return the operation status */
   1042            return status;
   1043          }
   1044          
   1045          /**
   1046            * @}
   1047            */ 
   1048          
   1049          /**
   1050            * @}
   1051            */ 
   1052          
   1053          /**
   1054            * @}
   1055            */ 
   1056          
   1057          /**
   1058            * @}
   1059            */
   1060          
   1061          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FLASH_ClearFlag
       0   FLASH_DataCacheCmd
       0   FLASH_DataCacheReset
      24   FLASH_EraseAllSectors
        24   -> FLASH_WaitForLastOperation
      24   FLASH_EraseSector
        24   -> FLASH_WaitForLastOperation
       0   FLASH_GetFlagStatus
       0   FLASH_GetStatus
       0   FLASH_ITConfig
       0   FLASH_InstructionCacheCmd
       0   FLASH_InstructionCacheReset
       0   FLASH_Lock
       0   FLASH_OB_BORConfig
       0   FLASH_OB_GetBOR
       0   FLASH_OB_GetRDP
       0   FLASH_OB_GetUser
       0   FLASH_OB_GetWRP
       8   FLASH_OB_Launch
         8   -> FLASH_WaitForLastOperation
       0   FLASH_OB_Lock
      16   FLASH_OB_RDPConfig
        16   -> FLASH_WaitForLastOperation
       0   FLASH_OB_Unlock
      24   FLASH_OB_UserConfig
        24   -> FLASH_WaitForLastOperation
      16   FLASH_OB_WRPConfig
        16   -> FLASH_WaitForLastOperation
       0   FLASH_PrefetchBufferCmd
      24   FLASH_ProgramByte
        24   -> FLASH_WaitForLastOperation
      24   FLASH_ProgramDoubleWord
        24   -> FLASH_WaitForLastOperation
      24   FLASH_ProgramHalfWord
        24   -> FLASH_WaitForLastOperation
      24   FLASH_ProgramWord
        24   -> FLASH_WaitForLastOperation
       0   FLASH_SetLatency
       0   FLASH_Unlock
       8   FLASH_WaitForLastOperation
         8   -> FLASH_GetStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_10
       4  ??DataTable28_11
       4  ??DataTable28_2
       4  ??DataTable28_3
       4  ??DataTable28_4
       4  ??DataTable28_5
       4  ??DataTable28_6
       4  ??DataTable28_7
       4  ??DataTable28_8
       4  ??DataTable28_9
       6  FLASH_ClearFlag
      36  FLASH_DataCacheCmd
      14  FLASH_DataCacheReset
     118  FLASH_EraseAllSectors
     144  FLASH_EraseSector
      22  FLASH_GetFlagStatus
      52  FLASH_GetStatus
      28  FLASH_ITConfig
      36  FLASH_InstructionCacheCmd
      14  FLASH_InstructionCacheReset
      14  FLASH_Lock
      18  FLASH_OB_BORConfig
      10  FLASH_OB_GetBOR
      22  FLASH_OB_GetRDP
      10  FLASH_OB_GetUser
       8  FLASH_OB_GetWRP
      22  FLASH_OB_Launch
      12  FLASH_OB_Lock
      24  FLASH_OB_RDPConfig
      20  FLASH_OB_Unlock
      52  FLASH_OB_UserConfig
      50  FLASH_OB_WRPConfig
      36  FLASH_PrefetchBufferCmd
      66  FLASH_ProgramByte
      98  FLASH_ProgramDoubleWord
      70  FLASH_ProgramHalfWord
      70  FLASH_ProgramWord
       8  FLASH_SetLatency
      28  FLASH_Unlock
      40  FLASH_WaitForLastOperation

 
 1'196 bytes in section .text
 
 1'196 bytes of CODE memory

Errors: none
Warnings: none
