###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         25/Feb/2023  19:59:35
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\proj\velograph\snail_w\stm32_snail\common\board\dima_board.c
#    Command line      =
#        -f
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board\dima_board.o.rsp
#        (D:\proj\velograph\snail_w\stm32_snail\common\board\dima_board.c -D
#        VECT_TAB_FLASH -D IAR_ARM_CM3 -D DIMA_BRD -D STEP_X -D STM32F205xx -D
#        BOOTER -lcN
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\List\Board
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\.\ -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\freertos\source\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\dbg\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\board\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\can\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\my_misc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\eeprom_emul\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board\dima_board.o.d
#    Locale            =  C
#    List file         =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\List\Board\dima_board.lst
#    Object file       =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board\dima_board.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\proj\velograph\snail_w\stm32_snail\common\board\dima_board.c
      1          #include <string.h>
      2          #include "FreeRTOS.h"
      3          #include "queue.h"
      4          ////#include "semphr.h"
      5          ///#include "stm32f2xx_gpio.h"
      6          ///#include "stm32f2xx_rcc.h"
      7          
      8          #include "can.h"
      9          #include "can_cmds.h"
     10          #include "board.h"
     11          #include "printk.h"
     12          
     13          extern void uDelay (const uint32_t usec);
     14          extern void  put_tst_pin(uint8_t idat);
     15          
     16          uint32_t cur_coord=0;
     17          uint8_t cur_stat=0;
     18          
     19          void CAN_Config(void);
     20          
     21          ///=============================
     22          int send_char_dbg (int c) 
     23          { 
     24          while (!(UART_DBG->SR & 0x0080));
     25          UART_DBG->DR = (c & 0x1FF);
     26          return (c);
     27          }
     28          void _putk(char ch)
     29          {
     30          send_char_dbg(ch);
     31          }
     32          
     33          int get_byte_dbg (void) 
     34          {
     35          while (!(UART_DBG->SR & USART_SR_RXNE));
     36          return (UART_DBG->DR);
     37          }
     38          int check_push_key_dbg(void)
     39          {
     40          return  (UART_DBG->SR & USART_SR_RXNE); 
     41          }
     42          
     43          void init_gpio(void)
     44          {
     45          ////RCC_AHBPeriphClockCmd(XEN_PIN_RCC_AHB,ENABLE);
     46          GPIO_InitTypeDef GPIO_InitStructure;
     47          ////=============== TST2 ============================
     48          RCC_AHB1PeriphClockCmd(TST2_PIN_RCC, ENABLE);
     49          GPIO_InitStructure.GPIO_Pin = TST2_PIN;
     50          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     51          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
     52          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     53          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
     54          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
     55          GPIO_Init( TST2_PIN_GPIO, &GPIO_InitStructure );
     56          ////=============== TST3 ============================
     57          RCC_AHB1PeriphClockCmd(TST3_PIN_RCC, ENABLE);
     58          GPIO_InitStructure.GPIO_Pin = TST3_PIN;
     59          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     60          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
     61          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     62          
     63          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     64          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
     65          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
     66          GPIO_Init( TST3_PIN_GPIO, &GPIO_InitStructure );
     67          GPIO_PinAFConfig(TST3_PIN_GPIO, TST3_PIN_NPIN, GPIO_AF_TIM1);
     68          
     69          ////=============== TST7 ============================
     70          RCC_AHB1PeriphClockCmd(TST7_PIN_RCC, ENABLE);
     71          GPIO_InitStructure.GPIO_Pin = TST7_PIN;
     72          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     73          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
     74          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     75          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     76          GPIO_Init( TST7_PIN_GPIO, &GPIO_InitStructure );
     77          GPIO_PinAFConfig(TST7_PIN_GPIO, TST7_PIN_NPIN, GPIO_AF_TIM8);
     78            
     79          ////=========== DBG_UART =================================================== 
     80          RCC_AHB1PeriphClockCmd(UART_DBG_TX_RCC, ENABLE);
     81          GPIO_InitStructure.GPIO_Pin = UART_DBG_TX_PIN;
     82          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     83          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     84          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     85          GPIO_Init( UART_DBG_TX_GPIO, &GPIO_InitStructure );
     86          
     87          RCC_AHB1PeriphClockCmd(UART_DBG_RX_RCC, ENABLE);
     88          GPIO_InitStructure.GPIO_Pin = UART_DBG_RX_PIN;
     89          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     90          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     91          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     92          GPIO_Init( UART_DBG_RX_GPIO, &GPIO_InitStructure );
     93            
     94          GPIO_PinAFConfig(UART_DBG_TX_GPIO, UART_DBG_TX_PIN_NPIN, UART_DBG_TX_AF);
     95          GPIO_PinAFConfig(UART_DBG_RX_GPIO, UART_DBG_RX_PIN_NPIN, UART_DBG_RX_AF);
     96          ////===================================================================
     97          ////=============== MOT_FAULT ============================
     98          RCC_AHB1PeriphClockCmd(MOT_FAULT_PIN_RCC, ENABLE);
     99          GPIO_InitStructure.GPIO_Pin = MOT_FAULT_PIN;
    100          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    101          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    102          GPIO_Init( MOT_FAULT_PIN_GPIO, &GPIO_InitStructure );
    103          ////=============== MOT_STALLN ============================
    104          RCC_AHB1PeriphClockCmd(MOT_STALLN_PIN_RCC, ENABLE);
    105          GPIO_InitStructure.GPIO_Pin = MOT_STALLN_PIN;
    106          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    107          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    108          GPIO_Init( MOT_STALLN_PIN_GPIO, &GPIO_InitStructure );
    109          ////=============== CONC1 ============================
    110          RCC_AHB1PeriphClockCmd(CONC1_PIN_RCC, ENABLE);
    111          GPIO_InitStructure.GPIO_Pin = CONC1_PIN;
    112          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    113          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    114          GPIO_Init( CONC1_PIN_GPIO, &GPIO_InitStructure );
    115          ////=============== CONC0 ============================
    116          RCC_AHB1PeriphClockCmd(CONC0_PIN_RCC, ENABLE);
    117          GPIO_InitStructure.GPIO_Pin = CONC0_PIN;
    118          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    119          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    120          GPIO_Init( CONC0_PIN_GPIO, &GPIO_InitStructure );
    121          ////=============== MOT_RESET ============================
    122          RCC_AHB1PeriphClockCmd(MOT_RESET_PIN_RCC, ENABLE);
    123          GPIO_InitStructure.GPIO_Pin = MOT_RESET_PIN;
    124          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    125          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    126          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    127          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    128          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    129          GPIO_Init( MOT_RESET_PIN_GPIO, &GPIO_InitStructure );
    130          ////=============== MOT_SLEEP ============================
    131          RCC_AHB1PeriphClockCmd(MOT_SLEEP_PIN_RCC, ENABLE);
    132          GPIO_InitStructure.GPIO_Pin = MOT_SLEEP_PIN;
    133          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    134          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    135          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    136          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    137          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    138          GPIO_Init( MOT_SLEEP_PIN_GPIO, &GPIO_InitStructure );
    139          ////#define MOT_STEP_TIM  	        TIM12
    140          ////=============== MOT_STEP ============================
    141          RCC_AHB1PeriphClockCmd(MOT_STEP_PIN_RCC, ENABLE);
    142          GPIO_InitStructure.GPIO_Pin = MOT_STEP_PIN;
    143          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    144          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    145          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    146          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    147          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    148          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    149          GPIO_Init( MOT_STEP_PIN_GPIO, &GPIO_InitStructure );
    150          GPIO_PinAFConfig(MOT_STEP_PIN_GPIO, MOT_STEP_PIN_NPIN, GPIO_AF_TIM1);
    151          ////===================================================================
    152          
    153          ////=============== MOT_DIR ============================
    154          RCC_AHB1PeriphClockCmd(MOT_DIR_PIN_RCC, ENABLE);
    155          GPIO_InitStructure.GPIO_Pin = MOT_DIR_PIN;
    156          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    157          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    158          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    159          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    160          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    161          GPIO_Init( MOT_DIR_PIN_GPIO, &GPIO_InitStructure );
    162          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    163          
    164          ////=============== MOT_SPI_SCS ============================
    165          RCC_AHB1PeriphClockCmd(MOT_SPI_SCS_PIN_RCC, ENABLE);
    166          GPIO_InitStructure.GPIO_Pin = MOT_SPI_SCS_PIN;
    167          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    168          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    169          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    170          GPIO_Init( MOT_SPI_SCS_PIN_GPIO, &GPIO_InitStructure );
    171          ////============== CAN1_INH ============================
    172          RCC_AHB1PeriphClockCmd(CAN1_INH_PIN_RCC, ENABLE);
    173          GPIO_InitStructure.GPIO_Pin = CAN1_INH_PIN;
    174          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    175          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    176          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    177          GPIO_Init( CAN1_INH_PIN_GPIO, &GPIO_InitStructure );
    178          GPIO_ResetBits(CAN1_INH_PIN_GPIO, CAN1_INH_PIN);
    179          
    180          }
    181          ////=============================================
    182          void UART_DBG_Init(void)
    183          {
    184          ////GPIO_InitTypeDef GPIO_InitStructure;
    185          USART_InitTypeDef USART_InitStructure;
    186          UART_DBG_CLK_INIT(UART_DBG_CLK, ENABLE);
    187          USART_DeInit(UART_DBG);
    188          USART_InitStructure.USART_BaudRate = 115200;
    189          USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    190          USART_InitStructure.USART_StopBits = USART_StopBits_1 ;
    191          USART_InitStructure.USART_Parity = USART_Parity_No;
    192          USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    193          USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    194          USART_Init(UART_DBG, &USART_InitStructure);
    195          UART_DBG->CR1 |= USART_CR1_RXNEIE;
    196          USART_Cmd(UART_DBG, ENABLE);
    197          }
    198          
    199          ////==================================================
    200          
    201          
    202          ///===========================================================
    203          volatile uint32_t gsr;
    204          
    205          ////===============================================
    206          uint8_t get_conc0(void)
    207          {
    208          return GPIO_ReadInputDataBit(CONC0_PIN_GPIO, CONC0_PIN);
    209          }
    210          uint8_t get_conc1(void)
    211          {
    212          return GPIO_ReadInputDataBit(CONC1_PIN_GPIO, CONC1_PIN);
    213          }
    214          ////=============================================
    215          void hw_board_init(void)
    216          {
    217          NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );
    218          init_gpio();
    219          UART_DBG_Init(); 
    220          /*
    221          #ifndef BOOTER
    222             motor_init();
    223          #endif
    224          cur_stat=STATE_READY;
    225          */
    226          }
    227          ////============================================
    228          
    229          ////============================================
    230          extern uint8_t can1_send(uint16_t id,uint8_t data_len,uint8_t *data);
    231          extern uint8_t  CAN_TxRdy;              /* CAN HW ready to transmit message */
    232          extern uint8_t  CAN_RxRdy;              /* CAN HW received a message        */
    233          ///=========================================================
    234          void CAN1_Init (void)
    235          {
    236          uint32_t id;
    237           uint32_t mask;
    238          CAN_Config();
    239          
    240          mask= ID_MASK << 21; ///5+16
    241          
    242          #if STEP_X
    243            id=ID_X_CMD<<21; ///5+16
    244          
    245          #elif STEP_Y
    246            id=ID_Y_CMD<<21; ///5+16
    247          #elif STEP_Z
    248            id=ID_Z_CMD<<21; ///5+16
    249          #else 
    250            #error "\n\r=== STEP_... nodefined ==="; 
    251          #endif
    252          
    253          CAN_FilterConfig(0,id,mask);	
    254            /* Enable FIFO 0 message pending Interrupt */
    255            CAN_ITConfig(CAN1, CAN_IT_FMP0, ENABLE);
    256          }
    257          
    258          extern can_msg_t CAN_RxMsg;
    259          ////========================================================  
    260          void tst1_task( void *pvParameters )
    261          {
    262          ////uint8_t btst=0; 
    263          uint32_t t_coord=0;  
    264          uint8_t t_stat=0x8; 
    265          
    266          ////uint8_t ii=0; 
    267          printk("\n\r tst1_task"); 
    268          ///=======================================
    269          #if 0
    270          can_msg_t  send_msg;
    271          go_cmd_t t_go_cmd;
    272          t_go_cmd.cmd=GO_CMD ;
    273          t_go_cmd.dirs=1;
    274          t_go_cmd.step_per=1000;
    275          send_msg.len=CAN_MAX_NUM_BYTES;
    276          send_msg.format=STANDARD_FORMAT;
    277          send_msg.type=DATA_FRAME;
    278          t_go_cmd.steps=10;
    279          memcpy(send_msg.data,&t_go_cmd,sizeof(go_cmd_t));
    280          send_msg.id=ID_X_CMD; 
    281          #endif
    282          ///============================================
    283          #if 0
    284          for(;;)
    285            {
    286            if( CAN_RxRdy)
    287              {
    288              CAN_RxRdy=0;
    289              printk("\n\r can_rx"); 
    290              printk("\n\r ExtId[%x]",CAN_RxMsg.id);
    291              printk("\n\r DLC[%x]\n\r ",CAN_RxMsg.len);
    292              for(ii=0;ii<8;ii++)
    293                {
    294                printk("[%x] ",CAN_RxMsg.data[ii]);
    295                }
    296              }
    297            else
    298            {
    299          ////   CAN_wrMsg (&send_msg);
    300              msleep(20);
    301            }
    302            }
    303          #endif
    304          for(;;)
    305            {
    306            put_can_cmd_stat(t_stat,t_coord);
    307             
    308             t_coord++; 
    309              msleep(20);
    310            }
    311          }
    312          ////=======================================================
    313          void tst_task( void *pvParameters )
    314          {
    315          ///uint8_t btst=0; 
    316          char key=0;
    317          printk("\n\r tst_task"); 
    318           
    319          for(;;)
    320          {
    321          if(check_push_key_dbg())
    322            {
    323            key=get_byte_dbg() ;  
    324            switch(key)
    325              {
    326              case 'a':
    327              case 'A':
    328                printk("\n\r go to app"); 
    329                goto_app();
    330                break;
    331              case 'b':
    332              case 'B':
    333                printk("\n\r go to boot"); 
    334                goto_booter();
    335                break;
    336             }
    337            } 
    338          msleep(10);
    339          }
    340          }
    341          	

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   CAN1_Init
        16   -> CAN_Config
        16   -> CAN_FilterConfig
        16   -> CAN_ITConfig
      24   UART_DBG_Init
        24   -> RCC_APB2PeriphClockCmd
        24   -> USART_Cmd
        24   -> USART_DeInit
        24   -> USART_Init
       8   _putk
         8   -> send_char_dbg
       0   check_push_key_dbg
       0   get_byte_dbg
       8   get_conc0
         8   -> GPIO_ReadInputDataBit
       8   get_conc1
         8   -> GPIO_ReadInputDataBit
       8   hw_board_init
         8   -> NVIC_PriorityGroupConfig
         8   -> UART_DBG_Init
         8   -> init_gpio
      32   init_gpio
        32   -> GPIO_Init
        32   -> GPIO_PinAFConfig
        32   -> GPIO_ResetBits
        32   -> RCC_AHB1PeriphClockCmd
       0   send_char_dbg
      16   tst1_task
        16   -> _printk
        16   -> put_can_cmd_stat
        16   -> vTaskDelay
      16   tst_task
        16   -> _printk
        16   -> check_push_key_dbg
        16   -> get_byte_dbg
        16   -> goto_app
        16   -> goto_booter
        16   -> vTaskDelay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      16  ?_0
      12  ?_1
      16  ?_2
      16  ?_3
      36  CAN1_Init
      82  UART_DBG_Init
      14  _putk
      12  check_push_key_dbg
       4  cur_coord
       1  cur_stat
      18  get_byte_dbg
      12  get_conc0
      12  get_conc1
       4  gsr
      20  hw_board_init
     632  init_gpio
      24  send_char_dbg
      34  tst1_task
      78  tst_task

 
     9 bytes in section .bss
    60 bytes in section .rodata
 1'022 bytes in section .text
 
 1'022 bytes of CODE  memory
    60 bytes of CONST memory
     9 bytes of DATA  memory

Errors: none
Warnings: none
