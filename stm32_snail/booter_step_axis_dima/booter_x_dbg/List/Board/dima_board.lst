###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         11/Feb/2023  18:28:31
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\board\dima_board.c
#    Command line      =
#        -f
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board\dima_board.o.rsp
#        (D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\board\dima_board.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D DIMA_BRD -D STEP_X -D STM32F205xx
#        -lcN
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\List\Board
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\.\ -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\board\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\freertos\source\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\dbg\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\usb\drv\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\board\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\my_grbl\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\can\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board\dima_board.o.d
#    Locale            =  C
#    List file         =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\List\Board\dima_board.lst
#    Object file       =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board\dima_board.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\board\dima_board.c
      1          #include <string.h>
      2          #include "FreeRTOS.h"
      3          #include "queue.h"
      4          #include "semphr.h"
      5          ///#include "stm32f2xx_gpio.h"
      6          ///#include "stm32f2xx_rcc.h"
      7          
      8          #include "can.h"
      9          #include "can_cmds.h"
     10          #include "board.h"
     11          #include "printk.h"
     12          
     13          extern void uDelay (const uint32_t usec);
     14          extern void  put_tst_pin(uint8_t idat);
     15          
     16          uint32_t cur_coord=0;
     17          uint8_t cur_stat=0;
     18          
     19          void mot_spi_wr(uint8_t addr,uint16_t idata);
     20          uint16_t mot_spi_rd(uint8_t addr);
     21          void CAN_Config(void);
     22          
     23          ///=============================
     24          int send_char_dbg (int c) 
     25          { 
     26          while (!(UART_DBG->SR & 0x0080));
     27          UART_DBG->DR = (c & 0x1FF);
     28          return (c);
     29          }
     30          void _putk(char ch)
     31          {
     32          send_char_dbg(ch);
     33          }
     34          
     35          int get_byte_dbg (void) 
     36          {
     37          while (!(UART_DBG->SR & USART_SR_RXNE));
     38          return (UART_DBG->DR);
     39          }
     40          int check_push_key_dbg(void)
     41          {
     42          return  (UART_DBG->SR & USART_SR_RXNE); 
     43          }
     44          
     45          void init_gpio(void)
     46          {
     47          ////RCC_AHBPeriphClockCmd(XEN_PIN_RCC_AHB,ENABLE);
     48          GPIO_InitTypeDef GPIO_InitStructure;
     49          ////=============== TST2 ============================
     50          RCC_AHB1PeriphClockCmd(TST2_PIN_RCC, ENABLE);
     51          GPIO_InitStructure.GPIO_Pin = TST2_PIN;
     52          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     53          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
     54          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     55          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
     56          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
     57          GPIO_Init( TST2_PIN_GPIO, &GPIO_InitStructure );
     58          ////=============== TST3 ============================
     59          RCC_AHB1PeriphClockCmd(TST3_PIN_RCC, ENABLE);
     60          GPIO_InitStructure.GPIO_Pin = TST3_PIN;
     61          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     62          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
     63          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     64          
     65          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     66          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
     67          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
     68          GPIO_Init( TST3_PIN_GPIO, &GPIO_InitStructure );
     69          GPIO_PinAFConfig(TST3_PIN_GPIO, TST3_PIN_NPIN, GPIO_AF_TIM1);
     70          
     71          ////=============== TST7 ============================
     72          RCC_AHB1PeriphClockCmd(TST7_PIN_RCC, ENABLE);
     73          GPIO_InitStructure.GPIO_Pin = TST7_PIN;
     74          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     75          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
     76          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     77          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     78          GPIO_Init( TST7_PIN_GPIO, &GPIO_InitStructure );
     79          GPIO_PinAFConfig(TST7_PIN_GPIO, TST7_PIN_NPIN, GPIO_AF_TIM8);
     80            
     81          ////=========== DBG_UART =================================================== 
     82          RCC_AHB1PeriphClockCmd(UART_DBG_TX_RCC, ENABLE);
     83          GPIO_InitStructure.GPIO_Pin = UART_DBG_TX_PIN;
     84          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     85          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     86          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     87          GPIO_Init( UART_DBG_TX_GPIO, &GPIO_InitStructure );
     88          
     89          RCC_AHB1PeriphClockCmd(UART_DBG_RX_RCC, ENABLE);
     90          GPIO_InitStructure.GPIO_Pin = UART_DBG_RX_PIN;
     91          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     92          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     93          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     94          GPIO_Init( UART_DBG_RX_GPIO, &GPIO_InitStructure );
     95            
     96          GPIO_PinAFConfig(UART_DBG_TX_GPIO, UART_DBG_TX_PIN_NPIN, UART_DBG_TX_AF);
     97          GPIO_PinAFConfig(UART_DBG_RX_GPIO, UART_DBG_RX_PIN_NPIN, UART_DBG_RX_AF);
     98          ////===================================================================
     99          ////=============== MOT_FAULT ============================
    100          RCC_AHB1PeriphClockCmd(MOT_FAULT_PIN_RCC, ENABLE);
    101          GPIO_InitStructure.GPIO_Pin = MOT_FAULT_PIN;
    102          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    103          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    104          GPIO_Init( MOT_FAULT_PIN_GPIO, &GPIO_InitStructure );
    105          ////=============== MOT_STALLN ============================
    106          RCC_AHB1PeriphClockCmd(MOT_STALLN_PIN_RCC, ENABLE);
    107          GPIO_InitStructure.GPIO_Pin = MOT_STALLN_PIN;
    108          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    109          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    110          GPIO_Init( MOT_STALLN_PIN_GPIO, &GPIO_InitStructure );
    111          ////=============== CONC1 ============================
    112          RCC_AHB1PeriphClockCmd(CONC1_PIN_RCC, ENABLE);
    113          GPIO_InitStructure.GPIO_Pin = CONC1_PIN;
    114          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    115          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    116          GPIO_Init( CONC1_PIN_GPIO, &GPIO_InitStructure );
    117          ////=============== CONC0 ============================
    118          RCC_AHB1PeriphClockCmd(CONC0_PIN_RCC, ENABLE);
    119          GPIO_InitStructure.GPIO_Pin = CONC0_PIN;
    120          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    121          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    122          GPIO_Init( CONC0_PIN_GPIO, &GPIO_InitStructure );
    123          ////=============== MOT_RESET ============================
    124          RCC_AHB1PeriphClockCmd(MOT_RESET_PIN_RCC, ENABLE);
    125          GPIO_InitStructure.GPIO_Pin = MOT_RESET_PIN;
    126          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    127          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    128          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    129          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    130          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    131          GPIO_Init( MOT_RESET_PIN_GPIO, &GPIO_InitStructure );
    132          ////=============== MOT_SLEEP ============================
    133          RCC_AHB1PeriphClockCmd(MOT_SLEEP_PIN_RCC, ENABLE);
    134          GPIO_InitStructure.GPIO_Pin = MOT_SLEEP_PIN;
    135          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    136          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    137          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    138          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    139          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    140          GPIO_Init( MOT_SLEEP_PIN_GPIO, &GPIO_InitStructure );
    141          ////#define MOT_STEP_TIM  	        TIM12
    142          ////=============== MOT_STEP ============================
    143          RCC_AHB1PeriphClockCmd(MOT_STEP_PIN_RCC, ENABLE);
    144          GPIO_InitStructure.GPIO_Pin = MOT_STEP_PIN;
    145          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    146          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    147          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    148          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    149          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    150          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    151          GPIO_Init( MOT_STEP_PIN_GPIO, &GPIO_InitStructure );
    152          GPIO_PinAFConfig(MOT_STEP_PIN_GPIO, MOT_STEP_PIN_NPIN, GPIO_AF_TIM1);
    153          ////===================================================================
    154          
    155          ////=============== MOT_DIR ============================
    156          RCC_AHB1PeriphClockCmd(MOT_DIR_PIN_RCC, ENABLE);
    157          GPIO_InitStructure.GPIO_Pin = MOT_DIR_PIN;
    158          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    159          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    160          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    161          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    162          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    163          GPIO_Init( MOT_DIR_PIN_GPIO, &GPIO_InitStructure );
    164          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    165          
    166          ////=============== MOT_SPI_SCS ============================
    167          RCC_AHB1PeriphClockCmd(MOT_SPI_SCS_PIN_RCC, ENABLE);
    168          GPIO_InitStructure.GPIO_Pin = MOT_SPI_SCS_PIN;
    169          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    170          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    171          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    172          GPIO_Init( MOT_SPI_SCS_PIN_GPIO, &GPIO_InitStructure );
    173          ////============== CAN1_INH ============================
    174          RCC_AHB1PeriphClockCmd(CAN1_INH_PIN_RCC, ENABLE);
    175          GPIO_InitStructure.GPIO_Pin = CAN1_INH_PIN;
    176          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    177          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    178          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    179          GPIO_Init( CAN1_INH_PIN_GPIO, &GPIO_InitStructure );
    180          GPIO_ResetBits(CAN1_INH_PIN_GPIO, CAN1_INH_PIN);
    181          
    182          }
    183          ////=============================================
    184          void UART_DBG_Init(void)
    185          {
    186          ////GPIO_InitTypeDef GPIO_InitStructure;
    187          USART_InitTypeDef USART_InitStructure;
    188          UART_DBG_CLK_INIT(UART_DBG_CLK, ENABLE);
    189          USART_DeInit(UART_DBG);
    190          USART_InitStructure.USART_BaudRate = 115200;
    191          USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    192          USART_InitStructure.USART_StopBits = USART_StopBits_1 ;
    193          USART_InitStructure.USART_Parity = USART_Parity_No;
    194          USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    195          USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    196          USART_Init(UART_DBG, &USART_InitStructure);
    197          UART_DBG->CR1 |= USART_CR1_RXNEIE;
    198          USART_Cmd(UART_DBG, ENABLE);
    199          }
    200          
    201          ////==================================================
    202          
    203          void  set_sleep_mot(uint8_t idat)
    204          {
    205          if(idat&0x1)
    206            {
    207            GPIO_SetBits(MOT_SLEEP_PIN_GPIO, MOT_SLEEP_PIN);
    208            }
    209          else
    210            {
    211             GPIO_ResetBits(MOT_SLEEP_PIN_GPIO, MOT_SLEEP_PIN);
    212            }
    213          }
    214          void  set_dir_mot(uint8_t idat)
    215          {
    216          uint8_t tdat=0;
    217          #if STEP_X
    218            tdat=idat&DIR_X;
    219          #elif STEP_Y
    220            tdat=idat&DIR_Y;
    221          #elif STEP_Z
    222            tdat=idat&DIR_Z;
    223          #endif
    224          if(tdat)
    225            {
    226            GPIO_SetBits(MOT_DIR_PIN_GPIO, MOT_DIR_PIN);
    227            }
    228          else
    229            {
    230             GPIO_ResetBits(MOT_DIR_PIN_GPIO, MOT_DIR_PIN);
    231            }
    232          }
    233          void  set_reset_mot(uint8_t idat)
    234          {
    235          if(idat&0x1)
    236            {
    237            GPIO_SetBits(MOT_RESET_PIN_GPIO, MOT_RESET_PIN);
    238            }
    239          else
    240            {
    241             GPIO_ResetBits(MOT_RESET_PIN_GPIO, MOT_RESET_PIN);
    242            }
    243          }
    244          
    245          ////==================================================
    246          
    247          volatile uint32_t num_step=0;
    248          
    249          void mot_step_tim_init(void)
    250          {
    251          NVIC_InitTypeDef NVIC_InitStructure; 
    252          
    253          RCC->APB2ENR |= MOT_STEP_TIM_RCC;
    254          MOT_STEP_TIM ->PSC = DEF_MOT_TIM_PRESC;
    255          MOT_STEP_TIM ->ARR = DEF_MOT_TIM_PERIOD;////
    256          MOT_STEP_TIM ->CCR1 = DEF_MOT_TIM_PERIOD/2;////30;
    257          MOT_STEP_TIM->CCER |= TIM_CCER_CC1E;////TIM_CCER_CC2NE;////| TIM_CCER_CC3NP;
    258          MOT_STEP_TIM->BDTR |= TIM_BDTR_MOE;
    259          MOT_STEP_TIM->CCMR1 = TIM_CCMR1_OC1M_0 | TIM_CCMR1_OC1M_1; 
    260          MOT_STEP_TIM->CR1 &= ~TIM_CR1_DIR;
    261          MOT_STEP_TIM->CR1 &= ~TIM_CR1_CMS;
    262          
    263          MOT_STEP_TIM ->DIER = TIM_DIER_CC1IE;
    264          TIM_ClearITPendingBit(MOT_STEP_TIM, TIM_IT_CC1);
    265          
    266          NVIC_InitStructure.NVIC_IRQChannel = MOT_TIM_IRQN;
    267          //// highest priority
    268          NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;
    269          
    270          NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    271          //// highest priority
    272          NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    273          NVIC_Init(&NVIC_InitStructure);
    274          
    275          }
    276          
    277          void stop_mot_step_tim(void)
    278          {
    279          TIM_Cmd(MOT_STEP_TIM, DISABLE);
    280          
    281          }
    282          void ena_mot(uint8_t ena_dis)
    283          {
    284          uint16_t tmp;
    285          ////return ; 
    286          tmp=mot_spi_rd(ADDR_MOT_CTRL);
    287          if(ena_dis&0x1)
    288          {
    289          tmp|=0x1;
    290          }
    291          else
    292          {
    293          tmp&= ~0x1;
    294          }
    295          mot_spi_wr(ADDR_MOT_CTRL,tmp);
    296          }
    297          ///===========================================================
    298          void put_mot_nstep(uint32_t nstep)
    299          {
    300          ena_mot(1) ;
    301          num_step=nstep; 
    302          TIM_ITConfig(MOT_STEP_TIM, TIM_IT_CC1, ENABLE);
    303          TIM_Cmd(MOT_STEP_TIM, ENABLE);
    304          }
    305          
    306          ///===========================================================
    307          volatile uint32_t gsr;
    308          
    309          ////=======================================================
    310          void MOT_STEP_TIM_IRQHandler(void)
    311          { 
    312          if(num_step)
    313            {
    314            num_step--;  
    315            if(num_step==0)
    316              {
    317              stop_mot_step_tim(); 
    318              cur_stat=STATE_READY;  
    319          
    320              ena_mot(0) ;
    321              }
    322            }
    323          ////TIM_ClearITPendingBit(MOT_STEP_TIM, TIM_IT_CC2);
    324          TIM_ClearITPendingBit(MOT_STEP_TIM, TIM_IT_CC1);
    325          }
    326          ////===============================================
    327          uint8_t get_conc0(void)
    328          {
    329          return GPIO_ReadInputDataBit(CONC0_PIN_GPIO, CONC0_PIN);
    330          }
    331          uint8_t get_conc1(void)
    332          {
    333          return GPIO_ReadInputDataBit(CONC1_PIN_GPIO, CONC1_PIN);
    334          }
    335          void motor_init(void)
    336          {
    337          set_sleep_mot(1);
    338          ////set_ena_mot(1);
    339          set_reset_mot(1);
    340          uDelay(1000);
    341          set_reset_mot(0);
    342          uDelay(20000);
    343          init_step_mot();
    344          ena_mot(0) ;
    345          set_mot_rej(DEF_MOT_REJ);
    346            
    347          }
    348          ////=============================================
    349          void hw_board_init(void)
    350          {
    351          NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );
    352          init_gpio();
    353          UART_DBG_Init(); 
    354          
    355          mot_step_tim_init();
    356          mot_spi_init();
    357          cur_stat=STATE_READY;
    358          motor_init();
    359          ena_mot(0) ;
    360          
    361          ////init_enc_tim();
    362          ////CAN_Config();
    363          
    364          }
    365          ////============================================
    366          ////==============================================
    367          void mot_spi_init(void)
    368          {
    369          GPIO_InitTypeDef GPIO_InitStructure;
    370          SPI_InitTypeDef  SPI_InitStructure;
    371            MOT_SPI_PeriphClockCmd(MOT_SPI_RCC, ENABLE);
    372            
    373          RCC_AHB1PeriphClockCmd(MOT_SPI_SCK_PIN_RCC,ENABLE);
    374          RCC_AHB1PeriphClockCmd(MOT_SPI_MISO_PIN_RCC,ENABLE);
    375          RCC_AHB1PeriphClockCmd(MOT_SPI_MOSI_PIN_RCC,ENABLE);
    376          ////RCC_AHB1PeriphClockCmd(MOT_SPI_SCS_PIN_RCC,ENABLE);
    377          
    378          GPIO_PinAFConfig(MOT_SPI_SCK_PIN_GPIO, MOT_SPI_SCK_PIN_NPIN, MOT_SPI_AF);
    379          GPIO_PinAFConfig(MOT_SPI_MISO_PIN_GPIO, MOT_SPI_MISO_PIN_NPIN, MOT_SPI_AF);
    380          GPIO_PinAFConfig(MOT_SPI_MOSI_PIN_GPIO, MOT_SPI_MOSI_PIN_NPIN, MOT_SPI_AF);
    381          ////GPIO_PinAFConfig(MOT_SPI_SCS_PIN_GPIO, MOT_SPI_SCS_PIN_NPIN, MOT_SPI_AF);
    382          
    383          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    384          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    385          ////GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    386          ///GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
    387          GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    388          GPIO_InitStructure.GPIO_Pin = MOT_SPI_MISO_PIN;
    389          GPIO_Init(MOT_SPI_MISO_PIN_GPIO, &GPIO_InitStructure);
    390          
    391          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    392          GPIO_InitStructure.GPIO_Pin = MOT_SPI_SCK_PIN;
    393          GPIO_Init(MOT_SPI_SCK_PIN_GPIO, &GPIO_InitStructure);
    394          ////GPIO_InitStructure.GPIO_Pin = MOT_SPI_MISO_PIN;
    395          /////GPIO_Init(MOT_SPI_MISO_PIN_GPIO, &GPIO_InitStructure);
    396          GPIO_InitStructure.GPIO_Pin = MOT_SPI_MOSI_PIN;
    397          GPIO_Init(MOT_SPI_MOSI_PIN_GPIO, &GPIO_InitStructure);
    398          
    399          ////GPIO_InitStructure.GPIO_Pin = MOT_SPI_SCS_PIN;
    400          /////GPIO_Init(MOT_SPI_SCS_PIN_GPIO, &GPIO_InitStructure);
    401          
    402          SPI_I2S_DeInit(MOT_SPI);
    403          SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
    404          SPI_InitStructure.SPI_DataSize = SPI_DataSize_16b;
    405          SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
    406          SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
    407          SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;///SPI_NSS_Hard;///SPI_NSS_Soft;///SPI_NSS_Hard;
    408          SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_64;
    409          SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
    410          SPI_InitStructure.SPI_CRCPolynomial = 7;
    411          SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
    412          SPI_Init(MOT_SPI, &SPI_InitStructure);
    413          SPI_Cmd(MOT_SPI, ENABLE);
    414          }
    415          uint16_t mot_spi_transfer(uint16_t i_data)
    416          {
    417          uint16_t rez=0; 
    418          GPIO_SetBits(MOT_SPI_SCS_PIN_GPIO, MOT_SPI_SCS_PIN);
    419          
    420          while (SPI_I2S_GetFlagStatus(MOT_SPI, SPI_I2S_FLAG_TXE) == RESET);
    421          SPI_I2S_SendData(MOT_SPI, i_data);
    422          while (SPI_I2S_GetFlagStatus(MOT_SPI, SPI_I2S_FLAG_RXNE) == RESET);
    423          while (SPI_I2S_GetFlagStatus(MOT_SPI, SPI_I2S_FLAG_TXE) == RESET);
    424          rez=SPI_I2S_ReceiveData(MOT_SPI);
    425          GPIO_ResetBits(MOT_SPI_SCS_PIN_GPIO, MOT_SPI_SCS_PIN);
    426          return rez;
    427          }
    428          ////==============================================
    429          void mot_spi_set_br(uint16_t br)
    430          {
    431          uint16_t tmpreg = 0;
    432          tmpreg = MOT_SPI->CR1& ~(0x7<<3);
    433          tmpreg |=	br&(0x7<<3);
    434          MOT_SPI->CR1=tmpreg;
    435          }
    436          
    437          void mot_spi_wr(uint8_t addr,uint16_t idata)
    438          {
    439          uint16_t tmp;
    440          tmp=(addr&0x7)<<12;
    441          tmp|= idata&0xfff;
    442          mot_spi_transfer(tmp);
    443          }
    444          void mot_spi_wrp(uint8_t addr,uint16_t *pdata)
    445          {
    446          uint16_t tmp;
    447          memcpy(&tmp,pdata,sizeof(uint16_t));
    448          mot_spi_wr(addr,tmp);       
    449          }
    450          uint16_t mot_spi_rd(uint8_t addr)
    451          {
    452          uint16_t rez;
    453          uint16_t tmp;
    454          tmp=(addr&0x7)<<12;
    455          tmp|= 0x8000;
    456          rez=mot_spi_transfer(tmp);
    457          return rez&0xfff;
    458          }
    459          ////========================================================  
    460          
    461          CTRL_Register_t 	G_CTRL_REG;
    462          TORQUE_Register_t 	G_TORQUE_REG;
    463           OFF_Register_t 	G_OFF_REG;
    464          BLANK_Register_t	G_BLANK_REG;
    465          DECAY_Register_t 	G_DECAY_REG;
    466          STALL_Register_t 	G_STALL_REG;
    467          DRIVE_Register_t 	G_DRIVE_REG;
    468          STATUS_Register_t 	G_STATUS_REG;
    469          
    470          void init_step_mot(void)
    471          {
    472            
    473          // CTRL Register
    474          
    475          G_CTRL_REG.DTIME 	= 0;///0x03;
    476          G_CTRL_REG.ISGAIN 	= 0;///0x03;
    477          G_CTRL_REG.EXSTALL 	= 0x00;
    478          G_CTRL_REG.MODE 	= 0;///0x03;
    479          G_CTRL_REG.RSTEP 	= 0x00;
    480          G_CTRL_REG.RDIR 	= 0x00;
    481          G_CTRL_REG.ENBL 	= 0x01;
    482          
    483          // TORQUE Register
    484          G_TORQUE_REG.SIMPLTH = 0x00;
    485          G_TORQUE_REG.TORQUE  = 0xBA;
    486          
    487          // OFF Register
    488          G_OFF_REG.PWMMODE 	= 0x00;
    489          G_OFF_REG.TOFF 		= 0x30;
    490          
    491          // BLANK Register
    492          G_BLANK_REG.ABT 	= 0x01;
    493          G_BLANK_REG.TBLANK 	= 0x08;
    494          
    495          // DECAY Register.
    496          G_DECAY_REG.DECMOD  = 0x03;
    497          G_DECAY_REG.TDECAY 	= 0x10;
    498          
    499          // STALL Register
    500          G_STALL_REG.VDIV 	= 0x03;
    501          G_STALL_REG.SDCNT 	= 0x03;
    502          G_STALL_REG.SDTHR 	= 0x40;
    503          
    504          // DRIVE Register
    505          G_DRIVE_REG.OCPTH 	= 0x01;
    506          G_DRIVE_REG.IDRIVEP = 0x00;
    507          G_DRIVE_REG.IDRIVEN = 0x00;
    508          G_DRIVE_REG.TDRIVEP = 0x01;
    509          G_DRIVE_REG.TDRIVEN = 0x01;
    510          G_DRIVE_REG.OCPDEG 	= 0x01;
    511          
    512          mot_spi_wrp(ADDR_MOT_CTRL,(uint16_t*)&G_CTRL_REG);
    513          mot_spi_wrp(ADDR_MOT_TORQUE,(uint16_t*)&G_TORQUE_REG);
    514          mot_spi_wrp(ADDR_MOT_OFF,(uint16_t*)&G_OFF_REG);
    515          mot_spi_wrp(ADDR_MOT_BLANK,(uint16_t*)&G_BLANK_REG);
    516          mot_spi_wrp(ADDR_MOT_DECAY,(uint16_t*)&G_DECAY_REG);
    517          mot_spi_wrp(ADDR_MOT_STALL,(uint16_t*)&G_STALL_REG);
    518          mot_spi_wrp(ADDR_MOT_DRIVE,(uint16_t*)&G_DRIVE_REG);
    519          mot_spi_wr(ADDR_MOT_STATUS,0);       
    520          
    521          }
    522          ////========================================================  
    523          void set_mot_rej(uint8_t rej)
    524          {
    525          uint16_t tmp;
    526          CTRL_Register_t *t_ctrl_reg=(CTRL_Register_t*)&tmp;
    527          tmp=mot_spi_rd(ADDR_MOT_CTRL);
    528          
    529          t_ctrl_reg->MODE=rej;
    530          mot_spi_wr(ADDR_MOT_CTRL,tmp);
    531          
    532          tmp=mot_spi_rd(ADDR_MOT_CTRL);
    533          }
    534          
    535          
    536          void print_mot_reg(void)
    537          {
    538          uint16_t tmp;
    539          tmp=mot_spi_rd(ADDR_MOT_CTRL);
    540          printk("\n\r CTRL[%x]",tmp);
    541          
    542          tmp=mot_spi_rd(ADDR_MOT_TORQUE);
    543          printk("\n\r TORQUE[%x]",tmp);
    544          tmp=mot_spi_rd(ADDR_MOT_OFF);
    545          printk("\n\r OFF[%x]",tmp);
    546          tmp=mot_spi_rd(ADDR_MOT_BLANK);
    547          printk("\n\r BLANK[%x]",tmp);
    548          tmp=mot_spi_rd(ADDR_MOT_STALL);
    549          printk("\n\r STALL[%x]",tmp);
    550          tmp=mot_spi_rd(ADDR_MOT_DRIVE);
    551          printk("\n\r DRIVE[%x]",tmp);
    552          tmp=mot_spi_rd(ADDR_MOT_STATUS);
    553          printk("\n\r STATUS[%x]",tmp);
    554          
    555          }
    556          
    557          
    558          ////============================================
    559          extern uint8_t can1_send(uint16_t id,uint8_t data_len,uint8_t *data);
    560          extern uint8_t  CAN_TxRdy;              /* CAN HW ready to transmit message */
    561          extern uint8_t  CAN_RxRdy;              /* CAN HW received a message        */
    562          ////extern CanRxMsg RxMessage;
    563          void reset_mot_step(void)
    564          {
    565            
    566          }
    567          ////void put_mot_nstep(uint32_t nstep)
    568          
    569          void set_mot_per(uint16_t per)
    570          {
    571          if(per>MAX_PER)
    572            per=MAX_PER;
    573          else if(per<MIN_PER)
    574            per=MIN_PER;
    575          MOT_STEP_TIM ->ARR = per*2;////
    576          MOT_STEP_TIM ->CCR1 = per;////
    577          }
    578          ///=========================================================
    579          void CAN1_Init (void)
    580          {
    581          uint32_t id;
    582           uint32_t mask;
    583          CAN_Config();
    584          
    585          mask= (uint32_t)ID_MASK << 21; ///5+16
    586          
    587          #if STEP_X
    588            id=ID_X_CMD<<21; ///5+16
    589          
    590          #elif STEP_Y
    591            id=ID_Y_CMD<<21; ///5+16
    592          #elif STEP_Z
    593            id=ID_Z_CMD<<21; ///5+16
    594          #else 
    595            #error "\n\r=== STEP_... nodefined ==="; 
    596          #endif
    597          
    598          CAN_FilterConfig(0,id,mask);	
    599            /* Enable FIFO 0 message pending Interrupt */
    600            CAN_ITConfig(CAN1, CAN_IT_FMP0, ENABLE);
    601          }
    602          
    603          extern can_msg_t CAN_RxMsg;
    604          ////xQueueHandle queu_can_resv;
    605          
    606          
    607          ////========================================================  
    608          void tst1_task( void *pvParameters )
    609          {
    610          ////uint8_t btst=0; 
    611          uint32_t t_coord=0;  
    612          uint8_t t_stat=0x8; 
    613          
    614          ////uint8_t ii=0; 
    615          printk("\n\r tst1_task"); 
    616          ///=======================================
    617          #if 0
    618          can_msg_t  send_msg;
    619          go_cmd_t t_go_cmd;
    620          t_go_cmd.cmd=GO_CMD ;
    621          t_go_cmd.dirs=1;
    622          t_go_cmd.step_per=1000;
    623          send_msg.len=CAN_MAX_NUM_BYTES;
    624          send_msg.format=STANDARD_FORMAT;
    625          send_msg.type=DATA_FRAME;
    626          t_go_cmd.steps=10;
    627          memcpy(send_msg.data,&t_go_cmd,sizeof(go_cmd_t));
    628          send_msg.id=ID_X_CMD; 
    629          #endif
    630          ///============================================
    631          #if 0
    632          for(;;)
    633            {
    634            if( CAN_RxRdy)
    635              {
    636              CAN_RxRdy=0;
    637              printk("\n\r can_rx"); 
    638              printk("\n\r ExtId[%x]",CAN_RxMsg.id);
    639              printk("\n\r DLC[%x]\n\r ",CAN_RxMsg.len);
    640              for(ii=0;ii<8;ii++)
    641                {
    642                printk("[%x] ",CAN_RxMsg.data[ii]);
    643                }
    644              }
    645            else
    646            {
    647          ////   CAN_wrMsg (&send_msg);
    648              msleep(20);
    649            }
    650            }
    651          #endif
    652          for(;;)
    653            {
    654            put_can_cmd_stat(t_stat,t_coord);
    655             
    656             t_coord++; 
    657              msleep(20);
    658            }
    659          }
    660          ////=======================================================
    661          	

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   CAN1_Init
        16   -> CAN_Config
        16   -> CAN_FilterConfig
        16   -> CAN_ITConfig
       8   TIM1_CC_IRQHandler
         8   -> TIM_ClearITPendingBit
         8   -> ena_mot
         8   -> stop_mot_step_tim
      24   UART_DBG_Init
        24   -> RCC_APB2PeriphClockCmd
        24   -> USART_Cmd
        24   -> USART_DeInit
        24   -> USART_Init
       8   _putk
         8   -> send_char_dbg
       0   check_push_key_dbg
      16   ena_mot
        16   -> mot_spi_rd
        16   -> mot_spi_wr
       0   get_byte_dbg
       8   get_conc0
         8   -> GPIO_ReadInputDataBit
       8   get_conc1
         8   -> GPIO_ReadInputDataBit
       8   hw_board_init
         8   -> NVIC_PriorityGroupConfig
         8   -> UART_DBG_Init
         8   -> ena_mot
         8   -> init_gpio
         8   -> mot_spi_init
         8   -> mot_step_tim_init
         8   -> motor_init
      32   init_gpio
        32   -> GPIO_Init
        32   -> GPIO_PinAFConfig
        32   -> GPIO_ResetBits
        32   -> RCC_AHB1PeriphClockCmd
      32   init_step_mot
        32   -> mot_spi_wr
        32   -> mot_spi_wrp
      40   mot_spi_init
        40   -> GPIO_Init
        40   -> GPIO_PinAFConfig
        40   -> RCC_AHB1PeriphClockCmd
        40   -> RCC_APB1PeriphClockCmd
        40   -> SPI_Cmd
        40   -> SPI_I2S_DeInit
        40   -> SPI_Init
      16   mot_spi_rd
        16   -> mot_spi_transfer
       4   mot_spi_set_br
      24   mot_spi_transfer
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> SPI_I2S_GetFlagStatus
        24   -> SPI_I2S_ReceiveData
        24   -> SPI_I2S_SendData
      16   mot_spi_wr
        16   -> mot_spi_transfer
      32   mot_spi_wrp
        32   -> __aeabi_memcpy
        32   -> mot_spi_wr
       8   mot_step_tim_init
         8   -> NVIC_Init
         8   -> TIM_ClearITPendingBit
       8   motor_init
         8   -> ena_mot
         8   -> init_step_mot
         8   -> set_mot_rej
         8   -> set_reset_mot
         8   -> set_sleep_mot
         8   -> uDelay
      32   print_mot_reg
        32   -> _printk
        32   -> mot_spi_rd
      16   put_mot_nstep
        16   -> TIM_Cmd
        16   -> TIM_ITConfig
        16   -> ena_mot
       0   reset_mot_step
       0   send_char_dbg
      16   set_dir_mot
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
       0   set_mot_per
      16   set_mot_rej
        16   -> mot_spi_rd
        16   -> mot_spi_wr
       8   set_reset_mot
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
       8   set_sleep_mot
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
       8   stop_mot_step_tim
         8   -> TIM_Cmd
      16   tst1_task
        16   -> _printk
        16   -> put_can_cmd_stat
        16   -> vTaskDelay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_10
       4  ??DataTable22_11
       4  ??DataTable22_12
       4  ??DataTable22_13
       4  ??DataTable22_14
       4  ??DataTable22_15
       4  ??DataTable22_16
       4  ??DataTable22_17
       4  ??DataTable22_18
       4  ??DataTable22_19
       4  ??DataTable22_2
       4  ??DataTable22_20
       4  ??DataTable22_21
       4  ??DataTable22_22
       4  ??DataTable22_23
       4  ??DataTable22_24
       4  ??DataTable22_25
       4  ??DataTable22_26
       4  ??DataTable22_27
       4  ??DataTable22_28
       4  ??DataTable22_29
       4  ??DataTable22_3
       4  ??DataTable22_30
       4  ??DataTable22_31
       4  ??DataTable22_32
       4  ??DataTable22_33
       4  ??DataTable22_34
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
      12  ?_0
      16  ?_1
      12  ?_2
      16  ?_3
      16  ?_4
      16  ?_5
      16  ?_6
      16  ?_7
      36  CAN1_Init
       2  G_BLANK_REG
       2  G_CTRL_REG
       2  G_DECAY_REG
       2  G_DRIVE_REG
       2  G_OFF_REG
       2  G_STALL_REG
       2  G_STATUS_REG
       2  G_TORQUE_REG
      54  TIM1_CC_IRQHandler
      86  UART_DBG_Init
      14  _putk
      14  check_push_key_dbg
       4  cur_coord
       1  cur_stat
      40  ena_mot
      20  get_byte_dbg
      14  get_conc0
      14  get_conc1
       4  gsr
      46  hw_board_init
     640  init_gpio
     360  init_step_mot
     228  mot_spi_init
      32  mot_spi_rd
      26  mot_spi_set_br
      92  mot_spi_transfer
      32  mot_spi_wr
      40  mot_spi_wrp
     142  mot_step_tim_init
      54  motor_init
       4  num_step
     134  print_mot_reg
      40  put_mot_nstep
       2  reset_mot_step
      24  send_char_dbg
      46  set_dir_mot
      56  set_mot_per
      46  set_mot_rej
      36  set_reset_mot
      36  set_sleep_mot
      14  stop_mot_step_tim
      34  tst1_task

 
    29 bytes in section .bss
   120 bytes in section .rodata
 2'592 bytes in section .text
 
 2'592 bytes of CODE  memory
   120 bytes of CONST memory
    29 bytes of DATA  memory

Errors: none
Warnings: none
