###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         01/Apr/2023  19:21:28
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\proj\velograph\snail_w\stm32_snail\common\board\dima_board.c
#    Command line      =
#        -f
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board\dima_board.o.rsp
#        (D:\proj\velograph\snail_w\stm32_snail\common\board\dima_board.c -D
#        VECT_TAB_FLASH -D IAR_ARM_CM3 -D DIMA_BRD -D STEP_X -D STM32F205xx -D
#        BOOTER -lcN
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\List\Board
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\.\ -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\freertos\source\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\dbg\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\board\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\can\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\my_misc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\eeprom_emul\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board\dima_board.o.d
#    Locale            =  C
#    List file         =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\List\Board\dima_board.lst
#    Object file       =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board\dima_board.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\proj\velograph\snail_w\stm32_snail\common\board\dima_board.c
      1          #include <string.h>
      2          #include "FreeRTOS.h"
      3          #include "queue.h"
      4          
      5          #include "can.h"
      6          #include "can_cmds.h"
      7          #include "board.h"
      8          #include "printk.h"
      9          
     10          extern void uDelay (const uint32_t usec);
     11          extern void  put_tst_pin(uint8_t idat);
     12          
     13          uint32_t cur_coord=0;
     14          uint8_t cur_stat=0;
     15          
     16          void CAN_Config(void);
     17          
     18          ///=============================
     19          int send_char_dbg (int c) 
     20          { 
     21          while (!(UART_DBG->SR & 0x0080));
     22          UART_DBG->DR = (c & 0x1FF);
     23          return (c);
     24          }
     25          void _putk(char ch)
     26          {
     27          send_char_dbg(ch);
     28          }
     29          
     30          int get_byte_dbg (void) 
     31          {
     32          while (!(UART_DBG->SR & USART_SR_RXNE));
     33          return (UART_DBG->DR);
     34          }
     35          int check_push_key_dbg(void)
     36          {
     37          return  (UART_DBG->SR & USART_SR_RXNE); 
     38          }
     39          
     40          void init_gpio(void)
     41          {
     42          ////RCC_AHBPeriphClockCmd(XEN_PIN_RCC_AHB,ENABLE);
     43          GPIO_InitTypeDef GPIO_InitStructure;
     44          ////=============== TST2 ============================
     45          RCC_AHB1PeriphClockCmd(TST2_PIN_RCC, ENABLE);
     46          GPIO_InitStructure.GPIO_Pin = TST2_PIN;
     47          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     48          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
     49          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     50          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
     51          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
     52          GPIO_Init( TST2_PIN_GPIO, &GPIO_InitStructure );
     53          ////=============== TST3 ============================
     54          RCC_AHB1PeriphClockCmd(TST3_PIN_RCC, ENABLE);
     55          GPIO_InitStructure.GPIO_Pin = TST3_PIN;
     56          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     57          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
     58          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     59          
     60          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     61          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
     62          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
     63          GPIO_Init( TST3_PIN_GPIO, &GPIO_InitStructure );
     64          GPIO_PinAFConfig(TST3_PIN_GPIO, TST3_PIN_NPIN, GPIO_AF_TIM1);
     65          
     66          ////=============== TST7 ============================
     67          RCC_AHB1PeriphClockCmd(TST7_PIN_RCC, ENABLE);
     68          GPIO_InitStructure.GPIO_Pin = TST7_PIN;
     69          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     70          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
     71          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     72          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     73          GPIO_Init( TST7_PIN_GPIO, &GPIO_InitStructure );
     74          GPIO_PinAFConfig(TST7_PIN_GPIO, TST7_PIN_NPIN, GPIO_AF_TIM8);
     75            
     76          ////=========== DBG_UART =================================================== 
     77          RCC_AHB1PeriphClockCmd(UART_DBG_TX_RCC, ENABLE);
     78          GPIO_InitStructure.GPIO_Pin = UART_DBG_TX_PIN;
     79          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     80          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     81          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     82          GPIO_Init( UART_DBG_TX_GPIO, &GPIO_InitStructure );
     83          
     84          RCC_AHB1PeriphClockCmd(UART_DBG_RX_RCC, ENABLE);
     85          GPIO_InitStructure.GPIO_Pin = UART_DBG_RX_PIN;
     86          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     87          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
     88          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
     89          GPIO_Init( UART_DBG_RX_GPIO, &GPIO_InitStructure );
     90            
     91          GPIO_PinAFConfig(UART_DBG_TX_GPIO, UART_DBG_TX_PIN_NPIN, UART_DBG_TX_AF);
     92          GPIO_PinAFConfig(UART_DBG_RX_GPIO, UART_DBG_RX_PIN_NPIN, UART_DBG_RX_AF);
     93          ////===================================================================
     94          ////=============== MOT_FAULT ============================
     95          RCC_AHB1PeriphClockCmd(MOT_FAULT_PIN_RCC, ENABLE);
     96          GPIO_InitStructure.GPIO_Pin = MOT_FAULT_PIN;
     97          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     98          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
     99          GPIO_Init( MOT_FAULT_PIN_GPIO, &GPIO_InitStructure );
    100          ////=============== MOT_STALLN ============================
    101          RCC_AHB1PeriphClockCmd(MOT_STALLN_PIN_RCC, ENABLE);
    102          GPIO_InitStructure.GPIO_Pin = MOT_STALLN_PIN;
    103          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    104          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    105          GPIO_Init( MOT_STALLN_PIN_GPIO, &GPIO_InitStructure );
    106          ////=============== CONC1 ============================
    107          RCC_AHB1PeriphClockCmd(CONC1_PIN_RCC, ENABLE);
    108          GPIO_InitStructure.GPIO_Pin = CONC1_PIN;
    109          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    110          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    111          GPIO_Init( CONC1_PIN_GPIO, &GPIO_InitStructure );
    112          ////=============== CONC0 ============================
    113          RCC_AHB1PeriphClockCmd(CONC0_PIN_RCC, ENABLE);
    114          GPIO_InitStructure.GPIO_Pin = CONC0_PIN;
    115          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    116          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    117          GPIO_Init( CONC0_PIN_GPIO, &GPIO_InitStructure );
    118          ////=============== MOT_RESET ============================
    119          RCC_AHB1PeriphClockCmd(MOT_RESET_PIN_RCC, ENABLE);
    120          GPIO_InitStructure.GPIO_Pin = MOT_RESET_PIN;
    121          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    122          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    123          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    124          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    125          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    126          GPIO_Init( MOT_RESET_PIN_GPIO, &GPIO_InitStructure );
    127          ////=============== MOT_SLEEP ============================
    128          RCC_AHB1PeriphClockCmd(MOT_SLEEP_PIN_RCC, ENABLE);
    129          GPIO_InitStructure.GPIO_Pin = MOT_SLEEP_PIN;
    130          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    131          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    132          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    133          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    134          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    135          GPIO_Init( MOT_SLEEP_PIN_GPIO, &GPIO_InitStructure );
    136          ////#define MOT_STEP_TIM  	        TIM12
    137          ////=============== MOT_STEP ============================
    138          RCC_AHB1PeriphClockCmd(MOT_STEP_PIN_RCC, ENABLE);
    139          GPIO_InitStructure.GPIO_Pin = MOT_STEP_PIN;
    140          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    141          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    142          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    143          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    144          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    145          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    146          GPIO_Init( MOT_STEP_PIN_GPIO, &GPIO_InitStructure );
    147          GPIO_PinAFConfig(MOT_STEP_PIN_GPIO, MOT_STEP_PIN_NPIN, GPIO_AF_TIM1);
    148          ////===================================================================
    149          
    150          ////=============== MOT_DIR ============================
    151          RCC_AHB1PeriphClockCmd(MOT_DIR_PIN_RCC, ENABLE);
    152          GPIO_InitStructure.GPIO_Pin = MOT_DIR_PIN;
    153          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    154          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    155          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    156          ////GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    157          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    158          GPIO_Init( MOT_DIR_PIN_GPIO, &GPIO_InitStructure );
    159          ////GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    160          
    161          ////=============== MOT_SPI_SCS ============================
    162          RCC_AHB1PeriphClockCmd(MOT_SPI_SCS_PIN_RCC, ENABLE);
    163          GPIO_InitStructure.GPIO_Pin = MOT_SPI_SCS_PIN;
    164          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    165          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    166          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    167          GPIO_Init( MOT_SPI_SCS_PIN_GPIO, &GPIO_InitStructure );
    168          ////=============== CAN1_INH ============================
    169          RCC_AHB1PeriphClockCmd(CAN1_INH_PIN_RCC, ENABLE);
    170          GPIO_InitStructure.GPIO_Pin = CAN1_INH_PIN;
    171          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    172          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    173          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    174          GPIO_Init( CAN1_INH_PIN_GPIO, &GPIO_InitStructure );
    175          GPIO_ResetBits(CAN1_INH_PIN_GPIO, CAN1_INH_PIN);
    176           /* CAN GPIOs configuration **************************************************/
    177            /* Enable GPIO clock */
    178          RCC_AHB1PeriphClockCmd(CAN1_GPIO_CLK, ENABLE);
    179          
    180            /* Connect CAN pins to AF9 */
    181            GPIO_PinAFConfig(CAN1_GPIO_PORT, CAN1_RX_SOURCE, CAN1_AF_PORT);
    182            GPIO_PinAFConfig(CAN1_GPIO_PORT, CAN1_TX_SOURCE, CAN1_AF_PORT);
    183          
    184            /* Configure CAN RX and TX pins */
    185            GPIO_InitStructure.GPIO_Pin = CAN1_RX_PIN | CAN1_TX_PIN;
    186            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    187            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    188            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    189            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    190            GPIO_Init(CAN1_GPIO_PORT, &GPIO_InitStructure);
    191          
    192          }
    193          ////=============================================
    194          void UART_DBG_Init(void)
    195          {
    196          ////GPIO_InitTypeDef GPIO_InitStructure;
    197          USART_InitTypeDef USART_InitStructure;
    198          UART_DBG_CLK_INIT(UART_DBG_CLK, ENABLE);
    199          USART_DeInit(UART_DBG);
    200          USART_InitStructure.USART_BaudRate = 115200;
    201          USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    202          USART_InitStructure.USART_StopBits = USART_StopBits_1 ;
    203          USART_InitStructure.USART_Parity = USART_Parity_No;
    204          USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    205          USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    206          USART_Init(UART_DBG, &USART_InitStructure);
    207          UART_DBG->CR1 |= USART_CR1_RXNEIE;
    208          USART_Cmd(UART_DBG, ENABLE);
    209          }
    210          
    211          ////==================================================
    212          
    213          
    214          ///===========================================================
    215          volatile uint32_t gsr;
    216          
    217          ////===============================================
    218          uint8_t get_conc0(void)
    219          {
    220          return GPIO_ReadInputDataBit(CONC0_PIN_GPIO, CONC0_PIN);
    221          }
    222          uint8_t get_conc1(void)
    223          {
    224          return GPIO_ReadInputDataBit(CONC1_PIN_GPIO, CONC1_PIN);
    225          }
    226          ////=============================================
    227          void hw_board_init(void)
    228          {
    229          NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );
    230          init_gpio();
    231          UART_DBG_Init(); 
    232          init_can();
    233          
    234          /*
    235          #ifndef BOOTER
    236             motor_init();
    237          #endif
    238          cur_stat=STATE_READY;
    239          */
    240          }
    241          ////============================================
    242          
    243          ////============================================
    244          extern uint8_t can1_send(uint16_t id,uint8_t data_len,uint8_t *data);
    245          extern uint8_t  CAN_TxRdy;              /* CAN HW ready to transmit message */
    246          extern uint8_t  CAN_RxRdy;              /* CAN HW received a message        */
    247          ///=========================================================
    248          void _CAN1_Init (void)
    249          {
    250          uint32_t id;
    251           uint32_t mask;
    252          CAN_Config();
    253          
    254          mask= ID_MASK << 21; ///5+16
    255          
    256          id=ID_BRD<<21; ///5+16
    257          
    258          CAN_FilterConfig(0,id,mask);	
    259            /* Enable FIFO 0 message pending Interrupt */
    260            CAN_ITConfig(CAN1, CAN_IT_FMP0, ENABLE);
    261          }
    262          
    263          extern can_msg_t CAN_RxMsg;
    264          ////========================================================  
    265          void tst1_task( void *pvParameters )
    266          {
    267          ////uint8_t btst=0; 
    268          uint32_t t_coord=0;  
    269          uint8_t t_stat=0x8; 
    270          
    271          ////uint8_t ii=0; 
    272          printk("\n\r tst1_task"); 
    273          ///=======================================
    274          #if 0
    275          can_msg_t  send_msg;
    276          go_cmd_t t_go_cmd;
    277          t_go_cmd.cmd=GO_CMD ;
    278          t_go_cmd.dirs=1;
    279          t_go_cmd.step_per=1000;
    280          send_msg.len=CAN_MAX_NUM_BYTES;
    281          send_msg.format=STANDARD_FORMAT;
    282          send_msg.type=DATA_FRAME;
    283          t_go_cmd.steps=10;
    284          memcpy(send_msg.data,&t_go_cmd,sizeof(go_cmd_t));
    285          send_msg.id=ID_BRD; 
    286          #endif
    287          ///============================================
    288          #if 0
    289          for(;;)
    290            {
    291            if( CAN_RxRdy)
    292              {
    293              CAN_RxRdy=0;
    294              printk("\n\r can_rx"); 
    295              printk("\n\r ExtId[%x]",CAN_RxMsg.id);
    296              printk("\n\r DLC[%x]\n\r ",CAN_RxMsg.len);
    297              for(ii=0;ii<8;ii++)
    298                {
    299                printk("[%x] ",CAN_RxMsg.data[ii]);
    300                }
    301              }
    302            else
    303            {
    304          ////   CAN_wrMsg (&send_msg);
    305              msleep(20);
    306            }
    307            }
    308          #endif
    309          for(;;)
    310            {
    311            put_can_cmd_stat(t_stat,t_coord);
    312             
    313             t_coord++; 
    314              msleep(20);
    315            }
    316          }
    317          ////=======================================================
    318          void tst_task( void *pvParameters )
    319          {
    320          ///uint8_t btst=0; 
    321          char key=0;
    322          printk("\n\r tst_task"); 
    323           
    324          for(;;)
    325          {
    326          if(check_push_key_dbg())
    327            {
    328            key=get_byte_dbg() ;  
    329            switch(key)
    330              {
    331              case 'a':
    332              case 'A':
    333                printk("\n\r go to app"); 
    334                goto_app();
    335                break;
    336              case 'b':
    337              case 'B':
    338                printk("\n\r go to boot"); 
    339                goto_booter();
    340                break;
    341             }
    342            } 
    343          msleep(10);
    344          }
    345          }
    346          	

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   UART_DBG_Init
        24   -> RCC_APB2PeriphClockCmd
        24   -> USART_Cmd
        24   -> USART_DeInit
        24   -> USART_Init
      16   _CAN1_Init
        16   -> CAN_Config
        16   -> CAN_FilterConfig
        16   -> CAN_ITConfig
       8   _putk
         8   -> send_char_dbg
       0   check_push_key_dbg
       0   get_byte_dbg
       8   get_conc0
         8   -> GPIO_ReadInputDataBit
       8   get_conc1
         8   -> GPIO_ReadInputDataBit
       8   hw_board_init
         8   -> NVIC_PriorityGroupConfig
         8   -> UART_DBG_Init
         8   -> init_can
         8   -> init_gpio
      32   init_gpio
        32   -> GPIO_Init
        32   -> GPIO_PinAFConfig
        32   -> GPIO_ResetBits
        32   -> RCC_AHB1PeriphClockCmd
       0   send_char_dbg
      16   tst1_task
        16   -> _printk
        16   -> put_can_cmd_stat
        16   -> vTaskDelay
      16   tst_task
        16   -> _printk
        16   -> check_push_key_dbg
        16   -> get_byte_dbg
        16   -> goto_app
        16   -> goto_booter
        16   -> vTaskDelay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      16  ?_0
      12  ?_1
      16  ?_2
      16  ?_3
      82  UART_DBG_Init
      36  _CAN1_Init
      14  _putk
      14  check_push_key_dbg
       4  cur_coord
       1  cur_stat
      20  get_byte_dbg
      12  get_conc0
      12  get_conc1
       4  gsr
      24  hw_board_init
     700  init_gpio
      24  send_char_dbg
      34  tst1_task
      78  tst_task

 
     9 bytes in section .bss
    60 bytes in section .rodata
 1'098 bytes in section .text
 
 1'098 bytes of CODE  memory
    60 bytes of CONST memory
     9 bytes of DATA  memory

Errors: none
Warnings: none
