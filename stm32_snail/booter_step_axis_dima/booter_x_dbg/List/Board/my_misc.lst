###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         11/Mar/2023  15:47:52
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\proj\velograph\snail_w\stm32_snail\common\my_misc\my_misc.c
#    Command line      =
#        -f
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board\my_misc.o.rsp
#        (D:\proj\velograph\snail_w\stm32_snail\common\my_misc\my_misc.c -D
#        VECT_TAB_FLASH -D IAR_ARM_CM3 -D DIMA_BRD -D STEP_X -D STM32F205xx -D
#        BOOTER -lcN
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\List\Board
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\.\ -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\freertos\source\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\dbg\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\board\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\can\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\my_misc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\eeprom_emul\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board\my_misc.o.d
#    Locale            =  C
#    List file         =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\List\Board\my_misc.lst
#    Object file       =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board\my_misc.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\proj\velograph\snail_w\stm32_snail\common\my_misc\my_misc.c
      1          #include <stdint.h>
      2          #include "board.h"
      3          #include "my_misc.h"
      4          
      5          #include "can_cmds.h"
      6          #include "printk.h"
      7          static uint32_t GetSector(uint32_t Address);
      8          
      9          ///=======================================================================
     10          void uDelay (const uint32_t usec)
     11          {
     12          uint32_t count = 0;
     13          const uint32_t utime = 45*usec;////(120 * usec / 7);
     14          do
     15            {
     16             if ( ++count > utime )
     17              {
     18              return ;
     19              }
     20            }
     21          while (1);
     22          }
     23          ///=======================================================================
     24          
     25          pFunction Jump_To_Application;
     26          uint32_t jumpAddress;
     27          
     28          void goto_booter(void)
     29          {
     30          __disable_irq();
     31          NVIC_SetVectorTable(NVIC_VectTab_FLASH, BOOT_BASE_ADDRESS);
     32            
     33          jumpAddress = *(__IO uint32_t*) (BOOT_BASE_ADDRESS + 4);
     34          ////Jump_To_Application = (pFunction)JumpAddress;
     35          ////printk(" Jamp addres=[%x:%x]\r\n",jumpAddress,BOOT_BASE_ADDRESS);	
     36             Jump_To_Application = (pFunction) jumpAddress;
     37          /* Initialize user application's Stack Pointer */
     38          __set_CONTROL(0) ;
     39          __set_MSP(*(__IO uint32_t*) BOOT_BASE_ADDRESS);
     40          Jump_To_Application();
     41            
     42          }
     43          void goto_app(void)
     44          {
     45          ////uint32_t sp_tst=0;  
     46          __disable_irq();
     47          NVIC_SetVectorTable(NVIC_VectTab_FLASH, APP_BASE_ADDRESS);
     48          jumpAddress = *(__IO uint32_t*) (APP_BASE_ADDRESS + 4);
     49          ////sp_tst= *(__IO uint32_t*) (APP_BASE_ADDRESS);
     50          ///printk(" Jamp addres=[%x:%x:%x]\r\n",jumpAddress,APP_BASE_ADDRESS,sp_tst);	
     51          ///printk(" Jamp addres=[%x:%x:%x]\r\n",jumpAddress,APP_BASE_ADDRESS,sp_tst);	
     52          ///printk(" Jamp addres=[%x:%x:%x]\r\n",jumpAddress,APP_BASE_ADDRESS,sp_tst);	
     53          ////printk(" Jamp addres=[%x:%x:%x]\r\n",jumpAddress,APP_BASE_ADDRESS,sp_tst);	
     54          Jump_To_Application = (pFunction)jumpAddress;
     55          /* Initialize user application's Stack Pointer */
     56          __set_CONTROL(0) ;
     57          __set_MSP(*(__IO uint32_t*) APP_BASE_ADDRESS);
     58          Jump_To_Application();
     59            
     60          }
     61          ////=================================================
     62          void FLASH_If_Init(void)
     63          { 
     64          FLASH_Unlock(); 
     65          
     66            /* Clear pending flags (if any) */  
     67          FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | 
     68                          FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR|FLASH_FLAG_PGSERR);
     69          }
     70          
     71          uint32_t FLASH_If_Erase(uint32_t StartSector)
     72          {
     73          uint32_t UserStartSector = GetSector(APP_BASE_ADDRESS);
     74          
     75          if (FLASH_EraseSector(UserStartSector, VoltageRange_3) != FLASH_COMPLETE)
     76              {
     77              return 1;
     78              }
     79             
     80            return 0;
     81          }
     82          uint32_t FLASH_If_Write(__IO uint32_t* FlashAddress, uint32_t* Data ,uint32_t DataLength)
     83          {
     84            uint32_t i = 0;
     85          
     86            for (i = 0; (i < DataLength) && (*FlashAddress <= (APP_END_ADDRESS-4)); i++)
     87            {
     88              /* Device voltage range supposed to be [2.7V to 3.6V], the operation will
     89                 be done by word */ 
     90              if (FLASH_ProgramWord(*FlashAddress, *(uint32_t*)(Data+i)) == FLASH_COMPLETE)
     91              {
     92               /* Check the written value */
     93                if (*(uint32_t*)*FlashAddress != *(uint32_t*)(Data+i))
     94                {
     95                  /* Flash content doesn't match SRAM content */
     96                  return(2);
     97                }
     98                /* Increment FLASH destination address */
     99                *FlashAddress += 4;
    100              }
    101              else
    102              {
    103                /* Error occurred while writing data in Flash memory */
    104                return (1);
    105              }
    106            }
    107          
    108            return (0);
    109          }
    110          
    111          static uint32_t GetSector(uint32_t Address)
    112          {
    113            uint32_t sector = 0;
    114            
    115            if((Address < ADDR_FLASH_SECTOR_1) && (Address >= ADDR_FLASH_SECTOR_0))
    116            {
    117              sector = FLASH_Sector_0;  
    118            }
    119            else if((Address < ADDR_FLASH_SECTOR_2) && (Address >= ADDR_FLASH_SECTOR_1))
    120            {
    121              sector = FLASH_Sector_1;  
    122            }
    123            else if((Address < ADDR_FLASH_SECTOR_3) && (Address >= ADDR_FLASH_SECTOR_2))
    124            {
    125              sector = FLASH_Sector_2;  
    126            }
    127            else if((Address < ADDR_FLASH_SECTOR_4) && (Address >= ADDR_FLASH_SECTOR_3))
    128            {
    129              sector = FLASH_Sector_3;  
    130            }
    131            else if(Address >= ADDR_FLASH_SECTOR_4)
    132            {
    133              sector = FLASH_Sector_4;  
    134            }
    135              return sector;
    136          }
    137          
    138          uint8_t erase_sectors(uint8_t *data)
    139          {
    140          return FLASH_If_Erase(0);  
    141          }
    142          uint8_t prg_dat(uint8_t *data)
    143          {
    144          uint8_t ii;   
    145          FLASH_Status t_fl_stat;  
    146          uint8_t num_bytes;
    147          uint32_t addr_prg;
    148          prg_flash_cmd_t *p_prg_flash_cmd=(prg_flash_cmd_t *)data;
    149          num_bytes=p_prg_flash_cmd->num_bytes;
    150          
    151          if((num_bytes>MAX_NUM_BYTES_PRG)||(num_bytes==0))
    152            return ERROR_NUM_BYTES_PRG;
    153          addr_prg=p_prg_flash_cmd->b_addr + APP_BASE_ADDRESS;
    154          if(addr_prg>APP_END_ADDRESS)
    155            return ERROR_ADDR_PRG;
    156          
    157          switch(num_bytes)  {
    158            case 1:
    159              t_fl_stat=FLASH_ProgramByte(addr_prg, p_prg_flash_cmd->data[0]); 
    160              break;
    161            case 2:
    162              t_fl_stat=FLASH_ProgramHalfWord(addr_prg, (uint16_t )p_prg_flash_cmd->data[0]); 
    163              break;
    164            case 3:
    165              for(ii=0;ii<3;ii++)
    166                {
    167                t_fl_stat=FLASH_ProgramByte(addr_prg+ii, p_prg_flash_cmd->data[ii]); 
    168                if( t_fl_stat!=FLASH_COMPLETE)
    169                  break;
    170                }
    171              break;
    172            case 4:
    173              t_fl_stat=FLASH_ProgramWord(addr_prg, (uint32_t )p_prg_flash_cmd->data[0]); 
    174              break;
    175          }
    176          if(t_fl_stat==FLASH_COMPLETE ) 
    177            return 0;  
    178          else
    179            return ERROR_FLAH_PRG;
    180          
    181          }
    182          
    183          ////=================================================

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   FLASH_If_Erase
        16   -> FLASH_EraseSector
        16   -> GetSector
       8   FLASH_If_Init
         8   -> FLASH_ClearFlag
         8   -> FLASH_Unlock
      24   FLASH_If_Write
        24   -> FLASH_ProgramWord
       0   GetSector
       8   erase_sectors
         8   -> FLASH_If_Erase
       8   goto_app
         8   -- Indirect call
         8   -> NVIC_SetVectorTable
       8   goto_booter
         8   -- Indirect call
         8   -> NVIC_SetVectorTable
      32   prg_dat
        32   -> FLASH_ProgramByte
        32   -> FLASH_ProgramHalfWord
        32   -> FLASH_ProgramWord
       0   uDelay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      32  FLASH_If_Erase
      14  FLASH_If_Init
      72  FLASH_If_Write
      80  GetSector
       4  Jump_To_Application
      14  erase_sectors
      48  goto_app
      52  goto_booter
       4  jumpAddress
     176  prg_dat
      18  uDelay

 
   8 bytes in section .bss
 546 bytes in section .text
 
 546 bytes of CODE memory
   8 bytes of DATA memory

Errors: none
Warnings: none
