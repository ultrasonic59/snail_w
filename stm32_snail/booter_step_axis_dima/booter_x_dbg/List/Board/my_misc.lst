###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         25/Feb/2023  19:59:35
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\proj\velograph\snail_w\stm32_snail\common\my_misc\my_misc.c
#    Command line      =
#        -f
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board\my_misc.o.rsp
#        (D:\proj\velograph\snail_w\stm32_snail\common\my_misc\my_misc.c -D
#        VECT_TAB_FLASH -D IAR_ARM_CM3 -D DIMA_BRD -D STEP_X -D STM32F205xx -D
#        BOOTER -lcN
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\List\Board
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\.\ -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\freertos\source\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\dbg\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\board\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\can\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\my_misc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\eeprom_emul\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board\my_misc.o.d
#    Locale            =  C
#    List file         =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\List\Board\my_misc.lst
#    Object file       =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\Board\my_misc.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\proj\velograph\snail_w\stm32_snail\common\my_misc\my_misc.c
      1          #include <stdint.h>
      2          #include "board.h"
      3          #include "my_misc.h"
      4          
      5          ////#include <cmsis_iccarm.h>
      6          #include "printk.h"
      7          static uint32_t GetSector(uint32_t Address);
      8          
      9          ///=======================================================================
     10          void uDelay (const uint32_t usec)
     11          {
     12          uint32_t count = 0;
     13          const uint32_t utime = 45*usec;////(120 * usec / 7);
     14          do
     15            {
     16             if ( ++count > utime )
     17              {
     18              return ;
     19              }
     20            }
     21          while (1);
     22          }
     23          ///=======================================================================
     24          
     25          pFunction Jump_To_Application;
     26          uint32_t jumpAddress;
     27          
     28          void goto_booter(void)
     29          {
     30          __disable_irq();
     31          NVIC_SetVectorTable(NVIC_VectTab_FLASH, BOOT_BASE_ADDRESS);
     32            
     33          jumpAddress = *(__IO uint32_t*) (BOOT_BASE_ADDRESS + 4);
     34          ////Jump_To_Application = (pFunction)JumpAddress;
     35          ////printk(" Jamp addres=[%x:%x]\r\n",jumpAddress,BOOT_BASE_ADDRESS);	
     36             Jump_To_Application = (pFunction) jumpAddress;
     37          /* Initialize user application's Stack Pointer */
     38          __set_CONTROL(0) ;
     39          __set_MSP(*(__IO uint32_t*) BOOT_BASE_ADDRESS);
     40          Jump_To_Application();
     41            
     42          }
     43          void goto_app(void)
     44          {
     45          ////uint32_t sp_tst=0;  
     46          __disable_irq();
     47          NVIC_SetVectorTable(NVIC_VectTab_FLASH, APP_BASE_ADDRESS);
     48          jumpAddress = *(__IO uint32_t*) (APP_BASE_ADDRESS + 4);
     49          ////sp_tst= *(__IO uint32_t*) (APP_BASE_ADDRESS);
     50          ///printk(" Jamp addres=[%x:%x:%x]\r\n",jumpAddress,APP_BASE_ADDRESS,sp_tst);	
     51          ///printk(" Jamp addres=[%x:%x:%x]\r\n",jumpAddress,APP_BASE_ADDRESS,sp_tst);	
     52          ///printk(" Jamp addres=[%x:%x:%x]\r\n",jumpAddress,APP_BASE_ADDRESS,sp_tst);	
     53          ////printk(" Jamp addres=[%x:%x:%x]\r\n",jumpAddress,APP_BASE_ADDRESS,sp_tst);	
     54          Jump_To_Application = (pFunction)jumpAddress;
     55          /* Initialize user application's Stack Pointer */
     56          __set_CONTROL(0) ;
     57          __set_MSP(*(__IO uint32_t*) APP_BASE_ADDRESS);
     58          Jump_To_Application();
     59            
     60          }
     61          ////=================================================
     62          void FLASH_If_Init(void)
     63          { 
     64            FLASH_Unlock(); 
     65          
     66            /* Clear pending flags (if any) */  
     67            FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | 
     68                            FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR|FLASH_FLAG_PGSERR);
     69          }
     70          uint32_t FLASH_If_Erase(uint32_t StartSector)
     71          {
     72            uint32_t UserStartSector = FLASH_Sector_1, i = 0;
     73          
     74            /* Get the sector where start the user flash area */
     75            UserStartSector = GetSector(APPLICATION_ADDRESS);
     76          
     77            for(i = UserStartSector; i <= FLASH_Sector_11; i += 8)
     78            {
     79              /* Device voltage range supposed to be [2.7V to 3.6V], the operation will
     80                 be done by word */ 
     81              if (FLASH_EraseSector(i, VoltageRange_3) != FLASH_COMPLETE)
     82              {
     83                /* Error occurred while page erase */
     84                return (1);
     85              }
     86            }
     87            
     88            return (0);
     89          }
     90          uint32_t FLASH_If_Write(__IO uint32_t* FlashAddress, uint32_t* Data ,uint32_t DataLength)
     91          {
     92            uint32_t i = 0;
     93          
     94            for (i = 0; (i < DataLength) && (*FlashAddress <= (USER_FLASH_END_ADDRESS-4)); i++)
     95            {
     96              /* Device voltage range supposed to be [2.7V to 3.6V], the operation will
     97                 be done by word */ 
     98              if (FLASH_ProgramWord(*FlashAddress, *(uint32_t*)(Data+i)) == FLASH_COMPLETE)
     99              {
    100               /* Check the written value */
    101                if (*(uint32_t*)*FlashAddress != *(uint32_t*)(Data+i))
    102                {
    103                  /* Flash content doesn't match SRAM content */
    104                  return(2);
    105                }
    106                /* Increment FLASH destination address */
    107                *FlashAddress += 4;
    108              }
    109              else
    110              {
    111                /* Error occurred while writing data in Flash memory */
    112                return (1);
    113              }
    114            }
    115          
    116            return (0);
    117          }
    118          
    119          static uint32_t GetSector(uint32_t Address)
    120          {
    121            uint32_t sector = 0;
    122            
    123            if((Address < ADDR_FLASH_SECTOR_1) && (Address >= ADDR_FLASH_SECTOR_0))
    124            {
    125              sector = FLASH_Sector_0;  
    126            }
    127            else if((Address < ADDR_FLASH_SECTOR_2) && (Address >= ADDR_FLASH_SECTOR_1))
    128            {
    129              sector = FLASH_Sector_1;  
    130            }
    131            else if((Address < ADDR_FLASH_SECTOR_3) && (Address >= ADDR_FLASH_SECTOR_2))
    132            {
    133              sector = FLASH_Sector_2;  
    134            }
    135            else if((Address < ADDR_FLASH_SECTOR_4) && (Address >= ADDR_FLASH_SECTOR_3))
    136            {
    137              sector = FLASH_Sector_3;  
    138            }
    139            else if((Address < ADDR_FLASH_SECTOR_5) && (Address >= ADDR_FLASH_SECTOR_4))
    140            {
    141              sector = FLASH_Sector_4;  
    142            }
    143            else if((Address < ADDR_FLASH_SECTOR_6) && (Address >= ADDR_FLASH_SECTOR_5))
    144            {
    145              sector = FLASH_Sector_5;  
    146            }
    147            else if((Address < ADDR_FLASH_SECTOR_7) && (Address >= ADDR_FLASH_SECTOR_6))
    148            {
    149              sector = FLASH_Sector_6;  
    150            }
    151            else if((Address < ADDR_FLASH_SECTOR_8) && (Address >= ADDR_FLASH_SECTOR_7))
    152            {
    153              sector = FLASH_Sector_7;  
    154            }
    155            else if((Address < ADDR_FLASH_SECTOR_9) && (Address >= ADDR_FLASH_SECTOR_8))
    156            {
    157              sector = FLASH_Sector_8;  
    158            }
    159            else if((Address < ADDR_FLASH_SECTOR_10) && (Address >= ADDR_FLASH_SECTOR_9))
    160            {
    161              sector = FLASH_Sector_9;  
    162            }
    163            else if((Address < ADDR_FLASH_SECTOR_11) && (Address >= ADDR_FLASH_SECTOR_10))
    164            {
    165              sector = FLASH_Sector_10;  
    166            }
    167            else/*(Address < FLASH_END_ADDR) && (Address >= ADDR_FLASH_SECTOR_11))*/
    168            {
    169              sector = FLASH_Sector_11;  
    170            }
    171              return sector;
    172          }
    173          
    174          uint8_t erase_sectors(uint8_t *data)
    175          {
    176            
    177          return 0;  
    178          }
    179          uint8_t prg_dat(uint8_t *data)
    180          {
    181          return 0;  
    182          }
    183          
    184          ////=================================================

Errors: 14
Warnings: none
