###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         25/Feb/2023  19:59:36
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\can_thr.c
#    Command line      =
#        -f
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\can_thr.o.rsp
#        (D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\can_thr.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D DIMA_BRD -D STEP_X -D STM32F205xx
#        -D BOOTER -lcN
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\List\
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\.\ -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\freertos\source\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\dbg\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\board\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\can\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\my_misc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\eeprom_emul\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\can_thr.o.d
#    Locale            =  C
#    List file         =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\List\can_thr.lst
#    Object file       =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\can_thr.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\can_thr.c
      1          #include <string.h>
      2          #include "FreeRTOS.h"
      3          #include "queue.h"
      4          #include "semphr.h"
      5          ///#include "stm32f2xx_gpio.h"
      6          ///#include "stm32f2xx_rcc.h"
      7          
      8          #include "can.h"
      9          #include "can_cmds.h"
     10          #include "board.h"
     11          #include "printk.h"
     12          
     13          extern can_msg_t CAN_RxMsg;
     14          
     15          xQueueHandle queu_to_send;
     16          
     17          int go_cmd(go_cmd_t *p_go_cmd)
     18          {
     19          #ifndef BOOTER  
     20          cur_stat=STATE_MOVE;  
     21          printk("\n\rGo [dir=%x:per=%x:steps=%x] ",p_go_cmd->dirs,p_go_cmd->step_per,p_go_cmd->steps);
     22          
     23          set_dir_mot(p_go_cmd->dirs);
     24          ////set_step_per(p_go_cmd->step_per);
     25          set_mot_per(p_go_cmd->step_per);
     26          put_mot_nstep(p_go_cmd->steps);
     27          #endif
     28          return 0;
     29          }
     30          
     31          void can_rsv_task( void *pvParameters )
     32          {
     33          printk("\n\r can_rsv_task"); 
     34           for(;;)
     35            {
     36            if( CAN_RxRdy)
     37              {
     38              CAN_RxRdy=0;
     39              obr_can_cmd(CAN_RxMsg.data);
     40          #if 0    
     41              switch(CAN_RxMsg.data[0]) {
     42                case GO_CMD:
     43                  {
     44                  put_can_ack(GO_CMD);
     45                    
     46                  go_cmd((go_cmd_t *)CAN_RxMsg.data);
     47            ////       printk("Go [dir=%x:per=%d:steps=%d] ",p_can_cmd->dirs,p_can_cmd->step_per,p_can_cmd->steps);
     48                   
     49                  }
     50                  break;
     51                case GET_STAT_CMD:
     52                  {
     53                  put_can_cmd_stat(cur_stat,cur_coord);
     54                   printk("[stat=%x] ",cur_stat);
     55          
     56                   }
     57                  break;
     58                  
     59              default:
     60                break;
     61              }
     62          #endif
     63          #if 0   
     64              printk("\n\r can_rx"); 
     65              printk("\n\r ExtId[%x]",CAN_RxMsg.id);
     66              printk("\n\r DLC[%x]\n\r ",CAN_RxMsg.len);
     67              for(ii=0;ii<8;ii++)
     68                {
     69                printk("[%x] ",CAN_RxMsg.data[ii]);
     70                }
     71          #endif
     72              }
     73            else
     74            {
     75          ////   CAN_wrMsg (&send_msg);
     76              msleep(20);
     77            }
     78            }
     79          }
     80          
     81          void can_send_thread(void* pp)
     82          {
     83          can_msg_t  snd_msg;
     84          
     85          printk("\n\r can_send_thread");
     86          
     87          queu_to_send=xQueueCreate(CAN_MAX_LEN_QUEU,sizeof(can_msg_t));
     88          for(;;)
     89            {
     90            xQueueReceive(queu_to_send,&snd_msg,portMAX_DELAY);
     91          ////  can_wait_ready(READY_X);             //// wait ready X,Y,Z
     92            CAN_wrMsg (&snd_msg);
     93            
     94           //// test_print(&snd_msg);
     95            
     96           ////  tst_print();
     97          ///  set_curr_dir(st.dir_outbits);
     98          ////  obr_segment();
     99          ///=================================================
    100          ////  sys.state &= ~STATE_CYCLE;
    101          
    102            }
    103          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   can_rsv_task
         8   -> _printk
         8   -> obr_can_cmd
         8   -> vTaskDelay
      32   can_send_thread
        32   -> CAN_wrMsg
        32   -> _printk
        32   -> xQueueGenericCreate
        32   -> xQueueReceive
       0   go_cmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
      16  ?_0
      20  ?_1
      38  can_rsv_task
      46  can_send_thread
       6  go_cmd
       4  queu_to_send

 
   4 bytes in section .bss
  36 bytes in section .rodata
 110 bytes in section .text
 
 110 bytes of CODE  memory
  36 bytes of CONST memory
   4 bytes of DATA  memory

Errors: none
Warnings: none
