###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         11/Mar/2023  15:47:53
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\boot_sys_stm32f2xx.c
#    Command line      =
#        -f
#        "D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\ST
#        Library\boot_sys_stm32f2xx.o.rsp"
#        (D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\boot_sys_stm32f2xx.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D DIMA_BRD -D STEP_X -D STM32F205xx
#        -D BOOTER -lcN
#        "D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\List\ST
#        Library" --diag_suppress Pa082,pe191 -o
#        "D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\ST
#        Library" --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\.\ -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\freertos\source\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\dbg\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\board\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\can\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\my_misc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\eeprom_emul\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        "D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\ST
#        Library\boot_sys_stm32f2xx.o.d"
#    Locale            =  C
#    List file         =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\List\ST
#        Library\boot_sys_stm32f2xx.lst
#    Object file       =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\ST
#        Library\boot_sys_stm32f2xx.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\boot_sys_stm32f2xx.c
      1          
      2          #include "stm32f2xx.h"
      3          
      4          /* #define VECT_TAB_SRAM */
      5          #define VECT_TAB_OFFSET  0x00000 /*!< Vector Table base offset field. 
      6                                             This value must be a multiple of 0x200. */
      7          
      8          
      9          /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N */
     10          #define PLL_M      16   /// 25
     11          #define PLL_N      240
     12          
     13          /* SYSCLK = PLL_VCO / PLL_P */
     14          #define PLL_P      2
     15          
     16          /* USB OTG FS, SDIO and RNG Clock =  PLL_VCO / PLLQ */
     17          #define PLL_Q      5
     18          
     19            uint32_t SystemCoreClock = 120000000;
     20          
     21            __I uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
     22          
     23          
     24          static void SetSysClock(void);
     25          
     26          /**
     27            * @brief  Setup the microcontroller system
     28            *         Initialize the Embedded Flash Interface, the PLL and update the 
     29            *         SystemFrequency variable.
     30            * @param  None
     31            * @retval None
     32            */
     33          void SystemInit(void)
     34          {
     35            /* Reset the RCC clock configuration to the default reset state ------------*/
     36            /* Set HSION bit */
     37            RCC->CR |= (uint32_t)0x00000001;
     38          
     39            /* Reset CFGR register */
     40            RCC->CFGR = 0x00000000;
     41          
     42            /* Reset HSEON, CSSON and PLLON bits */
     43            RCC->CR &= (uint32_t)0xFEF6FFFF;
     44          
     45            /* Reset PLLCFGR register */
     46            RCC->PLLCFGR = 0x24003010;
     47          
     48            /* Reset HSEBYP bit */
     49            RCC->CR &= (uint32_t)0xFFFBFFFF;
     50          
     51            /* Disable all interrupts */
     52            RCC->CIR = 0x00000000;
     53          
     54          #ifdef DATA_IN_ExtSRAM
     55            SystemInit_ExtMemCtl(); 
     56          #endif /* DATA_IN_ExtSRAM */
     57                   
     58            /* Configure the System clock source, PLL Multiplier and Divider factors, 
     59               AHB/APBx prescalers and Flash settings ----------------------------------*/
     60            SetSysClock();
     61          
     62            /* Configure the Vector Table location add offset address ------------------*/
     63          #ifdef VECT_TAB_SRAM
     64            SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
     65          #else
     66            SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
     67          #endif
     68          }
     69          
     70          /**
     71            * @brief  Update SystemCoreClock variable according to Clock Register Values.
     72            *         The SystemCoreClock variable contains the core clock (HCLK), it can
     73            *         be used by the user application to setup the SysTick timer or configure
     74            *         other parameters.
     75            *           
     76            * @note   Each time the core clock (HCLK) changes, this function must be called
     77            *         to update SystemCoreClock variable value. Otherwise, any configuration
     78            *         based on this variable will be incorrect.         
     79            *     
     80            * @note   - The system frequency computed by this function is not the real 
     81            *           frequency in the chip. It is calculated based on the predefined 
     82            *           constant and the selected clock source:
     83            *             
     84            *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(*)
     85            *                                              
     86            *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(**)
     87            *                          
     88            *           - If SYSCLK source is PLL, SystemCoreClock will contain the HSE_VALUE(**) 
     89            *             or HSI_VALUE(*) multiplied/divided by the PLL factors.
     90            *         
     91            *         (*) HSI_VALUE is a constant defined in stm32f2xx.h file (default value
     92            *             16 MHz) but the real value may vary depending on the variations
     93            *             in voltage and temperature.   
     94            *    
     95            *         (**) HSE_VALUE is a constant defined in stm32f2xx.h file (default value
     96            *              25 MHz), user has to ensure that HSE_VALUE is same as the real
     97            *              frequency of the crystal used. Otherwise, this function may
     98            *              have wrong result.
     99            *                
    100            *         - The result of this function could be not correct when using fractional
    101            *           value for HSE crystal.
    102            *     
    103            * @param  None
    104            * @retval None
    105            */
    106          void SystemCoreClockUpdate(void)
    107          {
    108            uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
    109            
    110            /* Get SYSCLK source -------------------------------------------------------*/
    111            tmp = RCC->CFGR & RCC_CFGR_SWS;
    112          
    113            switch (tmp)
    114            {
    115              case 0x00:  /* HSI used as system clock source */
    116                SystemCoreClock = HSI_VALUE;
    117                break;
    118              case 0x04:  /* HSE used as system clock source */
    119                SystemCoreClock = HSE_VALUE;
    120                break;
    121              case 0x08:  /* PLL used as system clock source */
    122          
    123                /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
    124                   SYSCLK = PLL_VCO / PLL_P
    125                   */    
    126                pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
    127                pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
    128                
    129                if (pllsource != 0)
    130                {
    131                  /* HSE used as PLL clock source */
    132                  pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
    133                }
    134                else
    135                {
    136                  /* HSI used as PLL clock source */
    137                  pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
    138                }
    139          
    140                pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
    141                SystemCoreClock = pllvco/pllp;
    142                break;
    143              default:
    144                SystemCoreClock = HSI_VALUE;
    145                break;
    146            }
    147            /* Compute HCLK frequency --------------------------------------------------*/
    148            /* Get HCLK prescaler */
    149            tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
    150            /* HCLK frequency */
    151            SystemCoreClock >>= tmp;
    152          }
    153          
    154          /**
    155            * @brief  Configures the System clock source, PLL Multiplier and Divider factors, 
    156            *         AHB/APBx prescalers and Flash settings
    157            * @Note   This function should be called only once the RCC clock configuration  
    158            *         is reset to the default reset state (done in SystemInit() function).   
    159            * @param  None
    160            * @retval None
    161            */
    162          static void SetSysClock(void)
    163          {
    164          /******************************************************************************/
    165          /*            PLL (clocked by HSE) used as System clock source                */
    166          /******************************************************************************/
    167            __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
    168            
    169            /* Enable HSE */
    170            RCC->CR |= ((uint32_t)RCC_CR_HSEON);
    171           
    172            /* Wait till HSE is ready and if Time out is reached exit */
    173            do
    174            {
    175              HSEStatus = RCC->CR & RCC_CR_HSERDY;
    176              StartUpCounter++;
    177            } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
    178          
    179            if ((RCC->CR & RCC_CR_HSERDY) != RESET)
    180            {
    181              HSEStatus = (uint32_t)0x01;
    182            }
    183            else
    184            {
    185              HSEStatus = (uint32_t)0x00;
    186            }
    187          
    188            if (HSEStatus == (uint32_t)0x01)
    189            {
    190              /* HCLK = SYSCLK / 1*/
    191              RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
    192                
    193              /* PCLK2 = HCLK / 2*/
    194              RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
    195              
    196              /* PCLK1 = HCLK / 4*/
    197              RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
    198          
    199              /* Configure the main PLL */
    200              RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
    201                             (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);
    202          
    203              /* Enable the main PLL */
    204              RCC->CR |= RCC_CR_PLLON;
    205          
    206              /* Wait till the main PLL is ready */
    207              while((RCC->CR & RCC_CR_PLLRDY) == 0)
    208              {
    209              }
    210             
    211              /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    212              FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | FLASH_ACR_DCEN | FLASH_ACR_LATENCY_3WS;
    213          
    214              /* Select the main PLL as system clock source */
    215              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
    216              RCC->CFGR |= RCC_CFGR_SW_PLL;
    217          
    218              /* Wait till the main PLL is used as system clock source */
    219              while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
    220              {
    221              }
    222            }
    223            else
    224            { /* If HSE fails to start-up, the application will have wrong clock
    225                   configuration. User can add here some code to deal with this error */
    226            }
    227          
    228          }
    229          
    230          /**
    231            * @brief  Setup the external memory controller. Called in startup_stm32f2xx.s
    232            *         before jump to __main
    233            * @param  None
    234            * @retval None
    235            */
    236          #ifdef DATA_IN_ExtSRAM
    237          /**
    238            * @brief  Setup the external memory controller.
    239            *         Called in startup_stm32f2xx.s before jump to main.
    240            *         This function configures the external SRAM mounted on STM322xG_EVAL board
    241            *         This SRAM will be used as program data memory (including heap and stack).
    242            * @param  None
    243            * @retval None
    244            */
    245          void SystemInit_ExtMemCtl(void)
    246          {
    247          /*-- GPIOs Configuration -----------------------------------------------------*/
    248          /*
    249           +-------------------+--------------------+------------------+------------------+
    250           +                       SRAM pins assignment                                  +
    251           +-------------------+--------------------+------------------+------------------+
    252           | PD0  <-> FSMC_D2  | PE0  <-> FSMC_NBL0 | PF0  <-> FSMC_A0 | PG0 <-> FSMC_A10 |
    253           | PD1  <-> FSMC_D3  | PE1  <-> FSMC_NBL1 | PF1  <-> FSMC_A1 | PG1 <-> FSMC_A11 |
    254           | PD4  <-> FSMC_NOE | PE7  <-> FSMC_D4   | PF2  <-> FSMC_A2 | PG2 <-> FSMC_A12 |
    255           | PD5  <-> FSMC_NWE | PE8  <-> FSMC_D5   | PF3  <-> FSMC_A3 | PG3 <-> FSMC_A13 |
    256           | PD8  <-> FSMC_D13 | PE9  <-> FSMC_D6   | PF4  <-> FSMC_A4 | PG4 <-> FSMC_A14 |
    257           | PD9  <-> FSMC_D14 | PE10 <-> FSMC_D7   | PF5  <-> FSMC_A5 | PG5 <-> FSMC_A15 |
    258           | PD10 <-> FSMC_D15 | PE11 <-> FSMC_D8   | PF12 <-> FSMC_A6 | PG9 <-> FSMC_NE2 |
    259           | PD11 <-> FSMC_A16 | PE12 <-> FSMC_D9   | PF13 <-> FSMC_A7 |------------------+
    260           | PD12 <-> FSMC_A17 | PE13 <-> FSMC_D10  | PF14 <-> FSMC_A8 | 
    261           | PD14 <-> FSMC_D0  | PE14 <-> FSMC_D11  | PF15 <-> FSMC_A9 | 
    262           | PD15 <-> FSMC_D1  | PE15 <-> FSMC_D12  |------------------+
    263           +-------------------+--------------------+
    264          */
    265             /* Enable GPIOD, GPIOE, GPIOF and GPIOG interface clock */
    266            RCC->AHB1ENR   = 0x00000078;
    267            
    268            /* Connect PDx pins to FSMC Alternate function */
    269            GPIOD->AFR[0]  = 0x00cc00cc;
    270            GPIOD->AFR[1]  = 0xcc0ccccc;
    271            /* Configure PDx pins in Alternate function mode */  
    272            GPIOD->MODER   = 0xa2aa0a0a;
    273            /* Configure PDx pins speed to 100 MHz */  
    274            GPIOD->OSPEEDR = 0xf3ff0f0f;
    275            /* Configure PDx pins Output type to push-pull */  
    276            GPIOD->OTYPER  = 0x00000000;
    277            /* No pull-up, pull-down for PDx pins */ 
    278            GPIOD->PUPDR   = 0x00000000;
    279          
    280            /* Connect PEx pins to FSMC Alternate function */
    281            GPIOE->AFR[0]  = 0xc00000cc;
    282            GPIOE->AFR[1]  = 0xcccccccc;
    283            /* Configure PEx pins in Alternate function mode */ 
    284            GPIOE->MODER   = 0xaaaa800a;
    285            /* Configure PEx pins speed to 100 MHz */ 
    286            GPIOE->OSPEEDR = 0xffffc00f;
    287            /* Configure PEx pins Output type to push-pull */  
    288            GPIOE->OTYPER  = 0x00000000;
    289            /* No pull-up, pull-down for PEx pins */ 
    290            GPIOE->PUPDR   = 0x00000000;
    291          
    292            /* Connect PFx pins to FSMC Alternate function */
    293            GPIOF->AFR[0]  = 0x00cccccc;
    294            GPIOF->AFR[1]  = 0xcccc0000;
    295            /* Configure PFx pins in Alternate function mode */   
    296            GPIOF->MODER   = 0xaa000aaa;
    297            /* Configure PFx pins speed to 100 MHz */ 
    298            GPIOF->OSPEEDR = 0xff000fff;
    299            /* Configure PFx pins Output type to push-pull */  
    300            GPIOF->OTYPER  = 0x00000000;
    301            /* No pull-up, pull-down for PFx pins */ 
    302            GPIOF->PUPDR   = 0x00000000;
    303          
    304            /* Connect PGx pins to FSMC Alternate function */
    305            GPIOG->AFR[0]  = 0x00cccccc;
    306            GPIOG->AFR[1]  = 0x000000c0;
    307            /* Configure PGx pins in Alternate function mode */ 
    308            GPIOG->MODER   = 0x00080aaa;
    309            /* Configure PGx pins speed to 100 MHz */ 
    310            GPIOG->OSPEEDR = 0x000c0fff;
    311            /* Configure PGx pins Output type to push-pull */  
    312            GPIOG->OTYPER  = 0x00000000;
    313            /* No pull-up, pull-down for PGx pins */ 
    314            GPIOG->PUPDR   = 0x00000000;
    315            
    316          /*-- FSMC Configuration ------------------------------------------------------*/
    317            /* Enable the FSMC interface clock */
    318            RCC->AHB3ENR         = 0x00000001;
    319          
    320            /* Configure and enable Bank1_SRAM2 */
    321            FSMC_Bank1->BTCR[2]  = 0x00001015;
    322            FSMC_Bank1->BTCR[3]  = 0x00010400;
    323            FSMC_Bank1E->BWTR[2] = 0x0fffffff;
    324          /*
    325            Bank1_SRAM2 is configured as follow:
    326          
    327            p.FSMC_AddressSetupTime = 0;
    328            p.FSMC_AddressHoldTime = 0;
    329            p.FSMC_DataSetupTime = 4;
    330            p.FSMC_BusTurnAroundDuration = 1;
    331            p.FSMC_CLKDivision = 0;
    332            p.FSMC_DataLatency = 0;
    333            p.FSMC_AccessMode = FSMC_AccessMode_A;
    334          
    335            FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM2;
    336            FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
    337            FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_PSRAM;
    338            FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
    339            FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
    340            FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;  
    341            FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
    342            FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;
    343            FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
    344            FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
    345            FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
    346            FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
    347            FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
    348            FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &p;
    349            FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &p;
    350          */
    351            
    352          }
    353          #endif /* DATA_IN_ExtSRAM */
    354          
    355          
    356          /**
    357            * @}
    358            */
    359          
    360          /**
    361            * @}
    362            */
    363            
    364          /**
    365            * @}
    366            */
    367          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   SetSysClock
      16   SystemCoreClockUpdate
       8   SystemInit
         8   -> SetSysClock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
      16  AHBPrescTable
     150  SetSysClock
       4  SystemCoreClock
     162  SystemCoreClockUpdate
      60  SystemInit

 
  20 bytes in section .data
 420 bytes in section .text
 
 420 bytes of CODE memory
  20 bytes of DATA memory

Errors: none
Warnings: none
