###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         01/Apr/2023  19:21:28
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\booter_can_cmds.c
#    Command line                 =
#        -f
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\drv\booter_can_cmds.o.rsp
#        (D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\booter_can_cmds.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D DIMA_BRD -D STEP_X -D STM32F205xx
#        -D BOOTER -lcN
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\List\drv
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\drv
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\.\ -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\freertos\source\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\dbg\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\board\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\can\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\my_misc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\eeprom_emul\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\drv\booter_can_cmds.o.d
#    Locale                       =  C
#    List file                    =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\List\drv\booter_can_cmds.lst
#    Object file                  =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\drv\booter_can_cmds.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\booter_can_cmds.c
      1          #include <stdint.h>
      2          #include <string.h>
      3          #include <stdlib.h>
      4          
      5          #include "FreeRTOS.h"
      6          #include "task.h"
      7          #include "semphr.h"
      8          #include "queue.h"
      9          #include "board.h"
     10          #include "can.h"
     11          #include "can_cmds.h"
     12          #include "printk.h"
     13          #include "my_misc.h"
     14          ////=======================================
     15          extern xQueueHandle queu_to_send;
     16          
     17          int put_can_cmd_reset_all(void)
     18          {
     19            return 0;
     20          }
     21          
     22          void _mc_reset(void)
     23          {
     24          put_can_cmd_reset_all();  
     25          ////report_init_message();
     26          }
     27          int put_can_cmd_go(uint8_t dirs,uint16_t per
     28                             ,uint32_t step_x
     29                             ,uint32_t step_y
     30                             ,uint32_t step_z)
     31          {
     32          ///uint8_t btst=0;  
     33          can_msg_t  send_msg;
     34          go_cmd_t t_go_cmd;
     35          t_go_cmd.cmd=GO_CMD ;
     36          t_go_cmd.dirs=dirs;
     37          t_go_cmd.step_per=per;
     38          send_msg.len=CAN_MAX_NUM_BYTES;
     39          send_msg.format=STANDARD_FORMAT;
     40          send_msg.type=DATA_FRAME;
     41          if(step_x)
     42            {
     43             t_go_cmd.steps=step_x;
     44             memcpy(send_msg.data,&t_go_cmd,sizeof(go_cmd_t));
     45             send_msg.id=ID_BRD; 
     46             xQueueSend(queu_to_send,&send_msg,CAN_TIMEOUT_SEND);
     47            }
     48          if(step_y)
     49            {
     50             t_go_cmd.steps=step_y;
     51             memcpy(send_msg.data,&t_go_cmd,sizeof(go_cmd_t));
     52             send_msg.id=ID_BRD; 
     53             xQueueSend(queu_to_send,&send_msg,CAN_TIMEOUT_SEND);
     54            }
     55          if(step_z)
     56            {
     57             t_go_cmd.steps=step_z;
     58             memcpy(send_msg.data,&t_go_cmd,sizeof(go_cmd_t));
     59             send_msg.id=ID_BRD; 
     60             xQueueSend(queu_to_send,&send_msg,CAN_TIMEOUT_SEND);
     61            }
     62          
     63          ////send_msg.data[1]=btst;    
     64          ////xQueueSend(queu_to_send,&send_msg,CAN_TIMEOUT_SEND);
     65          
     66          ///go_cmd_t   go_cmd;
     67          #if 0        
     68                  printk("\n\r tst_cnt[%d][%02x][%d][%d][%d]", per, dirs
     69                      , step_x
     70                      , step_y
     71                      , step_z
     72                  );
     73          #endif
     74          
     75            return 0;
     76          }
     77          ////================================================
     78          #ifndef _MASTER_
     79          extern uint32_t cur_coord;
     80          extern uint8_t cur_stat;
     81          
     82          int put_can_cmd_stat(uint8_t state
     83                             ,uint32_t coord)
     84          {
     85          ///uint8_t btst=0;  
     86          can_msg_t  send_msg;
     87          put_stat_cmd_t t_put_stat_cmd;
     88          t_put_stat_cmd.cmd=PUT_STAT_CMD ;
     89          t_put_stat_cmd.axis= AXIS_BRD;
     90          
     91          ////t_put_stat_cmd.coord=cur_coord;
     92          ///t_put_stat_cmd.state=cur_stat;
     93          t_put_stat_cmd.coord=coord;
     94          t_put_stat_cmd.state=state;
     95          send_msg.len=CAN_MAX_NUM_BYTES;
     96          send_msg.format=STANDARD_FORMAT;
     97          send_msg.type=DATA_FRAME;
     98          memcpy(send_msg.data,&t_put_stat_cmd,sizeof(put_stat_cmd_t));
     99          send_msg.id=ID_MASTER_CMD; 
    100          xQueueSend(queu_to_send,&send_msg,CAN_TIMEOUT_SEND);
    101          
    102            return 0;
    103          }
    104          
    105          int put_can_ack(uint8_t cmd )
    106          {
    107          ///uint8_t btst=0;  
    108          can_msg_t  send_msg;
    109          
    110          put_ack_t t_put_ack;
    111          
    112          t_put_ack.cmd=PUT_ACK ;
    113          t_put_ack.ack.axis= AXIS_BRD;
    114          
    115           t_put_ack.ack.ack_cmd=cmd;
    116          send_msg.len= sizeof(put_ack_t);
    117          send_msg.format=STANDARD_FORMAT;
    118          send_msg.type=DATA_FRAME;
    119          memcpy(send_msg.data,&t_put_ack,sizeof(put_ack_t));
    120          send_msg.id=ID_MASTER_CMD; 
    121          xQueueSend(queu_to_send,&send_msg,CAN_TIMEOUT_SEND);
    122          
    123            return 0;
    124          }
    125          
    126          
    127          #endif
    128          
    129          int obr_can_cmd(uint8_t *data)
    130          {
    131          switch(data[0]) {
    132            case GO_TO_APP:
    133              goto_app();
    134              break;
    135            case GO_TO_BOOTER:
    136              goto_booter();
    137              break;
    138            case ERASE_SECTORS:
    139              erase_sectors(data+1);
    140              break;
    141            case PRG_DAT:
    142              prg_dat(data);
    143              break;
    144            case CHECK_CONN:
    145              put_can_ack(CHECK_CONN );
    146              printk("CHECK_CONN[%x] ",cur_stat);
    147              break;
    148           
    149             case GET_BOOT_STAT:
    150              put_can_cmd_stat(cur_stat,cur_coord);
    151              printk("[stat=%x] ",cur_stat);
    152              break;
    153                  
    154              default:
    155                break;
    156              }
    157          return 0;  
    158          }
    159          ////======================================================

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   _mc_reset
         8   -> put_can_cmd_reset_all
      16   obr_can_cmd
        16   -> _printk
        16   -> erase_sectors
        16   -> goto_app
        16   -> goto_booter
        16   -> prg_dat
        16   -> put_can_ack
        16   -> put_can_cmd_stat
      40   put_can_ack
        40   -> __aeabi_memcpy
        40   -> xQueueGenericSend
      64   put_can_cmd_go
        64   -> __aeabi_memcpy
        64   -> xQueueGenericSend
       0   put_can_cmd_reset_all
      48   put_can_cmd_stat
        48   -> __aeabi_memcpy
        48   -> xQueueGenericSend


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
      16  ?_0
      12  ?_1
       8  _mc_reset
     104  obr_can_cmd
      82  put_can_ack
     188  put_can_cmd_go
       4  put_can_cmd_reset_all
      92  put_can_cmd_stat

 
  28 bytes in section .rodata
 498 bytes in section .text
 
 498 bytes of CODE  memory
  28 bytes of CONST memory

Errors: none
Warnings: none
