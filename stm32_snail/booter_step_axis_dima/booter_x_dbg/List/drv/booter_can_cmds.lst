###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         11/Mar/2023  15:47:52
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\booter_can_cmds.c
#    Command line                 =
#        -f
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\drv\booter_can_cmds.o.rsp
#        (D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\booter_can_cmds.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D DIMA_BRD -D STEP_X -D STM32F205xx
#        -D BOOTER -lcN
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\List\drv
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\drv
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\.\ -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\freertos\source\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\dbg\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\board\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\can\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\my_misc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\..\common\libraries\eeprom_emul\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\drv\booter_can_cmds.o.d
#    Locale                       =  C
#    List file                    =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\List\drv\booter_can_cmds.lst
#    Object file                  =
#        D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\booter_x_dbg\Obj\drv\booter_can_cmds.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

D:\proj\velograph\snail_w\stm32_snail\booter_step_axis_dima\src\booter_can_cmds.c
      1          #include <stdint.h>
      2          #include <string.h>
      3          #include <stdlib.h>
      4          
      5          #include "FreeRTOS.h"
      6          #include "task.h"
      7          #include "semphr.h"
      8          #include "queue.h"
      9          ////#include "my_grbl.h"
     10          #include "can.h"
     11          #include "can_cmds.h"
     12          #include "printk.h"
     13          #include "my_misc.h"
     14          ////=======================================
     15          extern xQueueHandle queu_to_send;
     16          
     17          int put_can_cmd_reset_all(void)
     18          {
     19            return 0;
     20          }
     21          
     22          void _mc_reset(void)
     23          {
     24          put_can_cmd_reset_all();  
     25          ////report_init_message();
     26          }
     27          int put_can_cmd_go(uint8_t dirs,uint16_t per
     28                             ,uint32_t step_x
     29                             ,uint32_t step_y
     30                             ,uint32_t step_z)
     31          {
     32          ///uint8_t btst=0;  
     33          can_msg_t  send_msg;
     34          go_cmd_t t_go_cmd;
     35          t_go_cmd.cmd=GO_CMD ;
     36          t_go_cmd.dirs=dirs;
     37          t_go_cmd.step_per=per;
     38          send_msg.len=CAN_MAX_NUM_BYTES;
     39          send_msg.format=STANDARD_FORMAT;
     40          send_msg.type=DATA_FRAME;
     41          if(step_x)
     42            {
     43             t_go_cmd.steps=step_x;
     44             memcpy(send_msg.data,&t_go_cmd,sizeof(go_cmd_t));
     45             send_msg.id=ID_X_CMD; 
     46             xQueueSend(queu_to_send,&send_msg,CAN_TIMEOUT_SEND);
     47            }
     48          if(step_y)
     49            {
     50             t_go_cmd.steps=step_y;
     51             memcpy(send_msg.data,&t_go_cmd,sizeof(go_cmd_t));
     52             send_msg.id=ID_Y_CMD; 
     53             xQueueSend(queu_to_send,&send_msg,CAN_TIMEOUT_SEND);
     54            }
     55          if(step_z)
     56            {
     57             t_go_cmd.steps=step_z;
     58             memcpy(send_msg.data,&t_go_cmd,sizeof(go_cmd_t));
     59             send_msg.id=ID_Z_CMD; 
     60             xQueueSend(queu_to_send,&send_msg,CAN_TIMEOUT_SEND);
     61            }
     62          
     63          ////send_msg.data[1]=btst;    
     64          ////xQueueSend(queu_to_send,&send_msg,CAN_TIMEOUT_SEND);
     65          
     66          ///go_cmd_t   go_cmd;
     67          #if 0        
     68                  printk("\n\r tst_cnt[%d][%02x][%d][%d][%d]", per, dirs
     69                      , step_x
     70                      , step_y
     71                      , step_z
     72                  );
     73          #endif
     74          
     75            return 0;
     76          }
     77          ////================================================
     78          #ifndef _MASTER_
     79          extern uint32_t cur_coord;
     80          extern uint8_t cur_stat;
     81          
     82          int put_can_cmd_stat(uint8_t state
     83                             ,uint32_t coord)
     84          {
     85          ///uint8_t btst=0;  
     86          can_msg_t  send_msg;
     87          put_stat_cmd_t t_put_stat_cmd;
     88          t_put_stat_cmd.cmd=PUT_STAT_CMD ;
     89          #if STEP_X
     90            t_put_stat_cmd.axis= AXIS_X;
     91          #elif STEP_Y
     92            t_put_stat_cmd.axis= AXIS_Y;
     93          #elif STEP_Z
     94            t_put_stat_cmd.axis= AXIS_Z;
     95          #else
     96            t_put_stat_cmd.axis= 0;
     97          #endif
     98          ////t_put_stat_cmd.coord=cur_coord;
     99          ///t_put_stat_cmd.state=cur_stat;
    100          t_put_stat_cmd.coord=coord;
    101          t_put_stat_cmd.state=state;
    102          send_msg.len=CAN_MAX_NUM_BYTES;
    103          send_msg.format=STANDARD_FORMAT;
    104          send_msg.type=DATA_FRAME;
    105          memcpy(send_msg.data,&t_put_stat_cmd,sizeof(put_stat_cmd_t));
    106          send_msg.id=ID_MASTER_CMD; 
    107          xQueueSend(queu_to_send,&send_msg,CAN_TIMEOUT_SEND);
    108          
    109            return 0;
    110          }
    111          int put_can_ack(uint8_t cmd )
    112          {
    113          ///uint8_t btst=0;  
    114          can_msg_t  send_msg;
    115          
    116          put_ack_t t_put_ack;
    117          
    118          t_put_ack.cmd=PUT_ACK ;
    119          #if STEP_X
    120            t_put_ack.ack.axis= AXIS_X;
    121          #elif STEP_Y
    122            t_put_ack..ack.axis= AXIS_Y;
    123          #elif STEP_Z
    124            t_put_ack..ack.axis= AXIS_Z;
    125          #else
    126            t_put_ack..ack.axis= 0;
    127          #endif
    128           t_put_ack.ack.ack_cmd=cmd;
    129          send_msg.len= sizeof(put_ack_t);
    130          send_msg.format=STANDARD_FORMAT;
    131          send_msg.type=DATA_FRAME;
    132          memcpy(send_msg.data,&t_put_ack,sizeof(put_ack_t));
    133          send_msg.id=ID_MASTER_CMD; 
    134          xQueueSend(queu_to_send,&send_msg,CAN_TIMEOUT_SEND);
    135          
    136            return 0;
    137          }
    138          
    139          
    140          #endif
    141          
    142          int obr_can_cmd(uint8_t *data)
    143          {
    144          switch(data[0]) {
    145            case GO_TO_APP:
    146              goto_app();
    147              break;
    148            case GO_TO_BOOTER:
    149              goto_booter();
    150              break;
    151            case ERASE_SECTORS:
    152              erase_sectors(data+1);
    153              break;
    154            case PRG_DAT:
    155              prg_dat(data);
    156              break;
    157             case GET_BOOT_STAT:
    158              put_can_cmd_stat(cur_stat,cur_coord);
    159              printk("[stat=%x] ",cur_stat);
    160              break;
    161                  
    162              default:
    163                break;
    164              }
    165          return 0;  
    166          }
    167          ////======================================================

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   _mc_reset
         8   -> put_can_cmd_reset_all
      16   obr_can_cmd
        16   -> _printk
        16   -> erase_sectors
        16   -> goto_app
        16   -> goto_booter
        16   -> prg_dat
        16   -> put_can_cmd_stat
      40   put_can_ack
        40   -> __aeabi_memcpy
        40   -> xQueueGenericSend
      64   put_can_cmd_go
        64   -> __aeabi_memcpy
        64   -> xQueueGenericSend
       0   put_can_cmd_reset_all
      48   put_can_cmd_stat
        48   -> __aeabi_memcpy
        48   -> xQueueGenericSend


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
      12  ?_0
       8  _mc_reset
      82  obr_can_cmd
      82  put_can_ack
     188  put_can_cmd_go
       4  put_can_cmd_reset_all
      92  put_can_cmd_stat

 
  12 bytes in section .rodata
 472 bytes in section .text
 
 472 bytes of CODE  memory
  12 bytes of CONST memory

Errors: none
Warnings: none
