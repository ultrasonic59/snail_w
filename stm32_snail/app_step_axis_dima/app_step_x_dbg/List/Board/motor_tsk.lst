###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         09/Mar/2023  13:21:47
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\src\motor_tsk.c
#    Command line      =
#        -f
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\app_step_x_dbg\Obj\Board\motor_tsk.o.rsp
#        (D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\src\motor_tsk.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D DIMA_BRD -D STEP_X -D STM32F205xx
#        -lcN
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\app_step_x_dbg\List\Board
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\app_step_x_dbg\Obj\Board
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\.\ -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\src\board\ -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\src\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\dbg\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\usb\drv\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\board\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\my_grbl\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\can\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\my_misc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\libraries\eeprom_emul\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\app_step_x_dbg\Obj\Board\motor_tsk.o.d
#    Locale            =  C
#    List file         =
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\app_step_x_dbg\List\Board\motor_tsk.lst
#    Object file       =
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\app_step_x_dbg\Obj\Board\motor_tsk.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\src\motor_tsk.c
      1          #include <string.h>
      2          #include "FreeRTOS.h"
      3          #include "queue.h"
      4          #include "semphr.h"
      5          
      6          ////#include "board.h"
      7          #include "board.h"
      8          #include "printk.h"
      9          
     10          #include "snail_can_cmds.h"
     11          #include "can.h"
     12          #include "can_cmds.h"
     13          
     14          cmd_t cur_cmd={0};
     15          void mot_spi_wr(uint8_t addr,uint16_t idata);
     16          uint16_t mot_spi_rd(uint8_t addr);
     17          void mot_spi_init(void);
     18          
     19          void motor_task( void *pvParameters )
     20          {
     21          ///uint8_t btst=0; 
     22          uint8_t psk=0; 
     23          ///uint16_t tst;
     24          char key=0;
     25          int nstep=300;
     26          uint8_t dir=0;
     27          uint8_t mot_rej=0;
     28          printk("\n\r motor_task"); 
     29          motor_init();
     30          
     31          #if 0
     32          set_sleep_mot(1);
     33          ////set_ena_mot(1);
     34          set_reset_mot(1);
     35          uDelay(1000);
     36          set_reset_mot(0);
     37          uDelay(20000);
     38          init_step_mot();
     39          ////set_ena_mot(0);
     40          ///tst=mot_spi_rd(0x0);
     41          ///tst|=0x1;
     42          ///mot_spi_wr(0x0,tst);
     43           ena_mot(0) ;
     44          #endif
     45           
     46          for(;;)
     47          {
     48          if(check_push_key_dbg())
     49            {
     50            key=get_byte_dbg() ;  
     51            switch(key)
     52              {
     53              case 'a':
     54                nstep += 20;
     55                break;
     56              case 's':
     57                if(nstep)
     58                  nstep-= 20;
     59                  break;
     60              case 'd':
     61                dir ++;
     62                dir&=0x1;
     63                break;
     64              case 'm':
     65                mot_rej ++;
     66                if(mot_rej>8)
     67                  mot_rej=0;
     68           ////     mot_rej&=0x7;
     69                break;
     70              case 'p':
     71               psk=1;
     72                break;
     73              case 'z':
     74               print_mot_reg();
     75                break;
     76              
     77             }
     78            printk("\n\r nstep[%d] dir[%x] Mot_rej[%x]",nstep,dir,mot_rej); 
     79            set_dir_mot(dir);
     80            set_mot_rej(mot_rej);
     81            if(psk)
     82              {
     83              put_mot_nstep(nstep);
     84              psk=0;
     85              }
     86            
     87            }  
     88          }
     89          }
     90          
     91          ///=============================================
     92          ////==============================================
     93          void mot_spi_init(void)
     94          {
     95          GPIO_InitTypeDef GPIO_InitStructure;
     96          SPI_InitTypeDef  SPI_InitStructure;
     97            MOT_SPI_PeriphClockCmd(MOT_SPI_RCC, ENABLE);
     98            
     99          RCC_AHB1PeriphClockCmd(MOT_SPI_SCK_PIN_RCC,ENABLE);
    100          RCC_AHB1PeriphClockCmd(MOT_SPI_MISO_PIN_RCC,ENABLE);
    101          RCC_AHB1PeriphClockCmd(MOT_SPI_MOSI_PIN_RCC,ENABLE);
    102          ////RCC_AHB1PeriphClockCmd(MOT_SPI_SCS_PIN_RCC,ENABLE);
    103          
    104          GPIO_PinAFConfig(MOT_SPI_SCK_PIN_GPIO, MOT_SPI_SCK_PIN_NPIN, MOT_SPI_AF);
    105          GPIO_PinAFConfig(MOT_SPI_MISO_PIN_GPIO, MOT_SPI_MISO_PIN_NPIN, MOT_SPI_AF);
    106          GPIO_PinAFConfig(MOT_SPI_MOSI_PIN_GPIO, MOT_SPI_MOSI_PIN_NPIN, MOT_SPI_AF);
    107          ////GPIO_PinAFConfig(MOT_SPI_SCS_PIN_GPIO, MOT_SPI_SCS_PIN_NPIN, MOT_SPI_AF);
    108          
    109          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    110          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    111          ////GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    112          ///GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
    113          GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
    114          GPIO_InitStructure.GPIO_Pin = MOT_SPI_MISO_PIN;
    115          GPIO_Init(MOT_SPI_MISO_PIN_GPIO, &GPIO_InitStructure);
    116          
    117          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    118          GPIO_InitStructure.GPIO_Pin = MOT_SPI_SCK_PIN;
    119          GPIO_Init(MOT_SPI_SCK_PIN_GPIO, &GPIO_InitStructure);
    120          ////GPIO_InitStructure.GPIO_Pin = MOT_SPI_MISO_PIN;
    121          /////GPIO_Init(MOT_SPI_MISO_PIN_GPIO, &GPIO_InitStructure);
    122          GPIO_InitStructure.GPIO_Pin = MOT_SPI_MOSI_PIN;
    123          GPIO_Init(MOT_SPI_MOSI_PIN_GPIO, &GPIO_InitStructure);
    124          
    125          ////GPIO_InitStructure.GPIO_Pin = MOT_SPI_SCS_PIN;
    126          /////GPIO_Init(MOT_SPI_SCS_PIN_GPIO, &GPIO_InitStructure);
    127          
    128          SPI_I2S_DeInit(MOT_SPI);
    129          SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
    130          SPI_InitStructure.SPI_DataSize = SPI_DataSize_16b;
    131          SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
    132          SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
    133          SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;///SPI_NSS_Hard;///SPI_NSS_Soft;///SPI_NSS_Hard;
    134          SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_64;
    135          SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
    136          SPI_InitStructure.SPI_CRCPolynomial = 7;
    137          SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
    138          SPI_Init(MOT_SPI, &SPI_InitStructure);
    139          SPI_Cmd(MOT_SPI, ENABLE);
    140          }
    141          uint16_t mot_spi_transfer(uint16_t i_data)
    142          {
    143          uint16_t rez=0; 
    144          GPIO_SetBits(MOT_SPI_SCS_PIN_GPIO, MOT_SPI_SCS_PIN);
    145          
    146          while (SPI_I2S_GetFlagStatus(MOT_SPI, SPI_I2S_FLAG_TXE) == RESET);
    147          SPI_I2S_SendData(MOT_SPI, i_data);
    148          while (SPI_I2S_GetFlagStatus(MOT_SPI, SPI_I2S_FLAG_RXNE) == RESET);
    149          while (SPI_I2S_GetFlagStatus(MOT_SPI, SPI_I2S_FLAG_TXE) == RESET);
    150          rez=SPI_I2S_ReceiveData(MOT_SPI);
    151          GPIO_ResetBits(MOT_SPI_SCS_PIN_GPIO, MOT_SPI_SCS_PIN);
    152          return rez;
    153          }
    154          ////==============================================
    155          void mot_spi_set_br(uint16_t br)
    156          {
    157          uint16_t tmpreg = 0;
    158          tmpreg = MOT_SPI->CR1& ~(0x7<<3);
    159          tmpreg |=	br&(0x7<<3);
    160          MOT_SPI->CR1=tmpreg;
    161          }
    162          
    163          void mot_spi_wr(uint8_t addr,uint16_t idata)
    164          {
    165          uint16_t tmp;
    166          tmp=(addr&0x7)<<12;
    167          tmp|= idata&0xfff;
    168          mot_spi_transfer(tmp);
    169          }
    170          void mot_spi_wrp(uint8_t addr,uint16_t *pdata)
    171          {
    172          uint16_t tmp;
    173          memcpy(&tmp,pdata,sizeof(uint16_t));
    174          mot_spi_wr(addr,tmp);       
    175          }
    176          uint16_t mot_spi_rd(uint8_t addr)
    177          {
    178          uint16_t rez;
    179          uint16_t tmp;
    180          tmp=(addr&0x7)<<12;
    181          tmp|= 0x8000;
    182          rez=mot_spi_transfer(tmp);
    183          return rez&0xfff;
    184          }
    185          ////========================================================  
    186          
    187          CTRL_Register_t 	G_CTRL_REG;
    188          TORQUE_Register_t 	G_TORQUE_REG;
    189           OFF_Register_t 	G_OFF_REG;
    190          BLANK_Register_t	G_BLANK_REG;
    191          DECAY_Register_t 	G_DECAY_REG;
    192          STALL_Register_t 	G_STALL_REG;
    193          DRIVE_Register_t 	G_DRIVE_REG;
    194          STATUS_Register_t 	G_STATUS_REG;
    195          
    196          void init_step_mot(void)
    197          {
    198            
    199          // CTRL Register
    200          
    201          G_CTRL_REG.DTIME 	= 0;///0x03;
    202          G_CTRL_REG.ISGAIN 	= 0;///0x03;
    203          G_CTRL_REG.EXSTALL 	= 0x00;
    204          G_CTRL_REG.MODE 	= 0;///0x03;
    205          G_CTRL_REG.RSTEP 	= 0x00;
    206          G_CTRL_REG.RDIR 	= 0x00;
    207          G_CTRL_REG.ENBL 	= 0x01;
    208          
    209          // TORQUE Register
    210          G_TORQUE_REG.SIMPLTH = 0x00;
    211          G_TORQUE_REG.TORQUE  = 0xBA;
    212          
    213          // OFF Register
    214          G_OFF_REG.PWMMODE 	= 0x00;
    215          G_OFF_REG.TOFF 		= 0x30;
    216          
    217          // BLANK Register
    218          G_BLANK_REG.ABT 	= 0x01;
    219          G_BLANK_REG.TBLANK 	= 0x08;
    220          
    221          // DECAY Register.
    222          G_DECAY_REG.DECMOD  = 0x03;
    223          G_DECAY_REG.TDECAY 	= 0x10;
    224          
    225          // STALL Register
    226          G_STALL_REG.VDIV 	= 0x03;
    227          G_STALL_REG.SDCNT 	= 0x03;
    228          G_STALL_REG.SDTHR 	= 0x40;
    229          
    230          // DRIVE Register
    231          G_DRIVE_REG.OCPTH 	= 0x01;
    232          G_DRIVE_REG.IDRIVEP = 0x00;
    233          G_DRIVE_REG.IDRIVEN = 0x00;
    234          G_DRIVE_REG.TDRIVEP = 0x01;
    235          G_DRIVE_REG.TDRIVEN = 0x01;
    236          G_DRIVE_REG.OCPDEG 	= 0x01;
    237          
    238          mot_spi_wrp(ADDR_MOT_CTRL,(uint16_t*)&G_CTRL_REG);
    239          mot_spi_wrp(ADDR_MOT_TORQUE,(uint16_t*)&G_TORQUE_REG);
    240          mot_spi_wrp(ADDR_MOT_OFF,(uint16_t*)&G_OFF_REG);
    241          mot_spi_wrp(ADDR_MOT_BLANK,(uint16_t*)&G_BLANK_REG);
    242          mot_spi_wrp(ADDR_MOT_DECAY,(uint16_t*)&G_DECAY_REG);
    243          mot_spi_wrp(ADDR_MOT_STALL,(uint16_t*)&G_STALL_REG);
    244          mot_spi_wrp(ADDR_MOT_DRIVE,(uint16_t*)&G_DRIVE_REG);
    245          mot_spi_wr(ADDR_MOT_STATUS,0);       
    246          
    247          }
    248          ////========================================================  
    249          void set_mot_rej(uint8_t rej)
    250          {
    251          uint16_t tmp;
    252          CTRL_Register_t *t_ctrl_reg=(CTRL_Register_t*)&tmp;
    253          tmp=mot_spi_rd(ADDR_MOT_CTRL);
    254          
    255          t_ctrl_reg->MODE=rej;
    256          mot_spi_wr(ADDR_MOT_CTRL,tmp);
    257          
    258          tmp=mot_spi_rd(ADDR_MOT_CTRL);
    259          }
    260          
    261          
    262          void print_mot_reg(void)
    263          {
    264          uint16_t tmp;
    265          tmp=mot_spi_rd(ADDR_MOT_CTRL);
    266          printk("\n\r CTRL[%x]",tmp);
    267          
    268          tmp=mot_spi_rd(ADDR_MOT_TORQUE);
    269          printk("\n\r TORQUE[%x]",tmp);
    270          tmp=mot_spi_rd(ADDR_MOT_OFF);
    271          printk("\n\r OFF[%x]",tmp);
    272          tmp=mot_spi_rd(ADDR_MOT_BLANK);
    273          printk("\n\r BLANK[%x]",tmp);
    274          tmp=mot_spi_rd(ADDR_MOT_STALL);
    275          printk("\n\r STALL[%x]",tmp);
    276          tmp=mot_spi_rd(ADDR_MOT_DRIVE);
    277          printk("\n\r DRIVE[%x]",tmp);
    278          tmp=mot_spi_rd(ADDR_MOT_STATUS);
    279          printk("\n\r STATUS[%x]",tmp);
    280          
    281          }
    282          ////extern CanRxMsg RxMessage;
    283          void reset_mot_step(void)
    284          {
    285            
    286          }
    287          ////void put_mot_nstep(uint32_t nstep)
    288          
    289          void set_mot_per(uint16_t per)
    290          {
    291          if(per>MAX_PER)
    292            per=MAX_PER;
    293          else if(per<MIN_PER)
    294            per=MIN_PER;
    295          MOT_STEP_TIM ->ARR = per*2;////
    296          MOT_STEP_TIM ->CCR1 = per;////
    297          }
    298          
    299          ////=======================================================
    300          void stop_mot_step_tim(void)
    301          {
    302          TIM_Cmd(MOT_STEP_TIM, DISABLE);
    303          
    304          }
    305          volatile uint32_t num_step=0;
    306          void  set_dir_mot(uint8_t idat)
    307          {
    308          uint8_t tdat=0;
    309          #if STEP_X
    310            tdat=idat&DIR_X;
    311          #elif STEP_Y
    312            tdat=idat&DIR_Y;
    313          #elif STEP_Z
    314            tdat=idat&DIR_Z;
    315          #endif
    316          if(tdat)
    317            {
    318            GPIO_SetBits(MOT_DIR_PIN_GPIO, MOT_DIR_PIN);
    319            }
    320          else
    321            {
    322             GPIO_ResetBits(MOT_DIR_PIN_GPIO, MOT_DIR_PIN);
    323            }
    324          }
    325          void  set_reset_mot(uint8_t idat)
    326          {
    327          if(idat&0x1)
    328            {
    329            GPIO_SetBits(MOT_RESET_PIN_GPIO, MOT_RESET_PIN);
    330            }
    331          else
    332            {
    333             GPIO_ResetBits(MOT_RESET_PIN_GPIO, MOT_RESET_PIN);
    334            }
    335          }
    336          
    337          void  set_sleep_mot(uint8_t idat)
    338          {
    339          if(idat&0x1)
    340            {
    341            GPIO_SetBits(MOT_SLEEP_PIN_GPIO, MOT_SLEEP_PIN);
    342            }
    343          else
    344            {
    345             GPIO_ResetBits(MOT_SLEEP_PIN_GPIO, MOT_SLEEP_PIN);
    346            }
    347          }
    348          ////==================================================
    349          
    350          
    351          
    352          void mot_step_tim_init(void)
    353          {
    354          NVIC_InitTypeDef NVIC_InitStructure; 
    355          
    356          RCC->APB2ENR |= MOT_STEP_TIM_RCC;
    357          MOT_STEP_TIM ->PSC = DEF_MOT_TIM_PRESC;
    358          MOT_STEP_TIM ->ARR = DEF_MOT_TIM_PERIOD;////
    359          MOT_STEP_TIM ->CCR1 = DEF_MOT_TIM_PERIOD/2;////30;
    360          MOT_STEP_TIM->CCER |= TIM_CCER_CC1E;////TIM_CCER_CC2NE;////| TIM_CCER_CC3NP;
    361          MOT_STEP_TIM->BDTR |= TIM_BDTR_MOE;
    362          MOT_STEP_TIM->CCMR1 = TIM_CCMR1_OC1M_0 | TIM_CCMR1_OC1M_1; 
    363          MOT_STEP_TIM->CR1 &= ~TIM_CR1_DIR;
    364          MOT_STEP_TIM->CR1 &= ~TIM_CR1_CMS;
    365          
    366          MOT_STEP_TIM ->DIER = TIM_DIER_CC1IE;
    367          TIM_ClearITPendingBit(MOT_STEP_TIM, TIM_IT_CC1);
    368          
    369          NVIC_InitStructure.NVIC_IRQChannel = MOT_TIM_IRQN;
    370          //// highest priority
    371          NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;
    372          
    373          NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    374          //// highest priority
    375          NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    376          NVIC_Init(&NVIC_InitStructure);
    377          
    378          }
    379          
    380          ///===========================================================
    381          void ena_mot(uint8_t ena_dis)
    382          {
    383          uint16_t tmp;
    384          ////return ; 
    385          tmp=mot_spi_rd(ADDR_MOT_CTRL);
    386          if(ena_dis&0x1)
    387          {
    388          tmp|=0x1;
    389          }
    390          else
    391          {
    392          tmp&= ~0x1;
    393          }
    394          mot_spi_wr(ADDR_MOT_CTRL,tmp);
    395          }
    396          
    397          void put_mot_nstep(uint32_t nstep)
    398          {
    399          ena_mot(1) ;
    400          num_step=nstep; 
    401          TIM_ITConfig(MOT_STEP_TIM, TIM_IT_CC1, ENABLE);
    402          TIM_Cmd(MOT_STEP_TIM, ENABLE);
    403          }
    404          
    405          void MOT_STEP_TIM_IRQHandler(void)
    406          { 
    407          if(num_step)
    408            {
    409            num_step--;  
    410            if(num_step==0)
    411              {
    412              stop_mot_step_tim(); 
    413              cur_stat=STATE_READY;  
    414          
    415              ena_mot(0) ;
    416              }
    417            }
    418          ////TIM_ClearITPendingBit(MOT_STEP_TIM, TIM_IT_CC2);
    419          TIM_ClearITPendingBit(MOT_STEP_TIM, TIM_IT_CC1);
    420          }
    421          
    422          ///=============================================
    423          void motor_init(void)
    424          {
    425          mot_step_tim_init();
    426          mot_spi_init();
    427          
    428          set_sleep_mot(1);
    429          ////set_ena_mot(1);
    430          set_reset_mot(1);
    431          uDelay(1000);
    432          set_reset_mot(0);
    433          uDelay(20000);
    434          init_step_mot();
    435          ena_mot(0) ;
    436          set_mot_rej(DEF_MOT_REJ);
    437            
    438          }
    439          ///==============================================

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   TIM1_CC_IRQHandler
         8   -> TIM_ClearITPendingBit
         8   -> ena_mot
         8   -> stop_mot_step_tim
      16   ena_mot
        16   -> mot_spi_rd
        16   -> mot_spi_wr
      32   init_step_mot
        32   -> mot_spi_wr
        32   -> mot_spi_wrp
      40   mot_spi_init
        40   -> GPIO_Init
        40   -> GPIO_PinAFConfig
        40   -> RCC_AHB1PeriphClockCmd
        40   -> RCC_APB1PeriphClockCmd
        40   -> SPI_Cmd
        40   -> SPI_I2S_DeInit
        40   -> SPI_Init
      16   mot_spi_rd
        16   -> mot_spi_transfer
       4   mot_spi_set_br
      24   mot_spi_transfer
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> SPI_I2S_GetFlagStatus
        24   -> SPI_I2S_ReceiveData
        24   -> SPI_I2S_SendData
      16   mot_spi_wr
        16   -> mot_spi_transfer
      32   mot_spi_wrp
        32   -> __aeabi_memcpy
        32   -> mot_spi_wr
       8   mot_step_tim_init
         8   -> NVIC_Init
         8   -> TIM_ClearITPendingBit
       8   motor_init
         8   -> ena_mot
         8   -> init_step_mot
         8   -> mot_spi_init
         8   -> mot_step_tim_init
         8   -> set_mot_rej
         8   -> set_reset_mot
         8   -> set_sleep_mot
         8   -> uDelay
      32   motor_task
        32   -> _printk
        32   -> check_push_key_dbg
        32   -> get_byte_dbg
        32   -> motor_init
        32   -> print_mot_reg
        32   -> put_mot_nstep
        32   -> set_dir_mot
        32   -> set_mot_rej
      32   print_mot_reg
        32   -> _printk
        32   -> mot_spi_rd
      16   put_mot_nstep
        16   -> TIM_Cmd
        16   -> TIM_ITConfig
        16   -> ena_mot
       0   reset_mot_step
      16   set_dir_mot
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
       0   set_mot_per
      16   set_mot_rej
        16   -> mot_spi_rd
        16   -> mot_spi_wr
       8   set_reset_mot
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
       8   set_sleep_mot
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
       8   stop_mot_step_tim
         8   -> TIM_Cmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_17
       4  ??DataTable13_18
       4  ??DataTable13_19
       4  ??DataTable13_2
       4  ??DataTable13_20
       4  ??DataTable13_21
       4  ??DataTable13_22
       4  ??DataTable13_23
       4  ??DataTable13_24
       4  ??DataTable13_25
       4  ??DataTable13_26
       4  ??DataTable13_27
       4  ??DataTable13_28
       4  ??DataTable13_29
       4  ??DataTable13_3
       4  ??DataTable13_30
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
      16  ?_0
      36  ?_1
      12  ?_2
      16  ?_3
      12  ?_4
      16  ?_5
      16  ?_6
      16  ?_7
      16  ?_8
       2  G_BLANK_REG
       2  G_CTRL_REG
       2  G_DECAY_REG
       2  G_DRIVE_REG
       2  G_OFF_REG
       2  G_STALL_REG
       2  G_STATUS_REG
       2  G_TORQUE_REG
      48  TIM1_CC_IRQHandler
       8  cur_cmd
      40  ena_mot
     366  init_step_mot
     228  mot_spi_init
      32  mot_spi_rd
      28  mot_spi_set_br
      94  mot_spi_transfer
      32  mot_spi_wr
      40  mot_spi_wrp
     124  mot_step_tim_init
      62  motor_init
     182  motor_task
       4  num_step
     134  print_mot_reg
      36  put_mot_nstep
       2  reset_mot_step
      42  set_dir_mot
      56  set_mot_per
      46  set_mot_rej
      32  set_reset_mot
      32  set_sleep_mot
      12  stop_mot_step_tim

 
    28 bytes in section .bss
   156 bytes in section .rodata
 1'792 bytes in section .text
 
 1'792 bytes of CODE  memory
   156 bytes of CONST memory
    28 bytes of DATA  memory

Errors: none
Warnings: none
