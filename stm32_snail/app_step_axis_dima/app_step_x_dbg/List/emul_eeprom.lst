###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         09/Mar/2023  13:21:47
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\proj\velograph\snail_w\stm32_snail\common\libraries\eeprom_emul\emul_eeprom.c
#    Command line      =
#        -f
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\app_step_x_dbg\Obj\emul_eeprom.o.rsp
#        (D:\proj\velograph\snail_w\stm32_snail\common\libraries\eeprom_emul\emul_eeprom.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D DIMA_BRD -D STEP_X -D STM32F205xx
#        -lcN
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\app_step_x_dbg\List\
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\app_step_x_dbg\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\.\ -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\src\board\ -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\src\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\dbg\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\usb\drv\inc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\board\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\my_grbl\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\can\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\my_misc\
#        -I
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\..\common\libraries\eeprom_emul\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\app_step_x_dbg\Obj\emul_eeprom.o.d
#    Locale            =  C
#    List file         =
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\app_step_x_dbg\List\emul_eeprom.lst
#    Object file       =
#        D:\proj\velograph\snail_w\stm32_snail\app_step_axis_dima\app_step_x_dbg\Obj\emul_eeprom.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\proj\velograph\snail_w\stm32_snail\common\libraries\eeprom_emul\emul_eeprom.c
      1          /**
      2            ******************************************************************************
      3            * @file    EEPROM_Emulation/src/eeprom.c 
      4            * @author  MCD Application Team
      5            * @version V3.1.0
      6            * @date    07/27/2009
      7            * @brief   This file provides all the EEPROM emulation firmware functions.
      8            ******************************************************************************
      9            * @copy
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2009 STMicroelectronics</center></h2>
     19            */ 
     20          /** @addtogroup EEPROM_Emulation
     21            * @{
     22            */ 
     23          
     24          /* Includes ------------------------------------------------------------------*/
     25          #include "emul_eeprom.h"
     26          
     27          
     28          /* Global variable used to store variable value in read sequence */
     29          uint16_t DataVar = 0;
     30          
     31          /* Virtual address defined by the user: 0xFFFF value is prohibited */
     32          ////extern uint16_t VirtAddVarTab[NumbOfVar];
     33          //// uint16_t VirtAddVarTab[NumbOfVar] = {0x5555, 0x6666, 0x7777};
     34          
     35          /* Private function prototypes -----------------------------------------------*/
     36          /* Private functions ---------------------------------------------------------*/
     37          static FLASH_Status EE_Format(void);
     38          static uint16_t EE_FindValidPage(uint8_t Operation);
     39          static uint16_t EE_VerifyPageFullWriteVariable(uint16_t VirtAddress, uint16_t Data);
     40          static uint16_t EE_PageTransfer(uint16_t VirtAddress, uint16_t Data);
     41          
     42          /**
     43            * @brief  Restore the pages to a known good state in case of page's status
     44            *   corruption after a power loss.
     45            * @param  None.
     46            * @retval - Flash error code: on write Flash error
     47            *         - FLASH_COMPLETE: on success
     48            */
     49          
     50          uint16_t EE_Init(void)
     51          {
     52            uint16_t PageStatus0 = 6, PageStatus1 = 6;
     53            uint16_t VarIdx = 0;
     54            uint16_t EepromStatus = 0, ReadStatus = 0;
     55            int16_t x = -1;
     56            uint16_t  FlashStatus;
     57          
     58            /* Get Page0 status */
     59            PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
     60            /* Get Page1 status */
     61            PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
     62          
     63            /* Check for invalid header states and repair if necessary */
     64            switch (PageStatus0)
     65            {
     66              case ERASED:
     67                if (PageStatus1 == VALID_PAGE) /* Page0 erased, Page1 valid */
     68                {
     69                  /* Erase Page0 */
     70                  FlashStatus = FLASH_EraseSector(PAGE0_BASE_ADDRESS,VoltageRange_3);
     71                  /* If erase operation was failed, a Flash error code is returned */
     72                  if (FlashStatus != FLASH_COMPLETE)
     73                  {
     74                    return FlashStatus;
     75                  }
     76                }
     77                else if (PageStatus1 == RECEIVE_DATA) /* Page0 erased, Page1 receive */
     78                {
     79                  /* Erase Page0 */
     80                  FlashStatus = FLASH_EraseSector(PAGE0_BASE_ADDRESS,VoltageRange_3);
     81                  /* If erase operation was failed, a Flash error code is returned */
     82                  if (FlashStatus != FLASH_COMPLETE)
     83                  {
     84                    return FlashStatus;
     85                  }
     86                  /* Mark Page1 as valid */
     87                  FlashStatus = FLASH_ProgramHalfWord(PAGE1_BASE_ADDRESS, VALID_PAGE);
     88                  /* If program operation was failed, a Flash error code is returned */
     89                  if (FlashStatus != FLASH_COMPLETE)
     90                  {
     91                    return FlashStatus;
     92                  }
     93                }
     94                else /* First EEPROM access (Page0&1 are erased) or invalid state -> format EEPROM */
     95                {
     96                  /* Erase both Page0 and Page1 and set Page0 as valid page */
     97                  FlashStatus = EE_Format();
     98                  /* If erase/program operation was failed, a Flash error code is returned */
     99                  if (FlashStatus != FLASH_COMPLETE)
    100                  {
    101                    return FlashStatus;
    102                  }
    103                }
    104                break;
    105          
    106              case RECEIVE_DATA:
    107                if (PageStatus1 == VALID_PAGE) /* Page0 receive, Page1 valid */
    108                {
    109                  /* Transfer data from Page1 to Page0 */
    110                  for (VarIdx = 0; VarIdx < MAX_EEPROM_ADDRESS; VarIdx++)
    111                  {
    112                    if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VarIdx)
    113                    {
    114                      x = VarIdx;
    115                    }
    116                    if (VarIdx != x)
    117                    {
    118                      /* Read the last variables' updates */
    119                      ReadStatus = EE_ReadVariable(VarIdx, &DataVar);
    120                      /* In case variable corresponding to the virtual address was found */
    121                      if (ReadStatus != 0x1)
    122                      {
    123                        /* Transfer the variable to the Page0 */
    124                        EepromStatus = EE_VerifyPageFullWriteVariable(VarIdx, DataVar);
    125                        /* If program operation was failed, a Flash error code is returned */
    126                        if (EepromStatus != FLASH_COMPLETE)
    127                        {
    128                          return EepromStatus;
    129                        }
    130                      }
    131                    }
    132                  }
    133                  /* Mark Page0 as valid */
    134                  FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);
    135                  /* If program operation was failed, a Flash error code is returned */
    136                  if (FlashStatus != FLASH_COMPLETE)
    137                  {
    138                    return FlashStatus;
    139                  }
    140                  /* Erase Page1 */
    141                  FlashStatus = FLASH_EraseSector(PAGE1_BASE_ADDRESS,VoltageRange_3);
    142                  /* If erase operation was failed, a Flash error code is returned */
    143                  if (FlashStatus != FLASH_COMPLETE)
    144                  {
    145                    return FlashStatus;
    146                  }
    147                }
    148                else if (PageStatus1 == ERASED) /* Page0 receive, Page1 erased */
    149                {
    150                  /* Erase Page1 */
    151                  FlashStatus = FLASH_EraseSector(PAGE1_BASE_ADDRESS,VoltageRange_3);
    152                  /* If erase operation was failed, a Flash error code is returned */
    153                  if (FlashStatus != FLASH_COMPLETE)
    154                  {
    155                    return FlashStatus;
    156                  }
    157                  /* Mark Page0 as valid */
    158                  FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);
    159                  /* If program operation was failed, a Flash error code is returned */
    160                  if (FlashStatus != FLASH_COMPLETE)
    161                  {
    162                    return FlashStatus;
    163                  }
    164                }
    165                else /* Invalid state -> format eeprom */
    166                {
    167                  /* Erase both Page0 and Page1 and set Page0 as valid page */
    168                  FlashStatus = EE_Format();
    169                  /* If erase/program operation was failed, a Flash error code is returned */
    170                  if (FlashStatus != FLASH_COMPLETE)
    171                  {
    172                    return FlashStatus;
    173                  }
    174                }
    175                break;
    176          
    177              case VALID_PAGE:
    178                if (PageStatus1 == VALID_PAGE) /* Invalid state -> format eeprom */
    179                {
    180                  /* Erase both Page0 and Page1 and set Page0 as valid page */
    181                  FlashStatus = EE_Format();
    182                  /* If erase/program operation was failed, a Flash error code is returned */
    183                  if (FlashStatus != FLASH_COMPLETE)
    184                  {
    185                    return FlashStatus;
    186                  }
    187                }
    188                else if (PageStatus1 == ERASED) /* Page0 valid, Page1 erased */
    189                {
    190                  /* Erase Page1 */
    191                  FlashStatus = FLASH_EraseSector(PAGE1_BASE_ADDRESS,VoltageRange_3);
    192                  /* If erase operation was failed, a Flash error code is returned */
    193                  if (FlashStatus != FLASH_COMPLETE)
    194                  {
    195                    return FlashStatus;
    196                  }
    197                }
    198                else /* Page0 valid, Page1 receive */
    199                {
    200                  /* Transfer data from Page0 to Page1 */
    201                  for (VarIdx = 0; VarIdx < MAX_EEPROM_ADDRESS; VarIdx++)
    202                  {
    203                    if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VarIdx)
    204                    {
    205                      x = VarIdx;
    206                    }
    207                    if (VarIdx != x)
    208                    {
    209                      /* Read the last variables' updates */
    210                      ReadStatus = EE_ReadVariable(VarIdx, &DataVar);
    211                      /* In case variable corresponding to the virtual address was found */
    212                      if (ReadStatus != 0x1)
    213                      {
    214                        /* Transfer the variable to the Page1 */
    215                        EepromStatus = EE_VerifyPageFullWriteVariable(VarIdx, DataVar);
    216                        /* If program operation was failed, a Flash error code is returned */
    217                        if (EepromStatus != FLASH_COMPLETE)
    218                        {
    219                          return EepromStatus;
    220                        }
    221                      }
    222                    }
    223                  }
    224                  /* Mark Page1 as valid */
    225                  FlashStatus = FLASH_ProgramHalfWord(PAGE1_BASE_ADDRESS, VALID_PAGE);
    226                  /* If program operation was failed, a Flash error code is returned */
    227                  if (FlashStatus != FLASH_COMPLETE)
    228                  {
    229                    return FlashStatus;
    230                  }
    231                  /* Erase Page0 */
    232                  FlashStatus = FLASH_EraseSector(PAGE0_BASE_ADDRESS,VoltageRange_3);
    233                  /* If erase operation was failed, a Flash error code is returned */
    234                  if (FlashStatus != FLASH_COMPLETE)
    235                  {
    236                    return FlashStatus;
    237                  }
    238                }
    239                break;
    240          
    241              default:  /* Any other state -> format eeprom */
    242                /* Erase both Page0 and Page1 and set Page0 as valid page */
    243                FlashStatus = EE_Format();
    244                /* If erase/program operation was failed, a Flash error code is returned */
    245                if (FlashStatus != FLASH_COMPLETE)
    246                {
    247                  return FlashStatus;
    248                }
    249                break;
    250            }
    251          
    252            return FLASH_COMPLETE;
    253          }
    254          
    255          /**
    256            * @brief  Returns the last stored variable data, if found, which correspond to
    257            *   the passed virtual address
    258            * @param  VirtAddress: Variable virtual address
    259            * @param  Data: Global variable contains the read variable value
    260            * @retval Success or error status:
    261            *           - 0: if variable was found
    262            *           - 1: if the variable was not found
    263            *           - NO_VALID_PAGE: if no valid page was found.
    264            */
    265          uint16_t EE_ReadVariable(uint16_t VirtAddress, uint16_t* Data)
    266          {
    267            uint16_t ValidPage = PAGE0;
    268            uint16_t AddressValue = 0x5555, ReadStatus = 1;
    269            uint32_t Address = 0x08010000, PageStartAddress = 0x08010000;
    270          
    271            /* Get active Page for read operation */
    272            ValidPage = EE_FindValidPage(READ_FROM_VALID_PAGE);
    273          
    274            /* Check if there is no valid page */
    275            if (ValidPage == NO_VALID_PAGE)
    276            {
    277              return  NO_VALID_PAGE;
    278            }
    279          
    280            /* Get the valid Page start Address */
    281            PageStartAddress = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * EEPROM_PAGE_SIZE));
    282          
    283            /* Get the valid Page end Address */
    284            Address = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((1 + ValidPage) * EEPROM_PAGE_SIZE));
    285          
    286            /* Check each active page address starting from end */
    287            while (Address > (PageStartAddress + 2))
    288            {
    289              /* Get the current location content to be compared with virtual address */
    290              AddressValue = (*(__IO uint16_t*)Address);
    291          
    292              /* Compare the read address with the virtual address */
    293              if (AddressValue == VirtAddress)
    294              {
    295                /* Get content of Address-2 which is variable value */
    296                *Data = (*(__IO uint16_t*)(Address - 2));
    297          
    298                /* In case variable value is read, reset ReadStatus flag */
    299                ReadStatus = 0;
    300          
    301                break;
    302              }
    303              else
    304              {
    305                /* Next address location */
    306                Address = Address - 4;
    307              }
    308            }
    309          
    310            /* Return ReadStatus value: (0: variable exist, 1: variable doesn't exist) */
    311            return ReadStatus;
    312          }
    313          
    314          /**
    315            * @brief  Writes/upadtes variable data in EEPROM.
    316            * @param  VirtAddress: Variable virtual address
    317            * @param  Data: 16 bit data to be written
    318            * @retval Success or error status:
    319            *           - FLASH_COMPLETE: on success
    320            *           - PAGE_FULL: if valid page is full
    321            *           - NO_VALID_PAGE: if no valid page was found
    322            *           - Flash error code: on write Flash error
    323            */
    324          uint16_t EE_WriteVariable(uint16_t VirtAddress, uint16_t Data)
    325          {
    326            uint16_t Status = 0;
    327          
    328            /* Write the variable virtual address and value in the EEPROM */
    329            Status = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
    330          
    331            /* In case the EEPROM active page is full */
    332            if (Status == PAGE_FULL)
    333            {
    334              /* Perform Page transfer */
    335              Status = EE_PageTransfer(VirtAddress, Data);
    336            }
    337          
    338            /* Return last operation status */
    339            return Status;
    340          }
    341          
    342          /**
    343            * @brief  Erases PAGE0 and PAGE1 and writes VALID_PAGE header to PAGE0
    344            * @param  None
    345            * @retval Status of the last operation (Flash write or erase) done during
    346            *         EEPROM formating
    347            */
    348          static FLASH_Status EE_Format(void)
    349          {
    350            FLASH_Status FlashStatus = FLASH_COMPLETE;
    351          
    352            /* Erase Page0 */
    353            FlashStatus = FLASH_EraseSector(PAGE0_BASE_ADDRESS,VoltageRange_3);
    354          
    355            /* If erase operation was failed, a Flash error code is returned */
    356            if (FlashStatus != FLASH_COMPLETE)
    357            {
    358              return FlashStatus;
    359            }
    360          
    361            /* Set Page0 as valid page: Write VALID_PAGE at Page0 base address */
    362            FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);
    363          
    364            /* If program operation was failed, a Flash error code is returned */
    365            if (FlashStatus != FLASH_COMPLETE)
    366            {
    367              return FlashStatus;
    368            }
    369          
    370            /* Erase Page1 */
    371            FlashStatus = FLASH_EraseSector(PAGE1_BASE_ADDRESS,VoltageRange_3);
    372          
    373            /* Return Page1 erase operation status */
    374            return FlashStatus;
    375          }
    376          
    377          /**
    378            * @brief  Find valid Page for write or read operation
    379            * @param  Operation: operation to achieve on the valid page.
    380            *   This parameter can be one of the following values:
    381            *     @arg READ_FROM_VALID_PAGE: read operation from valid page
    382            *     @arg WRITE_IN_VALID_PAGE: write operation from valid page
    383            * @retval Valid page number (PAGE0 or PAGE1) or NO_VALID_PAGE in case
    384            *   of no valid page was found
    385            */
    386          static uint16_t EE_FindValidPage(uint8_t Operation)
    387          {
    388            uint16_t PageStatus0 = 6, PageStatus1 = 6;
    389          
    390            /* Get Page0 actual status */
    391            PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
    392          
    393            /* Get Page1 actual status */
    394            PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
    395          
    396            /* Write or read operation */
    397            switch (Operation)
    398            {
    399              case WRITE_IN_VALID_PAGE:   /* ---- Write operation ---- */
    400                if (PageStatus1 == VALID_PAGE)
    401                {
    402                  /* Page0 receiving data */
    403                  if (PageStatus0 == RECEIVE_DATA)
    404                  {
    405                    return PAGE0;         /* Page0 valid */
    406                  }
    407                  else
    408                  {
    409                    return PAGE1;         /* Page1 valid */
    410                  }
    411                }
    412                else if (PageStatus0 == VALID_PAGE)
    413                {
    414                  /* Page1 receiving data */
    415                  if (PageStatus1 == RECEIVE_DATA)
    416                  {
    417                    return PAGE1;         /* Page1 valid */
    418                  }
    419                  else
    420                  {
    421                    return PAGE0;         /* Page0 valid */
    422                  }
    423                }
    424                else
    425                {
    426                  return NO_VALID_PAGE;   /* No valid Page */
    427                }
    428          
    429              case READ_FROM_VALID_PAGE:  /* ---- Read operation ---- */
    430                if (PageStatus0 == VALID_PAGE)
    431                {
    432                  return PAGE0;           /* Page0 valid */
    433                }
    434                else if (PageStatus1 == VALID_PAGE)
    435                {
    436                  return PAGE1;           /* Page1 valid */
    437                }
    438                else
    439                {
    440                  return NO_VALID_PAGE ;  /* No valid Page */
    441                }
    442          
    443              default:
    444                return PAGE0;             /* Page0 valid */
    445            }
    446          }
    447          
    448          /**
    449            * @brief  Verify if active page is full and Writes variable in EEPROM.
    450            * @param  VirtAddress: 16 bit virtual address of the variable
    451            * @param  Data: 16 bit data to be written as variable value
    452            * @retval Success or error status:
    453            *           - FLASH_COMPLETE: on success
    454            *           - PAGE_FULL: if valid page is full
    455            *           - NO_VALID_PAGE: if no valid page was found
    456            *           - Flash error code: on write Flash error
    457            */
    458          static uint16_t EE_VerifyPageFullWriteVariable(uint16_t VirtAddress, uint16_t Data)
    459          {
    460            FLASH_Status FlashStatus = FLASH_COMPLETE;
    461            uint16_t ValidPage = PAGE0;
    462            uint32_t Address = 0x08010000, PageEndAddress = 0x080107FF;
    463          
    464            /* Get valid Page for write operation */
    465            ValidPage = EE_FindValidPage(WRITE_IN_VALID_PAGE);
    466          
    467            /* Check if there is no valid page */
    468            if (ValidPage == NO_VALID_PAGE)
    469            {
    470              return  NO_VALID_PAGE;
    471            }
    472          
    473            /* Get the valid Page start Address */
    474            Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * EEPROM_PAGE_SIZE));
    475          
    476            /* Get the valid Page end Address */
    477            PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((1 + ValidPage) * EEPROM_PAGE_SIZE));
    478          
    479            /* Check each active page address starting from begining */
    480            while (Address < PageEndAddress)
    481            {
    482              /* Verify if Address and Address+2 contents are 0xFFFFFFFF */
    483              if ((*(__IO uint32_t*)Address) == 0xFFFFFFFF)
    484              {
    485                /* Set variable data */
    486                FlashStatus = FLASH_ProgramHalfWord(Address, Data);
    487                /* If program operation was failed, a Flash error code is returned */
    488                if (FlashStatus != FLASH_COMPLETE)
    489                {
    490                  return FlashStatus;
    491                }
    492                /* Set variable virtual address */
    493                FlashStatus = FLASH_ProgramHalfWord(Address + 2, VirtAddress);
    494                /* Return program operation status */
    495                return FlashStatus;
    496              }
    497              else
    498              {
    499                /* Next address location */
    500                Address = Address + 4;
    501              }
    502            }
    503          
    504            /* Return PAGE_FULL in case the valid page is full */
    505            return PAGE_FULL;
    506          }
    507          
    508          /**
    509            * @brief  Transfers last updated variables data from the full Page to
    510            *   an empty one.
    511            * @param  VirtAddress: 16 bit virtual address of the variable
    512            * @param  Data: 16 bit data to be written as variable value
    513            * @retval Success or error status:
    514            *           - FLASH_COMPLETE: on success
    515            *           - PAGE_FULL: if valid page is full
    516            *           - NO_VALID_PAGE: if no valid page was found
    517            *           - Flash error code: on write Flash error
    518            */
    519          static uint16_t EE_PageTransfer(uint16_t VirtAddress, uint16_t Data)
    520          {
    521            FLASH_Status FlashStatus = FLASH_COMPLETE;
    522            uint32_t NewPageAddress = 0x080103FF, OldPageAddress = 0x08010000;
    523            uint16_t ValidPage = PAGE0, VarIdx = 0;
    524            uint16_t EepromStatus = 0, ReadStatus = 0;
    525          
    526            /* Get active Page for read operation */
    527            ValidPage = EE_FindValidPage(READ_FROM_VALID_PAGE);
    528          
    529            if (ValidPage == PAGE1)       /* Page1 valid */
    530            {
    531              /* New page address where variable will be moved to */
    532              NewPageAddress = PAGE0_BASE_ADDRESS;
    533          
    534              /* Old page address where variable will be taken from */
    535              OldPageAddress = PAGE1_BASE_ADDRESS;
    536            }
    537            else if (ValidPage == PAGE0)  /* Page0 valid */
    538            {
    539              /* New page address where variable will be moved to */
    540              NewPageAddress = PAGE1_BASE_ADDRESS;
    541          
    542              /* Old page address where variable will be taken from */
    543              OldPageAddress = PAGE0_BASE_ADDRESS;
    544            }
    545            else
    546            {
    547              return NO_VALID_PAGE;       /* No valid Page */
    548            }
    549          
    550            /* Set the new Page status to RECEIVE_DATA status */
    551            FlashStatus = FLASH_ProgramHalfWord(NewPageAddress, RECEIVE_DATA);
    552            /* If program operation was failed, a Flash error code is returned */
    553            if (FlashStatus != FLASH_COMPLETE)
    554            {
    555              return FlashStatus;
    556            }
    557          
    558            /* Write the variable passed as parameter in the new active page */
    559            EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
    560            /* If program operation was failed, a Flash error code is returned */
    561            if (EepromStatus != FLASH_COMPLETE)
    562            {
    563              return EepromStatus;
    564            }
    565          
    566            /* Transfer process: transfer variables from old to the new active page */
    567            for (VarIdx = 0; VarIdx < MAX_EEPROM_ADDRESS; VarIdx++)
    568            {
    569              if (VarIdx != VirtAddress)  /* Check each variable except the one passed as parameter */
    570              {
    571                /* Read the other last variable updates */
    572                ReadStatus = EE_ReadVariable(VarIdx, &DataVar);
    573                /* In case variable corresponding to the virtual address was found */
    574                if (ReadStatus != 0x1)
    575                {
    576                  /* Transfer the variable to the new active page */
    577                  EepromStatus = EE_VerifyPageFullWriteVariable(VarIdx, DataVar);
    578                  /* If program operation was failed, a Flash error code is returned */
    579                  if (EepromStatus != FLASH_COMPLETE)
    580                  {
    581                    return EepromStatus;
    582                  }
    583                }
    584              }
    585            }
    586          
    587            /* Erase the old Page: Set old Page status to ERASED status */
    588            FlashStatus = FLASH_EraseSector(OldPageAddress,VoltageRange_3);
    589            /* If erase operation was failed, a Flash error code is returned */
    590            if (FlashStatus != FLASH_COMPLETE)
    591            {
    592              return FlashStatus;
    593            }
    594          
    595            /* Set new Page status to VALID_PAGE status */
    596            FlashStatus = FLASH_ProgramHalfWord(NewPageAddress, VALID_PAGE);
    597            /* If program operation was failed, a Flash error code is returned */
    598            if (FlashStatus != FLASH_COMPLETE)
    599            {
    600              return FlashStatus;
    601            }
    602          
    603            /* Return last operation flash status */
    604            return FlashStatus;
    605          }
    606          uint16_t eeprom_init(void)
    607          {
    608            uint16_t rez;
    609          FLASH_Unlock();
    610          /* EEPROM Init */
    611          rez= EE_Init();
    612          FLASH_Lock();
    613          return rez;
    614          }
    615          /**
    616            * @}
    617            */ 
    618          
    619          /******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   EE_FindValidPage
      16   EE_Format
        16   -> FLASH_EraseSector
        16   -> FLASH_ProgramHalfWord
      32   EE_Init
        32   -> EE_Format
        32   -> EE_ReadVariable
        32   -> EE_VerifyPageFullWriteVariable
        32   -> FLASH_EraseSector
        32   -> FLASH_ProgramHalfWord
      48   EE_PageTransfer
        48   -> EE_FindValidPage
        48   -> EE_ReadVariable
        48   -> EE_VerifyPageFullWriteVariable
        48   -> FLASH_EraseSector
        48   -> FLASH_ProgramHalfWord
      32   EE_ReadVariable
        32   -> EE_FindValidPage
      40   EE_VerifyPageFullWriteVariable
        40   -> EE_FindValidPage
        40   -> FLASH_ProgramHalfWord
      24   EE_WriteVariable
        24   -> EE_PageTransfer
        24   -> EE_VerifyPageFullWriteVariable
       8   eeprom_init
         8   -> EE_Init
         8   -> FLASH_Lock
         8   -> FLASH_Unlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       2  DataVar
     122  EE_FindValidPage
      66  EE_Format
     686  EE_Init
     276  EE_PageTransfer
     108  EE_ReadVariable
     132  EE_VerifyPageFullWriteVariable
      50  EE_WriteVariable
      22  eeprom_init

 
     2 bytes in section .bss
 1'498 bytes in section .text
 
 1'498 bytes of CODE memory
     2 bytes of DATA memory

Errors: none
Warnings: none
