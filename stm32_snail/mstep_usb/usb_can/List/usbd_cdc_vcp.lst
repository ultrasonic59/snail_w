###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         08/May/2021  18:23:20
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\common\usb\cdc_vcp\usbd_cdc_vcp.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EWC927.tmp
#        (D:\proj\velograph\snail\stm32_snail\common\usb\cdc_vcp\usbd_cdc_vcp.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -D MSTEP_BRD -D
#        USE_USB_OTG_FS -lcN
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\usb_can\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\usb_can\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\.\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_usb\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\libraries\inc\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\dbg\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\usb\core\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\usb\drv\inc\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\usb\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\usb\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\hdlc\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\usb\cdc\ -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\usb_can\List\usbd_cdc_vcp.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\usb_can\Obj\usbd_cdc_vcp.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\common\usb\cdc_vcp\usbd_cdc_vcp.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbd_cdc_vcp.c
      4            * @author  MCD Application Team
      5            * @version V1.2.0
      6            * @date    09-November-2015
      7            * @brief   Generic media access Layer.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */ 
     27          #include <stdlib.h>
     28          #include <string.h>
     29          #include "FreeRTOS.h"
     30          #include "task.h"
     31          #include "queue.h"
     32          
     33          #include "usbd_conf.h"
     34          #include "usbd_desc.h"
     35          ////#include "rook_rtos.h"
     36          #include "my_types.h"
     37          #include "_hdlc.h"
     38          #include "printk.h"
     39          #include "min_max.h"
     40          #include "ring_buff.h"
     41          #include "board.h"
     42          
     43          #if (USB_CLASS == CDC_VCP)|| (USB_CLASS == MSC_CDC)    
     44          ///================================
     45          
     46          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED 
     47          #pragma     data_alignment = 4 
     48          #endif /* USB_OTG_HS_INTERNAL_DMA_ENABLED */
     49          
     50          #include "usbd_cdc_vcp.h"
     51          
     52          hdlc_stat_t g_hdlc_vcp;
     53          /* These are external variables imported from CDC core to be used for IN 
     54             transfer management. */
     55          extern uint8_t  APP_Rx_Buffer []; /* Write CDC received data in this buffer.
     56                                               These data will be sent over USB IN endpoint
     57                                               in the CDC core functions. */
     58          extern uint32_t APP_Rx_ptr_in;    /* Increment this pointer or roll it back to
     59                                               start address when writing received data
     60                                               in the buffer APP_Rx_Buffer. */
     61          
     62          /* Private function prototypes -----------------------------------------------*/
     63          static uint16_t VCP_Init     (void);
     64          static uint16_t VCP_DeInit   (void);
     65          static uint16_t VCP_Ctrl     (uint32_t Cmd, uint8_t* Buf, uint32_t Len);
     66          ////static uint16_t VCP_DataTx   (uint8_t* Buf, uint32_t Len);
     67          ////static 
     68          ////uint16_t VCP_DataRx   (uint8_t* Buf, uint32_t Len);
     69          
     70          ///static uint16_t VCP_COMConfig(uint8_t Conf);
     71          
     72          CDC_IF_Prop_TypeDef VCP_fops = 
     73          {
     74            VCP_Init,
     75            VCP_DeInit,
     76            VCP_Ctrl,
     77            0,
     78            0
     79          ///  VCP_DataTx,
     80          ///  VCP_DataRx
     81          };
     82          
     83          static uint16_t VCP_Init(void)
     84          {
     85            return USBD_OK;
     86          }
     87          static uint16_t VCP_DeInit(void)
     88          {
     89            return USBD_OK;
     90          }
     91          
     92          static uint16_t VCP_Ctrl (uint32_t Cmd, uint8_t* Buf, uint32_t Len)
     93          { 
     94            return USBD_OK;
     95          }
     96          ///=========================================
     97          /*
     98           * VCP data Rx/Tx API
     99           */
    100          
    101          void VCP_MarkRead(unsigned sz)
    102          {
    103          	atomic_t a = atomic_begin();
    104          	USB_Rx_buff_tail = ring_wrap(USB_Rx_buff_size, USB_Rx_buff_tail + sz);
    105          	atomic_end(a);
    106          }
    107          
    108          void VCP_MarkWritten(unsigned sz)
    109          {
    110          	atomic_t a = atomic_begin();
    111          	USB_Tx_buff_head = ring_wrap(USB_TX_BUFF_SIZE, USB_Tx_buff_head + sz);
    112          	atomic_end(a);
    113          }
    114          
    115          unsigned VCP_DataAvail(void)
    116          {
    117          	atomic_t a = atomic_begin();
    118          	unsigned sz = ring_data_avail(USB_Rx_buff_size, USB_Rx_buff_head, USB_Rx_buff_tail);
    119          	atomic_end(a);
    120          	return sz;
    121          }
    122          
    123          unsigned VCP_SpaceAvail(void)
    124          {
    125          	atomic_t a = atomic_begin();
    126          	unsigned sz = ring_space_avail(USB_TX_BUFF_SIZE, USB_Tx_buff_head, USB_Tx_buff_tail);
    127          	atomic_end(a);
    128          	return sz;
    129          }
    130          
    131          unsigned VCP_DataAvailContig(void)
    132          {
    133          	atomic_t a = atomic_begin();
    134          	unsigned sz = ring_data_contig(USB_Rx_buff_size, USB_Rx_buff_head, USB_Rx_buff_tail);
    135          	atomic_end(a);
    136          	return sz;
    137          }
    138          
    139          unsigned VCP_SpaceAvailContig(void)
    140          {
    141          	atomic_t a = atomic_begin();
    142          	unsigned sz = ring_space_contig(USB_TX_BUFF_SIZE, USB_Tx_buff_head, USB_Tx_buff_tail);
    143          	atomic_end(a);
    144          	return sz;
    145          }
    146          
    147          unsigned VCP_GetContig(void* buff, unsigned max_len)
    148          {
    149          	unsigned avail = VCP_DataAvailContig();
    150          	unsigned sz = MIN_(avail, max_len);
    151          	if (sz) {
    152          		memcpy(buff, VCP_DataPtr(), sz);
    153          		VCP_MarkRead(sz);
    154          	}
    155          	return sz;
    156          }
    157          
    158          unsigned VCP_PutContig(void const* buff, unsigned len)
    159          {
    160          unsigned avail = VCP_SpaceAvailContig();
    161          unsigned sz = MIN_(avail, len);
    162          if (sz) 
    163            {
    164            memcpy(VCP_SpacePtr(), buff, sz);
    165            VCP_MarkWritten(sz);
    166            }
    167          return sz;
    168          }
    169          
    170          ///==========================================
    171          
    172          #if 0
    173          void hdlc_vcp_send_byte(u8 val)
    174          {
    175          ///u8 btmp = val;
    176          APP_Rx_Buffer[APP_Rx_ptr_in]=val;
    177          APP_Rx_ptr_in++;
    178          if(APP_Rx_ptr_in == APP_RX_DATA_SIZE)
    179            {
    180            APP_Rx_ptr_in = 0;
    181            }  
    182          ////xQueueSend(g_hdlc_bt.ua_snd_dat, &btmp, portMAX_DELAY);
    183          /////on_int_tx_uart_bt();
    184          ///_printk("[%x]",APP_Rx_ptr_in);
    185          
    186          }
    187          #else
    188          void hdlc_vcp_send_byte(u8 val)
    189          {
    190          int num;  
    191          u8 btmp=val;
    192          for(;;)
    193          {
    194           num= VCP_PutContig(&btmp,1);
    195           if(num)
    196             break;
    197           msleep(1);
    198          }
    199          }
    200          #endif
    201          
    202          #if 0
    203          uint8_t hdlc_vcp_send_frame(uint8_t *buff,uint16_t len)
    204          {
    205          #if 1
    206          uint16_t ii;
    207          
    208          for(ii=0;ii<len;ii++)
    209          {
    210          APP_Rx_Buffer[APP_Rx_ptr_in]=buff[ii]; 
    211          if(APP_Rx_ptr_in == APP_RX_DATA_SIZE)
    212            {
    213            APP_Rx_ptr_in = 0;
    214            }  
    215          
    216          }
    217          ///memcpy(APP_Rx_Buffer,buff,len);  
    218          #endif
    219          return 0;
    220          }
    221          #endif
    222          ///==========================================
    223          ////extern u16     hdlc_bt_get_req_dat(u8 num_req,u8 *buf);
    224          ////extern int hdlc_bt_set_rec_dat(u8 cmd, void *in_buf);
    225          ////extern int hdlc_bt_get_rez(u8 type_rez,void *obuf);
    226          ////extern TaskHandle_t  my_system_monitor_thread_handle;
    227          
    228          TaskHandle_t  vcp_rx_thread_handle;
    229          TaskHandle_t  vcp_tx_thread_handle;
    230          TaskHandle_t  vcp_thread_handle;
    231          
    232          ////static 
    233          uint16_t VCP_DataRx (uint8_t* Buf, uint32_t Len)
    234          {
    235          ///signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
    236          uint8_t ch;
    237          int ii;
    238          ///VCP_MarkRead(Len);
    239          for(ii=0;ii<Len;ii++)
    240            {
    241            ch = Buf[ii];
    242            if (hdlc1_on_bytein(&g_hdlc_vcp, ch) > 0)
    243              {
    244              xQueueSend(g_hdlc_vcp.ev_rsv_frame, &ch,TIMEOUT_SEND);
    245          ///    xQueueSendFromISR(g_hdlc_vcp.ev_rsv_frame, &ch, &xHigherPriorityTaskWoken);
    246              }
    247            }
    248          ////VCP_MarkRead(Len);
    249          return USBD_OK;
    250          }
    251          ////===================================
    252          void vcp_thread(void *pdata)
    253          {
    254          uint8_t rd_dat;  
    255          uint32_t ii;  
    256          #if 1  
    257          for (;;) 
    258          {
    259          unsigned sz  = VCP_DataAvailContig();
    260          if (sz)
    261            {
    262            for(ii=0;ii<sz;ii++)
    263              {
    264              VCP_GetContig(&rd_dat,1);
    265              if (hdlc1_on_bytein(&g_hdlc_vcp, rd_dat) > 0)
    266                {
    267                xQueueSend(g_hdlc_vcp.ev_rsv_frame, &rd_dat,TIMEOUT_SEND);
    268                }
    269              }
    270            }
    271          ///else
    272          ///  {
    273            msleep(1);
    274          ///  }
    275          }
    276          #endif
    277          }
    278          
    279          ////===================================
    280          
    281          extern u16	pc_get_req_dat(u8 num_req,u16 offs,u8 *buf);
    282          extern int      pc_set_rec_dat(u8 cmd,void *in_buf);
    283          ///u8 addr= *((u8*)pdata);
    284          
    285          ///=======================
    286          void init_hdlc_vcp(void)
    287          {
    288          BaseType_t rez;  
    289          g_hdlc_vcp.fn_send_byte=hdlc_vcp_send_byte;
    290          ////g_hdlc_vcp.fn_send_frame=hdlc_vcp_send_frame;
    291          g_hdlc_vcp.fn_set_rec_dat=pc_set_rec_dat;////hdlc_bt_set_rec_dat;
    292          g_hdlc_vcp.fn_get_req_dat=pc_get_req_dat;////hdlc_bt_get_req_dat;
    293          g_hdlc_vcp.ua_snd_dat=xQueueCreate(512,sizeof(unsigned char));		//8192
    294          g_hdlc_vcp.ev_rsv_ack=xQueueCreate(1,1);
    295          g_hdlc_vcp.ev_rsv_dat=xQueueCreate(1,1);
    296          g_hdlc_vcp.ev_rsv_frame=xQueueCreate(1,1);
    297          g_hdlc_vcp.ev_snd_frame=xQueueCreate(16, sizeof(uint32_t));
    298          hdlc1_init(&g_hdlc_vcp);
    299          
    300          rez=xTaskCreate(vcp_thread, (const char*)"vcp_thread",VCP_TX_STACK_SIZE/2, 0, APP_PRIORITY, &vcp_thread_handle);
    301          ////_printk("vcp_thread[%x]",rez);
    302          ////vTaskSuspend(vcp_thread_handle);
    303          
    304          rez=xTaskCreate(hdlc1_obr_frame, (const char*)"HDLC_vcp_rx",VCP_RX_STACK_SIZE, (void*)&g_hdlc_vcp, APP_PRIORITY, &vcp_rx_thread_handle);
    305          ////_printk("hdlc1_obr_frame[%x]",rez);
    306          rez=xTaskCreate(hdlc1_snd_task, (const char*)"HDLC_vcp_tx", VCP_TX_STACK_SIZE, (void*)&g_hdlc_vcp, APP_PRIORITY, &vcp_tx_thread_handle);
    307          ////_printk("hdlc1_snd_task[%x]",rez);
    308          
    309          ///xTaskCreate(vcp_thread, (const char*)"vcp_thread",VCP_TX_STACK_SIZE/2, 0, APP_PRIORITY, vcp_thread_handle);
    310          
    311          ////vTaskSuspend(vcp_thread_handle);
    312          ////vTaskSuspend(vcp_rx_thread_handle);
    313          ////vTaskSuspend(vcp_tx_thread_handle);
    314          
    315          ///put_tst1(0);
    316          }
    317          
    318          ///======================================  
    319          ////static uint8_t flg_usb_on=0;
    320          ///======================================  
    321          void on_off_usb_thr(uint8_t on_off)
    322          {
    323          
    324          #if 0  
    325          if(on_off&0x1)
    326            {
    327            if(flg_usb_on)
    328              return;
    329            flg_usb_on=1;
    330          ////  put_tst1(1);
    331           vTaskResume(vcp_rx_thread_handle);
    332           vTaskResume(vcp_tx_thread_handle);
    333           vTaskResume(vcp_thread_handle);
    334          
    335            }
    336          else
    337            {
    338            if(!flg_usb_on)
    339              return;
    340            flg_usb_on=0;
    341            vTaskSuspend(vcp_rx_thread_handle);
    342            vTaskSuspend(vcp_tx_thread_handle);
    343            vTaskSuspend(vcp_thread_handle);
    344          ///  put_tst1(0);
    345            }
    346          #endif
    347          }
    348          ///======================================  
    349          #endif ///(USB_CLASS == CDC_VCP)
    350          ///======================================  

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   VCP_Ctrl
      16   VCP_DataAvail
        16   -> atomic_begin
        16   -> atomic_end
        16   -> ring_data_avail
      16   VCP_DataAvailContig
        16   -> atomic_begin
        16   -> atomic_end
        16   -> ring_data_contig
       0   VCP_DataPtr
      24   VCP_DataRx
        24   -> hdlc1_on_bytein
        24   -> xQueueGenericSend
       0   VCP_DeInit
      32   VCP_GetContig
        32   -> VCP_DataAvailContig
        32   -> VCP_DataPtr
        32   -> VCP_MarkRead
        32   -> __aeabi_memcpy
       0   VCP_Init
      16   VCP_MarkRead
        16   -> atomic_begin
        16   -> atomic_end
        16   -> ring_wrap
      16   VCP_MarkWritten
        16   -> atomic_begin
        16   -> atomic_end
        16   -> ring_wrap
      32   VCP_PutContig
        32   -> VCP_MarkWritten
        32   -> VCP_SpaceAvailContig
        32   -> VCP_SpacePtr
        32   -> __aeabi_memcpy
      16   VCP_SpaceAvail
        16   -> atomic_begin
        16   -> atomic_end
        16   -> ring_space_avail
      16   VCP_SpaceAvailContig
        16   -> atomic_begin
        16   -> atomic_end
        16   -> ring_space_contig
       0   VCP_SpacePtr
       0   atomic_begin
       0   atomic_end
      16   hdlc_vcp_send_byte
        16   -> VCP_PutContig
        16   -> vTaskDelay
      24   init_hdlc_vcp
        24   -> hdlc1_init
        24   -> xQueueGenericCreate
        24   -> xTaskCreate
       0   on_off_usb_thr
       0   ring_data_avail
       0   ring_data_contig
      16   ring_space_avail
        16   -> ring_data_avail
       0   ring_space_contig
       0   ring_wrap
      24   vcp_thread
        24   -> VCP_DataAvailContig
        24   -> VCP_GetContig
        24   -> hdlc1_on_bytein
        24   -> vTaskDelay
        24   -> xQueueGenericSend


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_17
       4  ??DataTable11_18
       4  ??DataTable11_19
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
      12  ?_0
      12  ?_1
      12  ?_2
       6  VCP_Ctrl
      36  VCP_DataAvail
      36  VCP_DataAvailContig
      10  VCP_DataPtr
      54  VCP_DataRx
       4  VCP_DeInit
      60  VCP_GetContig
       4  VCP_Init
      34  VCP_MarkRead
      34  VCP_MarkWritten
      60  VCP_PutContig
      36  VCP_SpaceAvail
      36  VCP_SpaceAvailContig
      10  VCP_SpacePtr
      20  VCP_fops
       8  atomic_begin
       6  atomic_end
      84  g_hdlc_vcp
      32  hdlc_vcp_send_byte
     156  init_hdlc_vcp
       2  on_off_usb_thr
      20  ring_data_avail
      18  ring_data_contig
      24  ring_space_avail
      26  ring_space_contig
      12  ring_wrap
       4  vcp_rx_thread_handle
      70  vcp_thread
       4  vcp_thread_handle
       4  vcp_tx_thread_handle

 
  96 bytes in section .bss
  20 bytes in section .data
  36 bytes in section .rodata
 874 bytes in section .text
 
 874 bytes of CODE  memory
  36 bytes of CONST memory
 116 bytes of DATA  memory

Errors: none
Warnings: 1
