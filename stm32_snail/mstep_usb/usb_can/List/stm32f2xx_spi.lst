###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         05/Dec/2020  20:45:04
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\common\libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_spi.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EWB704.tmp
#        (D:\proj\velograph\snail\stm32_snail\common\libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_spi.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -D MSTEP_BRD -D
#        USE_USB_OTG_FS -lcN
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\usb_can\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\usb_can\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\.\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_usb\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\libraries\inc\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\dbg\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\usb\core\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\usb\drv\inc\
#        -I D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\usb\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\usb\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\hdlc\ -I
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\..\common\usb\cdc\ -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\usb_can\List\stm32f2xx_spi.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\mstep_usb\usb_can\Obj\stm32f2xx_spi.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\common\libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_spi.c
      4            * @author  MCD Application Team
      5            * @version V1.1.0
      6            * @date    07-October-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Serial peripheral interface (SPI):           
      9            *           - Initialization and Configuration
     10            *           - Data transfers functions
     11            *           - Hardware CRC Calculation
     12            *           - DMA transfers management
     13            *           - Interrupts and flags management 
     14            *           
     15            *  @verbatim
     16            *          
     17            *                    
     18            *          ===================================================================
     19            *                                 How to use this driver
     20            *          ===================================================================
     21            *          1. Enable peripheral clock using the following functions 
     22            *             RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE) for SPI1
     23            *             RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE) for SPI2
     24            *             RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI3.
     25            *
     26            *          2. Enable SCK, MOSI, MISO and NSS GPIO clocks using RCC_AHB1PeriphClockCmd()
     27            *             function.
     28            *             In I2S mode, if an external clock source is used then the I2S CKIN pin GPIO
     29            *             clock should also be enabled.
     30            *
     31            *          3. Peripherals alternate function: 
     32            *                 - Connect the pin to the desired peripherals' Alternate 
     33            *                   Function (AF) using GPIO_PinAFConfig() function
     34            *                 - Configure the desired pin in alternate function by:
     35            *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     36            *                 - Select the type, pull-up/pull-down and output speed via 
     37            *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
     38            *                 - Call GPIO_Init() function
     39            *              In I2S mode, if an external clock source is used then the I2S CKIN pin
     40            *              should be also configured in Alternate function Push-pull pull-up mode. 
     41            *        
     42            *          4. Program the Polarity, Phase, First Data, Baud Rate Prescaler, Slave 
     43            *             Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
     44            *             function.
     45            *             In I2S mode, program the Mode, Standard, Data Format, MCLK Output, Audio 
     46            *             frequency and Polarity using I2S_Init() function.
     47            *             For I2S mode, make sure that either:
     48            *              - I2S PLL is configured using the functions RCC_I2SCLKConfig(RCC_I2S2CLKSource_PLLI2S), 
     49            *                RCC_PLLI2SCmd(ENABLE) and RCC_GetFlagStatus(RCC_FLAG_PLLI2SRDY).
     50            *              or 
     51            *              - External clock source is configured using the function 
     52            *                RCC_I2SCLKConfig(RCC_I2S2CLKSource_Ext) and after setting correctly the define constant
     53            *                I2S_EXTERNAL_CLOCK_VAL in the stm32f2xx_conf.h file. 
     54            *
     55            *          5. Enable the NVIC and the corresponding interrupt using the function 
     56            *             SPI_ITConfig() if you need to use interrupt mode. 
     57            *
     58            *          6. When using the DMA mode 
     59            *                   - Configure the DMA using DMA_Init() function
     60            *                   - Active the needed channel Request using SPI_I2S_DMACmd() function
     61            * 
     62            *          7. Enable the SPI using the SPI_Cmd() function or enable the I2S using
     63            *             I2S_Cmd().
     64            * 
     65            *          8. Enable the DMA using the DMA_Cmd() function when using DMA mode. 
     66            *
     67            *          9. Optionally, you can enable/configure the following parameters without
     68            *             re-initialization (i.e there is no need to call again SPI_Init() function):
     69            *              - When bidirectional mode (SPI_Direction_1Line_Rx or SPI_Direction_1Line_Tx)
     70            *                is programmed as Data direction parameter using the SPI_Init() function
     71            *                it can be possible to switch between SPI_Direction_Tx or SPI_Direction_Rx
     72            *                using the SPI_BiDirectionalLineConfig() function.
     73            *              - When SPI_NSS_Soft is selected as Slave Select Management parameter 
     74            *                using the SPI_Init() function it can be possible to manage the 
     75            *                NSS internal signal using the SPI_NSSInternalSoftwareConfig() function.
     76            *              - Reconfigure the data size using the SPI_DataSizeConfig() function  
     77            *              - Enable or disable the SS output using the SPI_SSOutputCmd() function  
     78            *          
     79            *          10. To use the CRC Hardware calculation feature refer to the Peripheral 
     80            *              CRC hardware Calculation subsection.
     81            *   
     82            *
     83            * @note    This driver supports only the I2S clock scheme available in Silicon
     84            *          RevisionB and RevisionY.
     85            *     
     86            * @note    In I2S mode: if an external clock is used as source clock for the I2S,  
     87            *          then the define I2S_EXTERNAL_CLOCK_VAL in file stm32f2xx_conf.h should 
     88            *          be enabled and set to the value of the source clock frequency (in Hz).
     89            * 
     90            * @note    In SPI mode: To use the SPI TI mode, call the function SPI_TIModeCmd() 
     91            *          just after calling the function SPI_Init().
     92            *
     93            *  @endverbatim  
     94            *                                  
     95            ******************************************************************************
     96            * @attention
     97            *
     98            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     99            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
    100            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
    101            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
    102            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
    103            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
    104            *
    105            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
    106            ******************************************************************************  
    107            */ 
    108          
    109          /* Includes ------------------------------------------------------------------*/
    110          #include "stm32f2xx_conf.h"
    111          #include "stm32f2xx_spi.h"
    112          #include "stm32f2xx_rcc.h"
    113          
    114          /** @addtogroup STM32F2xx_StdPeriph_Driver
    115            * @{
    116            */
    117          
    118          /** @defgroup SPI 
    119            * @brief SPI driver modules
    120            * @{
    121            */ 
    122          
    123          /* Private typedef -----------------------------------------------------------*/
    124          /* Private define ------------------------------------------------------------*/
    125          
    126          /* SPI registers Masks */
    127          #define CR1_CLEAR_MASK            ((uint16_t)0x3040)
    128          #define I2SCFGR_CLEAR_MASK        ((uint16_t)0xF040)
    129          
    130          /* RCC PLLs masks */
    131          #define PLLCFGR_PPLR_MASK         ((uint32_t)0x70000000)
    132          #define PLLCFGR_PPLN_MASK         ((uint32_t)0x00007FC0)
    133          
    134          #define SPI_CR2_FRF               ((uint16_t)0x0010)
    135          #define SPI_SR_TIFRFE             ((uint16_t)0x0100)
    136          
    137          /* Private macro -------------------------------------------------------------*/
    138          /* Private variables ---------------------------------------------------------*/
    139          /* Private function prototypes -----------------------------------------------*/
    140          /* Private functions ---------------------------------------------------------*/
    141          
    142          /** @defgroup SPI_Private_Functions
    143            * @{
    144            */
    145          
    146          /** @defgroup SPI_Group1 Initialization and Configuration functions
    147           *  @brief   Initialization and Configuration functions 
    148           *
    149          @verbatim   
    150           ===============================================================================
    151                            Initialization and Configuration functions
    152           ===============================================================================  
    153          
    154            This section provides a set of functions allowing to initialize the SPI Direction,
    155            SPI Mode, SPI Data Size, SPI Polarity, SPI Phase, SPI NSS Management, SPI Baud
    156            Rate Prescaler, SPI First Bit and SPI CRC Polynomial.
    157            
    158            The SPI_Init() function follows the SPI configuration procedures for Master mode
    159            and Slave mode (details for these procedures are available in reference manual
    160            (RM0033)).
    161            
    162          @endverbatim
    163            * @{
    164            */
    165          
    166          /**
    167            * @brief  Deinitialize the SPIx peripheral registers to their default reset values.
    168            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
    169            *         in SPI mode or 2 or 3 in I2S mode.   
    170            * @retval None
    171            */
    172          void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
    173          {
    174            /* Check the parameters */
    175            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    176          
    177            if (SPIx == SPI1)
    178            {
    179              /* Enable SPI1 reset state */
    180              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
    181              /* Release SPI1 from reset state */
    182              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
    183            }
    184            else if (SPIx == SPI2)
    185            {
    186              /* Enable SPI2 reset state */
    187              RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
    188              /* Release SPI2 from reset state */
    189              RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
    190              }
    191            else
    192            {
    193              if (SPIx == SPI3)
    194              {
    195                /* Enable SPI3 reset state */
    196                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
    197                /* Release SPI3 from reset state */
    198                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
    199              }
    200            }
    201          }
    202          
    203          /**
    204            * @brief  Initializes the SPIx peripheral according to the specified 
    205            *         parameters in the SPI_InitStruct.
    206            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    207            * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
    208            *         contains the configuration information for the specified SPI peripheral.
    209            * @retval None
    210            */
    211          void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
    212          {
    213            uint16_t tmpreg = 0;
    214            
    215            /* check the parameters */
    216            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    217            
    218            /* Check the SPI parameters */
    219            assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
    220            assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
    221            assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
    222            assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
    223            assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
    224            assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
    225            assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
    226            assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
    227            assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
    228          
    229          /*---------------------------- SPIx CR1 Configuration ------------------------*/
    230            /* Get the SPIx CR1 value */
    231            tmpreg = SPIx->CR1;
    232            /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
    233            tmpreg &= CR1_CLEAR_MASK;
    234            /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
    235               master/salve mode, CPOL and CPHA */
    236            /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
    237            /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    238            /* Set LSBFirst bit according to SPI_FirstBit value */
    239            /* Set BR bits according to SPI_BaudRatePrescaler value */
    240            /* Set CPOL bit according to SPI_CPOL value */
    241            /* Set CPHA bit according to SPI_CPHA value */
    242            tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
    243                            SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
    244                            SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
    245                            SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
    246            /* Write to SPIx CR1 */
    247            SPIx->CR1 = tmpreg;
    248          
    249            /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
    250            SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
    251          /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
    252            /* Write to SPIx CRCPOLY */
    253            SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
    254          }
    255          
    256          /**
    257            * @brief  Initializes the SPIx peripheral according to the specified 
    258            *         parameters in the I2S_InitStruct.
    259            * @param  SPIx: where x can be  2 or 3 to select the SPI peripheral (configured in I2S mode).
    260            * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
    261            *         contains the configuration information for the specified SPI peripheral
    262            *         configured in I2S mode.
    263            *           
    264            * @note   The function calculates the optimal prescaler needed to obtain the most 
    265            *         accurate audio frequency (depending on the I2S clock source, the PLL values 
    266            *         and the product configuration). But in case the prescaler value is greater 
    267            *         than 511, the default value (0x02) will be configured instead.    
    268            * 
    269            * @note   if an external clock is used as source clock for the I2S, then the define
    270            *         I2S_EXTERNAL_CLOCK_VAL in file stm32f2xx_conf.h should be enabled and set
    271            *         to the value of the the source clock frequency (in Hz).
    272            *  
    273            * @retval None
    274            */
    275          void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
    276          {
    277            uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
    278            uint32_t tmp = 0, i2sclk = 0;
    279          #ifndef I2S_EXTERNAL_CLOCK_VAL
    280            uint32_t pllm = 0, plln = 0, pllr = 0;
    281          #endif /* I2S_EXTERNAL_CLOCK_VAL */
    282            
    283            /* Check the I2S parameters */
    284            assert_param(IS_SPI_23_PERIPH(SPIx));
    285            assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
    286            assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
    287            assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
    288            assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
    289            assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
    290            assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
    291          
    292          /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    293            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    294            SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
    295            SPIx->I2SPR = 0x0002;
    296            
    297            /* Get the I2SCFGR register value */
    298            tmpreg = SPIx->I2SCFGR;
    299            
    300            /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
    301            if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
    302            {
    303              i2sodd = (uint16_t)0;
    304              i2sdiv = (uint16_t)2;   
    305            }
    306            /* If the requested audio frequency is not the default, compute the prescaler */
    307            else
    308            {
    309              /* Check the frame length (For the Prescaler computing) *******************/
    310              if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
    311              {
    312                /* Packet length is 16 bits */
    313                packetlength = 1;
    314              }
    315              else
    316              {
    317                /* Packet length is 32 bits */
    318                packetlength = 2;
    319              }
    320          
    321              /* Get I2S source Clock frequency (only in Silicon RevisionB and RevisionY) */
    322                
    323              /* If an external I2S clock has to be used, this define should be set  
    324                 in the project configuration or in the stm32f2xx_conf.h file */
    325            #ifdef I2S_EXTERNAL_CLOCK_VAL     
    326              /* Set external clock as I2S clock source */
    327              if ((RCC->CFGR & RCC_CFGR_I2SSRC) == 0)
    328              {
    329                RCC->CFGR |= (uint32_t)RCC_CFGR_I2SSRC;
    330              }
    331              
    332              /* Set the I2S clock to the external clock  value */
    333              i2sclk = I2S_EXTERNAL_CLOCK_VAL;
    334          
    335            #else /* There is no define for External I2S clock source */
    336              /* Set PLLI2S as I2S clock source */
    337              if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
    338              {
    339                RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
    340              }    
    341              
    342              /* Get the PLLI2SN value */
    343              plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
    344                                (RCC_PLLI2SCFGR_PLLI2SN >> 6));
    345              
    346              /* Get the PLLI2SR value */
    347              pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
    348                                (RCC_PLLI2SCFGR_PLLI2SR >> 28));
    349              
    350              /* Get the PLLM value */
    351              pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
    352              
    353              /* Get the I2S source clock value */
    354              i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
    355            #endif /* I2S_EXTERNAL_CLOCK_VAL */
    356              
    357              /* Compute the Real divider depending on the MCLK output state, with a floating point */
    358              if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
    359              {
    360                /* MCLK output is enabled */
    361                tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
    362              }
    363              else
    364              {
    365                /* MCLK output is disabled */
    366                tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
    367              }
    368              
    369              /* Remove the flatting point */
    370              tmp = tmp / 10;  
    371                
    372              /* Check the parity of the divider */
    373              i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
    374             
    375              /* Compute the i2sdiv prescaler */
    376              i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
    377             
    378              /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    379              i2sodd = (uint16_t) (i2sodd << 8);
    380            }
    381          
    382            /* Test if the divider is 1 or 0 or greater than 0xFF */
    383            if ((i2sdiv < 2) || (i2sdiv > 0xFF))
    384            {
    385              /* Set the default values */
    386              i2sdiv = 2;
    387              i2sodd = 0;
    388            }
    389          
    390            /* Write to SPIx I2SPR register the computed value */
    391            SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
    392           
    393            /* Configure the I2S with the SPI_InitStruct values */
    394            tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
    395                            (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
    396                            (uint16_t)I2S_InitStruct->I2S_CPOL))));
    397           
    398            /* Write to SPIx I2SCFGR */  
    399            SPIx->I2SCFGR = tmpreg;
    400          }
    401          
    402          /**
    403            * @brief  Fills each SPI_InitStruct member with its default value.
    404            * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure which will be initialized.
    405            * @retval None
    406            */
    407          void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
    408          {
    409          /*--------------- Reset SPI init structure parameters values -----------------*/
    410            /* Initialize the SPI_Direction member */
    411            SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
    412            /* initialize the SPI_Mode member */
    413            SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
    414            /* initialize the SPI_DataSize member */
    415            SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
    416            /* Initialize the SPI_CPOL member */
    417            SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
    418            /* Initialize the SPI_CPHA member */
    419            SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
    420            /* Initialize the SPI_NSS member */
    421            SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
    422            /* Initialize the SPI_BaudRatePrescaler member */
    423            SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
    424            /* Initialize the SPI_FirstBit member */
    425            SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
    426            /* Initialize the SPI_CRCPolynomial member */
    427            SPI_InitStruct->SPI_CRCPolynomial = 7;
    428          }
    429          
    430          /**
    431            * @brief  Fills each I2S_InitStruct member with its default value.
    432            * @param  I2S_InitStruct: pointer to a I2S_InitTypeDef structure which will be initialized.
    433            * @retval None
    434            */
    435          void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
    436          {
    437          /*--------------- Reset I2S init structure parameters values -----------------*/
    438            /* Initialize the I2S_Mode member */
    439            I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
    440            
    441            /* Initialize the I2S_Standard member */
    442            I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
    443            
    444            /* Initialize the I2S_DataFormat member */
    445            I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
    446            
    447            /* Initialize the I2S_MCLKOutput member */
    448            I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
    449            
    450            /* Initialize the I2S_AudioFreq member */
    451            I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
    452            
    453            /* Initialize the I2S_CPOL member */
    454            I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
    455          }
    456          
    457          /**
    458            * @brief  Enables or disables the specified SPI peripheral.
    459            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    460            * @param  NewState: new state of the SPIx peripheral. 
    461            *          This parameter can be: ENABLE or DISABLE.
    462            * @retval None
    463            */
    464          void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    465          {
    466            /* Check the parameters */
    467            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    468            assert_param(IS_FUNCTIONAL_STATE(NewState));
    469            if (NewState != DISABLE)
    470            {
    471              /* Enable the selected SPI peripheral */
    472              SPIx->CR1 |= SPI_CR1_SPE;
    473            }
    474            else
    475            {
    476              /* Disable the selected SPI peripheral */
    477              SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
    478            }
    479          }
    480          
    481          /**
    482            * @brief  Enables or disables the specified SPI peripheral (in I2S mode).
    483            * @param  SPIx: where x can be 2 or 3 to select the SPI peripheral.
    484            * @param  NewState: new state of the SPIx peripheral. 
    485            *         This parameter can be: ENABLE or DISABLE.
    486            * @retval None
    487            */
    488          void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    489          {
    490            /* Check the parameters */
    491            assert_param(IS_SPI_23_PERIPH(SPIx));
    492            assert_param(IS_FUNCTIONAL_STATE(NewState));
    493            
    494            if (NewState != DISABLE)
    495            {
    496              /* Enable the selected SPI peripheral (in I2S mode) */
    497              SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
    498            }
    499            else
    500            {
    501              /* Disable the selected SPI peripheral in I2S mode */
    502              SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
    503            }
    504          }
    505          
    506          /**
    507            * @brief  Configures the data size for the selected SPI.
    508            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    509            * @param  SPI_DataSize: specifies the SPI data size.
    510            *          This parameter can be one of the following values:
    511            *            @arg SPI_DataSize_16b: Set data frame format to 16bit
    512            *            @arg SPI_DataSize_8b: Set data frame format to 8bit
    513            * @retval None
    514            */
    515          void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
    516          {
    517            /* Check the parameters */
    518            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    519            assert_param(IS_SPI_DATASIZE(SPI_DataSize));
    520            /* Clear DFF bit */
    521            SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
    522            /* Set new DFF bit value */
    523            SPIx->CR1 |= SPI_DataSize;
    524          }
    525          
    526          /**
    527            * @brief  Selects the data transfer direction in bidirectional mode for the specified SPI.
    528            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    529            * @param  SPI_Direction: specifies the data transfer direction in bidirectional mode. 
    530            *          This parameter can be one of the following values:
    531            *            @arg SPI_Direction_Tx: Selects Tx transmission direction
    532            *            @arg SPI_Direction_Rx: Selects Rx receive direction
    533            * @retval None
    534            */
    535          void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
    536          {
    537            /* Check the parameters */
    538            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    539            assert_param(IS_SPI_DIRECTION(SPI_Direction));
    540            if (SPI_Direction == SPI_Direction_Tx)
    541            {
    542              /* Set the Tx only mode */
    543              SPIx->CR1 |= SPI_Direction_Tx;
    544            }
    545            else
    546            {
    547              /* Set the Rx only mode */
    548              SPIx->CR1 &= SPI_Direction_Rx;
    549            }
    550          }
    551          
    552          /**
    553            * @brief  Configures internally by software the NSS pin for the selected SPI.
    554            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    555            * @param  SPI_NSSInternalSoft: specifies the SPI NSS internal state.
    556            *          This parameter can be one of the following values:
    557            *            @arg SPI_NSSInternalSoft_Set: Set NSS pin internally
    558            *            @arg SPI_NSSInternalSoft_Reset: Reset NSS pin internally
    559            * @retval None
    560            */
    561          void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
    562          {
    563            /* Check the parameters */
    564            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    565            assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
    566            if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
    567            {
    568              /* Set NSS pin internally by software */
    569              SPIx->CR1 |= SPI_NSSInternalSoft_Set;
    570            }
    571            else
    572            {
    573              /* Reset NSS pin internally by software */
    574              SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
    575            }
    576          }
    577          
    578          /**
    579            * @brief  Enables or disables the SS output for the selected SPI.
    580            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    581            * @param  NewState: new state of the SPIx SS output. 
    582            *          This parameter can be: ENABLE or DISABLE.
    583            * @retval None
    584            */
    585          void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    586          {
    587            /* Check the parameters */
    588            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    589            assert_param(IS_FUNCTIONAL_STATE(NewState));
    590            if (NewState != DISABLE)
    591            {
    592              /* Enable the selected SPI SS output */
    593              SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
    594            }
    595            else
    596            {
    597              /* Disable the selected SPI SS output */
    598              SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
    599            }
    600          }
    601          
    602          /**
    603            * @brief  Enables or disables the SPIx/I2Sx DMA interface.
    604            *   
    605            * @note   This function can be called only after the SPI_Init() function has 
    606            *         been called. 
    607            * @note   When TI mode is selected, the control bits SSM, SSI, CPOL and CPHA 
    608            *         are not taken into consideration and are configured by hardware
    609            *         respectively to the TI mode requirements.  
    610            * 
    611            * @param  SPIx: where x can be 1, 2 or 3 
    612            * @param  NewState: new state of the selected SPI TI communication mode.
    613            *          This parameter can be: ENABLE or DISABLE.
    614            * @retval None
    615            */
    616          void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    617          {
    618            /* Check the parameters */
    619            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    620            assert_param(IS_FUNCTIONAL_STATE(NewState));
    621          
    622            if (NewState != DISABLE)
    623            {
    624              /* Enable the TI mode for the selected SPI peripheral */
    625              SPIx->CR2 |= SPI_CR2_FRF;
    626            }
    627            else
    628            {
    629              /* Disable the TI mode for the selected SPI peripheral */
    630              SPIx->CR2 &= (uint16_t)~SPI_CR2_FRF;
    631            }
    632          }
    633          
    634          /**
    635            * @}
    636            */
    637          
    638          /** @defgroup SPI_Group2 Data transfers functions
    639           *  @brief   Data transfers functions
    640           *
    641          @verbatim   
    642           ===============================================================================
    643                                   Data transfers functions
    644           ===============================================================================  
    645          
    646            This section provides a set of functions allowing to manage the SPI data transfers
    647            
    648            In reception, data are received and then stored into an internal Rx buffer while 
    649            In transmission, data are first stored into an internal Tx buffer before being 
    650            transmitted.
    651          
    652            The read access of the SPI_DR register can be done using the SPI_I2S_ReceiveData()
    653            function and returns the Rx buffered value. Whereas a write access to the SPI_DR 
    654            can be done using SPI_I2S_SendData() function and stores the written data into 
    655            Tx buffer.
    656          
    657          @endverbatim
    658            * @{
    659            */
    660          
    661          /**
    662            * @brief  Returns the most recent received data by the SPIx/I2Sx peripheral. 
    663            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
    664            *         in SPI mode or 2 or 3 in I2S mode. 
    665            * @retval The value of the received data.
    666            */
    667          uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
    668          {
    669            /* Check the parameters */
    670            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    671            
    672            /* Return the data in the DR register */
    673            return SPIx->DR;
    674          }
    675          
    676          /**
    677            * @brief  Transmits a Data through the SPIx/I2Sx peripheral.
    678            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
    679            *         in SPI mode or 2 or 3 in I2S mode.     
    680            * @param  Data: Data to be transmitted.
    681            * @retval None
    682            */
    683          void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
    684          {
    685            /* Check the parameters */
    686            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    687            
    688            /* Write in the DR register the data to be sent */
    689            SPIx->DR = Data;
    690          }
    691          
    692          /**
    693            * @}
    694            */
    695          
    696          /** @defgroup SPI_Group3 Hardware CRC Calculation functions
    697           *  @brief   Hardware CRC Calculation functions
    698           *
    699          @verbatim   
    700           ===============================================================================
    701                                   Hardware CRC Calculation functions
    702           ===============================================================================  
    703          
    704            This section provides a set of functions allowing to manage the SPI CRC hardware 
    705            calculation
    706          
    707            SPI communication using CRC is possible through the following procedure:
    708               1. Program the Data direction, Polarity, Phase, First Data, Baud Rate Prescaler, 
    709                  Slave Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
    710                  function.
    711               2. Enable the CRC calculation using the SPI_CalculateCRC() function.
    712               3. Enable the SPI using the SPI_Cmd() function
    713               4. Before writing the last data to the TX buffer, set the CRCNext bit using the 
    714                SPI_TransmitCRC() function to indicate that after transmission of the last 
    715                data, the CRC should be transmitted.
    716               5. After transmitting the last data, the SPI transmits the CRC. The SPI_CR1_CRCNEXT
    717                  bit is reset. The CRC is also received and compared against the SPI_RXCRCR 
    718                  value. 
    719                  If the value does not match, the SPI_FLAG_CRCERR flag is set and an interrupt
    720                  can be generated when the SPI_I2S_IT_ERR interrupt is enabled.
    721          
    722          @note It is advised not to read the calculated CRC values during the communication.
    723          
    724          @note When the SPI is in slave mode, be careful to enable CRC calculation only 
    725                when the clock is stable, that is, when the clock is in the steady state. 
    726                If not, a wrong CRC calculation may be done. In fact, the CRC is sensitive 
    727                to the SCK slave input clock as soon as CRCEN is set, and this, whatever 
    728                the value of the SPE bit.
    729          
    730          @note With high bitrate frequencies, be careful when transmitting the CRC.
    731                As the number of used CPU cycles has to be as low as possible in the CRC 
    732                transfer phase, it is forbidden to call software functions in the CRC 
    733                transmission sequence to avoid errors in the last data and CRC reception. 
    734                In fact, CRCNEXT bit has to be written before the end of the transmission/reception 
    735                of the last data.
    736          
    737          @note For high bit rate frequencies, it is advised to use the DMA mode to avoid the
    738                degradation of the SPI speed performance due to CPU accesses impacting the 
    739                SPI bandwidth.
    740          
    741          @note When the STM32F2xx is configured as slave and the NSS hardware mode is 
    742                used, the NSS pin needs to be kept low between the data phase and the CRC 
    743                phase.
    744          
    745          @note When the SPI is configured in slave mode with the CRC feature enabled, CRC
    746                calculation takes place even if a high level is applied on the NSS pin. 
    747                This may happen for example in case of a multi-slave environment where the 
    748                communication master addresses slaves alternately.
    749          
    750          @note Between a slave de-selection (high level on NSS) and a new slave selection 
    751                (low level on NSS), the CRC value should be cleared on both master and slave
    752                sides in order to resynchronize the master and slave for their respective 
    753                CRC calculation.
    754          
    755          @note To clear the CRC, follow the procedure below:
    756                  1. Disable SPI using the SPI_Cmd() function
    757                  2. Disable the CRC calculation using the SPI_CalculateCRC() function.
    758                  3. Enable the CRC calculation using the SPI_CalculateCRC() function.
    759                  4. Enable SPI using the SPI_Cmd() function.
    760          
    761          @endverbatim
    762            * @{
    763            */
    764          
    765          /**
    766            * @brief  Enables or disables the CRC value calculation of the transferred bytes.
    767            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    768            * @param  NewState: new state of the SPIx CRC value calculation.
    769            *          This parameter can be: ENABLE or DISABLE.
    770            * @retval None
    771            */
    772          void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
    773          {
    774            /* Check the parameters */
    775            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    776            assert_param(IS_FUNCTIONAL_STATE(NewState));
    777            if (NewState != DISABLE)
    778            {
    779              /* Enable the selected SPI CRC calculation */
    780              SPIx->CR1 |= SPI_CR1_CRCEN;
    781            }
    782            else
    783            {
    784              /* Disable the selected SPI CRC calculation */
    785              SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
    786            }
    787          }
    788          
    789          /**
    790            * @brief  Transmit the SPIx CRC value.
    791            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    792            * @retval None
    793            */
    794          void SPI_TransmitCRC(SPI_TypeDef* SPIx)
    795          {
    796            /* Check the parameters */
    797            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    798            
    799            /* Enable the selected SPI CRC transmission */
    800            SPIx->CR1 |= SPI_CR1_CRCNEXT;
    801          }
    802          
    803          /**
    804            * @brief  Returns the transmit or the receive CRC register value for the specified SPI.
    805            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    806            * @param  SPI_CRC: specifies the CRC register to be read.
    807            *          This parameter can be one of the following values:
    808            *            @arg SPI_CRC_Tx: Selects Tx CRC register
    809            *            @arg SPI_CRC_Rx: Selects Rx CRC register
    810            * @retval The selected CRC register value..
    811            */
    812          uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
    813          {
    814            uint16_t crcreg = 0;
    815            /* Check the parameters */
    816            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    817            assert_param(IS_SPI_CRC(SPI_CRC));
    818            if (SPI_CRC != SPI_CRC_Rx)
    819            {
    820              /* Get the Tx CRC register */
    821              crcreg = SPIx->TXCRCR;
    822            }
    823            else
    824            {
    825              /* Get the Rx CRC register */
    826              crcreg = SPIx->RXCRCR;
    827            }
    828            /* Return the selected CRC register */
    829            return crcreg;
    830          }
    831          
    832          /**
    833            * @brief  Returns the CRC Polynomial register value for the specified SPI.
    834            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    835            * @retval The CRC Polynomial register value.
    836            */
    837          uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
    838          {
    839            /* Check the parameters */
    840            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    841            
    842            /* Return the CRC polynomial register */
    843            return SPIx->CRCPR;
    844          }
    845          
    846          /**
    847            * @}
    848            */
    849          
    850          /** @defgroup SPI_Group4 DMA transfers management functions
    851           *  @brief   DMA transfers management functions
    852            *
    853          @verbatim   
    854           ===============================================================================
    855                                   DMA transfers management functions
    856           ===============================================================================  
    857          
    858          @endverbatim
    859            * @{
    860            */
    861          
    862          /**
    863            * @brief  Enables or disables the SPIx/I2Sx DMA interface.
    864            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
    865            *         in SPI mode or 2 or 3 in I2S mode. 
    866            * @param  SPI_I2S_DMAReq: specifies the SPI DMA transfer request to be enabled or disabled. 
    867            *          This parameter can be any combination of the following values:
    868            *            @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
    869            *            @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
    870            * @param  NewState: new state of the selected SPI DMA transfer request.
    871            *          This parameter can be: ENABLE or DISABLE.
    872            * @retval None
    873            */
    874          void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
    875          {
    876            /* Check the parameters */
    877            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    878            assert_param(IS_FUNCTIONAL_STATE(NewState));
    879            assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
    880          
    881            if (NewState != DISABLE)
    882            {
    883              /* Enable the selected SPI DMA requests */
    884              SPIx->CR2 |= SPI_I2S_DMAReq;
    885            }
    886            else
    887            {
    888              /* Disable the selected SPI DMA requests */
    889              SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
    890            }
    891          }
    892          
    893          /**
    894            * @}
    895            */
    896          
    897          /** @defgroup SPI_Group5 Interrupts and flags management functions
    898           *  @brief   Interrupts and flags management functions
    899            *
    900          @verbatim   
    901           ===============================================================================
    902                                   Interrupts and flags management functions
    903           ===============================================================================  
    904          
    905            This section provides a set of functions allowing to configure the SPI Interrupts 
    906            sources and check or clear the flags or pending bits status.
    907            The user should identify which mode will be used in his application to manage 
    908            the communication: Polling mode, Interrupt mode or DMA mode. 
    909              
    910            Polling Mode
    911            =============
    912            In Polling Mode, the SPI/I2S communication can be managed by 9 flags:
    913               1. SPI_I2S_FLAG_TXE : to indicate the status of the transmit buffer register
    914               2. SPI_I2S_FLAG_RXNE : to indicate the status of the receive buffer register
    915               3. SPI_I2S_FLAG_BSY : to indicate the state of the communication layer of the SPI.
    916               4. SPI_FLAG_CRCERR : to indicate if a CRC Calculation error occur              
    917               5. SPI_FLAG_MODF : to indicate if a Mode Fault error occur
    918               6. SPI_I2S_FLAG_OVR : to indicate if an Overrun error occur
    919               7. I2S_FLAG_TIFRFE: to indicate a Frame Format error occurs.
    920               8. I2S_FLAG_UDR: to indicate an Underrun error occurs.
    921               9. I2S_FLAG_CHSIDE: to indicate Channel Side.
    922          
    923          @note Do not use the BSY flag to handle each data transmission or reception.  It is
    924                better to use the TXE and RXNE flags instead.
    925          
    926            In this Mode it is advised to use the following functions:
    927               - FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
    928               - void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
    929          
    930            Interrupt Mode
    931            ===============
    932            In Interrupt Mode, the SPI communication can be managed by 3 interrupt sources
    933            and 7 pending bits: 
    934            Pending Bits:
    935            ------------- 
    936               1. SPI_I2S_IT_TXE : to indicate the status of the transmit buffer register
    937               2. SPI_I2S_IT_RXNE : to indicate the status of the receive buffer register
    938               3. SPI_IT_CRCERR : to indicate if a CRC Calculation error occur (available in SPI mode only)            
    939               4. SPI_IT_MODF : to indicate if a Mode Fault error occur (available in SPI mode only)
    940               5. SPI_I2S_IT_OVR : to indicate if an Overrun error occur
    941               6. I2S_IT_UDR : to indicate an Underrun Error occurs (available in I2S mode only).
    942               7. I2S_FLAG_TIFRFE : to indicate a Frame Format error occurs (available in TI mode only).
    943          
    944            Interrupt Source:
    945            -----------------
    946               1. SPI_I2S_IT_TXE: specifies the interrupt source for the Tx buffer empty 
    947                                  interrupt.  
    948               2. SPI_I2S_IT_RXNE : specifies the interrupt source for the Rx buffer not 
    949                                    empty interrupt.
    950               3. SPI_I2S_IT_ERR : specifies the interrupt source for the errors interrupt.
    951          
    952            In this Mode it is advised to use the following functions:
    953               - void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
    954               - ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
    955               - void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
    956          
    957            DMA Mode
    958            ========
    959            In DMA Mode, the SPI communication can be managed by 2 DMA Channel requests:
    960               1. SPI_I2S_DMAReq_Tx: specifies the Tx buffer DMA transfer request
    961               2. SPI_I2S_DMAReq_Rx: specifies the Rx buffer DMA transfer request
    962          
    963            In this Mode it is advised to use the following function:
    964              - void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState);
    965          
    966          @endverbatim
    967            * @{
    968            */
    969          
    970          /**
    971            * @brief  Enables or disables the specified SPI/I2S interrupts.
    972            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
    973            *         in SPI mode or 2 or 3 in I2S mode.  
    974            * @param  SPI_I2S_IT: specifies the SPI interrupt source to be enabled or disabled. 
    975            *          This parameter can be one of the following values:
    976            *            @arg SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
    977            *            @arg SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
    978            *            @arg SPI_I2S_IT_ERR: Error interrupt mask
    979            * @param  NewState: new state of the specified SPI interrupt.
    980            *          This parameter can be: ENABLE or DISABLE.
    981            * @retval None
    982            */
    983          void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
    984          {
    985            uint16_t itpos = 0, itmask = 0 ;
    986            
    987            /* Check the parameters */
    988            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    989            assert_param(IS_FUNCTIONAL_STATE(NewState));
    990            assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
    991          
    992            /* Get the SPI IT index */
    993            itpos = SPI_I2S_IT >> 4;
    994          
    995            /* Set the IT mask */
    996            itmask = (uint16_t)1 << (uint16_t)itpos;
    997          
    998            if (NewState != DISABLE)
    999            {
   1000              /* Enable the selected SPI interrupt */
   1001              SPIx->CR2 |= itmask;
   1002            }
   1003            else
   1004            {
   1005              /* Disable the selected SPI interrupt */
   1006              SPIx->CR2 &= (uint16_t)~itmask;
   1007            }
   1008          }
   1009          
   1010          /**
   1011            * @brief  Checks whether the specified SPIx/I2Sx flag is set or not.
   1012            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1013            *         in SPI mode or 2 or 3 in I2S mode. 
   1014            * @param  SPI_I2S_FLAG: specifies the SPI flag to check. 
   1015            *          This parameter can be one of the following values:
   1016            *            @arg SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
   1017            *            @arg SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
   1018            *            @arg SPI_I2S_FLAG_BSY: Busy flag.
   1019            *            @arg SPI_I2S_FLAG_OVR: Overrun flag.
   1020            *            @arg SPI_FLAG_MODF: Mode Fault flag.
   1021            *            @arg SPI_FLAG_CRCERR: CRC Error flag.
   1022            *            @arg SPI_I2S_FLAG_TIFRFE: Format Error.
   1023            *            @arg I2S_FLAG_UDR: Underrun Error flag.
   1024            *            @arg I2S_FLAG_CHSIDE: Channel Side flag.  
   1025            * @retval The new state of SPI_I2S_FLAG (SET or RESET).
   1026            */
   1027          FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
   1028          {
   1029            FlagStatus bitstatus = RESET;
   1030            /* Check the parameters */
   1031            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1032            assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
   1033            
   1034            /* Check the status of the specified SPI flag */
   1035            if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
   1036            {
   1037              /* SPI_I2S_FLAG is set */
   1038              bitstatus = SET;
   1039            }
   1040            else
   1041            {
   1042              /* SPI_I2S_FLAG is reset */
   1043              bitstatus = RESET;
   1044            }
   1045            /* Return the SPI_I2S_FLAG status */
   1046            return  bitstatus;
   1047          }
   1048          
   1049          /**
   1050            * @brief  Clears the SPIx CRC Error (CRCERR) flag.
   1051            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1052            *         in SPI mode or 2 or 3 in I2S mode. 
   1053            * @param  SPI_I2S_FLAG: specifies the SPI flag to clear. 
   1054            *          This function clears only CRCERR flag.
   1055            *            @arg SPI_FLAG_CRCERR: CRC Error flag.  
   1056            *  
   1057            * @note   OVR (OverRun error) flag is cleared by software sequence: a read 
   1058            *          operation to SPI_DR register (SPI_I2S_ReceiveData()) followed by a read 
   1059            *          operation to SPI_SR register (SPI_I2S_GetFlagStatus()).
   1060            * @note   UDR (UnderRun error) flag is cleared by a read operation to 
   1061            *          SPI_SR register (SPI_I2S_GetFlagStatus()).   
   1062            * @note   MODF (Mode Fault) flag is cleared by software sequence: a read/write 
   1063            *          operation to SPI_SR register (SPI_I2S_GetFlagStatus()) followed by a 
   1064            *          write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
   1065            *  
   1066            * @retval None
   1067            */
   1068          void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
   1069          {
   1070            /* Check the parameters */
   1071            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1072            assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
   1073              
   1074            /* Clear the selected SPI CRC Error (CRCERR) flag */
   1075            SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
   1076          }
   1077          
   1078          /**
   1079            * @brief  Checks whether the specified SPIx/I2Sx interrupt has occurred or not.
   1080            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1081            *         in SPI mode or 2 or 3 in I2S mode.   
   1082            * @param  SPI_I2S_IT: specifies the SPI interrupt source to check. 
   1083            *          This parameter can be one of the following values:
   1084            *            @arg SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
   1085            *            @arg SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
   1086            *            @arg SPI_I2S_IT_OVR: Overrun interrupt.
   1087            *            @arg SPI_IT_MODF: Mode Fault interrupt.
   1088            *            @arg SPI_IT_CRCERR: CRC Error interrupt.
   1089            *            @arg I2S_IT_UDR: Underrun interrupt.  
   1090            *            @arg SPI_I2S_IT_TIFRFE: Format Error interrupt.  
   1091            * @retval The new state of SPI_I2S_IT (SET or RESET).
   1092            */
   1093          ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
   1094          {
   1095            ITStatus bitstatus = RESET;
   1096            uint16_t itpos = 0, itmask = 0, enablestatus = 0;
   1097          
   1098            /* Check the parameters */
   1099            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1100            assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
   1101          
   1102            /* Get the SPI_I2S_IT index */
   1103            itpos = 0x01 << (SPI_I2S_IT & 0x0F);
   1104          
   1105            /* Get the SPI_I2S_IT IT mask */
   1106            itmask = SPI_I2S_IT >> 4;
   1107          
   1108            /* Set the IT mask */
   1109            itmask = 0x01 << itmask;
   1110          
   1111            /* Get the SPI_I2S_IT enable bit status */
   1112            enablestatus = (SPIx->CR2 & itmask) ;
   1113          
   1114            /* Check the status of the specified SPI interrupt */
   1115            if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
   1116            {
   1117              /* SPI_I2S_IT is set */
   1118              bitstatus = SET;
   1119            }
   1120            else
   1121            {
   1122              /* SPI_I2S_IT is reset */
   1123              bitstatus = RESET;
   1124            }
   1125            /* Return the SPI_I2S_IT status */
   1126            return bitstatus;
   1127          }
   1128          
   1129          /**
   1130            * @brief  Clears the SPIx CRC Error (CRCERR) interrupt pending bit.
   1131            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1132            *         in SPI mode or 2 or 3 in I2S mode.  
   1133            * @param  SPI_I2S_IT: specifies the SPI interrupt pending bit to clear.
   1134            *         This function clears only CRCERR interrupt pending bit.   
   1135            *            @arg SPI_IT_CRCERR: CRC Error interrupt.
   1136            *   
   1137            * @note   OVR (OverRun Error) interrupt pending bit is cleared by software 
   1138            *          sequence: a read operation to SPI_DR register (SPI_I2S_ReceiveData()) 
   1139            *          followed by a read operation to SPI_SR register (SPI_I2S_GetITStatus()).
   1140            * @note   UDR (UnderRun Error) interrupt pending bit is cleared by a read 
   1141            *          operation to SPI_SR register (SPI_I2S_GetITStatus()).   
   1142            * @note   MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
   1143            *          a read/write operation to SPI_SR register (SPI_I2S_GetITStatus()) 
   1144            *          followed by a write operation to SPI_CR1 register (SPI_Cmd() to enable 
   1145            *          the SPI).
   1146            * @retval None
   1147            */
   1148          void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
   1149          {
   1150            uint16_t itpos = 0;
   1151            /* Check the parameters */
   1152            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1153            assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
   1154          
   1155            /* Get the SPI_I2S IT index */
   1156            itpos = 0x01 << (SPI_I2S_IT & 0x0F);
   1157          
   1158            /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
   1159            SPIx->SR = (uint16_t)~itpos;
   1160          }
   1161          
   1162          /**
   1163            * @}
   1164            */
   1165          
   1166          /**
   1167            * @}
   1168            */ 
   1169          
   1170          /**
   1171            * @}
   1172            */ 
   1173          
   1174          /**
   1175            * @}
   1176            */ 
   1177          
   1178          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   I2S_Cmd
      40   I2S_Init
       0   I2S_StructInit
       0   SPI_BiDirectionalLineConfig
       0   SPI_CalculateCRC
       0   SPI_Cmd
       0   SPI_DataSizeConfig
       0   SPI_GetCRC
       0   SPI_GetCRCPolynomial
       0   SPI_I2S_ClearFlag
       4   SPI_I2S_ClearITPendingBit
       0   SPI_I2S_DMACmd
       8   SPI_I2S_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       0   SPI_I2S_GetFlagStatus
      20   SPI_I2S_GetITStatus
      16   SPI_I2S_ITConfig
       0   SPI_I2S_ReceiveData
       0   SPI_I2S_SendData
       8   SPI_Init
       0   SPI_NSSInternalSoftwareConfig
       0   SPI_SSOutputCmd
       0   SPI_StructInit
       0   SPI_TIModeCmd
       0   SPI_TransmitCRC


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
      30  I2S_Cmd
     394  I2S_Init
      26  I2S_StructInit
      32  SPI_BiDirectionalLineConfig
      30  SPI_CalculateCRC
      30  SPI_Cmd
      18  SPI_DataSizeConfig
      22  SPI_GetCRC
       4  SPI_GetCRCPolynomial
      10  SPI_I2S_ClearFlag
      26  SPI_I2S_ClearITPendingBit
      24  SPI_I2S_DMACmd
      88  SPI_I2S_DeInit
      20  SPI_I2S_GetFlagStatus
      68  SPI_I2S_GetITStatus
      44  SPI_I2S_ITConfig
       4  SPI_I2S_ReceiveData
       4  SPI_I2S_SendData
      62  SPI_Init
      30  SPI_NSSInternalSoftwareConfig
      30  SPI_SSOutputCmd
      38  SPI_StructInit
      30  SPI_TIModeCmd
      10  SPI_TransmitCRC

 
 1'102 bytes in section .text
 
 1'102 bytes of CODE memory

Errors: none
Warnings: none
