###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         16/Oct/2021  20:54:58
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\report.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EW210E.tmp
#        (D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\report.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -D MSTEP_BRD -D
#        USE_USB_OTG_FS -D STM32F205xx -lcN
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\.\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\dbg\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\core\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\drv\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\hdlc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\cdc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\ -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\List\report.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\Obj\report.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\report.c
      1          /*
      2            report.c - reporting and messaging methods
      3            Part of Grbl
      4          
      5            Copyright (c) 2012-2016 Sungeun K. Jeon for Gnea Research LLC
      6          
      7            Grbl is free software: you can redistribute it and/or modify
      8            it under the terms of the GNU General Public License as published by
      9            the Free Software Foundation, either version 3 of the License, or
     10            (at your option) any later version.
     11          
     12            Grbl is distributed in the hope that it will be useful,
     13            but WITHOUT ANY WARRANTY; without even the implied warranty of
     14            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15            GNU General Public License for more details.
     16          
     17            You should have received a copy of the GNU General Public License
     18            along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
     19          */
     20          
     21          /*
     22            This file functions as the primary feedback interface for Grbl. Any outgoing data, such
     23            as the protocol status messages, feedback messages, and status reports, are stored here.
     24            For the most part, these functions primarily are called from protocol.c methods. If a
     25            different style feedback is desired (i.e. JSON), then a user can change these following
     26            methods to accomodate their needs.
     27          */
     28          
     29          #include "my_grbl.h"
     30          
     31          extern uint8_t serial_get_rx_buffer_available();
     32          extern uint8_t system_control_get_state();
     33          
     34          // Internal report utilities to reduce flash with repetitive tasks turned into functions.
     35          void report_util_setting_prefix(uint8_t n) { serial_write('$'); print_uint8_base10(n); serial_write('='); }
     36          static void report_util_line_feed() { printPgmString(PSTR("\r\n")); }
     37          static void report_util_feedback_line_feed() { serial_write(']'); report_util_line_feed(); }
     38          static void report_util_gcode_modes_G() { printPgmString(PSTR(" G")); }
     39          static void report_util_gcode_modes_M() { printPgmString(PSTR(" M")); }
     40          // static void report_util_comment_line_feed() { serial_write(')'); report_util_line_feed(); }
     41          static void report_util_axis_values(float *axis_value) {
     42            uint8_t idx;
     43            for (idx=0; idx<N_AXIS; idx++) {
     44              printFloat_CoordValue(axis_value[idx]);
     45              if (idx < (N_AXIS-1)) { serial_write(','); }
     46            }
     47          }
     48          
     49          /*
     50          static void report_util_setting_string(uint8_t n) {
     51            serial_write(' ');
     52            serial_write('(');
     53            switch(n) {
     54              case 0: printPgmString(PSTR("stp pulse")); break;
     55              case 1: printPgmString(PSTR("idl delay")); break; 
     56              case 2: printPgmString(PSTR("stp inv")); break;
     57              case 3: printPgmString(PSTR("dir inv")); break;
     58              case 4: printPgmString(PSTR("stp en inv")); break;
     59              case 5: printPgmString(PSTR("lim inv")); break;
     60              case 6: printPgmString(PSTR("prb inv")); break;
     61              case 10: printPgmString(PSTR("rpt")); break;
     62              case 11: printPgmString(PSTR("jnc dev")); break;
     63              case 12: printPgmString(PSTR("arc tol")); break;
     64              case 13: printPgmString(PSTR("rpt inch")); break;
     65              case 20: printPgmString(PSTR("sft lim")); break;
     66              case 21: printPgmString(PSTR("hrd lim")); break;
     67              case 22: printPgmString(PSTR("hm cyc")); break;
     68              case 23: printPgmString(PSTR("hm dir inv")); break;
     69              case 24: printPgmString(PSTR("hm feed")); break;
     70              case 25: printPgmString(PSTR("hm seek")); break;
     71              case 26: printPgmString(PSTR("hm delay")); break;
     72              case 27: printPgmString(PSTR("hm pulloff")); break;
     73              case 30: printPgmString(PSTR("rpm max")); break;
     74              case 31: printPgmString(PSTR("rpm min")); break;
     75              case 32: printPgmString(PSTR("laser")); break;
     76              default:
     77                n -= AXIS_SETTINGS_START_VAL;
     78                uint8_t idx = 0;
     79                while (n >= AXIS_SETTINGS_INCREMENT) {
     80                  n -= AXIS_SETTINGS_INCREMENT;
     81                  idx++;
     82                }
     83                serial_write(n+'x');
     84                switch (idx) {
     85                  case 0: printPgmString(PSTR(":stp/mm")); break;
     86                  case 1: printPgmString(PSTR(":mm/min")); break;
     87                  case 2: printPgmString(PSTR(":mm/s^2")); break;
     88                  case 3: printPgmString(PSTR(":mm max")); break;
     89                }
     90                break;
     91            }
     92            report_util_comment_line_feed();
     93          }
     94          */
     95          
     96          static void report_util_uint8_setting(uint8_t n, int val) {
     97            report_util_setting_prefix(n);
     98            print_uint8_base10(val);
     99            report_util_line_feed(); // report_util_setting_string(n); 
    100          }
    101          static void report_util_float_setting(uint8_t n, float val, uint8_t n_decimal) {
    102            report_util_setting_prefix(n);
    103            printFloat(val, n_decimal);
    104            report_util_line_feed(); // report_util_setting_string(n);
    105          }
    106          
    107          // Handles the primary confirmation protocol response for streaming interfaces and human-feedback.
    108          // For every incoming line, this method responds with an 'ok' for a successful command or an
    109          // 'error:'  to indicate some error event with the line or some critical system error during
    110          // operation. Errors events can originate from the g-code parser, settings module, or asynchronously
    111          // from a critical error, such as a triggered hard limit. Interface should always monitor for these
    112          // responses.
    113          void report_status_message(uint8_t status_code)
    114          {
    115            switch(status_code) {
    116              case STATUS_OK: // STATUS_OK
    117                printPgmString(PSTR("ok\r\n")); break;
    118              default:
    119                printPgmString(PSTR("error:"));
    120                print_uint8_base10(status_code);
    121                report_util_line_feed();
    122            }
    123          }
    124          
    125          // Prints alarm messages.
    126          void report_alarm_message(uint8_t alarm_code)
    127          {
    128            printPgmString(PSTR("ALARM:"));
    129            print_uint8_base10(alarm_code);
    130            report_util_line_feed();
    131            delay__ms(500); // Force delay to ensure message clears serial write buffer.
    132          }
    133          
    134          // Prints feedback messages. This serves as a centralized method to provide additional
    135          // user feedback for things that are not of the status/alarm message protocol. These are
    136          // messages such as setup warnings, switch toggling, and how to exit alarms.
    137          // NOTE: For interfaces, messages are always placed within brackets. And if silent mode
    138          // is installed, the message number codes are less than zero.
    139          void report_feedback_message(uint8_t message_code)
    140          {
    141            printPgmString(PSTR("[MSG:"));
    142            switch(message_code) {
    143              case MESSAGE_CRITICAL_EVENT:
    144                printPgmString(PSTR("Reset to continue")); break;
    145              case MESSAGE_ALARM_LOCK:
    146                printPgmString(PSTR("'$H'|'$X' to unlock")); break;
    147              case MESSAGE_ALARM_UNLOCK:
    148                printPgmString(PSTR("Caution: Unlocked")); break;
    149              case MESSAGE_ENABLED:
    150                printPgmString(PSTR("Enabled")); break;
    151              case MESSAGE_DISABLED:
    152                printPgmString(PSTR("Disabled")); break;
    153              case MESSAGE_SAFETY_DOOR_AJAR:
    154                printPgmString(PSTR("Check Door")); break;
    155              case MESSAGE_CHECK_LIMITS:
    156                printPgmString(PSTR("Check Limits")); break;
    157              case MESSAGE_PROGRAM_END:
    158                printPgmString(PSTR("Pgm End")); break;
    159              case MESSAGE_RESTORE_DEFAULTS:
    160                printPgmString(PSTR("Restoring defaults")); break;
    161              case MESSAGE_SPINDLE_RESTORE:
    162                printPgmString(PSTR("Restoring spindle")); break;
    163              case MESSAGE_SLEEP_MODE:
    164                printPgmString(PSTR("Sleeping")); break;
    165            }
    166            report_util_feedback_line_feed();
    167          }
    168          
    169          
    170          // Welcome message
    171          void _report_init_message()
    172          {
    173            printPgmString(PSTR("\r\nGrbl " GRBL_VERSION " ['$' for help]\r\n"));
    174          }
    175          
    176          // Grbl help message
    177          void report_grbl_help() {
    178            printPgmString(PSTR("[HLP:$$ $# $G $I $N $x=val $Nx=line $J=line $SLP $C $X $H ~ ! ? ctrl-x]\r\n"));    
    179          }
    180          
    181          
    182          // Grbl global settings print out.
    183          // NOTE: The numbering scheme here must correlate to storing in settings.c
    184          void report_grbl_settings() {
    185            // Print Grbl settings.
    186            report_util_uint8_setting(0,settings.pulse_microseconds);
    187            report_util_uint8_setting(1,settings.stepper_idle_lock_time);
    188            report_util_uint8_setting(2,settings.step_invert_mask);
    189            report_util_uint8_setting(3,settings.dir_invert_mask);
    190            report_util_uint8_setting(4,bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE));
    191            report_util_uint8_setting(5,bit_istrue(settings.flags,BITFLAG_INVERT_LIMIT_PINS));
    192            report_util_uint8_setting(6,bit_istrue(settings.flags,BITFLAG_INVERT_PROBE_PIN));
    193            report_util_uint8_setting(10,settings.status_report_mask);
    194            report_util_float_setting(11,settings.junction_deviation,N_DECIMAL_SETTINGVALUE);
    195            report_util_float_setting(12,settings.arc_tolerance,N_DECIMAL_SETTINGVALUE);
    196            report_util_uint8_setting(13,bit_istrue(settings.flags,BITFLAG_REPORT_INCHES));
    197            report_util_uint8_setting(20,bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE));
    198            report_util_uint8_setting(21,bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE));
    199            report_util_uint8_setting(22,bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE));
    200            report_util_uint8_setting(23,settings.homing_dir_mask);
    201            report_util_float_setting(24,settings.homing_feed_rate,N_DECIMAL_SETTINGVALUE);
    202            report_util_float_setting(25,settings.homing_seek_rate,N_DECIMAL_SETTINGVALUE);
    203            report_util_uint8_setting(26,settings.homing_debounce_delay);
    204            report_util_float_setting(27,settings.homing_pulloff,N_DECIMAL_SETTINGVALUE);
    205            report_util_float_setting(30,settings.rpm_max,N_DECIMAL_RPMVALUE);
    206            report_util_float_setting(31,settings.rpm_min,N_DECIMAL_RPMVALUE);
    207            #ifdef VARIABLE_SPINDLE
    208              report_util_uint8_setting(32,bit_istrue(settings.flags,BITFLAG_LASER_MODE));
    209            #else
    210              report_util_uint8_setting(32,0);
    211            #endif
    212            // Print axis settings
    213            uint8_t idx, set_idx;
    214            uint8_t val = AXIS_SETTINGS_START_VAL;
    215            for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    216              for (idx=0; idx<N_AXIS; idx++) {
    217                switch (set_idx) {
    218                  case 0: report_util_float_setting(val+idx,settings.steps_per_mm[idx],N_DECIMAL_SETTINGVALUE); break;
    219                  case 1: report_util_float_setting(val+idx,settings.max_rate[idx],N_DECIMAL_SETTINGVALUE); break;
    220                  case 2: report_util_float_setting(val+idx,settings.acceleration[idx]/(60*60),N_DECIMAL_SETTINGVALUE); break;
    221                  case 3: report_util_float_setting(val+idx,-settings.max_travel[idx],N_DECIMAL_SETTINGVALUE); break;
    222                }
    223              }
    224              val += AXIS_SETTINGS_INCREMENT;
    225            }
    226          }
    227          
    228          
    229          // Prints current probe parameters. Upon a probe command, these parameters are updated upon a
    230          // successful probe or upon a failed probe with the G38.3 without errors command (if supported).
    231          // These values are retained until Grbl is power-cycled, whereby they will be re-zeroed.
    232          void report_probe_parameters()
    233          {
    234            // Report in terms of machine position.
    235            printPgmString(PSTR("[PRB:"));
    236            float print_position[N_AXIS];
    237            system_convert_array_steps_to_mpos(print_position,sys_probe_position);
    238            report_util_axis_values(print_position);
    239            serial_write(':');
    240            print_uint8_base10(sys.probe_succeeded);
    241            report_util_feedback_line_feed();
    242          }
    243          
    244          
    245          // Prints Grbl NGC parameters (coordinate offsets, probing)
    246          void report_ngc_parameters()
    247          {
    248            float coord_data[N_AXIS];
    249            uint8_t coord_select;
    250            for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) {
    251              if (!(settings_read_coord_data(coord_select,coord_data))) {
    252                report_status_message(STATUS_SETTING_READ_FAIL);
    253                return;
    254              }
    255              printPgmString(PSTR("[G"));
    256              switch (coord_select) {
    257                case 6: printPgmString(PSTR("28")); break;
    258                case 7: printPgmString(PSTR("30")); break;
    259                default: print_uint8_base10(coord_select+54); break; // G54-G59
    260              }
    261              serial_write(':');
    262              report_util_axis_values(coord_data);
    263              report_util_feedback_line_feed();
    264            }
    265            printPgmString(PSTR("[G92:")); // Print G92,G92.1 which are not persistent in memory
    266            report_util_axis_values(gc_state.coord_offset);
    267            report_util_feedback_line_feed();
    268            printPgmString(PSTR("[TLO:")); // Print tool length offset value
    269            printFloat_CoordValue(gc_state.tool_length_offset);
    270            report_util_feedback_line_feed();
    271            report_probe_parameters(); // Print probe parameters. Not persistent in memory.
    272          }
    273          
    274          
    275          // Print current gcode parser mode state
    276          void report_gcode_modes()
    277          {
    278            printPgmString(PSTR("[GC:G"));
    279            if (gc_state.modal.motion >= MOTION_MODE_PROBE_TOWARD) {
    280              printPgmString(PSTR("38."));
    281              print_uint8_base10(gc_state.modal.motion - (MOTION_MODE_PROBE_TOWARD-2));
    282            } else {
    283              print_uint8_base10(gc_state.modal.motion);
    284            }
    285          
    286            report_util_gcode_modes_G();
    287            print_uint8_base10(gc_state.modal.coord_select+54);
    288          
    289            report_util_gcode_modes_G();
    290            print_uint8_base10(gc_state.modal.plane_select+17);
    291          
    292            report_util_gcode_modes_G();
    293            print_uint8_base10(21-gc_state.modal.units);
    294          
    295            report_util_gcode_modes_G();
    296            print_uint8_base10(gc_state.modal.distance+90);
    297          
    298            report_util_gcode_modes_G();
    299            print_uint8_base10(94-gc_state.modal.feed_rate);
    300          
    301            if (gc_state.modal.program_flow) {
    302              report_util_gcode_modes_M();
    303              switch (gc_state.modal.program_flow) {
    304                case PROGRAM_FLOW_PAUSED : serial_write('0'); break;
    305                // case PROGRAM_FLOW_OPTIONAL_STOP : serial_write('1'); break; // M1 is ignored and not supported.
    306                case PROGRAM_FLOW_COMPLETED_M2 : 
    307                case PROGRAM_FLOW_COMPLETED_M30 : 
    308                  print_uint8_base10(gc_state.modal.program_flow);
    309                  break;
    310              }
    311            }
    312          
    313            report_util_gcode_modes_M();
    314            switch (gc_state.modal.spindle) {
    315              case SPINDLE_ENABLE_CW : serial_write('3'); break;
    316              case SPINDLE_ENABLE_CCW : serial_write('4'); break;
    317              case SPINDLE_DISABLE : serial_write('5'); break;
    318            }
    319          
    320            report_util_gcode_modes_M();
    321            #ifdef ENABLE_M7
    322              if (gc_state.modal.coolant) { // Note: Multiple coolant states may be active at the same time.
    323                if (gc_state.modal.coolant & PL_COND_FLAG_COOLANT_MIST) { report_util_gcode_modes_M(); serial_write('7'); }
    324                if (gc_state.modal.coolant & PL_COND_FLAG_COOLANT_FLOOD) { report_util_gcode_modes_M(); serial_write('8'); }
    325              } else { report_util_gcode_modes_M(); serial_write('9'); }
    326            #else
    327              report_util_gcode_modes_M();
    328              if (gc_state.modal.coolant) { serial_write('8'); }
    329              else { serial_write('9'); }
    330            #endif
    331          
    332          	#ifdef ENABLE_PARKING_OVERRIDE_CONTROL
    333          		if (sys.override_ctrl == OVERRIDE_PARKING_MOTION) {
    334          			report_util_gcode_modes_M();
    335          			print_uint8_base10(56);
    336          		}
    337          	#endif
    338          
    339            printPgmString(PSTR(" T"));
    340            print_uint8_base10(gc_state.tool);
    341          
    342            printPgmString(PSTR(" F"));
    343            printFloat_RateValue(gc_state.feed_rate);
    344          
    345            #ifdef VARIABLE_SPINDLE
    346              printPgmString(PSTR(" S"));
    347              printFloat(gc_state.spindle_speed,N_DECIMAL_RPMVALUE);
    348            #endif
    349          
    350            report_util_feedback_line_feed();
    351          }
    352          
    353          // Prints specified startup line
    354          void report_startup_line(uint8_t n, char *line)
    355          {
    356            printPgmString(PSTR("$N"));
    357            print_uint8_base10(n);
    358            serial_write('=');
    359            printString(line);
    360            report_util_line_feed();
    361          }
    362          
    363          void report_execute_startup_message(char *line, uint8_t status_code)
    364          {
    365            serial_write('>');
    366            printString(line);
    367            serial_write(':');
    368            report_status_message(status_code);
    369          }
    370          
    371          // Prints build info line
    372          void report_build_info(char *line)
    373          {
    374            printPgmString(PSTR("[VER:" GRBL_VERSION "." GRBL_VERSION_BUILD ":"));
    375            printString(line);
    376            report_util_feedback_line_feed();
    377            printPgmString(PSTR("[OPT:")); // Generate compile-time build option list
    378            #ifdef VARIABLE_SPINDLE
    379              serial_write('V');
    380            #endif
    381            #ifdef USE_LINE_NUMBERS
    382              serial_write('N');
    383            #endif
    384            #ifdef ENABLE_M7
    385              serial_write('M');
    386            #endif
    387            #ifdef COREXY
    388              serial_write('C');
    389            #endif
    390            #ifdef PARKING_ENABLE
    391              serial_write('P');
    392            #endif
    393            #ifdef HOMING_FORCE_SET_ORIGIN
    394              serial_write('Z');
    395            #endif
    396            #ifdef HOMING_SINGLE_AXIS_COMMANDS
    397              serial_write('H');
    398            #endif
    399            #ifdef LIMITS_TWO_SWITCHES_ON_AXES
    400              serial_write('T');
    401            #endif
    402            #ifdef ALLOW_FEED_OVERRIDE_DURING_PROBE_CYCLES
    403              serial_write('A');
    404            #endif
    405          	#ifdef USE_SPINDLE_DIR_AS_ENABLE_PIN
    406          		serial_write('D');
    407          	#endif
    408          	#ifdef SPINDLE_ENABLE_OFF_WITH_ZERO_SPEED
    409          		serial_write('0');
    410          	#endif
    411          	#ifdef ENABLE_SOFTWARE_DEBOUNCE
    412          		serial_write('S');
    413          	#endif
    414          	#ifdef ENABLE_PARKING_OVERRIDE_CONTROL
    415          		serial_write('R');
    416          	#endif
    417          	#ifndef ENABLE_RESTORE_EEPROM_WIPE_ALL // NOTE: Shown when disabled.
    418              serial_write('*');
    419            #endif
    420            #ifndef ENABLE_RESTORE_EEPROM_DEFAULT_SETTINGS // NOTE: Shown when disabled.
    421              serial_write('$');
    422            #endif
    423            #ifndef ENABLE_RESTORE_EEPROM_CLEAR_PARAMETERS // NOTE: Shown when disabled.
    424              serial_write('#');
    425            #endif
    426            #ifndef ENABLE_BUILD_INFO_WRITE_COMMAND // NOTE: Shown when disabled.
    427              serial_write('I');
    428            #endif
    429            #ifndef FORCE_BUFFER_SYNC_DURING_EEPROM_WRITE // NOTE: Shown when disabled.
    430              serial_write('E');
    431            #endif
    432            #ifndef FORCE_BUFFER_SYNC_DURING_WCO_CHANGE // NOTE: Shown when disabled.
    433              serial_write('W');
    434            #endif
    435          	#ifndef HOMING_INIT_LOCK
    436          		serial_write('L');
    437          	#endif
    438          
    439            // NOTE: Compiled values, like override increments/max/min values, may be added at some point later.
    440          	serial_write(',');
    441          	print_uint8_base10(BLOCK_BUFFER_SIZE - 1);
    442          	serial_write(',');
    443          	print_uint8_base10(RX_BUFFER_SIZE);
    444          
    445          	report_util_feedback_line_feed();
    446          }
    447          
    448          
    449          // Prints the character string line Grbl has received from the user, which has been pre-parsed,
    450          // and has been sent into protocol_execute_line() routine to be executed by Grbl.
    451          void report_echo_line_received(char *line)
    452          {
    453            printPgmString(PSTR("[echo: ")); printString(line);
    454            report_util_feedback_line_feed();
    455          }
    456          
    457          
    458           // Prints real-time data. This function grabs a real-time snapshot of the stepper subprogram
    459           // and the actual location of the CNC machine. Users may change the following function to their
    460           // specific needs, but the desired real-time data report must be as short as possible. This is
    461           // requires as it minimizes the computational overhead and allows grbl to keep running smoothly,
    462           // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
    463          void report_realtime_status()
    464          {
    465            uint8_t idx;
    466            int32_t current_position[N_AXIS]; // Copy current state of the system position variable
    467            memcpy(current_position, sys_position, sizeof(sys_position));
    468            float print_position[N_AXIS];
    469            system_convert_array_steps_to_mpos(print_position, current_position);
    470          
    471            // Report current machine state and sub-states
    472            serial_write('<');
    473            switch (sys.state) {
    474            case STATE_IDLE: printPgmString(PSTR("Idle")); break;
    475            case STATE_CYCLE: printPgmString(PSTR("Run")); break;
    476            case STATE_HOLD:
    477              if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
    478                printPgmString(PSTR("Hold:"));
    479                if (sys.suspend & SUSPEND_HOLD_COMPLETE) { serial_write('0'); } // Ready to resume
    480                else { serial_write('1'); } // Actively holding
    481                break;
    482              } // Continues to print jog state during jog cancel.
    483            case STATE_JOG: printPgmString(PSTR("Jog")); break;
    484            case STATE_HOMING: printPgmString(PSTR("Home")); break;
    485            case STATE_ALARM: printPgmString(PSTR("Alarm")); break;
    486            case STATE_CHECK_MODE: printPgmString(PSTR("Check")); break;
    487            case STATE_SAFETY_DOOR:
    488              printPgmString(PSTR("Door:"));
    489              if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
    490                serial_write('3'); // Restoring
    491              }
    492              else {
    493                if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
    494                  if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) {
    495                    serial_write('1'); // Door ajar
    496                  }
    497                  else {
    498                    serial_write('0');
    499                  } // Door closed and ready to resume
    500                }
    501                else {
    502                  serial_write('2'); // Retracting
    503                }
    504              }
    505              break;
    506            case STATE_SLEEP: printPgmString(PSTR("Sleep")); break;
    507            }
    508          
    509            float wco[N_AXIS];
    510            if (bit_isfalse(settings.status_report_mask, BITFLAG_RT_STATUS_POSITION_TYPE) ||
    511              (sys.report_wco_counter == 0)) {
    512              for (idx = 0; idx< N_AXIS; idx++) {
    513                // Apply work coordinate offsets and tool length offset to current position.
    514                wco[idx] = gc_state.coord_system[idx] + gc_state.coord_offset[idx];
    515                if (idx == TOOL_LENGTH_OFFSET_AXIS) { wco[idx] += gc_state.tool_length_offset; }
    516                if (bit_isfalse(settings.status_report_mask, BITFLAG_RT_STATUS_POSITION_TYPE)) {
    517                  print_position[idx] -= wco[idx];
    518                }
    519              }
    520            }
    521          
    522            // Report machine position
    523            if (bit_istrue(settings.status_report_mask, BITFLAG_RT_STATUS_POSITION_TYPE)) {
    524              printPgmString(PSTR("|MPos:"));
    525            }
    526            else {
    527              printPgmString(PSTR("|WPos:"));
    528            }
    529            report_util_axis_values(print_position);
    530          
    531            // Returns planner and serial read buffer states.
    532          #ifdef REPORT_FIELD_BUFFER_STATE
    533            if (bit_istrue(settings.status_report_mask, BITFLAG_RT_STATUS_BUFFER_STATE)) {
    534              printPgmString(PSTR("|Bf:"));
    535              print_uint8_base10(plan_get_block_buffer_available());
    536              serial_write(',');
    537              print_uint8_base10(serial_get_rx_buffer_available());
    538            }
    539          #endif
    540          
    541          #ifdef USE_LINE_NUMBERS
    542          #ifdef REPORT_FIELD_LINE_NUMBERS
    543            // Report current line number
    544            plan_block_t * cur_block = plan_get_current_block();
    545            if (cur_block != NULL) {
    546              uint32_t ln = cur_block->line_number;
    547              if (ln > 0) {
    548                printPgmString(PSTR("|Ln:"));
    549                printInteger(ln);
    550              }
    551            }
    552          #endif
    553          #endif
    554          
    555            // Report realtime feed speed
    556          #ifdef REPORT_FIELD_CURRENT_FEED_SPEED
    557          #ifdef VARIABLE_SPINDLE
    558            printPgmString(PSTR("|FS:"));
    559            printFloat_RateValue(st_get_realtime_rate());
    560            serial_write(',');
    561            printFloat(sys.spindle_speed, N_DECIMAL_RPMVALUE);
    562          #else
    563            printPgmString(PSTR("|F:"));
    564            printFloat_RateValue(st_get_realtime_rate());
    565          #endif      
    566          #endif
    567          
    568          #ifdef REPORT_FIELD_PIN_STATE
    569            uint8_t lim_pin_state = limits_get_state();
    570            uint8_t ctrl_pin_state = system_control_get_state();
    571            uint8_t prb_pin_state = probe_get_state();
    572            if (lim_pin_state | ctrl_pin_state | prb_pin_state) {
    573              printPgmString(PSTR("|Pn:"));
    574              if (prb_pin_state) { serial_write('P'); }
    575              if (lim_pin_state) {
    576                if (bit_istrue(lim_pin_state, bit(X_AXIS))) { serial_write('X'); }
    577                if (bit_istrue(lim_pin_state, bit(Y_AXIS))) { serial_write('Y'); }
    578                if (bit_istrue(lim_pin_state, bit(Z_AXIS))) { serial_write('Z'); }
    579              }
    580              if (ctrl_pin_state) {
    581          #ifdef ENABLE_SAFETY_DOOR_INPUT_PIN
    582                if (bit_istrue(ctrl_pin_state, CONTROL_PIN_INDEX_SAFETY_DOOR)) { serial_write('D'); }
    583          #endif
    584                if (bit_istrue(ctrl_pin_state, CONTROL_PIN_INDEX_RESET)) { serial_write('R'); }
    585                if (bit_istrue(ctrl_pin_state, CONTROL_PIN_INDEX_FEED_HOLD)) { serial_write('H'); }
    586                if (bit_istrue(ctrl_pin_state, CONTROL_PIN_INDEX_CYCLE_START)) { serial_write('S'); }
    587              }
    588            }
    589          #endif
    590          
    591          #ifdef REPORT_FIELD_WORK_COORD_OFFSET
    592            if (sys.report_wco_counter > 0) { sys.report_wco_counter--; }
    593            else {
    594              if (sys.state & (STATE_HOMING | STATE_CYCLE | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)) {
    595                sys.report_wco_counter = (REPORT_WCO_REFRESH_BUSY_COUNT - 1); // Reset counter for slow refresh
    596              }
    597              else { sys.report_wco_counter = (REPORT_WCO_REFRESH_IDLE_COUNT - 1); }
    598              if (sys.report_ovr_counter == 0) { sys.report_ovr_counter = 1; } // Set override on next report.
    599              printPgmString(PSTR("|WCO:"));
    600              report_util_axis_values(wco);
    601            }
    602          #endif
    603          
    604            #ifdef REPORT_FIELD_OVERRIDES
    605              if (sys.report_ovr_counter > 0) { sys.report_ovr_counter--; }
    606              else {
    607                if (sys.state & (STATE_HOMING | STATE_CYCLE | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)) {
    608                  sys.report_ovr_counter = (REPORT_OVR_REFRESH_BUSY_COUNT - 1); // Reset counter for slow refresh
    609                }
    610                else { sys.report_ovr_counter = (REPORT_OVR_REFRESH_IDLE_COUNT - 1); }
    611                printPgmString(PSTR("|Ov:"));
    612                print_uint8_base10(sys.f_override);
    613                serial_write(',');
    614                print_uint8_base10(sys.r_override);
    615                serial_write(',');
    616                print_uint8_base10(sys.spindle_speed_ovr);
    617          
    618                uint8_t sp_state = spindle_get_state();
    619                uint8_t cl_state = coolant_get_state();
    620                if (sp_state || cl_state) {
    621                  printPgmString(PSTR("|A:"));
    622                  if (sp_state) { // != SPINDLE_STATE_DISABLE
    623                    #ifdef VARIABLE_SPINDLE 
    624                      #ifdef USE_SPINDLE_DIR_AS_ENABLE_PIN
    625                        serial_write('S'); // CW
    626                      #else
    627                        if (sp_state == SPINDLE_STATE_CW) { serial_write('S'); } // CW
    628                        else { serial_write('C'); } // CCW
    629                      #endif
    630                    #else
    631                      if (sp_state & SPINDLE_STATE_CW) { serial_write('S'); } // CW
    632                      else { serial_write('C'); } // CCW
    633                    #endif
    634                  }
    635                  if (cl_state & COOLANT_STATE_FLOOD) { serial_write('F'); }
    636                  #ifdef ENABLE_M7
    637                    if (cl_state & COOLANT_STATE_MIST) { serial_write('M'); }
    638                  #endif
    639                }
    640              }
    641            #endif
    642          
    643            serial_write('>');
    644            report_util_line_feed();
    645          }
    646          
    647          
    648          #ifdef DEBUG
    649            void report_realtime_debug()
    650            {
    651          
    652            }
    653          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   _report_init_message
         8   -> printString
       8   report_alarm_message
         8   -> delay__ms
         8   -> printString
         8   -> print_uint8_base10
         8   -> report_util_line_feed
       8   report_build_info
         8   -> printString
         8   -> print_uint8_base10
         8   -> report_util_feedback_line_feed
         8   -> serial_write
       8   report_echo_line_received
         8   -> printString
         8   -> report_util_feedback_line_feed
      16   report_execute_startup_message
        16   -> printString
        16   -> report_status_message
        16   -> serial_write
       8   report_feedback_message
         8   -> printString
         8   -> report_util_feedback_line_feed
       8   report_gcode_modes
         8   -> printFloat
         8   -> printFloat_RateValue
         8   -> printString
         8   -> print_uint8_base10
         8   -> report_util_feedback_line_feed
         8   -> report_util_gcode_modes_G
         8   -> report_util_gcode_modes_M
         8   -> serial_write
       8   report_grbl_help
         8   -> printString
      24   report_grbl_settings
        24   -> __aeabi_fdiv
        24   -> report_util_float_setting
        24   -> report_util_uint8_setting
      24   report_ngc_parameters
        24   -> printFloat_CoordValue
        24   -> printString
        24   -> print_uint8_base10
        24   -> report_probe_parameters
        24   -> report_status_message
        24   -> report_util_axis_values
        24   -> report_util_feedback_line_feed
        24   -> serial_write
        24   -> settings_read_coord_data
      16   report_probe_parameters
        16   -> printString
        16   -> print_uint8_base10
        16   -> report_util_axis_values
        16   -> report_util_feedback_line_feed
        16   -> serial_write
        16   -> system_convert_array_steps_to_mpos
      64   report_realtime_status
        64   -> __aeabi_fadd
        64   -> __aeabi_fsub
        64   -> __aeabi_memcpy
        64   -> coolant_get_state
        64   -> limits_get_state
        64   -> plan_get_block_buffer_available
        64   -> printFloat
        64   -> printFloat_RateValue
        64   -> printString
        64   -> print_uint8_base10
        64   -> probe_get_state
        64   -> report_util_axis_values
        64   -> report_util_line_feed
        64   -> serial_get_rx_buffer_available
        64   -> serial_write
        64   -> spindle_get_state
        64   -> st_get_realtime_rate
        64   -> system_control_get_state
        64   -> system_convert_array_steps_to_mpos
      16   report_startup_line
        16   -> printString
        16   -> print_uint8_base10
        16   -> report_util_line_feed
        16   -> serial_write
       8   report_status_message
         8   -> printString
         8   -> print_uint8_base10
         8   -> report_util_line_feed
      16   report_util_axis_values
        16   -> printFloat_CoordValue
        16   -> serial_write
       8   report_util_feedback_line_feed
         8   -> report_util_line_feed
         8   -> serial_write
      16   report_util_float_setting
        16   -> printFloat
        16   -> report_util_line_feed
        16   -> report_util_setting_prefix
       8   report_util_gcode_modes_G
         8   -> printString
       8   report_util_gcode_modes_M
         8   -> printString
       8   report_util_line_feed
         8   -> printString
       8   report_util_setting_prefix
         8   -> print_uint8_base10
         8   -> serial_write
      16   report_util_uint8_setting
        16   -> print_uint8_base10
        16   -> report_util_line_feed
        16   -> report_util_setting_prefix


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_18
       4  ??DataTable16_19
       4  ??DataTable16_2
       4  ??DataTable16_20
       4  ??DataTable16_21
       4  ??DataTable16_22
       4  ??DataTable16_23
       4  ??DataTable16_24
       4  ??DataTable16_25
       4  ??DataTable16_26
       4  ??DataTable16_27
       4  ??DataTable16_28
       4  ??DataTable16_29
       4  ??DataTable16_3
       4  ??DataTable16_30
       4  ??DataTable16_31
       4  ??DataTable16_32
       4  ??DataTable16_33
       4  ??DataTable16_34
       4  ??DataTable16_35
       4  ??DataTable16_36
       4  ??DataTable16_37
       4  ??DataTable16_38
       4  ??DataTable16_39
       4  ??DataTable16_4
       4  ??DataTable16_40
       4  ??DataTable16_41
       4  ??DataTable16_42
       4  ??DataTable16_43
       4  ??DataTable16_44
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ?_0
       4  ?_1
       8  ?_10
      12  ?_11
      12  ?_12
      16  ?_13
       8  ?_14
      20  ?_15
      20  ?_16
      12  ?_17
      32  ?_18
      76  ?_19
       4  ?_2
       8  ?_20
       4  ?_21
       4  ?_22
       4  ?_23
       8  ?_24
       8  ?_25
       8  ?_26
       4  ?_27
       4  ?_28
       4  ?_29
       8  ?_3
       4  ?_30
       4  ?_31
      20  ?_32
       8  ?_33
       8  ?_34
       8  ?_35
       4  ?_36
       8  ?_37
       4  ?_38
       8  ?_39
       8  ?_4
       8  ?_40
       8  ?_41
       8  ?_42
       8  ?_43
       8  ?_44
       8  ?_45
       8  ?_46
       8  ?_47
       8  ?_48
       8  ?_49
       8  ?_5
       8  ?_50
       4  ?_51
       8  ?_6
      20  ?_7
      20  ?_8
      20  ?_9
      12  _report_init_message
      34  report_alarm_message
      66  report_build_info
      24  report_echo_line_received
      34  report_execute_startup_message
     168  report_feedback_message
     272  report_gcode_modes
      12  report_grbl_help
     446  report_grbl_settings
     148  report_ngc_parameters
      48  report_probe_parameters
     828  report_realtime_status
      38  report_startup_line
      44  report_status_message
      46  report_util_axis_values
      14  report_util_feedback_line_feed
      32  report_util_float_setting
      10  report_util_gcode_modes_G
      10  report_util_gcode_modes_M
      10  report_util_line_feed
      26  report_util_setting_prefix
      28  report_util_uint8_setting

 
   544 bytes in section .rodata
 2'574 bytes in section .text
 
 2'574 bytes of CODE  memory
   544 bytes of CONST memory

Errors: none
Warnings: none
