###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         16/Oct/2021  20:54:57
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\grbl_system.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EW1B51.tmp
#        (D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\grbl_system.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -D MSTEP_BRD -D
#        USE_USB_OTG_FS -D STM32F205xx -lcN
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\.\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\dbg\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\core\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\drv\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\hdlc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\cdc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\ -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\List\grbl_system.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\Obj\grbl_system.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\grbl_system.c
      1          #include <stdint.h>
      2          #include "my_grbl.h"
      3          
      4          system_t sys;
      5          int32_t sys_position[N_AXIS];      // Real-time machine (aka home) position vector in steps.
      6          int32_t sys_probe_position[N_AXIS]; // Last probe position in machine coordinates and steps.
      7          volatile uint8_t sys_probe_state;   // Probing state value.  Used to coordinate the probing cycle with stepper ISR.
      8          volatile uint8_t sys_rt_exec_state;   // Global realtime executor bitflag variable for state management. See EXEC bitmasks.
      9          volatile uint8_t sys_rt_exec_alarm;   // Global realtime executor bitflag variable for setting various alarms.
     10          volatile uint8_t sys_rt_exec_motion_override; // Global realtime executor bitflag variable for motion-based overrides.
     11          volatile uint8_t sys_rt_exec_accessory_override; // Global realtime executor bitflag variable for spindle/coolant overrides.
     12          
     13          volatile uint8_t sys_rt_exec_state;   // Global realtime executor bitflag variable for state management. See EXEC bitmasks.
     14          volatile uint8_t sys_rt_exec_motion_override; // Global realtime executor bitflag variable for motion-based overrides.
     15          volatile uint8_t sys_rt_exec_accessory_override; // Global realtime executor bitflag variable for spindle/coolant overrides.
     16          
     17          void system_set_exec_state_flag(uint8_t flag) {
     18          ///  __disable_irq();
     19            sys_rt_exec_state |= (flag);
     20          ///  __enable_irq();
     21          }
     22          void system_set_exec_motion_override_flag(uint8_t mask) {
     23          ////  __disable_irq();
     24            sys_rt_exec_motion_override |= (mask);
     25          ///  __enable_irq();
     26          }
     27          void system_set_exec_accessory_override_flag(uint8_t mask) {
     28          ///  __disable_irq();
     29            sys_rt_exec_accessory_override |= (mask);
     30          ///  __enable_irq();
     31          }
     32          
     33          void system_clear_exec_motion_overrides() {
     34          //// __disable_irq();
     35            sys_rt_exec_motion_override = 0;
     36          ////  __enable_irq();
     37          }
     38          void system_set_exec_alarm(uint8_t code) {
     39          ////  __disable_irq();
     40            sys_rt_exec_alarm |= (code);
     41          ////  __enable_irq();
     42          }
     43          void system_clear_exec_state_flag(uint8_t mask) {
     44          ///  __disable_irq();
     45            sys_rt_exec_state &= ~(mask);
     46          ///  __enable_irq();
     47          }
     48          // Returns if safety door is ajar(T) or closed(F), based on pin state.
     49          uint8_t system_check_safety_door_ajar(void)
     50          {
     51            #ifdef ENABLE_SAFETY_DOOR_INPUT_PIN
     52              return(system_control_get_state() & CONTROL_PIN_INDEX_SAFETY_DOOR);
     53            #else
     54              return(false); // Input pin not enabled, so just return that it's closed.
     55            #endif
     56          }
     57          // Returns control pin state as a uint8 bitfield. Each bit indicates the input pin state, where
     58          // triggered is 1 and not triggered is 0. Invert mask is applied. Bitfield organization is
     59          // defined by the CONTROL_PIN_INDEX in the header file.
     60          uint8_t system_control_get_state()
     61          {
     62            uint8_t control_state = 0;
     63          #if 0 
     64            uint16_t pin= GPIO_ReadInputData(CONTROL_PIN_PORT);
     65            #ifdef INVERT_CONTROL_PIN_MASK
     66              pin ^= INVERT_CONTROL_PIN_MASK;
     67            #endif
     68            if (pin) {
     69              #ifdef ENABLE_SAFETY_DOOR_INPUT_PIN
     70                if (bit_isfalse(pin,(1<<CONTROL_SAFETY_DOOR_BIT))) { control_state |= CONTROL_PIN_INDEX_SAFETY_DOOR; }
     71              #endif
     72              if (bit_isfalse(pin,(1<<CONTROL_RESET_BIT))) { control_state |= CONTROL_PIN_INDEX_RESET; }
     73              if (bit_isfalse(pin,(1<<CONTROL_FEED_HOLD_BIT))) { control_state |= CONTROL_PIN_INDEX_FEED_HOLD; }
     74              if (bit_isfalse(pin,(1<<CONTROL_CYCLE_START_BIT))) { control_state |= CONTROL_PIN_INDEX_CYCLE_START; }
     75            }
     76          #endif
     77            return(control_state);
     78          }
     79          
     80          
     81          
     82          // Directs and executes one line of formatted input from protocol_process. While mostly
     83          // incoming streaming g-code blocks, this also executes Grbl internal commands, such as
     84          // settings, initiating the homing cycle, and toggling switch states. This differs from
     85          // the realtime command module by being susceptible to when Grbl is ready to execute the
     86          // next line during a cycle, so for switches like block delete, the switch only effects
     87          // the lines that are processed afterward, not necessarily real-time during a cycle,
     88          // since there are motions already stored in the buffer. However, this 'lag' should not
     89          // be an issue, since these commands are not typically used during a cycle.
     90          uint8_t system_execute_line(char *line)
     91          {
     92            uint8_t char_counter = 1;
     93            uint8_t helper_var = 0; // Helper variable
     94            float parameter, value;
     95            switch( line[char_counter] ) {
     96              case 0 : report_grbl_help(); break;
     97              case 'J' : // Jogging
     98                // Execute only if in IDLE or JOG states.
     99                if (sys.state != STATE_IDLE && sys.state != STATE_JOG) { return(STATUS_IDLE_ERROR); }
    100                if(line[2] != '=') { return(STATUS_INVALID_STATEMENT); }
    101                return(gc_execute_line(line)); // NOTE: $J= is ignored inside g-code parser and used to detect jog motions.
    102                break;
    103              case '$': case 'G': case 'C': case 'X':
    104                if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    105                switch( line[1] ) {
    106                  case '$' : // Prints Grbl settings
    107                    if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    108                    else { report_grbl_settings(); }
    109                    break;
    110                  case 'G' : // Prints gcode parser state
    111                    // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
    112                    report_gcode_modes();
    113                    break;
    114                  case 'C' : // Set check g-code mode [IDLE/CHECK]
    115                    // Perform reset when toggling off. Check g-code mode should only work if Grbl
    116                    // is idle and ready, regardless of alarm locks. This is mainly to keep things
    117                    // simple and consistent.
    118                    if ( sys.state == STATE_CHECK_MODE ) {
    119                      mc_reset();
    120                      report_feedback_message(MESSAGE_DISABLED);
    121                    } else {
    122                      if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    123                      sys.state = STATE_CHECK_MODE;
    124                      report_feedback_message(MESSAGE_ENABLED);
    125                    }
    126                    break;
    127                  case 'X' : // Disable alarm lock [ALARM]
    128                    if (sys.state == STATE_ALARM) {
    129                      // Block if safety door is ajar.
    130                      if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); }
    131                      report_feedback_message(MESSAGE_ALARM_UNLOCK);
    132                      sys.state = STATE_IDLE;
    133                      // Don't run startup script. Prevents stored moves in startup from causing accidents.
    134                    } // Otherwise, no effect.
    135                    break;
    136                }
    137                break;
    138              default :
    139                // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
    140                if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    141                switch( line[1] ) {
    142                  case '#' : // Print Grbl NGC parameters
    143                    if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    144                    else { report_ngc_parameters(); }
    145                    break;
    146                  case 'H' : // Perform homing cycle [IDLE/ALARM]
    147                    if (bit_isfalse(settings.flags,BITFLAG_HOMING_ENABLE)) {return(STATUS_SETTING_DISABLED); }
    148                    if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); } // Block if safety door is ajar.
    149                    sys.state = STATE_HOMING; // Set system state variable
    150                    if (line[2] == 0) {
    151                      mc_homing_cycle(HOMING_CYCLE_ALL);
    152                    #ifdef HOMING_SINGLE_AXIS_COMMANDS
    153                      } else if (line[3] == 0) {
    154                        switch (line[2]) {
    155                          case 'X': mc_homing_cycle(HOMING_CYCLE_X); break;
    156                          case 'Y': mc_homing_cycle(HOMING_CYCLE_Y); break;
    157                          case 'Z': mc_homing_cycle(HOMING_CYCLE_Z); break;
    158                          default: return(STATUS_INVALID_STATEMENT);
    159                        }
    160                    #endif
    161                    } else { return(STATUS_INVALID_STATEMENT); }
    162                    if (!sys.abort) {  // Execute startup scripts after successful homing.
    163                      sys.state = STATE_IDLE; // Set to IDLE when complete.
    164                      st_go_idle(); // Set steppers to the settings idle state before returning.
    165                      if (line[2] == 0) { system_execute_startup(line); }
    166                    }
    167                    break;
    168                  case 'S' : // Puts Grbl to sleep [IDLE/ALARM]
    169                    if ((line[2] != 'L') || (line[3] != 'P') || (line[4] != 0)) { return(STATUS_INVALID_STATEMENT); }
    170                    system_set_exec_state_flag(EXEC_SLEEP); // Set to execute sleep mode immediately
    171                    break;
    172                  case 'I' : // Print or store build info. [IDLE/ALARM]
    173                    if ( line[++char_counter] == 0 ) {
    174                      settings_read_build_info(line);
    175                      report_build_info(line);
    176                    #ifdef ENABLE_BUILD_INFO_WRITE_COMMAND
    177                      } else { // Store startup line [IDLE/ALARM]
    178                        if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    179                        helper_var = char_counter; // Set helper variable as counter to start of user info line.
    180                        do {
    181                          line[char_counter-helper_var] = line[char_counter];
    182                        } while (line[char_counter++] != 0);
    183                        settings_store_build_info(line);
    184                    #endif
    185                    }
    186                    break;
    187                  case 'R' : // Restore defaults [IDLE/ALARM]
    188                    if ((line[2] != 'S') || (line[3] != 'T') || (line[4] != '=') || (line[6] != 0)) { return(STATUS_INVALID_STATEMENT); }
    189                    switch (line[5]) {
    190                      #ifdef ENABLE_RESTORE_EEPROM_DEFAULT_SETTINGS
    191                        case '$': settings_restore(SETTINGS_RESTORE_DEFAULTS); break;
    192                      #endif
    193                      #ifdef ENABLE_RESTORE_EEPROM_CLEAR_PARAMETERS
    194                        case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
    195                      #endif
    196                      #ifdef ENABLE_RESTORE_EEPROM_WIPE_ALL
    197                        case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
    198                      #endif
    199                      default: return(STATUS_INVALID_STATEMENT);
    200                    }
    201                    report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
    202                    mc_reset(); // Force reset to ensure settings are initialized correctly.
    203                    break;
    204                  case 'N' : // Startup lines. [IDLE/ALARM]
    205                    if ( line[++char_counter] == 0 ) { // Print startup lines
    206                      for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
    207                        if (!(settings_read_startup_line(helper_var, line))) {
    208                          report_status_message(STATUS_SETTING_READ_FAIL);
    209                        } else {
    210                          report_startup_line(helper_var,line);
    211                        }
    212                      }
    213                      break;
    214                    } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
    215                      if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    216                      helper_var = true;  // Set helper_var to flag storing method.
    217                      // No break. Continues into default: to read remaining command characters.
    218                    }
    219                  default :  // Storing setting methods [IDLE/ALARM]
    220                    if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    221                    if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    222                    if (helper_var) { // Store startup line
    223                      // Prepare sending gcode block to gcode parser by shifting all characters
    224                      helper_var = char_counter; // Set helper variable as counter to start of gcode block
    225                      do {
    226                        line[char_counter-helper_var] = line[char_counter];
    227                      } while (line[char_counter++] != 0);
    228                      // Execute gcode block to ensure block is valid.
    229                      helper_var = gc_execute_line(line); // Set helper_var to returned status code.
    230                      if (helper_var) { return(helper_var); }
    231                      else {
    232                        helper_var = (uint8_t)truncf(parameter); // Set helper_var to int value of parameter
    233                        settings_store_startup_line(helper_var,line);
    234                      }
    235                    } else { // Store global setting.
    236                      if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    237                      if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    238                      return(settings_store_global_setting((uint8_t)parameter, value));
    239                    }
    240                }
    241            }
    242            return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    243          }
    244          
    245          
    246          
    247          // Executes user startup script, if stored.
    248          void system_execute_startup(char *line)
    249          {
    250            uint8_t n;
    251            for (n=0; n < N_STARTUP_LINE; n++) {
    252              if (!(settings_read_startup_line(n, line))) {
    253                line[0] = 0;
    254                report_execute_startup_message(line,STATUS_SETTING_READ_FAIL);
    255              } else {
    256                if (line[0] != 0) {
    257                  uint8_t status_code = gc_execute_line(line);
    258                  report_execute_startup_message(line,status_code);
    259                }
    260              }
    261            }
    262          }
    263          
    264          void system_flag_wco_change()
    265          {
    266            #ifdef FORCE_BUFFER_SYNC_DURING_WCO_CHANGE
    267              protocol_buffer_synchronize();
    268            #endif
    269            sys.report_wco_counter = 0;
    270          }
    271          // Returns machine position of axis 'idx'. Must be sent a 'step' array.
    272          // NOTE: If motor steps and machine position are not in the same coordinate frame, this function
    273          //   serves as a central place to compute the transformation.
    274          float system_convert_axis_steps_to_mpos(int32_t *steps, uint8_t idx)
    275          {
    276            float pos=0;
    277          #if 0  
    278            #ifdef COREXY
    279              if (idx==X_AXIS) {
    280                pos = (float)system_convert_corexy_to_x_axis_steps(steps) / settings.steps_per_mm[idx];
    281              } else if (idx==Y_AXIS) {
    282                pos = (float)system_convert_corexy_to_y_axis_steps(steps) / settings.steps_per_mm[idx];
    283              } else {
    284                pos = steps[idx]/settings.steps_per_mm[idx];
    285              }
    286            #else
    287              pos = steps[idx]/settings.steps_per_mm[idx];
    288            #endif
    289          #endif   
    290            return(pos);
    291          }
    292          void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
    293          {
    294            uint8_t idx;
    295            for (idx=0; idx<N_AXIS; idx++) {
    296              position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
    297            }
    298            return;
    299          }
    300          // Checks and reports if target array exceeds machine travel limits.
    301          uint8_t system_check_travel_limits(float *target)
    302          {
    303          #if 0
    304            uint8_t idx;
    305            for (idx=0; idx<N_AXIS; idx++) {
    306              #ifdef HOMING_FORCE_SET_ORIGIN
    307                // When homing forced set origin is enabled, soft limits checks need to account for directionality.
    308                // NOTE: max_travel is stored as negative
    309                if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
    310                  if (target[idx] < 0 || target[idx] > -settings.max_travel[idx]) { return(true); }
    311                } else {
    312                  if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
    313                }
    314              #else
    315                // NOTE: max_travel is stored as negative
    316                if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
    317              #endif
    318            }
    319          #endif
    320            return(false);
    321          }
    322          
    323          void system_clear_exec_alarm() {
    324          ////  __disable_irq();
    325            sys_rt_exec_alarm = 0;
    326          ////  __enable_irq();
    327          }
    328          void system_clear_exec_accessory_overrides() {
    329          ////  __disable_irq();
    330            sys_rt_exec_accessory_override = 0;
    331          ////  __enable_irq();
    332          }
    333          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   system_check_safety_door_ajar
       0   system_check_travel_limits
       0   system_clear_exec_accessory_overrides
       0   system_clear_exec_alarm
       0   system_clear_exec_motion_overrides
       0   system_clear_exec_state_flag
       0   system_control_get_state
      16   system_convert_array_steps_to_mpos
        16   -> system_convert_axis_steps_to_mpos
       0   system_convert_axis_steps_to_mpos
      32   system_execute_line
        32   -> __aeabi_f2iz
        32   -> gc_execute_line
        32   -> mc_homing_cycle
        32   -> mc_reset
        32   -> read_float
        32   -> report_build_info
        32   -> report_feedback_message
        32   -> report_gcode_modes
        32   -> report_grbl_help
        32   -> report_grbl_settings
        32   -> report_ngc_parameters
        32   -> report_startup_line
        32   -> report_status_message
        32   -> settings_read_build_info
        32   -> settings_read_startup_line
        32   -> settings_restore
        32   -> settings_store_build_info
        32   -> settings_store_global_setting
        32   -> settings_store_startup_line
        32   -> st_go_idle
        32   -> system_check_safety_door_ajar
        32   -> system_execute_startup
        32   -> system_set_exec_state_flag
        32   -> truncf
        32 __aeabi_cfrcmple
      16   system_execute_startup
        16   -> gc_execute_line
        16   -> report_execute_startup_message
        16   -> settings_read_startup_line
       8   system_flag_wco_change
         8   -> protocol_buffer_synchronize
       0   system_set_exec_accessory_override_flag
       0   system_set_exec_alarm
       0   system_set_exec_motion_override_flag
       0   system_set_exec_state_flag


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
      20  sys
      12  sys_position
      12  sys_probe_position
       1  sys_probe_state
       1  sys_rt_exec_accessory_override
       1  sys_rt_exec_alarm
       1  sys_rt_exec_motion_override
       1  sys_rt_exec_state
       4  system_check_safety_door_ajar
       6  system_check_travel_limits
       8  system_clear_exec_accessory_overrides
       8  system_clear_exec_alarm
      10  system_clear_exec_motion_overrides
      12  system_clear_exec_state_flag
       6  system_control_get_state
      40  system_convert_array_steps_to_mpos
       6  system_convert_axis_steps_to_mpos
     870  system_execute_line
      72  system_execute_startup
      14  system_flag_wco_change
      12  system_set_exec_accessory_override_flag
      12  system_set_exec_alarm
      12  system_set_exec_motion_override_flag
      12  system_set_exec_state_flag

 
    49 bytes in section .bss
 1'132 bytes in section .text
 
 1'132 bytes of CODE memory
    49 bytes of DATA memory

Errors: none
Warnings: none
