###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         16/Oct/2021  20:54:57
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\my_stepper.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EW1E19.tmp
#        (D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\my_stepper.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -D MSTEP_BRD -D
#        USE_USB_OTG_FS -D STM32F205xx -lcN
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\.\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\dbg\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\core\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\drv\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\hdlc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\cdc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\ -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\List\my_stepper.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\Obj\my_stepper.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\my_stepper.c
      1          /*
      2            stepper.c - stepper motor driver: executes motion plans using stepper motors
      3            Part of Grbl
      4          
      5            Copyright (c) 2011-2016 Sungeun K. Jeon for Gnea Research LLC
      6            Copyright (c) 2009-2011 Simen Svale Skogsrud
      7          
      8            Grbl is free software: you can redistribute it and/or modify
      9            it under the terms of the GNU General Public License as published by
     10            the Free Software Foundation, either version 3 of the License, or
     11            (at your option) any later version.
     12          
     13            Grbl is distributed in the hope that it will be useful,
     14            but WITHOUT ANY WARRANTY; without even the implied warranty of
     15            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16            GNU General Public License for more details.
     17          
     18            You should have received a copy of the GNU General Public License
     19            along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
     20          */
     21          
     22          #include "my_grbl.h"
     23          
     24          #include "stm32f2xx_rcc.h"
     25          #include "stm32f2xx_tim.h"
     26          #include "misc.h"
     27          #include "my_stepper.h"
     28          
     29          void TIM_Configuration(TIM_TypeDef* TIMER, u16 Period, u16 Prescaler, u8 PP);
     30          extern void  put_steps(uint8_t steps);
     31          
     32          // Used to avoid ISR nesting of the "Stepper Driver Interrupt". Should never occur though.
     33          static volatile uint8_t busy;
     34          uint8_t curr_dir=0;
     35          
     36          static st_block_t st_block_buffer[SEGMENT_BUFFER_SIZE-1];
     37          static segment_t segment_buffer[SEGMENT_BUFFER_SIZE];
     38          static stepper_t st;
     39          // Step segment ring buffer indices
     40          static volatile uint8_t segment_buffer_tail;
     41          static uint8_t segment_buffer_head;
     42          static uint8_t segment_next_head;
     43          static uint16_t step_port_invert_mask;
     44          static uint16_t dir_port_invert_mask;
     45          static plan_block_t *pl_block;     // Pointer to the planner block being prepped
     46          static st_block_t *st_prep_block;  // Pointer to the stepper block data being prepped
     47          static st_prep_t prep;
     48          
     49          
     50          ////===============================================
     51          void  set_curr_dir(uint8_t dirs)
     52          {
     53          curr_dir=dirs;  
     54          }
     55          
     56          ////===============================================
     57          
     58          #if 0
     59          // Step and direction port invert masks.
     60          static PORTPINDEF step_port_invert_mask;
     61          static PORTPINDEF dir_port_invert_mask;
     62          
     63          /// This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
     64          // a step. This ISR resets the motor port after a short period (settings.pulse_microseconds)
     65          // completing one step cycle.
     66          void TIM3_IRQHandler(void)
     67          {
     68          	if ((TIM3->SR & 0x0001) != 0)                  // check interrupt source
     69          	{
     70          		TIM3->SR &= ~(1<<0);                          // clear UIF flag
     71          		TIM3->CNT = 0;
     72           		NVIC_DisableIRQ(TIM3_IRQn);
     73              // Reset stepping pins (leave the direction pins)
     74          		GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK));
     75          	}
     76          }
     77          
     78          
     79          ////================================================================================
     80          
     81          
     82          
     83          #endif
     84          
     85          ////===================================================================
     86          
     87          /*    BLOCK VELOCITY PROFILE DEFINITION
     88                    __________________________
     89                   /|                        |\     _________________         ^
     90                  / |                        | \   /|               |\        |
     91                 /  |                        |  \ / |               | \       s
     92                /   |                        |   |  |               |  \      p
     93               /    |                        |   |  |               |   \     e
     94              +-----+------------------------+---+--+---------------+----+    e
     95              |               BLOCK 1            ^      BLOCK 2          |    d
     96                                                 |
     97                            time ----->      EXAMPLE: Block 2 entry speed is at max junction velocity
     98          
     99            The planner block buffer is planned assuming constant acceleration velocity profiles and are
    100            continuously joined at block junctions as shown above. However, the planner only actively computes
    101            the block entry speeds for an optimal velocity plan, but does not compute the block internal
    102            velocity profiles. These velocity profiles are computed ad-hoc as they are executed by the
    103            stepper algorithm and consists of only 7 possible types of profiles: cruise-only, cruise-
    104            deceleration, acceleration-cruise, acceleration-only, deceleration-only, full-trapezoid, and
    105            triangle(no cruise).
    106          
    107                                                  maximum_speed (< nominal_speed) ->  +
    108                              +--------+ <- maximum_speed (= nominal_speed)          /|\
    109                             /          \                                           / | \
    110           current_speed -> +            \                                         /  |  + <- exit_speed
    111                            |             + <- exit_speed                         /   |  |
    112                            +-------------+                     current_speed -> +----+--+
    113                             time -->  ^  ^                                           ^  ^
    114                                       |  |                                           |  |
    115                          decelerate_after(in mm)                             decelerate_after(in mm)
    116                              ^           ^                                           ^  ^
    117                              |           |                                           |  |
    118                          accelerate_until(in mm)                             accelerate_until(in mm)
    119          
    120            The step segment buffer computes the executing block velocity profile and tracks the critical
    121            parameters for the stepper algorithm to accurately trace the profile. These critical parameters
    122            are shown and defined in the above illustration.
    123          */
    124          
    125          
    126          // Stepper state initialization. Cycle should only start if the st.cycle_start flag is
    127          // enabled. Startup init and limits call this function but shouldn't start the cycle.
    128          void st_wake_up(void)
    129          {
    130            // Enable stepper drivers.
    131            if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) 
    132            { 
    133            SetStepperDisableBit();
    134            }
    135            else 
    136            { 
    137            ResetStepperDisableBit(); 
    138            }
    139            // Initialize stepper output bits to ensure first ISR call does not step.
    140            st.step_outbits = step_port_invert_mask;
    141          
    142            // Initialize step pulse timing from settings. Here to ensure updating after re-writing.
    143            #ifdef STEP_PULSE_DELAY
    144              // Set total step pulse time after direction pin set. Ad hoc computation from oscilloscope.
    145              st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);
    146              // Set delay between direction pin write and step command.
    147              OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
    148            #else // Normal operation
    149              // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
    150              st.step_pulse_time = (settings.pulse_microseconds)*TICKS_PER_MICROSECOND;
    151            #endif
    152          #if 0
    153            // Enable Stepper Driver Interrupt
    154            TIM3->ARR = st.step_pulse_time - 1;
    155            TIM3->EGR = TIM_PSCReloadMode_Immediate;
    156            TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
    157          #endif
    158            TIM2->ARR = st.exec_segment->cycles_per_tick - 1;
    159            /* Set the Autoreload value */
    160          #ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        
    161            TIM2->PSC = st.exec_segment->prescaler;
    162          #endif
    163            TIM2->EGR = TIM_PSCReloadMode_Immediate;
    164            NVIC_EnableIRQ(TIM2_IRQn);
    165          }
    166          
    167          
    168          // Initialize and start the stepper motor subsystem
    169          void stepper_init(void)
    170          {
    171          #if 0  
    172            // Configure step and direction interface pins
    173          	GPIO_InitTypeDef GPIO_InitStructure;
    174          	RCC_APB2PeriphClockCmd(RCC_STEPPERS_DISABLE_PORT, ENABLE);
    175          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    176          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    177          	GPIO_InitStructure.GPIO_Pin = STEPPERS_DISABLE_MASK;
    178          	GPIO_Init(STEPPERS_DISABLE_PORT, &GPIO_InitStructure);
    179          
    180          	RCC_APB2PeriphClockCmd(RCC_STEP_PORT, ENABLE);
    181          	GPIO_InitStructure.GPIO_Pin = STEP_MASK;
    182          	GPIO_Init(STEP_PORT, &GPIO_InitStructure);
    183          
    184          	RCC_APB2PeriphClockCmd(RCC_DIRECTION_PORT, ENABLE);
    185          	GPIO_InitStructure.GPIO_Pin = DIRECTION_MASK;
    186          	GPIO_Init(DIRECTION_PORT, &GPIO_InitStructure);
    187          #endif  
    188          //// Configurating TIM2
    189          RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
    190          //// RCC->APB1ENR |= RCC_APB1Periph_TIM2;
    191          TIM_Configuration(TIM2, 1, 1, 1);
    192          
    193            // Configurating TIM3
    194          ////RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
    195          	// RCC->APB1ENR |= RCC_APB1Periph_TIM3;
    196          ////TIM_Configuration(TIM3, 1, 1, 1);
    197          
    198            // Stop/Distable TIM2 & TIM3 here
    199          ////NVIC_DisableIRQ(TIM3_IRQn);
    200          NVIC_DisableIRQ(TIM2_IRQn);
    201          }
    202          // Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
    203          void st_generate_step_dir_invert_masks()
    204          {
    205            uint8_t idx;
    206            step_port_invert_mask = 0;
    207            dir_port_invert_mask = 0;
    208            for (idx=0; idx<N_AXIS; idx++) {
    209              if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= step_pin_mask[idx]; }
    210              if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= direction_pin_mask[idx]; }
    211            }
    212          }
    213          
    214          
    215          /* "The Stepper Driver Interrupt" - This timer interrupt is the workhorse of Grbl. Grbl employs
    216             the venerable Bresenham line algorithm to manage and exactly synchronize multi-axis moves.
    217             Unlike the popular DDA algorithm, the Bresenham algorithm is not susceptible to numerical
    218             round-off errors and only requires fast integer counters, meaning low computational overhead
    219             and maximizing the Arduino's capabilities. However, the downside of the Bresenham algorithm
    220             is, for certain multi-axis motions, the non-dominant axes may suffer from un-smooth step
    221             pulse trains, or aliasing, which can lead to strange audible noises or shaking. This is
    222             particularly noticeable or may cause motion issues at low step frequencies (0-5kHz), but
    223             is usually not a physical problem at higher frequencies, although audible.
    224               To improve Bresenham multi-axis performance, Grbl uses what we call an Adaptive Multi-Axis
    225             Step Smoothing (AMASS) algorithm, which does what the name implies. At lower step frequencies,
    226             AMASS artificially increases the Bresenham resolution without effecting the algorithm's
    227             innate exactness. AMASS adapts its resolution levels automatically depending on the step
    228             frequency to be executed, meaning that for even lower step frequencies the step smoothing
    229             level increases. Algorithmically, AMASS is acheived by a simple bit-shifting of the Bresenham
    230             step count for each AMASS level. For example, for a Level 1 step smoothing, we bit shift
    231             the Bresenham step event count, effectively multiplying it by 2, while the axis step counts
    232             remain the same, and then double the stepper ISR frequency. In effect, we are allowing the
    233             non-dominant Bresenham axes step in the intermediate ISR tick, while the dominant axis is
    234             stepping every two ISR ticks, rather than every ISR tick in the traditional sense. At AMASS
    235             Level 2, we simply bit-shift again, so the non-dominant Bresenham axes can step within any
    236             of the four ISR ticks, the dominant axis steps every four ISR ticks, and quadruple the
    237             stepper ISR frequency. And so on. This, in effect, virtually eliminates multi-axis aliasing
    238             issues with the Bresenham algorithm and does not significantly alter Grbl's performance, but
    239             in fact, more efficiently utilizes unused CPU cycles overall throughout all configurations.
    240               AMASS retains the Bresenham algorithm exactness by requiring that it always executes a full
    241             Bresenham step, regardless of AMASS Level. Meaning that for an AMASS Level 2, all four
    242             intermediate steps must be completed such that baseline Bresenham (Level 0) count is always
    243             retained. Similarly, AMASS Level 3 means all eight intermediate steps must be executed.
    244             Although the AMASS Levels are in reality arbitrary, where the baseline Bresenham counts can
    245             be multiplied by any integer value, multiplication by powers of two are simply used to ease
    246             CPU overhead with bitshift integer operations.
    247               This interrupt is simple and dumb by design. All the computational heavy-lifting, as in
    248             determining accelerations, is performed elsewhere. This interrupt pops pre-computed segments,
    249             defined as constant velocity over n number of steps, from the step segment buffer and then
    250             executes them by pulsing the stepper pins appropriately via the Bresenham algorithm. This
    251             ISR is supported by The Stepper Port Reset Interrupt which it uses to reset the stepper port
    252             after each pulse. The bresenham line tracer algorithm controls all stepper outputs
    253             simultaneously with these two interrupts.
    254          
    255             NOTE: This interrupt must be as efficient as possible and complete before the next ISR tick,
    256             which for Grbl must be less than 33.3usec (@30kHz ISR rate). Oscilloscope measured time in
    257             ISR is 5usec typical and 25usec maximum, well below requirement.
    258             NOTE: This ISR expects at least one step to be executed per segment.
    259          */
    260          // TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller
    261          // int8 variables and update position counters only when a segment completes. This can get complicated
    262          // with probing and homing cycles that require true real-time positions.
    263          void TIM2_IRQHandler(void)
    264          {
    265          if ((TIM2->SR & 0x0001) != 0)                  // check interrupt source
    266            {
    267            TIM2->SR &= ~(1 << 0);                          // clear UIF flag
    268            TIM2->CNT = 0;
    269            }
    270          else
    271            {
    272            return;
    273            }
    274          if (busy) { // The busy-flag is used to avoid reentering this interrupt
    275              return; 
    276              } 
    277          ////  GPIO_Write(DIRECTION_PORT, (GPIO_ReadOutputData(DIRECTION_PORT) & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK));
    278            set_curr_dir(st.dir_outbits);
    279            TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
    280          
    281            // Then pulse the stepping pins
    282            #ifdef STEP_PULSE_DELAY
    283              st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwriting.
    284            #else  // Normal operation
    285          ////	GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | st.step_outbits);
    286                 put_steps(st.step_outbits) ;
    287            #endif
    288          
    289            // Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after
    290            // exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.
    291             NVIC_EnableIRQ(TIM3_IRQn);
    292          
    293            busy = true;
    294          
    295            // If there is no step segment, attempt to pop one from the stepper buffer
    296            if (st.exec_segment == NULL) {
    297              // Anything in the buffer? If so, load and initialize next step segment.
    298              if (segment_buffer_head != segment_buffer_tail) {
    299                // Initialize new step segment and load number of steps to execute
    300                st.exec_segment = &segment_buffer[segment_buffer_tail];
    301          
    302                // Initialize step segment timing per step and load number of steps to execute.
    303          	  TIM2->ARR = st.exec_segment->cycles_per_tick - 1;
    304          	  /* Set the Autoreload value */
    305          #ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        
    306          	  TIM2->PSC = st.exec_segment->prescaler;
    307          #endif
    308                st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
    309                // If the new segment starts a new planner block, initialize stepper variables and counters.
    310                // NOTE: When the segment data index changes, this indicates a new planner block.
    311                if ( st.exec_block_index != st.exec_segment->st_block_index ) {
    312                  st.exec_block_index = st.exec_segment->st_block_index;
    313                  st.exec_block = &st_block_buffer[st.exec_block_index];
    314          
    315                  // Initialize Bresenham line and distance counters
    316                  st.counter_x = st.counter_y = st.counter_z = (st.exec_block->step_event_count >> 1);
    317                }
    318                st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask;
    319          
    320                #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    321                  // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
    322                  st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
    323                  st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
    324                  st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
    325                #endif
    326          
    327                #ifdef VARIABLE_SPINDLE
    328                  // Set real-time spindle output as segment is loaded, just prior to the first step.
    329                  spindle_set_speed(st.exec_segment->spindle_pwm);
    330                #endif
    331          
    332              } else {
    333                // Segment buffer empty. Shutdown.
    334                st_go_idle();
    335                // Ensure pwm is set properly upon completion of rate-controlled motion.
    336                #ifdef VARIABLE_SPINDLE
    337                if (st.exec_block->is_pwm_rate_adjusted) { spindle_set_speed(SPINDLE_PWM_OFF_VALUE); }
    338                #endif
    339                system_set_exec_state_flag(EXEC_CYCLE_STOP); // Flag main program for cycle end
    340                return; // Nothing to do but exit.
    341              }
    342            }
    343          
    344          
    345            // Check probing state.
    346            if (sys_probe_state == PROBE_ACTIVE) { probe_state_monitor(); }
    347          
    348            // Reset step out bits.
    349            st.step_outbits = 0;
    350          
    351            // Execute step displacement profile by Bresenham line algorithm
    352            #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    353              st.counter_x += st.steps[X_AXIS];
    354            #else
    355              st.counter_x += st.exec_block->steps[X_AXIS];
    356            #endif
    357            if (st.counter_x > st.exec_block->step_event_count) {
    358              st.step_outbits |= (1<<X_STEP_BIT);
    359              st.counter_x -= st.exec_block->step_event_count;
    360              if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys_position[X_AXIS]--; }
    361              else { sys_position[X_AXIS]++; }
    362            }
    363            #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    364              st.counter_y += st.steps[Y_AXIS];
    365            #else
    366              st.counter_y += st.exec_block->steps[Y_AXIS];
    367            #endif
    368            if (st.counter_y > st.exec_block->step_event_count) {
    369              st.step_outbits |= (1<<Y_STEP_BIT);
    370              st.counter_y -= st.exec_block->step_event_count;
    371              if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys_position[Y_AXIS]--; }
    372              else { sys_position[Y_AXIS]++; }
    373            }
    374            #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    375              st.counter_z += st.steps[Z_AXIS];
    376            #else
    377              st.counter_z += st.exec_block->steps[Z_AXIS];
    378            #endif
    379            if (st.counter_z > st.exec_block->step_event_count) {
    380              st.step_outbits |= (1<<Z_STEP_BIT);
    381              st.counter_z -= st.exec_block->step_event_count;
    382              if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys_position[Z_AXIS]--; }
    383              else { sys_position[Z_AXIS]++; }
    384            }
    385          
    386            // During a homing cycle, lock out and prevent desired axes from moving.
    387            if (sys.state == STATE_HOMING) { st.step_outbits &= sys.homing_axis_lock; }
    388          
    389            st.step_count--; // Decrement step events count
    390            if (st.step_count == 0) {
    391              // Segment is complete. Discard current segment and advance segment indexing.
    392              st.exec_segment = NULL;
    393              uint8_t segment_tail_next = segment_buffer_tail + 1;
    394              if (segment_tail_next == SEGMENT_BUFFER_SIZE)
    395              {
    396                segment_tail_next = 0;
    397              }
    398              segment_buffer_tail = segment_tail_next;
    399            }
    400          
    401            st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask
    402            busy = false;
    403          }
    404          
    405          // Reset and clear stepper subsystem variables
    406          void st_reset(void)
    407          {
    408            // Initialize stepper driver idle state.
    409            st_go_idle();
    410          
    411            // Initialize stepper algorithm variables.
    412            memset(&prep, 0, sizeof(st_prep_t));
    413            memset(&st, 0, sizeof(stepper_t));
    414            st.exec_segment = NULL;
    415            pl_block = NULL;  // Planner block pointer used by segment buffer
    416            segment_buffer_tail = 0;
    417            segment_buffer_head = 0; // empty = tail
    418            segment_next_head = 1;
    419            busy = false;
    420          
    421            st_generate_step_dir_invert_masks();
    422            st.dir_outbits = dir_port_invert_mask; // Initialize direction bits to default.
    423          
    424            // Initialize step and direction port pins.
    425            steps_reset();
    426          //// GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK));
    427          ////  GPIO_Write(DIRECTION_PORT, (GPIO_ReadOutputData(DIRECTION_PORT) & ~DIRECTION_MASK) | (dir_port_invert_mask & DIRECTION_MASK));
    428          }
    429          // Stepper shutdown
    430          void st_go_idle(void)
    431          {
    432            // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
    433            NVIC_DisableIRQ(TIM2_IRQn);
    434          
    435            busy = false;
    436          
    437            // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
    438            bool pin_state = false; // Keep enabled.
    439            if (((settings.stepper_idle_lock_time != 0xff) || sys_rt_exec_alarm || sys.state == STATE_SLEEP) && sys.state != STATE_HOMING) {
    440              // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    441              // stop and not drift from residual inertial forces at the end of the last movement.
    442              delay__ms(settings.stepper_idle_lock_time);
    443              pin_state = true; // Override. Disable steppers.
    444            }
    445            if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    446            if (pin_state) 
    447            { 
    448          	  SetStepperDisableBit();
    449            }
    450            else 
    451            { 
    452          	  ResetStepperDisableBit();
    453            }
    454          }
    455          
    456          
    457          
    458          // Called by planner_recalculate() when the executing block is updated by the new plan.
    459          void st_update_plan_block_parameters()
    460          {
    461            if (pl_block != NULL) { // Ignore if at start of a new block.
    462              prep.recalculate_flag |= PREP_FLAG_RECALCULATE;
    463              pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
    464              pl_block = NULL; // Flag st_prep_segment() to load and check active velocity profile.
    465            }
    466          }
    467          
    468          
    469          // Increments the step segment buffer block data ring buffer.
    470          static uint8_t st_next_block_index(uint8_t block_index)
    471          {
    472            block_index++;
    473            if ( block_index == (SEGMENT_BUFFER_SIZE-1) ) { return(0); }
    474            return(block_index);
    475          }
    476          
    477          
    478          #ifdef PARKING_ENABLE
    479            // Changes the run state of the step segment buffer to execute the special parking motion.
    480            void st_parking_setup_buffer()
    481            {
    482              // Store step execution data of partially completed block, if necessary.
    483              if (prep.recalculate_flag & PREP_FLAG_HOLD_PARTIAL_BLOCK) {
    484                prep.last_st_block_index = prep.st_block_index;
    485                prep.last_steps_remaining = prep.steps_remaining;
    486                prep.last_dt_remainder = prep.dt_remainder;
    487                prep.last_step_per_mm = prep.step_per_mm;
    488              }
    489              // Set flags to execute a parking motion
    490              prep.recalculate_flag |= PREP_FLAG_PARKING;
    491              prep.recalculate_flag &= ~(PREP_FLAG_RECALCULATE);
    492              pl_block = NULL; // Always reset parking motion to reload new block.
    493            }
    494          
    495          
    496            // Restores the step segment buffer to the normal run state after a parking motion.
    497            void st_parking_restore_buffer()
    498            {
    499              // Restore step execution data and flags of partially completed block, if necessary.
    500              if (prep.recalculate_flag & PREP_FLAG_HOLD_PARTIAL_BLOCK) {
    501                st_prep_block = &st_block_buffer[prep.last_st_block_index];
    502                prep.st_block_index = prep.last_st_block_index;
    503                prep.steps_remaining = prep.last_steps_remaining;
    504                prep.dt_remainder = prep.last_dt_remainder;
    505                prep.step_per_mm = prep.last_step_per_mm;
    506                prep.recalculate_flag = (PREP_FLAG_HOLD_PARTIAL_BLOCK | PREP_FLAG_RECALCULATE);
    507                prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm; // Recompute this value.
    508              } else {
    509                prep.recalculate_flag = false;
    510              }
    511              pl_block = NULL; // Set to reload next block.
    512            }
    513          #endif
    514          
    515          /* Prepares step segment buffer. Continuously called from main program.
    516          
    517             The segment buffer is an intermediary buffer interface between the execution of steps
    518             by the stepper algorithm and the velocity profiles generated by the planner. The stepper
    519             algorithm only executes steps within the segment buffer and is filled by the main program
    520             when steps are "checked-out" from the first block in the planner buffer. This keeps the
    521             step execution and planning optimization processes atomic and protected from each other.
    522             The number of steps "checked-out" from the planner buffer and the number of segments in
    523             the segment buffer is sized and computed such that no operation in the main program takes
    524             longer than the time it takes the stepper algorithm to empty it before refilling it.
    525             Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
    526             NOTE: Computation units are in steps, millimeters, and minutes.
    527          */
    528          void st_prep_buffer()
    529          {
    530            // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
    531            if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }
    532          
    533            while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
    534          
    535              // Determine if we need to load a new planner block or if the block needs to be recomputed.
    536              if (pl_block == NULL) {
    537          
    538                // Query planner for a queued block
    539                if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) { 
    540                  pl_block = plan_get_system_motion_block(); 
    541                  }
    542                else { 
    543                  pl_block = plan_get_current_block(); 
    544                  }
    545                if (pl_block == NULL) { // No planner blocks. Exit.
    546                  return; 
    547                  } 
    548          
    549                // Check if we need to only recompute the velocity profile or load a new block.
    550                if (prep.recalculate_flag & PREP_FLAG_RECALCULATE) {
    551          
    552                  #ifdef PARKING_ENABLE
    553                    if (prep.recalculate_flag & PREP_FLAG_PARKING) { prep.recalculate_flag &= ~(PREP_FLAG_RECALCULATE); }
    554                    else { prep.recalculate_flag = false; }
    555                  #else
    556                    prep.recalculate_flag = false;
    557                  #endif
    558          
    559                } else {
    560          
    561                  // Load the Bresenham stepping data for the block.
    562                  prep.st_block_index = st_next_block_index(prep.st_block_index);
    563          
    564                  // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
    565                  // when the segment buffer completes the planner block, it may be discarded when the
    566                  // segment buffer finishes the prepped block, but the stepper ISR is still executing it.
    567                  st_prep_block = &st_block_buffer[prep.st_block_index];
    568                  st_prep_block->direction_bits = pl_block->direction_bits;
    569                  uint8_t idx;
    570                  #ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    571                    for (idx=0; idx<N_AXIS; idx++) { st_prep_block->steps[idx] = (pl_block->steps[idx] << 1); }
    572                    st_prep_block->step_event_count = (pl_block->step_event_count << 1);
    573                  #else
    574                    // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS
    575                    // level, such that we never divide beyond the original data anywhere in the algorithm.
    576                    // If the original data is divided, we can lose a step from integer roundoff.
    577                    for (idx=0; idx<N_AXIS; idx++) { st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL; }
    578                    st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
    579                  #endif
    580          
    581                  // Initialize segment buffer data for generating the segments.
    582                  prep.steps_remaining = (float)pl_block->step_event_count;
    583                  prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
    584                  prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
    585                  prep.dt_remainder = 0.0f; // Reset for new segment block
    586          
    587                  if ((sys.step_control & STEP_CONTROL_EXECUTE_HOLD) || (prep.recalculate_flag & PREP_FLAG_DECEL_OVERRIDE)) {
    588                    // New block loaded mid-hold. Override planner block entry speed to enforce deceleration.
    589                    prep.current_speed = prep.exit_speed;
    590                    pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed;
    591                    prep.recalculate_flag &= ~(PREP_FLAG_DECEL_OVERRIDE);
    592                  } else {
    593                    prep.current_speed = sqrtf(pl_block->entry_speed_sqr);
    594                  }
    595          #ifdef VARIABLE_SPINDLE
    596                  // Setup laser mode variables. PWM rate adjusted motions will always complete a motion with the
    597                  // spindle off. 
    598                  st_prep_block->is_pwm_rate_adjusted = false;
    599                  if (settings.flags & BITFLAG_LASER_MODE) {
    600                    if (pl_block->condition & PL_COND_FLAG_SPINDLE_CCW) {
    601                      // Pre-compute inverse programmed rate to speed up PWM updating per step segment.
    602                      prep.inv_rate = 1.0f / pl_block->programmed_rate;
    603                      st_prep_block->is_pwm_rate_adjusted = true;
    604                    }
    605                  }
    606          #endif
    607                }
    608          
    609          			/* ---------------------------------------------------------------------------------
    610          			 Compute the velocity profile of a new planner block based on its entry and exit
    611          			 speeds, or recompute the profile of a partially-completed planner block if the
    612          			 planner has updated it. For a commanded forced-deceleration, such as from a feed
    613          			 hold, override the planner velocities and decelerate to the target exit speed.
    614          			*/
    615          			prep.mm_complete = 0.0f; // Default velocity profile complete at 0.0mm from end of block.
    616          			float inv_2_accel = 0.5f/pl_block->acceleration;
    617          			if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { // [Forced Deceleration to Zero Velocity]
    618          				// Compute velocity profile parameters for a feed hold in-progress. This profile overrides
    619          				// the planner block profile, enforcing a deceleration to zero speed.
    620          				prep.ramp_type = RAMP_DECEL;
    621          				// Compute decelerate distance relative to end of block.
    622          				float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
    623          				if (decel_dist < 0.0f) {
    624          					// Deceleration through entire planner block. End of feed hold is not in this block.
    625          					prep.exit_speed = sqrtf(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
    626          				} else {
    627          					prep.mm_complete = decel_dist; // End of feed hold.
    628          					prep.exit_speed = 0.0f;
    629          				}
    630          			} else { // [Normal Operation]
    631          				// Compute or recompute velocity profile parameters of the prepped planner block.
    632          				prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
    633          				prep.accelerate_until = pl_block->millimeters;
    634          
    635          				float exit_speed_sqr;
    636          				float nominal_speed;
    637                  if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
    638                    prep.exit_speed = exit_speed_sqr = 0.0f; // Enforce stop at end of system motion.
    639                  } else {
    640                    exit_speed_sqr = plan_get_exec_block_exit_speed_sqr();
    641                    prep.exit_speed = sqrtf(exit_speed_sqr);
    642                  }
    643          
    644                  nominal_speed = plan_compute_profile_nominal_speed(pl_block);
    645          				float nominal_speed_sqr = nominal_speed*nominal_speed;
    646          				float intersect_distance =
    647          								0.5f*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
    648          
    649                  if (pl_block->entry_speed_sqr > nominal_speed_sqr) { // Only occurs during override reductions.
    650                    prep.accelerate_until = pl_block->millimeters - inv_2_accel*(pl_block->entry_speed_sqr-nominal_speed_sqr);
    651                    if (prep.accelerate_until <= 0.0f) { // Deceleration-only.
    652                      prep.ramp_type = RAMP_DECEL;
    653                      // prep.decelerate_after = pl_block->millimeters;
    654                      // prep.maximum_speed = prep.current_speed;
    655          
    656                      // Compute override block exit speed since it doesn't match the planner exit speed.
    657                      prep.exit_speed = sqrtf(pl_block->entry_speed_sqr - 2*pl_block->acceleration*pl_block->millimeters);
    658                      prep.recalculate_flag |= PREP_FLAG_DECEL_OVERRIDE; // Flag to load next block as deceleration override.
    659          
    660                      // TODO: Determine correct handling of parameters in deceleration-only.
    661                      // Can be tricky since entry speed will be current speed, as in feed holds.
    662                      // Also, look into near-zero speed handling issues with this.
    663          
    664                    } else {
    665                      // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
    666                      prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr); // Should always be >= 0.0 due to planner reinit.
    667          						prep.maximum_speed = nominal_speed;
    668                      prep.ramp_type = RAMP_DECEL_OVERRIDE;
    669                    }
    670          				} else if (intersect_distance > 0.0f) {
    671          					if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
    672          						// NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
    673          						prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
    674          						if (prep.decelerate_after < intersect_distance) { // Trapezoid type
    675          							prep.maximum_speed = nominal_speed;
    676          							if (pl_block->entry_speed_sqr == nominal_speed_sqr) {
    677          								// Cruise-deceleration or cruise-only type.
    678          								prep.ramp_type = RAMP_CRUISE;
    679          							} else {
    680          								// Full-trapezoid or acceleration-cruise types
    681          								prep.accelerate_until -= inv_2_accel*(nominal_speed_sqr-pl_block->entry_speed_sqr);
    682          							}
    683          						} else { // Triangle type
    684          							prep.accelerate_until = intersect_distance;
    685          							prep.decelerate_after = intersect_distance;
    686          							prep.maximum_speed = sqrtf(2.0f*pl_block->acceleration*intersect_distance+exit_speed_sqr);
    687          						}
    688          					} else { // Deceleration-only type
    689                      prep.ramp_type = RAMP_DECEL;
    690                      // prep.decelerate_after = pl_block->millimeters;
    691                      // prep.maximum_speed = prep.current_speed;
    692          					}
    693          				} else { // Acceleration-only type
    694          					prep.accelerate_until = 0.0f;
    695          					// prep.decelerate_after = 0.0f;
    696          					prep.maximum_speed = prep.exit_speed;
    697          				}
    698          			}
    699                
    700                #ifdef VARIABLE_SPINDLE
    701                  bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); // Force update whenever updating block.
    702                #endif
    703              }
    704              
    705              // Initialize new segment
    706              segment_t *prep_segment = &segment_buffer[segment_buffer_head];
    707          
    708              // Set new segment to point to the current segment data block.
    709              prep_segment->st_block_index = prep.st_block_index;
    710          
    711              /*------------------------------------------------------------------------------------
    712                  Compute the average velocity of this new segment by determining the total distance
    713                traveled over the segment time DT_SEGMENT. The following code first attempts to create
    714                a full segment based on the current ramp conditions. If the segment time is incomplete
    715                when terminating at a ramp state change, the code will continue to loop through the
    716                progressing ramp states to fill the remaining segment execution time. However, if
    717                an incomplete segment terminates at the end of the velocity profile, the segment is
    718                considered completed despite having a truncated execution time less than DT_SEGMENT.
    719                  The velocity profile is always assumed to progress through the ramp sequence:
    720                acceleration ramp, cruising state, and deceleration ramp. Each ramp's travel distance
    721                may range from zero to the length of the block. Velocity profiles can end either at
    722                the end of planner block (typical) or mid-block at the end of a forced deceleration,
    723                such as from a feed hold.
    724              */
    725              float dt_max = DT_SEGMENT; // Maximum segment time
    726              float dt = 0.0f; // Initialize segment time
    727              float time_var = dt_max; // Time worker variable
    728              float mm_var; // mm-Distance worker variable
    729              float speed_var; // Speed worker variable
    730              float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    731              float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    732              if (minimum_mm < 0.0f) { minimum_mm = 0.0f; }
    733          
    734              do {
    735                switch (prep.ramp_type) {
    736                  case RAMP_DECEL_OVERRIDE:
    737                    speed_var = pl_block->acceleration*time_var;
    738          					if (prep.current_speed-prep.maximum_speed <= speed_var) {
    739                      // Cruise or cruise-deceleration types only for deceleration override.
    740          						mm_remaining = prep.accelerate_until;
    741                      time_var = 2.0f*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    742                      prep.ramp_type = RAMP_CRUISE;
    743                      prep.current_speed = prep.maximum_speed;
    744                    } else { // Mid-deceleration override ramp.
    745          						mm_remaining -= time_var*(prep.current_speed - 0.5f*speed_var);
    746                      prep.current_speed -= speed_var;
    747                    }
    748                    break;
    749                  case RAMP_ACCEL:
    750                    // NOTE: Acceleration ramp only computes during first do-while loop.
    751                    speed_var = pl_block->acceleration*time_var;
    752                    mm_remaining -= time_var*(prep.current_speed + 0.5f*speed_var);
    753                    if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    754                      // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
    755                      mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
    756                      time_var = 2.0f*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    757                      if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    758                      else { prep.ramp_type = RAMP_CRUISE; }
    759                      prep.current_speed = prep.maximum_speed;
    760                    } else { // Acceleration only.
    761                      prep.current_speed += speed_var;
    762                    }
    763                    break;
    764                  case RAMP_CRUISE:
    765                    // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
    766                    // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To
    767                    //   prevent this, simply enforce a minimum speed threshold in the planner.
    768                    mm_var = mm_remaining - prep.maximum_speed*time_var;
    769                    if (mm_var < prep.decelerate_after) { // End of cruise.
    770                      // Cruise-deceleration junction or end of block.
    771                      time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
    772                      mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
    773                      prep.ramp_type = RAMP_DECEL;
    774                    } else { // Cruising only.
    775                      mm_remaining = mm_var;
    776                    }
    777                    break;
    778                  default: // case RAMP_DECEL:
    779                    // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
    780                    speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
    781                    if (prep.current_speed > speed_var) { // Check if at or below zero speed.
    782                      // Compute distance from end of segment to end of block.
    783                      mm_var = mm_remaining - time_var*(prep.current_speed - 0.5f*speed_var); // (mm)
    784                      if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
    785                        mm_remaining = mm_var;
    786                        prep.current_speed -= speed_var;
    787                        break; // Segment complete. Exit switch-case statement. Continue do-while loop.
    788                      }
    789                    }
    790                    // Otherwise, at end of block or end of forced-deceleration.
    791                    time_var = 2.0f*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    792                    mm_remaining = prep.mm_complete;
    793                    prep.current_speed = prep.exit_speed;
    794                }
    795                dt += time_var; // Add computed ramp time to total segment time.
    796                if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
    797                else {
    798                  if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
    799                    // Increase segment time to ensure at least one step in segment. Override and loop
    800                    // through distance calculations until minimum_mm or mm_complete.
    801                    dt_max += DT_SEGMENT;
    802                    time_var = dt_max - dt;
    803                  } else {
    804                    break; // **Complete** Exit loop. Segment execution time maxed.
    805                  }
    806                }
    807              } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
    808          
    809              #ifdef VARIABLE_SPINDLE
    810                /* -----------------------------------------------------------------------------------
    811                  Compute spindle speed PWM output for step segment
    812                */
    813          
    814                if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
    815                  if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
    816                    float rpm = pl_block->spindle_speed;
    817                    // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.        
    818                    if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
    819                    // If current_speed is zero, then may need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE)
    820                    // but this would be instantaneous only and during a motion. May not matter at all.
    821                    prep.current_spindle_pwm = spindle_compute_pwm_value(rpm);
    822                  }
    823                  else {
    824                    sys.spindle_speed = 0.0;
    825                    prep.current_spindle_pwm = SPINDLE_PWM_OFF_VALUE;
    826                  }
    827                  bit_false(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    828                }
    829                prep_segment->spindle_pwm = prep.current_spindle_pwm; // Reload segment PWM value
    830          
    831              #endif
    832              
    833              /* -----------------------------------------------------------------------------------
    834                 Compute segment step rate, steps to execute, and apply necessary rate corrections.
    835                 NOTE: Steps are computed by direct scalar conversion of the millimeter distance
    836                 remaining in the block, rather than incrementally tallying the steps executed per
    837                 segment. This helps in removing floating point round-off issues of several additions.
    838                 However, since floats have only 7.2 significant digits, long moves with extremely
    839                 high step counts can exceed the precision of floats, which can lead to lost steps.
    840                 Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
    841                 supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    842              */
    843              float step_dist_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
    844              float n_steps_remaining = ceilf(step_dist_remaining); // Round-up current steps remaining
    845              float last_n_steps_remaining = ceilf(prep.steps_remaining); // Round-up last steps remaining
    846          	prep_segment->n_step = (uint16_t)(last_n_steps_remaining - n_steps_remaining); // Compute number of steps to execute.
    847          
    848              // Bail if we are at the end of a feed hold and don't have a step to execute.
    849              if (prep_segment->n_step == 0) {
    850                if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) {
    851                  // Less than one step to decelerate to zero speed, but already very close. AMASS
    852                  // requires full steps to execute. So, just bail.
    853                  bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    854                  #ifdef PARKING_ENABLE
    855                    if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
    856                  #endif
    857                  return; // Segment not generated, but current step data still retained.
    858                }
    859              }
    860          
    861              // Compute segment step rate. Since steps are integers and mm distances traveled are not,
    862              // the end of every segment can have a partial step of varying magnitudes that are not
    863              // executed, because the stepper ISR requires whole steps due to the AMASS algorithm. To
    864              // compensate, we track the time to execute the previous segment's partial step and simply
    865              // apply it with the partial step distance to the current segment, so that it minutely
    866              // adjusts the whole segment rate to keep step output exact. These rate adjustments are
    867              // typically very small and do not adversely effect performance, but ensures that Grbl
    868              // outputs the exact acceleration and velocity profiles as computed by the planner.
    869              dt += prep.dt_remainder; // Apply previous segment partial step execute time
    870              float inv_rate = dt/(last_n_steps_remaining - step_dist_remaining); // Compute adjusted step rate inverse
    871          
    872              // Compute CPU cycles per step for the prepped segment.
    873           ////???	uint32_t cycles = (uint32_t)ceilf((TICKS_PER_MICROSECOND * 1000000) *inv_rate * 60); // (cycles/step)
    874          uint32_t cycles = 1000;////????
    875              #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    876                // Compute step timing and multi-axis smoothing level.
    877                // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
    878                if (cycles < AMASS_LEVEL1) 
    879                { 
    880                  prep_segment->amass_level = 0; 
    881                }
    882                else {
    883                  if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
    884                  else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
    885                  else { prep_segment->amass_level = 3; }
    886                  cycles >>= prep_segment->amass_level;
    887                  prep_segment->n_step <<= prep_segment->amass_level;
    888                }
    889                if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
    890                else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
    891              #else
    892                // Compute step timing and timer prescalar for normal step generation.
    893                if (cycles < (1UL << 16)) { // < 65536  (4.1ms @ 16MHz)
    894                  prep_segment->prescaler = 1; // prescaler: 0
    895                  prep_segment->cycles_per_tick = cycles;
    896                } else if (cycles < (1UL << 19)) { // < 524288 (32.8ms@16MHz)
    897                  prep_segment->prescaler = 2; // prescaler: 8
    898                  prep_segment->cycles_per_tick = cycles >> 3;
    899                } else {
    900                  prep_segment->prescaler = 3; // prescaler: 64
    901                  if (cycles < (1UL << 22)) { // < 4194304 (262ms@16MHz)
    902                    prep_segment->cycles_per_tick =  cycles >> 6;
    903                  } else { // Just set the slowest speed possible. (Around 4 step/sec.)
    904                    prep_segment->cycles_per_tick = 0xffff;
    905                  }
    906                }
    907              #endif
    908          
    909              // Segment complete! Increment segment buffer indices, so stepper ISR can immediately execute it.
    910              segment_buffer_head = segment_next_head;
    911              if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
    912          
    913              // Update the appropriate planner and segment data.
    914              pl_block->millimeters = mm_remaining;
    915              prep.steps_remaining = n_steps_remaining;
    916              prep.dt_remainder = (n_steps_remaining - step_dist_remaining)*inv_rate;
    917          
    918              // Check for exit conditions and flag to load next planner block.
    919              if (mm_remaining == prep.mm_complete) {
    920                // End of planner block or forced-termination. No more distance to be executed.
    921                if (mm_remaining > 0.0f) { // At end of forced-termination.
    922                  // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
    923                  // the segment queue, where realtime protocol will set new state upon receiving the
    924                  // cycle stop flag from the ISR. Prep_segment is blocked until then.
    925                  bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    926                  #ifdef PARKING_ENABLE
    927                    if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
    928                  #endif
    929                  return; // Bail!
    930                } else { // End of planner block
    931                  // The planner block is complete. All steps are set to be executed in the segment buffer.
    932                  if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
    933                    bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    934                    return;
    935                  }
    936                  pl_block = NULL; // Set pointer to indicate check and load next planner block.
    937                  plan_discard_current_block();
    938                }
    939              }
    940          
    941            }
    942          }
    943          
    944          // Called by realtime status reporting to fetch the current speed being executed. This value
    945          // however is not exactly the current speed, but the speed computed in the last step segment
    946          // in the segment buffer. It will always be behind by up to the number of segment blocks (-1)
    947          // divided by the ACCELERATION TICKS PER SECOND in seconds.
    948          float st_get_realtime_rate()
    949          {
    950            if (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)){
    951              return prep.current_speed;
    952            }
    953            return 0.0f;
    954          }
    955          
    956          
    957          ////===================================================================
    958          
    959          
    960          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   TIM2_IRQHandler
        16   -> TIM_ClearITPendingBit
        16   -> __NVIC_EnableIRQ
        16   -> probe_state_monitor
        16   -> put_steps
        16   -> set_curr_dir
        16   -> spindle_set_speed
        16   -> st_go_idle
        16   -> system_set_exec_state_flag
       0   __NVIC_DisableIRQ
       0   __NVIC_EnableIRQ
       0   set_curr_dir
      16   st_generate_step_dir_invert_masks
       0   st_get_realtime_rate
      16   st_go_idle
        16   -> ResetStepperDisableBit
        16   -> SetStepperDisableBit
        16   -> __NVIC_DisableIRQ
        16   -> delay__ms
       0   st_next_block_index
      80   st_prep_buffer
        80   -> __aeabi_f2iz
        80   -> __aeabi_fadd
        80   -> __aeabi_fdiv
        80   -> __aeabi_fmul
        80   -> __aeabi_fsub
        80   -> __aeabi_ui2f
        80   -> ceilf
        80   -> plan_compute_profile_nominal_speed
        80   -> plan_discard_current_block
        80   -> plan_get_current_block
        80   -> plan_get_exec_block_exit_speed_sqr
        80   -> plan_get_system_motion_block
        80   -> spindle_compute_pwm_value
        80   -> sqrtf
        80   -> st_next_block_index
        80 __aeabi_cfcmpeq
        80 __aeabi_cfcmple
        80 __aeabi_cfrcmple
      32   st_reset
        32   -> __aeabi_memset
        32   -> st_generate_step_dir_invert_masks
        32   -> st_go_idle
        32   -> steps_reset
       8   st_update_plan_block_parameters
         8   -> __aeabi_fmul
       8   st_wake_up
         8   -> ResetStepperDisableBit
         8   -> SetStepperDisableBit
         8   -> __NVIC_EnableIRQ
       8   stepper_init
         8   -> RCC_APB1PeriphClockCmd
         8   -> TIM_Configuration
         8   -> __NVIC_DisableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_18
       4  ??DataTable10_19
       4  ??DataTable10_2
       4  ??DataTable10_20
       4  ??DataTable10_21
       4  ??DataTable10_22
       4  ??DataTable10_23
       4  ??DataTable10_24
       4  ??DataTable10_25
       4  ??DataTable10_26
       4  ??DataTable10_27
       4  ??DataTable10_28
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
     566  TIM2_IRQHandler
      40  __NVIC_DisableIRQ
      32  __NVIC_EnableIRQ
       1  busy
       1  curr_dir
       2  dir_port_invert_mask
       8  direction_pin_mask
       4  pl_block
      56  prep
      80  segment_buffer
       1  segment_buffer_head
       1  segment_buffer_tail
       1  segment_next_head
       8  set_curr_dir
      44  st
     180  st_block_buffer
     100  st_generate_step_dir_invert_masks
      20  st_get_realtime_rate
     108  st_go_idle
      22  st_next_block_index
       4  st_prep_block
    1808  st_prep_buffer
     114  st_reset
      42  st_update_plan_block_parameters
      74  st_wake_up
       8  step_pin_mask
       2  step_port_invert_mask
      32  stepper_init

 
   377 bytes in section .bss
    16 bytes in section .rodata
 3'082 bytes in section .text
 
 3'082 bytes of CODE  memory
    16 bytes of CONST memory
   377 bytes of DATA  memory

Errors: none
Warnings: none
