###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         16/Oct/2021  20:54:57
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\motion_control.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EW1DAA.tmp
#        (D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\motion_control.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -D MSTEP_BRD -D
#        USE_USB_OTG_FS -D STM32F205xx -lcN
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\.\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\dbg\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\core\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\drv\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\hdlc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\cdc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\ -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\List\motion_control.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\Obj\motion_control.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\motion_control.c
      1          /*
      2            motion_control.c - high level interface for issuing motion commands
      3            Part of Grbl
      4          
      5            Copyright (c) 2011-2016 Sungeun K. Jeon for Gnea Research LLC
      6            Copyright (c) 2009-2011 Simen Svale Skogsrud
      7          
      8            Grbl is free software: you can redistribute it and/or modify
      9            it under the terms of the GNU General Public License as published by
     10            the Free Software Foundation, either version 3 of the License, or
     11            (at your option) any later version.
     12          
     13            Grbl is distributed in the hope that it will be useful,
     14            but WITHOUT ANY WARRANTY; without even the implied warranty of
     15            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16            GNU General Public License for more details.
     17          
     18            You should have received a copy of the GNU General Public License
     19            along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
     20          */
     21          
     22          #include "my_grbl.h"
     23          
     24          
     25          // Execute linear motion in absolute millimeter coordinates. Feed rate given in millimeters/second
     26          // unless invert_feed_rate is true. Then the feed_rate means that the motion should be completed in
     27          // (1 minute)/feed_rate time.
     28          // NOTE: This is the primary gateway to the grbl planner. All line motions, including arc line
     29          // segments, must pass through this routine before being passed to the planner. The seperation of
     30          // mc_line and plan_buffer_line is done primarily to place non-planner-type functions from being
     31          // in the planner and to let backlash compensation or canned cycle integration simple and direct.
     32          void mc_line(float *target, plan_line_data_t *pl_data)
     33          {
     34            // If enabled, check for soft limit violations. Placed here all line motions are picked up
     35            // from everywhere in Grbl.
     36            if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
     37              // NOTE: Block jog state. Jogging is a special case and soft limits are handled independently.
     38              if (sys.state != STATE_JOG) { limits_soft_check(target); }
     39            }
     40          
     41            // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
     42            if (sys.state == STATE_CHECK_MODE) { return; }
     43          
     44            // NOTE: Backlash compensation may be installed here. It will need direction info to track when
     45            // to insert a backlash line motion(s) before the intended line motion and will require its own
     46            // plan_check_full_buffer() and check for system abort loop. Also for position reporting
     47            // backlash steps will need to be also tracked, which will need to be kept at a system level.
     48            // There are likely some other things that will need to be tracked as well. However, we feel
     49            // that backlash compensation should NOT be handled by Grbl itself, because there are a myriad
     50            // of ways to implement it and can be effective or ineffective for different CNC machines. This
     51            // would be better handled by the interface as a post-processor task, where the original g-code
     52            // is translated and inserts backlash motions that best suits the machine.
     53            // NOTE: Perhaps as a middle-ground, all that needs to be sent is a flag or special command that
     54            // indicates to Grbl what is a backlash compensation motion, so that Grbl executes the move but
     55            // doesn't update the machine position values. Since the position values used by the g-code
     56            // parser and planner are separate from the system machine positions, this is doable.
     57          
     58            // If the buffer is full: good! That means we are well ahead of the robot.
     59            // Remain in this loop until there is room in the buffer.
     60            do {
     61              protocol_execute_realtime(); // Check for any run-time commands
     62              if (sys.abort) { return; } // Bail, if system abort.
     63              if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffer is full.
     64              else { break; }
     65            } while (1);
     66          
     67            // Plan and queue motion into planner buffer
     68          	if (plan_buffer_line(target, pl_data) == PLAN_EMPTY_BLOCK) {
     69          		if (bit_istrue(settings.flags, BITFLAG_LASER_MODE)) {
     70          			// Correctly set spindle state, if there is a coincident position passed. Forces a buffer
     71          			// sync while in M3 laser mode only.
     72          			if (pl_data->condition & PL_COND_FLAG_SPINDLE_CW) {
     73          				spindle_sync(PL_COND_FLAG_SPINDLE_CW, pl_data->spindle_speed);
     74          			}
     75          		}
     76          	}
     77          }
     78          
     79          
     80          // Execute an arc in offset mode format. position == current xyz, target == target xyz,
     81          // offset == offset from current xyz, axis_X defines circle plane in tool space, axis_linear is
     82          // the direction of helical travel, radius == circle radius, isclockwise boolean. Used
     83          // for vector transformation direction.
     84          // The arc is approximated by generating a huge number of tiny, linear segments. The chordal tolerance
     85          // of each segment is configured in settings.arc_tolerance, which is defined to be the maximum normal
     86          // distance from segment to the circle when the end points both lie on the circle.
     87          void mc_arc(float *target, plan_line_data_t *pl_data, float *position, float *offset, float radius,
     88            uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc)
     89          {
     90            float center_axis0 = position[axis_0] + offset[axis_0];
     91            float center_axis1 = position[axis_1] + offset[axis_1];
     92            float r_axis0 = -offset[axis_0];  // Radius vector from center to current location
     93            float r_axis1 = -offset[axis_1];
     94            float rt_axis0 = target[axis_0] - center_axis0;
     95            float rt_axis1 = target[axis_1] - center_axis1;
     96          
     97            // CCW angle between position and target from circle center. Only one atan2() trig computation required.
     98            float angular_travel = atan2f(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis1);
     99            if (is_clockwise_arc) { // Correct atan2 output per direction
    100              if (angular_travel >= -ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel -= 2*M_PI; }
    101            } else {
    102              if (angular_travel <= ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel += 2*M_PI; }
    103            }
    104          
    105            // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
    106            // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
    107            // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
    108            // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
    109            uint16_t segments = (uint16_t)floorf(fabsf(0.5f*angular_travel*radius) /
    110                                    sqrtf(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
    111          
    112            if (segments) {
    113              // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
    114              // by a number of discrete segments. The inverse feed_rate should be correct for the sum of
    115              // all segments.
    116              if (pl_data->condition & PL_COND_FLAG_INVERSE_TIME) { 
    117                pl_data->feed_rate *= segments; 
    118                bit_false(pl_data->condition,PL_COND_FLAG_INVERSE_TIME); // Force as feed absolute mode over arc segments.
    119              }
    120              
    121              float theta_per_segment = angular_travel/segments;
    122              float linear_per_segment = (target[axis_linear] - position[axis_linear])/segments;
    123          
    124              /* Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
    125                 and phi is the angle of rotation. Solution approach by Jens Geisler.
    126                     r_T = [cos(phi) -sin(phi);
    127                            sin(phi)  cos(phi] * r ;
    128          
    129                 For arc generation, the center of the circle is the axis of rotation and the radius vector is
    130                 defined from the circle center to the initial position. Each line segment is formed by successive
    131                 vector rotations. Single precision values can accumulate error greater than tool precision in rare
    132                 cases. So, exact arc path correction is implemented. This approach avoids the problem of too many very
    133                 expensive trig operations [sin(),cos(),tan()] which can take 100-200 usec each to compute.
    134          
    135                 Small angle approximation may be used to reduce computation overhead further. A third-order approximation
    136                 (second order sin() has too much error) holds for most, if not, all CNC applications. Note that this
    137                 approximation will begin to accumulate a numerical drift error when theta_per_segment is greater than
    138                 ~0.25 rad(14 deg) AND the approximation is successively used without correction several dozen times. This
    139                 scenario is extremely unlikely, since segment lengths and theta_per_segment are automatically generated
    140                 and scaled by the arc tolerance setting. Only a very large arc tolerance setting, unrealistic for CNC
    141                 applications, would cause this numerical drift error. However, it is best to set N_ARC_CORRECTION from a
    142                 low of ~4 to a high of ~20 or so to avoid trig operations while keeping arc generation accurate.
    143          
    144                 This approximation also allows mc_arc to immediately insert a line segment into the planner
    145                 without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
    146                 a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead.
    147                 This is important when there are successive arc motions.
    148              */
    149              // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3/6) in ~52usec
    150              float cos_T = 2.0f - theta_per_segment*theta_per_segment;
    151              float sin_T = theta_per_segment*0.16666667f*(cos_T + 4.0f);
    152              cos_T *= 0.5;
    153          
    154              float sin_Ti;
    155              float cos_Ti;
    156              float r_axisi;
    157              uint16_t i;
    158              uint8_t count = 0;
    159          
    160              for (i = 1; i<segments; i++) { // Increment (segments-1).
    161          
    162                if (count < N_ARC_CORRECTION) {
    163                  // Apply vector rotation matrix. ~40 usec
    164                  r_axisi = r_axis0*sin_T + r_axis1*cos_T;
    165                  r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
    166                  r_axis1 = r_axisi;
    167                  count++;
    168                } else {
    169                  // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments. ~375 usec
    170                  // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
    171                  cos_Ti = cosf(i*theta_per_segment);
    172                  sin_Ti = sinf(i*theta_per_segment);
    173                  r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;
    174                  r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
    175                  count = 0;
    176                }
    177          
    178                // Update arc_target location
    179                position[axis_0] = center_axis0 + r_axis0;
    180                position[axis_1] = center_axis1 + r_axis1;
    181                position[axis_linear] += linear_per_segment;
    182          
    183                mc_line(position, pl_data);
    184          
    185                // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
    186                if (sys.abort) { return; }
    187              }
    188            }
    189            // Ensure last segment arrives at target location.
    190            mc_line(target, pl_data);
    191          }
    192          
    193          
    194          // Execute dwell in seconds.
    195          void mc_dwell(float seconds)
    196          {
    197            if (sys.state == STATE_CHECK_MODE) { return; }
    198            protocol_buffer_synchronize();
    199            delay_sec(seconds, DELAY_MODE_DWELL);
    200          }
    201          
    202          
    203          // Perform homing cycle to locate and set machine zero. Only '$H' executes this command.
    204          // NOTE: There should be no motions in the buffer and Grbl must be in an idle state before
    205          // executing the homing cycle. This prevents incorrect buffered plans after homing.
    206          void mc_homing_cycle(uint8_t cycle_mask)
    207          {
    208            // Check and abort homing cycle, if hard limits are already enabled. Helps prevent problems
    209            // with machines with limits wired on both ends of travel to one limit pin.
    210            // TODO: Move the pin-specific LIMIT_PIN call to limits.c as a function.
    211            #ifdef LIMITS_TWO_SWITCHES_ON_AXES
    212              if (limits_get_state()) {
    213                mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
    214                system_set_exec_alarm(EXEC_ALARM_HARD_LIMIT);
    215                return;
    216              }
    217            #endif
    218          
    219            limits_disable(); // Disable hard limits pin change register for cycle duration
    220          
    221            // -------------------------------------------------------------------------------------
    222            // Perform homing routine. NOTE: Special motion case. Only system reset works.
    223            
    224            #ifdef HOMING_SINGLE_AXIS_COMMANDS
    225              if (cycle_mask) { limits_go_home(cycle_mask); } // Perform homing cycle based on mask.
    226              else
    227            #endif
    228            {
    229              // Search to engage all axes limit switches at faster homing seek rate.
    230              limits_go_home(HOMING_CYCLE_0);  // Homing cycle 0
    231              #ifdef HOMING_CYCLE_1
    232                limits_go_home(HOMING_CYCLE_1);  // Homing cycle 1
    233              #endif
    234              #ifdef HOMING_CYCLE_2
    235                limits_go_home(HOMING_CYCLE_2);  // Homing cycle 2
    236              #endif
    237            }
    238          
    239            protocol_execute_realtime(); // Check for reset and set system abort.
    240            if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
    241          
    242            // Homing cycle complete! Setup system for normal operation.
    243            // -------------------------------------------------------------------------------------
    244          
    245            // Sync gcode parser and planner positions to homed position.
    246            gc_sync_position();
    247            plan_sync_position();
    248          #if 0
    249            // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
    250          	EXTI_ClearITPendingBit((1 << X_LIMIT_BIT) | (1 << Y_LIMIT_BIT) | (1 << Z_LIMIT_BIT));
    251          	NVIC_ClearPendingIRQ(EXTI15_10_IRQn);
    252          	NVIC_EnableIRQ(EXTI15_10_IRQn);
    253          #endif
    254          }
    255          
    256          
    257          // Perform tool length probe cycle. Requires probe switch.
    258          // NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
    259          uint8_t mc_probe_cycle(float *target, plan_line_data_t *pl_data, uint8_t parser_flags)
    260          {
    261            // TODO: Need to update this cycle so it obeys a non-auto cycle start.
    262            if (sys.state == STATE_CHECK_MODE) { return(GC_PROBE_CHECK_MODE); }
    263          
    264            // Finish all queued commands and empty planner buffer before starting probe cycle.
    265            protocol_buffer_synchronize();
    266            if (sys.abort) { return(GC_PROBE_ABORT); } // Return if system reset has been issued.
    267          
    268            // Initialize probing control variables
    269            uint8_t is_probe_away = bit_istrue(parser_flags, GC_PARSER_PROBE_IS_AWAY);
    270            uint8_t is_no_error = bit_istrue(parser_flags, GC_PARSER_PROBE_IS_NO_ERROR);
    271            sys.probe_succeeded = false; // Re-initialize probe history before beginning cycle.
    272            probe_configure_invert_mask(is_probe_away);
    273          
    274            // After syncing, check if probe is already triggered. If so, halt and issue alarm.
    275            // NOTE: This probe initialization error applies to all probing cycles.
    276            if ( probe_get_state() ) { // Check probe pin state.
    277              system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_INITIAL);
    278              protocol_execute_realtime();
    279              probe_configure_invert_mask(false); // Re-initialize invert mask before returning.
    280              return(GC_PROBE_FAIL_INIT); // Nothing else to do but bail.
    281            }
    282          
    283            // Setup and queue probing motion. Auto cycle-start should not start the cycle.
    284            mc_line(target, pl_data);
    285          
    286            // Activate the probing state monitor in the stepper module.
    287            sys_probe_state = PROBE_ACTIVE;
    288          
    289            // Perform probing cycle. Wait here until probe is triggered or motion completes.
    290            system_set_exec_state_flag(EXEC_CYCLE_START);
    291            do {
    292              protocol_execute_realtime();
    293              if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
    294            } while (sys.state != STATE_IDLE);
    295          
    296            // Probing cycle complete!
    297          
    298            // Set state variables and error out, if the probe failed and cycle with error is enabled.
    299            if (sys_probe_state == PROBE_ACTIVE) {
    300              if (is_no_error) { memcpy(sys_probe_position, sys_position, sizeof(sys_position)); }
    301              else { system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_CONTACT); }
    302            } else {
    303              sys.probe_succeeded = true; // Indicate to system the probing cycle completed successfully.
    304            }
    305            sys_probe_state = PROBE_OFF; // Ensure probe state monitor is disabled.
    306            probe_configure_invert_mask(false); // Re-initialize invert mask.
    307            protocol_execute_realtime();   // Check and execute run-time commands
    308          
    309            // Reset the stepper and planner buffers to remove the remainder of the probe motion.
    310            st_reset(); // Reset step segment buffer.
    311            plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
    312            plan_sync_position(); // Sync planner position to current machine position.
    313          
    314            #ifdef MESSAGE_PROBE_COORDINATES
    315              // All done! Output the probe position as message.
    316              report_probe_parameters();
    317            #endif
    318          
    319            if (sys.probe_succeeded) { return(GC_PROBE_FOUND); } // Successful probe cycle.
    320            else { return(GC_PROBE_FAIL_END); } // Failed to trigger probe within travel. With or without error.
    321          }
    322          
    323          #ifdef PARKING_ENABLE
    324          	void mc_parking_motion(float *parking_target, plan_line_data_t *pl_data)
    325          	{
    326          		if (sys.abort) { return; } // Block during abort.
    327          
    328          		uint8_t plan_status = plan_buffer_line(parking_target, pl_data);
    329          
    330          		if (plan_status) {
    331          			bit_true(sys.step_control, STEP_CONTROL_EXECUTE_SYS_MOTION);
    332          			bit_false(sys.step_control, STEP_CONTROL_END_MOTION); // Allow parking motion to execute, if feed hold is active.
    333          			st_parking_setup_buffer(); // Setup step segment buffer for special parking motion case
    334          			st_prep_buffer();
    335          			st_wake_up();
    336          			do {
    337          				protocol_exec_rt_system();
    338          				if (sys.abort) { return; }
    339          			} while (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION);
    340          			st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
    341          		}
    342          		else {
    343          			bit_false(sys.step_control, STEP_CONTROL_EXECUTE_SYS_MOTION);
    344          			protocol_exec_rt_system();
    345          		}
    346          
    347          	}
    348          #endif
    349          
    350          
    351          #ifdef ENABLE_PARKING_OVERRIDE_CONTROL
    352          void mc_override_ctrl_update(uint8_t override_state)
    353          {
    354          	// Finish all queued commands before altering override control state
    355          	protocol_buffer_synchronize();
    356          	if (sys.abort) { return; }
    357          	sys.override_ctrl = override_state;
    358          }
    359          #endif
    360          // Method to ready the system to reset by setting the realtime reset command and killing any
    361          // active processes in the system. This also checks if a system reset is issued while Grbl
    362          // is in a motion state. If so, kills the steppers and sets the system alarm to flag position
    363          // lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
    364          // realtime abort command and hard limits. So, keep to a minimum.
    365          void mc_reset()
    366          {
    367            // Only this function can set the system reset. Helps prevent multiple kill calls.
    368            if (bit_isfalse(sys_rt_exec_state, EXEC_RESET)) {
    369              system_set_exec_state_flag(EXEC_RESET);
    370          
    371              // Kill spindle and coolant.
    372              spindle_stop();
    373              coolant_stop();
    374          
    375              // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
    376              // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    377              // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    378              // violated, by which, all bets are off.
    379              if ((sys.state & (STATE_CYCLE | STATE_HOMING | STATE_JOG)) ||
    380              		(sys.step_control & (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION))) {
    381                if (sys.state == STATE_HOMING) {
    382                  if (!sys_rt_exec_alarm) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_RESET); }
    383                }
    384                else { system_set_exec_alarm(EXEC_ALARM_ABORT_CYCLE); }
    385                st_go_idle(); // Force kill steppers. Position has likely been lost.
    386              }
    387            }
    388          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     104   mc_arc
       104   -> __aeabi_d2f
       104   -> __aeabi_dadd
       104   -> __aeabi_dmul
       104   -> __aeabi_f2d
       104   -> __aeabi_f2iz
       104   -> __aeabi_fadd
       104   -> __aeabi_fdiv
       104   -> __aeabi_fmul
       104   -> __aeabi_fsub
       104   -> __aeabi_ui2f
       104   -> atan2f
       104   -> cosf
       104   -> floorf
       104   -> mc_line
       104   -> sinf
       104   -> sqrtf
       104 __aeabi_cfcmple
       104 __aeabi_cfrcmple
       8   mc_dwell
         8   -> delay_sec
         8   -> protocol_buffer_synchronize
       8   mc_homing_cycle
         8   -> gc_sync_position
         8   -> limits_disable
         8   -> limits_go_home
         8   -> plan_sync_position
         8   -> protocol_execute_realtime
      24   mc_line
        24   -> limits_soft_check
        24   -> plan_buffer_line
        24   -> plan_check_full_buffer
        24   -> protocol_auto_cycle_start
        24   -> protocol_execute_realtime
        24   -> spindle_sync
      48   mc_probe_cycle
        48   -> __aeabi_memcpy
        48   -> mc_line
        48   -> plan_reset
        48   -> plan_sync_position
        48   -> probe_configure_invert_mask
        48   -> probe_get_state
        48   -> protocol_buffer_synchronize
        48   -> protocol_execute_realtime
        48   -> report_probe_parameters
        48   -> st_reset
        48   -> system_set_exec_alarm
        48   -> system_set_exec_state_flag
       8   mc_reset
         8   -> coolant_stop
         8   -> spindle_stop
         8   -> st_go_idle
         8   -> system_set_exec_alarm
         8   -> system_set_exec_state_flag


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
     834  mc_arc
      26  mc_dwell
      42  mc_homing_cycle
     104  mc_line
     234  mc_probe_cycle
      76  mc_reset

 
 1'372 bytes in section .text
 
 1'372 bytes of CODE memory

Errors: none
Warnings: none
