###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         16/Oct/2021  20:54:57
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\nuts_bolts.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EW1E68.tmp
#        (D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\nuts_bolts.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -D MSTEP_BRD -D
#        USE_USB_OTG_FS -D STM32F205xx -lcN
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\.\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\dbg\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\core\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\drv\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\hdlc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\cdc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\ -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\List\nuts_bolts.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\Obj\nuts_bolts.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\nuts_bolts.c
      1          /*
      2            nuts_bolts.c - Shared functions
      3            Part of Grbl
      4          
      5            Copyright (c) 2011-2016 Sungeun K. Jeon for Gnea Research LLC
      6            Copyright (c) 2009-2011 Simen Svale Skogsrud
      7          
      8            Grbl is free software: you can redistribute it and/or modify
      9            it under the terms of the GNU General Public License as published by
     10            the Free Software Foundation, either version 3 of the License, or
     11            (at your option) any later version.
     12          
     13            Grbl is distributed in the hope that it will be useful,
     14            but WITHOUT ANY WARRANTY; without even the implied warranty of
     15            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16            GNU General Public License for more details.
     17          
     18            You should have received a copy of the GNU General Public License
     19            along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
     20          */
     21          
     22          #include "my_grbl.h"
     23          
     24          
     25          #define MAX_INT_DIGITS 8 // Maximum number of digits in int32 (and float)
     26          
     27          
     28          // Extracts a floating point value from a string. The following code is based loosely on
     29          // the avr-libc strtod() function by Michael Stumpf and Dmitry Xmelkov and many freely
     30          // available conversion method examples, but has been highly optimized for Grbl. For known
     31          // CNC applications, the typical decimal value is expected to be in the range of E0 to E-4.
     32          // Scientific notation is officially not supported by g-code, and the 'E' character may
     33          // be a g-code word on some CNC systems. So, 'E' notation will not be recognized.
     34          // NOTE: Thanks to Radu-Eosif Mihailescu for identifying the issues with using strtod().
     35          uint8_t read_float(char *line, uint8_t *char_counter, float *float_ptr)
     36          {
     37            char *ptr = line + *char_counter;
     38            unsigned char c;
     39          
     40            // Grab first character and increment pointer. No spaces assumed in line.
     41            c = *ptr++;
     42          
     43            // Capture initial positive/minus character
     44            bool isnegative = false;
     45            if (c == '-') {
     46              isnegative = true;
     47              c = *ptr++;
     48            } else if (c == '+') {
     49              c = *ptr++;
     50            }
     51          
     52            // Extract number into fast integer. Track decimal in terms of exponent value.
     53            uint32_t intval = 0;
     54            int8_t exp = 0;
     55            uint8_t ndigit = 0;
     56            bool isdecimal = false;
     57            while(1) {
     58              c -= '0';
     59              if (c <= 9) {
     60                ndigit++;
     61                if (ndigit <= MAX_INT_DIGITS) {
     62                  if (isdecimal) { exp--; }
     63                  intval = (((intval << 2) + intval) << 1) + c; // intval*10 + c
     64                } else {
     65                  if (!(isdecimal)) { exp++; }  // Drop overflow digits
     66                }
     67              } else if (c == (('.'-'0') & 0xff)  &&  !(isdecimal)) {
     68                isdecimal = true;
     69              } else {
     70                break;
     71              }
     72              c = *ptr++;
     73            }
     74          
     75            // Return if no digits have been read.
     76            if (!ndigit) { return(false); };
     77          
     78            // Convert integer into floating point.
     79            float fval;
     80            fval = (float)intval;
     81          
     82            // Apply decimal. Should perform no more than two floating point multiplications for the
     83            // expected range of E0 to E-4.
     84            if (fval != 0) {
     85              while (exp <= -2) {
     86                fval *= 0.01f;
     87                exp += 2;
     88              }
     89              if (exp < 0) {
     90                fval *= 0.1f;
     91              } else if (exp > 0) {
     92                do {
     93                  fval *= 10.0f;
     94                } while (--exp > 0);
     95              }
     96            }
     97          
     98            // Assign floating point value with correct sign.
     99            if (isnegative) {
    100              *float_ptr = -fval;
    101            } else {
    102              *float_ptr = fval;
    103            }
    104          
    105            *char_counter = ptr - line - 1; // Set char_counter to next statement
    106          
    107            return(true);
    108          }
    109          
    110          
    111          // Non-blocking delay function used for general operation and suspend features.
    112          void delay_sec(float seconds, uint8_t mode)
    113          {
    114          	uint16_t i = (uint16_t)ceilf(1000 / DWELL_TIME_STEP*seconds);
    115          	while (i-- > 0) {
    116          		if (sys.abort) { return; }
    117          		if (mode == DELAY_MODE_DWELL) {
    118          			protocol_execute_realtime();
    119          		} else { // DELAY_MODE_SYS_SUSPEND
    120          		  // Execute rt_system() only to avoid nesting suspend loops.
    121          		  protocol_exec_rt_system();
    122          		  if (sys.suspend & SUSPEND_RESTART_RETRACT) { return; } // Bail, if safety door reopens.
    123          		}
    124          		_delay_ms(DWELL_TIME_STEP); // Delay DWELL_TIME_STEP increment
    125          	}
    126          }
    127          
    128          
    129          // Delays variable defined milliseconds. Compiler compatibility fix for _delay_ms(),
    130          // which only accepts constants in future compiler releases.
    131          void delay__ms(uint16_t ms)
    132          {
    133            while ( ms-- ) { _delay_ms(1); }
    134          }
    135          
    136          
    137          // Simple hypotenuse computation function.
    138          float hypot_f(float x, float y) { return(sqrtf(x*x + y*y)); }
    139          
    140          
    141          float convert_delta_vector_to_unit_vector(float *vector)
    142          {
    143            uint8_t idx;
    144            float magnitude = 0.0f;
    145            for (idx=0; idx<N_AXIS; idx++) {
    146              if (vector[idx] != 0.0f) {
    147                magnitude += vector[idx]*vector[idx];
    148              }
    149            }
    150            magnitude = sqrtf(magnitude);
    151            float inv_magnitude = 1.0f/magnitude;
    152            for (idx=0; idx<N_AXIS; idx++) { vector[idx] *= inv_magnitude; }
    153            return(magnitude);
    154          }
    155          
    156          
    157          float limit_value_by_axis_maximum(float *max_value, float *unit_vec)
    158          {
    159            uint8_t idx;
    160            float limit_value = SOME_LARGE_VALUE;
    161            for (idx=0; idx<N_AXIS; idx++) {
    162              if (unit_vec[idx] != 0) {  // Avoid divide by zero.
    163                limit_value = min(limit_value,fabsf(max_value[idx]/unit_vec[idx]));
    164              }
    165            }
    166            return(limit_value);
    167          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   convert_delta_vector_to_unit_vector
        32   -> __aeabi_fadd
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> sqrtf
        32 __aeabi_cfcmpeq
       8   delay__ms
         8   -> _delay_ms
      24   delay_sec
        24   -> __aeabi_f2iz
        24   -> __aeabi_fmul
        24   -> _delay_ms
        24   -> ceilf
        24   -> protocol_exec_rt_system
        24   -> protocol_execute_realtime
      16   hypot_f
        16   -> __aeabi_fadd
        16   -> __aeabi_fmul
        16   -> sqrtf
      24   limit_value_by_axis_maximum
        24   -> __aeabi_fdiv
        24 __aeabi_cfcmpeq
        24 __aeabi_cfcmple
      48   read_float
        48   -> __aeabi_fmul
        48   -> __aeabi_ui2f
        48 __aeabi_cfcmpeq


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
     132  convert_delta_vector_to_unit_vector
      24  delay__ms
      76  delay_sec
      36  hypot_f
     100  limit_value_by_axis_maximum
     310  read_float

 
 702 bytes in section .text
 
 702 bytes of CODE memory

Errors: none
Warnings: none
