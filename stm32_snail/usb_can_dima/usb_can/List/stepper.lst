###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         15/Sep/2021  14:34:10
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\stepper.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EW5459.tmp
#        (D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\stepper.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -D MSTEP_BRD -D
#        USE_USB_OTG_FS -D STM32F205xx -lcN
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\.\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\dbg\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\core\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\drv\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\hdlc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\cdc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\ -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can\List\stepper.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can\Obj\stepper.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\stepper.c
      1          /*
      2            stepper.c - stepper motor driver: executes motion plans using stepper motors
      3            Part of Grbl
      4          
      5            Copyright (c) 2011-2016 Sungeun K. Jeon for Gnea Research LLC
      6            Copyright (c) 2009-2011 Simen Svale Skogsrud
      7          
      8            Grbl is free software: you can redistribute it and/or modify
      9            it under the terms of the GNU General Public License as published by
     10            the Free Software Foundation, either version 3 of the License, or
     11            (at your option) any later version.
     12          
     13            Grbl is distributed in the hope that it will be useful,
     14            but WITHOUT ANY WARRANTY; without even the implied warranty of
     15            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16            GNU General Public License for more details.
     17          
     18            You should have received a copy of the GNU General Public License
     19            along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
     20          */
     21          
     22          #include "my_grbl.h"
     23          #if 0
     24          ////typedef int bool;
     25          #include "stm32f10x_rcc.h"
     26          #include "stm32f10x_tim.h"
     27          ////#include "stm32f10x_nvic.h"
     28          
     29          #include "misc.h"
     30          void TIM_Configuration(TIM_TypeDef* TIMER, u16 Period, u16 Prescaler, u8 PP);
     31          
     32          
     33          // Some useful constants.
     34          #define DT_SEGMENT (1.0f/(ACCELERATION_TICKS_PER_SECOND*60.0f)) // min/segment
     35          #define REQ_MM_INCREMENT_SCALAR 1.25f
     36          #define RAMP_ACCEL 0
     37          #define RAMP_CRUISE 1
     38          #define RAMP_DECEL 2
     39          #define RAMP_DECEL_OVERRIDE 3
     40          
     41          #define PREP_FLAG_RECALCULATE bit(0)
     42          #define PREP_FLAG_HOLD_PARTIAL_BLOCK bit(1)
     43          #define PREP_FLAG_PARKING bit(2)
     44          #define PREP_FLAG_DECEL_OVERRIDE bit(3)
     45          const PORTPINDEF step_pin_mask[N_AXIS] =
     46          {
     47          	1 << X_STEP_BIT,
     48          	1 << Y_STEP_BIT,
     49          	1 << Z_STEP_BIT,
     50          
     51          };
     52          const PORTPINDEF direction_pin_mask[N_AXIS] =
     53          {
     54          	1 << X_DIRECTION_BIT,
     55          	1 << Y_DIRECTION_BIT,
     56          	1 << Z_DIRECTION_BIT,
     57          };
     58          #if 0
     59          const PORTPINDEF limit_pin_mask[N_AXIS] =
     60          {
     61          	1 << X_LIMIT_BIT,
     62          	1 << Y_LIMIT_BIT,
     63          	1 << Z_LIMIT_BIT,
     64          };
     65          #endif
     66          // Define Adaptive Multi-Axis Step-Smoothing(AMASS) levels and cutoff frequencies. The highest level
     67          // frequency bin starts at 0Hz and ends at its cutoff frequency. The next lower level frequency bin
     68          // starts at the next higher cutoff frequency, and so on. The cutoff frequencies for each level must
     69          // be considered carefully against how much it over-drives the stepper ISR, the accuracy of the 16-bit
     70          // timer, and the CPU overhead. Level 0 (no AMASS, normal operation) frequency bin starts at the
     71          // Level 1 cutoff frequency and up to as fast as the CPU allows (over 30kHz in limited testing).
     72          // NOTE: AMASS cutoff frequency multiplied by ISR overdrive factor must not exceed maximum step frequency.
     73          // NOTE: Current settings are set to overdrive the ISR to no more than 16kHz, balancing CPU overhead
     74          // and timer accuracy.  Do not alter these settings unless you know what you are doing.
     75          #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
     76          	#define MAX_AMASS_LEVEL 3
     77          	// AMASS_LEVEL0: Normal operation. No AMASS. No upper cutoff frequency. Starts at LEVEL1 cutoff frequency.
     78          	#define AMASS_LEVEL1 (F_CPU/8000) // Over-drives ISR (x2). Defined as F_CPU/(Cutoff frequency in Hz)
     79          	#define AMASS_LEVEL2 (F_CPU/4000) // Over-drives ISR (x4)
     80          	#define AMASS_LEVEL3 (F_CPU/2000) // Over-drives ISR (x8)
     81          
     82            #if MAX_AMASS_LEVEL <= 0
     83              error "AMASS must have 1 or more levels to operate correctly."
     84            #endif
     85          #endif
     86          
     87          
     88          // Stores the planner block Bresenham algorithm execution data for the segments in the segment
     89          // buffer. Normally, this buffer is partially in-use, but, for the worst case scenario, it will
     90          // never exceed the number of accessible stepper buffer segments (SEGMENT_BUFFER_SIZE-1).
     91          // NOTE: This data is copied from the prepped planner blocks so that the planner blocks may be
     92          // discarded when entirely consumed and completed by the segment buffer. Also, AMASS alters this
     93          // data for its own use.
     94          typedef struct {
     95            uint32_t steps[N_AXIS];
     96            uint32_t step_event_count;
     97            uint8_t direction_bits;
     98            #ifdef VARIABLE_SPINDLE
     99              uint8_t is_pwm_rate_adjusted; // Tracks motions that require constant laser power/rate
    100            #endif
    101          } st_block_t;
    102          static st_block_t st_block_buffer[SEGMENT_BUFFER_SIZE-1];
    103          
    104          // Primary stepper segment ring buffer. Contains small, short line segments for the stepper
    105          // algorithm to execute, which are "checked-out" incrementally from the first block in the
    106          // planner buffer. Once "checked-out", the steps in the segments buffer cannot be modified by
    107          // the planner, where the remaining planner block steps still can.
    108          typedef struct {
    109            uint16_t n_step;           // Number of step events to be executed for this segment
    110            uint16_t cycles_per_tick;  // Step distance traveled per ISR tick, aka step rate.
    111            uint8_t  st_block_index;   // Stepper block data index. Uses this information to execute this segment.
    112            #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    113              uint8_t amass_level;    // Indicates AMASS level for the ISR to execute this segment
    114            #else
    115              uint8_t prescaler;      // Without AMASS, a prescaler is required to adjust for slow timing.
    116            #endif
    117            #ifdef VARIABLE_SPINDLE
    118              uint8_t spindle_pwm;
    119            #endif
    120          } segment_t;
    121          static segment_t segment_buffer[SEGMENT_BUFFER_SIZE];
    122          
    123          // Stepper ISR data struct. Contains the running data for the main stepper ISR.
    124          typedef struct {
    125            // Used by the bresenham line algorithm
    126            uint32_t counter_x,        // Counter variables for the bresenham line tracer
    127                     counter_y,
    128                     counter_z;
    129            #ifdef STEP_PULSE_DELAY
    130              uint8_t step_bits;  // Stores out_bits output to complete the step pulse delay
    131            #endif
    132          
    133            uint8_t execute_step;     // Flags step execution for each interrupt.
    134            uint8_t step_pulse_time;  // Step pulse reset time after step rise
    135          
    136            PORTPINDEF step_outbits;         // The next stepping-bits to be output
    137            PORTPINDEF dir_outbits;
    138            #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    139              uint32_t steps[N_AXIS];
    140            #endif
    141          
    142            uint16_t step_count;       // Steps remaining in line segment motion
    143            uint8_t exec_block_index; // Tracks the current st_block index. Change indicates new block.
    144            st_block_t *exec_block;   // Pointer to the block data for the segment being executed
    145            segment_t *exec_segment;  // Pointer to the segment being executed
    146          } stepper_t;
    147          static stepper_t st;
    148          
    149          // Step segment ring buffer indices
    150          static volatile uint8_t segment_buffer_tail;
    151          static uint8_t segment_buffer_head;
    152          static uint8_t segment_next_head;
    153          
    154          // Step and direction port invert masks.
    155          static PORTPINDEF step_port_invert_mask;
    156          static PORTPINDEF dir_port_invert_mask;
    157          
    158          // Used to avoid ISR nesting of the "Stepper Driver Interrupt". Should never occur though.
    159          static volatile uint8_t busy;
    160          
    161          // Pointers for the step segment being prepped from the planner buffer. Accessed only by the
    162          // main program. Pointers may be planning segments or planner blocks ahead of what being executed.
    163          static plan_block_t *pl_block;     // Pointer to the planner block being prepped
    164          static st_block_t *st_prep_block;  // Pointer to the stepper block data being prepped
    165          
    166          // Segment preparation data struct. Contains all the necessary information to compute new segments
    167          // based on the current executing planner block.
    168          typedef struct {
    169            uint8_t st_block_index;  // Index of stepper common data block being prepped
    170            uint8_t recalculate_flag;
    171          
    172            float dt_remainder;
    173            float steps_remaining;
    174            float step_per_mm;
    175            float req_mm_increment;
    176          
    177            #ifdef PARKING_ENABLE
    178              uint8_t last_st_block_index;
    179              float last_steps_remaining;
    180              float last_step_per_mm;
    181              float last_dt_remainder;
    182            #endif
    183          
    184            uint8_t ramp_type;      // Current segment ramp state
    185            float mm_complete;      // End of velocity profile from end of current planner block in (mm).
    186                                    // NOTE: This value must coincide with a step(no mantissa) when converted.
    187            float current_speed;    // Current speed at the end of the segment buffer (mm/min)
    188            float maximum_speed;    // Maximum speed of executing block. Not always nominal speed. (mm/min)
    189            float exit_speed;       // Exit speed of executing block (mm/min)
    190            float accelerate_until; // Acceleration ramp end measured from end of block (mm)
    191            float decelerate_after; // Deceleration ramp start measured from end of block (mm)
    192          
    193            #ifdef VARIABLE_SPINDLE
    194              float inv_rate;    // Used by PWM laser mode to speed up segment calculations.
    195              uint8_t current_spindle_pwm;
    196            #endif
    197          } st_prep_t;
    198          static st_prep_t prep;
    199          
    200          
    201          /*    BLOCK VELOCITY PROFILE DEFINITION
    202                    __________________________
    203                   /|                        |\     _________________         ^
    204                  / |                        | \   /|               |\        |
    205                 /  |                        |  \ / |               | \       s
    206                /   |                        |   |  |               |  \      p
    207               /    |                        |   |  |               |   \     e
    208              +-----+------------------------+---+--+---------------+----+    e
    209              |               BLOCK 1            ^      BLOCK 2          |    d
    210                                                 |
    211                            time ----->      EXAMPLE: Block 2 entry speed is at max junction velocity
    212          
    213            The planner block buffer is planned assuming constant acceleration velocity profiles and are
    214            continuously joined at block junctions as shown above. However, the planner only actively computes
    215            the block entry speeds for an optimal velocity plan, but does not compute the block internal
    216            velocity profiles. These velocity profiles are computed ad-hoc as they are executed by the
    217            stepper algorithm and consists of only 7 possible types of profiles: cruise-only, cruise-
    218            deceleration, acceleration-cruise, acceleration-only, deceleration-only, full-trapezoid, and
    219            triangle(no cruise).
    220          
    221                                                  maximum_speed (< nominal_speed) ->  +
    222                              +--------+ <- maximum_speed (= nominal_speed)          /|\
    223                             /          \                                           / | \
    224           current_speed -> +            \                                         /  |  + <- exit_speed
    225                            |             + <- exit_speed                         /   |  |
    226                            +-------------+                     current_speed -> +----+--+
    227                             time -->  ^  ^                                           ^  ^
    228                                       |  |                                           |  |
    229                          decelerate_after(in mm)                             decelerate_after(in mm)
    230                              ^           ^                                           ^  ^
    231                              |           |                                           |  |
    232                          accelerate_until(in mm)                             accelerate_until(in mm)
    233          
    234            The step segment buffer computes the executing block velocity profile and tracks the critical
    235            parameters for the stepper algorithm to accurately trace the profile. These critical parameters
    236            are shown and defined in the above illustration.
    237          */
    238          
    239          
    240          // Stepper state initialization. Cycle should only start if the st.cycle_start flag is
    241          // enabled. Startup init and limits call this function but shouldn't start the cycle.
    242          void st_wake_up()????????
    243          {
    244            // Enable stepper drivers.
    245            if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) 
    246            { 
    247          	  SetStepperDisableBit();
    248            }
    249            else 
    250            { 
    251          	  ResetStepperDisableBit(); 
    252            }
    253          
    254            // Initialize stepper output bits to ensure first ISR call does not step.
    255            st.step_outbits = step_port_invert_mask;
    256          
    257            // Initialize step pulse timing from settings. Here to ensure updating after re-writing.
    258            #ifdef STEP_PULSE_DELAY
    259              // Set total step pulse time after direction pin set. Ad hoc computation from oscilloscope.
    260              st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);
    261              // Set delay between direction pin write and step command.
    262              OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
    263            #else // Normal operation
    264              // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
    265              st.step_pulse_time = (settings.pulse_microseconds)*TICKS_PER_MICROSECOND;
    266            #endif
    267          
    268            // Enable Stepper Driver Interrupt
    269            TIM3->ARR = st.step_pulse_time - 1;
    270            TIM3->EGR = TIM_PSCReloadMode_Immediate;
    271            TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
    272          
    273            TIM2->ARR = st.exec_segment->cycles_per_tick - 1;
    274            /* Set the Autoreload value */
    275          #ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        
    276            TIM2->PSC = st.exec_segment->prescaler;
    277          #endif
    278            TIM2->EGR = TIM_PSCReloadMode_Immediate;
    279            NVIC_EnableIRQ(TIM2_IRQn);
    280          }
    281          
    282          
    283          // Stepper shutdown
    284          void st_go_idle()
    285          {
    286            // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
    287            NVIC_DisableIRQ(TIM2_IRQn);
    288          
    289            busy = false;
    290          
    291            // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
    292            bool pin_state = false; // Keep enabled.
    293            if (((settings.stepper_idle_lock_time != 0xff) || sys_rt_exec_alarm || sys.state == STATE_SLEEP) && sys.state != STATE_HOMING) {
    294              // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    295              // stop and not drift from residual inertial forces at the end of the last movement.
    296              delay__ms(settings.stepper_idle_lock_time);
    297              pin_state = true; // Override. Disable steppers.
    298            }
    299            if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    300            if (pin_state) 
    301            { 
    302          	  SetStepperDisableBit();
    303            }
    304            else 
    305            { 
    306          	  ResetStepperDisableBit();
    307            }
    308          }
    309          
    310          
    311          /* "The Stepper Driver Interrupt" - This timer interrupt is the workhorse of Grbl. Grbl employs
    312             the venerable Bresenham line algorithm to manage and exactly synchronize multi-axis moves.
    313             Unlike the popular DDA algorithm, the Bresenham algorithm is not susceptible to numerical
    314             round-off errors and only requires fast integer counters, meaning low computational overhead
    315             and maximizing the Arduino's capabilities. However, the downside of the Bresenham algorithm
    316             is, for certain multi-axis motions, the non-dominant axes may suffer from un-smooth step
    317             pulse trains, or aliasing, which can lead to strange audible noises or shaking. This is
    318             particularly noticeable or may cause motion issues at low step frequencies (0-5kHz), but
    319             is usually not a physical problem at higher frequencies, although audible.
    320               To improve Bresenham multi-axis performance, Grbl uses what we call an Adaptive Multi-Axis
    321             Step Smoothing (AMASS) algorithm, which does what the name implies. At lower step frequencies,
    322             AMASS artificially increases the Bresenham resolution without effecting the algorithm's
    323             innate exactness. AMASS adapts its resolution levels automatically depending on the step
    324             frequency to be executed, meaning that for even lower step frequencies the step smoothing
    325             level increases. Algorithmically, AMASS is acheived by a simple bit-shifting of the Bresenham
    326             step count for each AMASS level. For example, for a Level 1 step smoothing, we bit shift
    327             the Bresenham step event count, effectively multiplying it by 2, while the axis step counts
    328             remain the same, and then double the stepper ISR frequency. In effect, we are allowing the
    329             non-dominant Bresenham axes step in the intermediate ISR tick, while the dominant axis is
    330             stepping every two ISR ticks, rather than every ISR tick in the traditional sense. At AMASS
    331             Level 2, we simply bit-shift again, so the non-dominant Bresenham axes can step within any
    332             of the four ISR ticks, the dominant axis steps every four ISR ticks, and quadruple the
    333             stepper ISR frequency. And so on. This, in effect, virtually eliminates multi-axis aliasing
    334             issues with the Bresenham algorithm and does not significantly alter Grbl's performance, but
    335             in fact, more efficiently utilizes unused CPU cycles overall throughout all configurations.
    336               AMASS retains the Bresenham algorithm exactness by requiring that it always executes a full
    337             Bresenham step, regardless of AMASS Level. Meaning that for an AMASS Level 2, all four
    338             intermediate steps must be completed such that baseline Bresenham (Level 0) count is always
    339             retained. Similarly, AMASS Level 3 means all eight intermediate steps must be executed.
    340             Although the AMASS Levels are in reality arbitrary, where the baseline Bresenham counts can
    341             be multiplied by any integer value, multiplication by powers of two are simply used to ease
    342             CPU overhead with bitshift integer operations.
    343               This interrupt is simple and dumb by design. All the computational heavy-lifting, as in
    344             determining accelerations, is performed elsewhere. This interrupt pops pre-computed segments,
    345             defined as constant velocity over n number of steps, from the step segment buffer and then
    346             executes them by pulsing the stepper pins appropriately via the Bresenham algorithm. This
    347             ISR is supported by The Stepper Port Reset Interrupt which it uses to reset the stepper port
    348             after each pulse. The bresenham line tracer algorithm controls all stepper outputs
    349             simultaneously with these two interrupts.
    350          
    351             NOTE: This interrupt must be as efficient as possible and complete before the next ISR tick,
    352             which for Grbl must be less than 33.3usec (@30kHz ISR rate). Oscilloscope measured time in
    353             ISR is 5usec typical and 25usec maximum, well below requirement.
    354             NOTE: This ISR expects at least one step to be executed per segment.
    355          */
    356          // TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller
    357          // int8 variables and update position counters only when a segment completes. This can get complicated
    358          // with probing and homing cycles that require true real-time positions.
    359          void TIM2_IRQHandler(void)
    360          {
    361          	if ((TIM2->SR & 0x0001) != 0)                  // check interrupt source
    362          	{
    363          		TIM2->SR &= ~(1 << 0);                          // clear UIF flag
    364          		TIM2->CNT = 0;
    365          	}
    366          	else
    367          	{
    368          		return;
    369          	}
    370          
    371            if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
    372            GPIO_Write(DIRECTION_PORT, (GPIO_ReadOutputData(DIRECTION_PORT) & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK));
    373            TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
    374          
    375            // Then pulse the stepping pins
    376            #ifdef STEP_PULSE_DELAY
    377              st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwriting.
    378            #else  // Normal operation
    379          	GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | st.step_outbits);
    380            #endif
    381          
    382            // Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after
    383            // exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.
    384             NVIC_EnableIRQ(TIM3_IRQn);
    385          
    386            busy = true;
    387          
    388            // If there is no step segment, attempt to pop one from the stepper buffer
    389            if (st.exec_segment == NULL) {
    390              // Anything in the buffer? If so, load and initialize next step segment.
    391              if (segment_buffer_head != segment_buffer_tail) {
    392                // Initialize new step segment and load number of steps to execute
    393                st.exec_segment = &segment_buffer[segment_buffer_tail];
    394          
    395                // Initialize step segment timing per step and load number of steps to execute.
    396          	  TIM2->ARR = st.exec_segment->cycles_per_tick - 1;
    397          	  /* Set the Autoreload value */
    398          #ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        
    399          	  TIM2->PSC = st.exec_segment->prescaler;
    400          #endif
    401                st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
    402                // If the new segment starts a new planner block, initialize stepper variables and counters.
    403                // NOTE: When the segment data index changes, this indicates a new planner block.
    404                if ( st.exec_block_index != st.exec_segment->st_block_index ) {
    405                  st.exec_block_index = st.exec_segment->st_block_index;
    406                  st.exec_block = &st_block_buffer[st.exec_block_index];
    407          
    408                  // Initialize Bresenham line and distance counters
    409                  st.counter_x = st.counter_y = st.counter_z = (st.exec_block->step_event_count >> 1);
    410                }
    411                st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask;
    412          
    413                #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    414                  // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
    415                  st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
    416                  st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
    417                  st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
    418                #endif
    419          
    420                #ifdef VARIABLE_SPINDLE
    421                  // Set real-time spindle output as segment is loaded, just prior to the first step.
    422                  spindle_set_speed(st.exec_segment->spindle_pwm);
    423                #endif
    424          
    425              } else {
    426                // Segment buffer empty. Shutdown.
    427                st_go_idle();
    428                // Ensure pwm is set properly upon completion of rate-controlled motion.
    429                #ifdef VARIABLE_SPINDLE
    430                if (st.exec_block->is_pwm_rate_adjusted) { spindle_set_speed(SPINDLE_PWM_OFF_VALUE); }
    431                #endif
    432                system_set_exec_state_flag(EXEC_CYCLE_STOP); // Flag main program for cycle end
    433                return; // Nothing to do but exit.
    434              }
    435            }
    436          
    437          
    438            // Check probing state.
    439            if (sys_probe_state == PROBE_ACTIVE) { probe_state_monitor(); }
    440          
    441            // Reset step out bits.
    442            st.step_outbits = 0;
    443          
    444            // Execute step displacement profile by Bresenham line algorithm
    445            #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    446              st.counter_x += st.steps[X_AXIS];
    447            #else
    448              st.counter_x += st.exec_block->steps[X_AXIS];
    449            #endif
    450            if (st.counter_x > st.exec_block->step_event_count) {
    451              st.step_outbits |= (1<<X_STEP_BIT);
    452              st.counter_x -= st.exec_block->step_event_count;
    453              if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys_position[X_AXIS]--; }
    454              else { sys_position[X_AXIS]++; }
    455            }
    456            #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    457              st.counter_y += st.steps[Y_AXIS];
    458            #else
    459              st.counter_y += st.exec_block->steps[Y_AXIS];
    460            #endif
    461            if (st.counter_y > st.exec_block->step_event_count) {
    462              st.step_outbits |= (1<<Y_STEP_BIT);
    463              st.counter_y -= st.exec_block->step_event_count;
    464              if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys_position[Y_AXIS]--; }
    465              else { sys_position[Y_AXIS]++; }
    466            }
    467            #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    468              st.counter_z += st.steps[Z_AXIS];
    469            #else
    470              st.counter_z += st.exec_block->steps[Z_AXIS];
    471            #endif
    472            if (st.counter_z > st.exec_block->step_event_count) {
    473              st.step_outbits |= (1<<Z_STEP_BIT);
    474              st.counter_z -= st.exec_block->step_event_count;
    475              if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys_position[Z_AXIS]--; }
    476              else { sys_position[Z_AXIS]++; }
    477            }
    478          
    479            // During a homing cycle, lock out and prevent desired axes from moving.
    480            if (sys.state == STATE_HOMING) { st.step_outbits &= sys.homing_axis_lock; }
    481          
    482            st.step_count--; // Decrement step events count
    483            if (st.step_count == 0) {
    484              // Segment is complete. Discard current segment and advance segment indexing.
    485              st.exec_segment = NULL;
    486              uint8_t segment_tail_next = segment_buffer_tail + 1;
    487              if (segment_tail_next == SEGMENT_BUFFER_SIZE)
    488              {
    489                segment_tail_next = 0;
    490              }
    491              segment_buffer_tail = segment_tail_next;
    492            }
    493          
    494            st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask
    495            busy = false;
    496          }
    497          
    498          
    499          /* The Stepper Port Reset Interrupt: Timer0 OVF interrupt handles the falling edge of the step
    500             pulse. This should always trigger before the next Timer1 COMPA interrupt and independently
    501             finish, if Timer1 is disabled after completing a move.
    502             NOTE: Interrupt collisions between the serial and stepper interrupts can cause delays by
    503             a few microseconds, if they execute right before one another. Not a big deal, but can
    504             cause issues at high step rates if another high frequency asynchronous interrupt is
    505             added to Grbl.
    506          */
    507          // This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
    508          // a step. This ISR resets the motor port after a short period (settings.pulse_microseconds)
    509          // completing one step cycle.
    510          void TIM3_IRQHandler(void)
    511          {
    512          	if ((TIM3->SR & 0x0001) != 0)                  // check interrupt source
    513          	{
    514          		TIM3->SR &= ~(1<<0);                          // clear UIF flag
    515          		TIM3->CNT = 0;
    516           		NVIC_DisableIRQ(TIM3_IRQn);
    517              // Reset stepping pins (leave the direction pins)
    518          		GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK));
    519          	}
    520          }
    521          
    522          
    523          // Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
    524          void st_generate_step_dir_invert_masks()
    525          {
    526            uint8_t idx;
    527            step_port_invert_mask = 0;
    528            dir_port_invert_mask = 0;
    529            for (idx=0; idx<N_AXIS; idx++) {
    530              if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= step_pin_mask[idx]; }
    531              if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= direction_pin_mask[idx]; }
    532            }
    533          }
    534          
    535          
    536          // Reset and clear stepper subsystem variables
    537          void st_reset()
    538          {
    539            // Initialize stepper driver idle state.
    540            st_go_idle();
    541          
    542            // Initialize stepper algorithm variables.
    543            memset(&prep, 0, sizeof(st_prep_t));
    544            memset(&st, 0, sizeof(stepper_t));
    545            st.exec_segment = NULL;
    546            pl_block = NULL;  // Planner block pointer used by segment buffer
    547            segment_buffer_tail = 0;
    548            segment_buffer_head = 0; // empty = tail
    549            segment_next_head = 1;
    550            busy = false;
    551          
    552            st_generate_step_dir_invert_masks();
    553            st.dir_outbits = dir_port_invert_mask; // Initialize direction bits to default.
    554          
    555            // Initialize step and direction port pins.
    556            GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK));
    557            GPIO_Write(DIRECTION_PORT, (GPIO_ReadOutputData(DIRECTION_PORT) & ~DIRECTION_MASK) | (dir_port_invert_mask & DIRECTION_MASK));
    558          }
    559          
    560          // Initialize and start the stepper motor subsystem
    561          void stepper_init()
    562          {
    563            // Configure step and direction interface pins
    564          	GPIO_InitTypeDef GPIO_InitStructure;
    565          	RCC_APB2PeriphClockCmd(RCC_STEPPERS_DISABLE_PORT, ENABLE);
    566          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    567          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    568          	GPIO_InitStructure.GPIO_Pin = STEPPERS_DISABLE_MASK;
    569          	GPIO_Init(STEPPERS_DISABLE_PORT, &GPIO_InitStructure);
    570          
    571          	RCC_APB2PeriphClockCmd(RCC_STEP_PORT, ENABLE);
    572          	GPIO_InitStructure.GPIO_Pin = STEP_MASK;
    573          	GPIO_Init(STEP_PORT, &GPIO_InitStructure);
    574          
    575          	RCC_APB2PeriphClockCmd(RCC_DIRECTION_PORT, ENABLE);
    576          	GPIO_InitStructure.GPIO_Pin = DIRECTION_MASK;
    577          	GPIO_Init(DIRECTION_PORT, &GPIO_InitStructure);
    578            
    579            // Configurating TIM2
    580            RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
    581          	// RCC->APB1ENR |= RCC_APB1Periph_TIM2;
    582          	TIM_Configuration(TIM2, 1, 1, 1);
    583          
    584            // Configurating TIM3
    585            RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
    586          	// RCC->APB1ENR |= RCC_APB1Periph_TIM3;
    587          	TIM_Configuration(TIM3, 1, 1, 1);
    588          
    589            // Stop/Distable TIM2 & TIM3 here
    590           	NVIC_DisableIRQ(TIM3_IRQn);
    591           	NVIC_DisableIRQ(TIM2_IRQn);
    592          }
    593          
    594          
    595          // Called by planner_recalculate() when the executing block is updated by the new plan.
    596          void st_update_plan_block_parameters()
    597          {
    598            if (pl_block != NULL) { // Ignore if at start of a new block.
    599              prep.recalculate_flag |= PREP_FLAG_RECALCULATE;
    600              pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
    601              pl_block = NULL; // Flag st_prep_segment() to load and check active velocity profile.
    602            }
    603          }
    604          
    605          
    606          // Increments the step segment buffer block data ring buffer.
    607          static uint8_t st_next_block_index(uint8_t block_index)
    608          {
    609            block_index++;
    610            if ( block_index == (SEGMENT_BUFFER_SIZE-1) ) { return(0); }
    611            return(block_index);
    612          }
    613          
    614          
    615          #ifdef PARKING_ENABLE
    616            // Changes the run state of the step segment buffer to execute the special parking motion.
    617            void st_parking_setup_buffer()
    618            {
    619              // Store step execution data of partially completed block, if necessary.
    620              if (prep.recalculate_flag & PREP_FLAG_HOLD_PARTIAL_BLOCK) {
    621                prep.last_st_block_index = prep.st_block_index;
    622                prep.last_steps_remaining = prep.steps_remaining;
    623                prep.last_dt_remainder = prep.dt_remainder;
    624                prep.last_step_per_mm = prep.step_per_mm;
    625              }
    626              // Set flags to execute a parking motion
    627              prep.recalculate_flag |= PREP_FLAG_PARKING;
    628              prep.recalculate_flag &= ~(PREP_FLAG_RECALCULATE);
    629              pl_block = NULL; // Always reset parking motion to reload new block.
    630            }
    631          
    632          
    633            // Restores the step segment buffer to the normal run state after a parking motion.
    634            void st_parking_restore_buffer()
    635            {
    636              // Restore step execution data and flags of partially completed block, if necessary.
    637              if (prep.recalculate_flag & PREP_FLAG_HOLD_PARTIAL_BLOCK) {
    638                st_prep_block = &st_block_buffer[prep.last_st_block_index];
    639                prep.st_block_index = prep.last_st_block_index;
    640                prep.steps_remaining = prep.last_steps_remaining;
    641                prep.dt_remainder = prep.last_dt_remainder;
    642                prep.step_per_mm = prep.last_step_per_mm;
    643                prep.recalculate_flag = (PREP_FLAG_HOLD_PARTIAL_BLOCK | PREP_FLAG_RECALCULATE);
    644                prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm; // Recompute this value.
    645              } else {
    646                prep.recalculate_flag = false;
    647              }
    648              pl_block = NULL; // Set to reload next block.
    649            }
    650          #endif
    651          
    652          
    653          /* Prepares step segment buffer. Continuously called from main program.
    654          
    655             The segment buffer is an intermediary buffer interface between the execution of steps
    656             by the stepper algorithm and the velocity profiles generated by the planner. The stepper
    657             algorithm only executes steps within the segment buffer and is filled by the main program
    658             when steps are "checked-out" from the first block in the planner buffer. This keeps the
    659             step execution and planning optimization processes atomic and protected from each other.
    660             The number of steps "checked-out" from the planner buffer and the number of segments in
    661             the segment buffer is sized and computed such that no operation in the main program takes
    662             longer than the time it takes the stepper algorithm to empty it before refilling it.
    663             Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
    664             NOTE: Computation units are in steps, millimeters, and minutes.
    665          */
    666          void st_prep_buffer()
    667          {
    668            // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
    669            if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }
    670          
    671            while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
    672          
    673              // Determine if we need to load a new planner block or if the block needs to be recomputed.
    674              if (pl_block == NULL) {
    675          
    676                // Query planner for a queued block
    677                if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) { pl_block = plan_get_system_motion_block(); }
    678                else { pl_block = plan_get_current_block(); }
    679                if (pl_block == NULL) { return; } // No planner blocks. Exit.
    680          
    681                // Check if we need to only recompute the velocity profile or load a new block.
    682                if (prep.recalculate_flag & PREP_FLAG_RECALCULATE) {
    683          
    684                  #ifdef PARKING_ENABLE
    685                    if (prep.recalculate_flag & PREP_FLAG_PARKING) { prep.recalculate_flag &= ~(PREP_FLAG_RECALCULATE); }
    686                    else { prep.recalculate_flag = false; }
    687                  #else
    688                    prep.recalculate_flag = false;
    689                  #endif
    690          
    691                } else {
    692          
    693                  // Load the Bresenham stepping data for the block.
    694                  prep.st_block_index = st_next_block_index(prep.st_block_index);
    695          
    696                  // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
    697                  // when the segment buffer completes the planner block, it may be discarded when the
    698                  // segment buffer finishes the prepped block, but the stepper ISR is still executing it.
    699                  st_prep_block = &st_block_buffer[prep.st_block_index];
    700                  st_prep_block->direction_bits = pl_block->direction_bits;
    701                  uint8_t idx;
    702                  #ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    703                    for (idx=0; idx<N_AXIS; idx++) { st_prep_block->steps[idx] = (pl_block->steps[idx] << 1); }
    704                    st_prep_block->step_event_count = (pl_block->step_event_count << 1);
    705                  #else
    706                    // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS
    707                    // level, such that we never divide beyond the original data anywhere in the algorithm.
    708                    // If the original data is divided, we can lose a step from integer roundoff.
    709                    for (idx=0; idx<N_AXIS; idx++) { st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL; }
    710                    st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
    711                  #endif
    712          
    713                  // Initialize segment buffer data for generating the segments.
    714                  prep.steps_remaining = (float)pl_block->step_event_count;
    715                  prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
    716                  prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
    717                  prep.dt_remainder = 0.0f; // Reset for new segment block
    718          
    719                  if ((sys.step_control & STEP_CONTROL_EXECUTE_HOLD) || (prep.recalculate_flag & PREP_FLAG_DECEL_OVERRIDE)) {
    720                    // New block loaded mid-hold. Override planner block entry speed to enforce deceleration.
    721                    prep.current_speed = prep.exit_speed;
    722                    pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed;
    723                    prep.recalculate_flag &= ~(PREP_FLAG_DECEL_OVERRIDE);
    724                  } else {
    725                    prep.current_speed = sqrtf(pl_block->entry_speed_sqr);
    726                  }
    727          #ifdef VARIABLE_SPINDLE
    728                  // Setup laser mode variables. PWM rate adjusted motions will always complete a motion with the
    729                  // spindle off. 
    730                  st_prep_block->is_pwm_rate_adjusted = false;
    731                  if (settings.flags & BITFLAG_LASER_MODE) {
    732                    if (pl_block->condition & PL_COND_FLAG_SPINDLE_CCW) {
    733                      // Pre-compute inverse programmed rate to speed up PWM updating per step segment.
    734                      prep.inv_rate = 1.0f / pl_block->programmed_rate;
    735                      st_prep_block->is_pwm_rate_adjusted = true;
    736                    }
    737                  }
    738          #endif
    739                }
    740          
    741          			/* ---------------------------------------------------------------------------------
    742          			 Compute the velocity profile of a new planner block based on its entry and exit
    743          			 speeds, or recompute the profile of a partially-completed planner block if the
    744          			 planner has updated it. For a commanded forced-deceleration, such as from a feed
    745          			 hold, override the planner velocities and decelerate to the target exit speed.
    746          			*/
    747          			prep.mm_complete = 0.0f; // Default velocity profile complete at 0.0mm from end of block.
    748          			float inv_2_accel = 0.5f/pl_block->acceleration;
    749          			if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { // [Forced Deceleration to Zero Velocity]
    750          				// Compute velocity profile parameters for a feed hold in-progress. This profile overrides
    751          				// the planner block profile, enforcing a deceleration to zero speed.
    752          				prep.ramp_type = RAMP_DECEL;
    753          				// Compute decelerate distance relative to end of block.
    754          				float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
    755          				if (decel_dist < 0.0f) {
    756          					// Deceleration through entire planner block. End of feed hold is not in this block.
    757          					prep.exit_speed = sqrtf(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
    758          				} else {
    759          					prep.mm_complete = decel_dist; // End of feed hold.
    760          					prep.exit_speed = 0.0f;
    761          				}
    762          			} else { // [Normal Operation]
    763          				// Compute or recompute velocity profile parameters of the prepped planner block.
    764          				prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
    765          				prep.accelerate_until = pl_block->millimeters;
    766          
    767          				float exit_speed_sqr;
    768          				float nominal_speed;
    769                  if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
    770                    prep.exit_speed = exit_speed_sqr = 0.0f; // Enforce stop at end of system motion.
    771                  } else {
    772                    exit_speed_sqr = plan_get_exec_block_exit_speed_sqr();
    773                    prep.exit_speed = sqrtf(exit_speed_sqr);
    774                  }
    775          
    776                  nominal_speed = plan_compute_profile_nominal_speed(pl_block);
    777          				float nominal_speed_sqr = nominal_speed*nominal_speed;
    778          				float intersect_distance =
    779          								0.5f*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
    780          
    781                  if (pl_block->entry_speed_sqr > nominal_speed_sqr) { // Only occurs during override reductions.
    782                    prep.accelerate_until = pl_block->millimeters - inv_2_accel*(pl_block->entry_speed_sqr-nominal_speed_sqr);
    783                    if (prep.accelerate_until <= 0.0f) { // Deceleration-only.
    784                      prep.ramp_type = RAMP_DECEL;
    785                      // prep.decelerate_after = pl_block->millimeters;
    786                      // prep.maximum_speed = prep.current_speed;
    787          
    788                      // Compute override block exit speed since it doesn't match the planner exit speed.
    789                      prep.exit_speed = sqrtf(pl_block->entry_speed_sqr - 2*pl_block->acceleration*pl_block->millimeters);
    790                      prep.recalculate_flag |= PREP_FLAG_DECEL_OVERRIDE; // Flag to load next block as deceleration override.
    791          
    792                      // TODO: Determine correct handling of parameters in deceleration-only.
    793                      // Can be tricky since entry speed will be current speed, as in feed holds.
    794                      // Also, look into near-zero speed handling issues with this.
    795          
    796                    } else {
    797                      // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
    798                      prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr); // Should always be >= 0.0 due to planner reinit.
    799          						prep.maximum_speed = nominal_speed;
    800                      prep.ramp_type = RAMP_DECEL_OVERRIDE;
    801                    }
    802          				} else if (intersect_distance > 0.0f) {
    803          					if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
    804          						// NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
    805          						prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
    806          						if (prep.decelerate_after < intersect_distance) { // Trapezoid type
    807          							prep.maximum_speed = nominal_speed;
    808          							if (pl_block->entry_speed_sqr == nominal_speed_sqr) {
    809          								// Cruise-deceleration or cruise-only type.
    810          								prep.ramp_type = RAMP_CRUISE;
    811          							} else {
    812          								// Full-trapezoid or acceleration-cruise types
    813          								prep.accelerate_until -= inv_2_accel*(nominal_speed_sqr-pl_block->entry_speed_sqr);
    814          							}
    815          						} else { // Triangle type
    816          							prep.accelerate_until = intersect_distance;
    817          							prep.decelerate_after = intersect_distance;
    818          							prep.maximum_speed = sqrtf(2.0f*pl_block->acceleration*intersect_distance+exit_speed_sqr);
    819          						}
    820          					} else { // Deceleration-only type
    821                      prep.ramp_type = RAMP_DECEL;
    822                      // prep.decelerate_after = pl_block->millimeters;
    823                      // prep.maximum_speed = prep.current_speed;
    824          					}
    825          				} else { // Acceleration-only type
    826          					prep.accelerate_until = 0.0f;
    827          					// prep.decelerate_after = 0.0f;
    828          					prep.maximum_speed = prep.exit_speed;
    829          				}
    830          			}
    831                
    832                #ifdef VARIABLE_SPINDLE
    833                  bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); // Force update whenever updating block.
    834                #endif
    835              }
    836              
    837              // Initialize new segment
    838              segment_t *prep_segment = &segment_buffer[segment_buffer_head];
    839          
    840              // Set new segment to point to the current segment data block.
    841              prep_segment->st_block_index = prep.st_block_index;
    842          
    843              /*------------------------------------------------------------------------------------
    844                  Compute the average velocity of this new segment by determining the total distance
    845                traveled over the segment time DT_SEGMENT. The following code first attempts to create
    846                a full segment based on the current ramp conditions. If the segment time is incomplete
    847                when terminating at a ramp state change, the code will continue to loop through the
    848                progressing ramp states to fill the remaining segment execution time. However, if
    849                an incomplete segment terminates at the end of the velocity profile, the segment is
    850                considered completed despite having a truncated execution time less than DT_SEGMENT.
    851                  The velocity profile is always assumed to progress through the ramp sequence:
    852                acceleration ramp, cruising state, and deceleration ramp. Each ramp's travel distance
    853                may range from zero to the length of the block. Velocity profiles can end either at
    854                the end of planner block (typical) or mid-block at the end of a forced deceleration,
    855                such as from a feed hold.
    856              */
    857              float dt_max = DT_SEGMENT; // Maximum segment time
    858              float dt = 0.0f; // Initialize segment time
    859              float time_var = dt_max; // Time worker variable
    860              float mm_var; // mm-Distance worker variable
    861              float speed_var; // Speed worker variable
    862              float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    863              float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    864              if (minimum_mm < 0.0f) { minimum_mm = 0.0f; }
    865          
    866              do {
    867                switch (prep.ramp_type) {
    868                  case RAMP_DECEL_OVERRIDE:
    869                    speed_var = pl_block->acceleration*time_var;
    870          					if (prep.current_speed-prep.maximum_speed <= speed_var) {
    871                      // Cruise or cruise-deceleration types only for deceleration override.
    872          						mm_remaining = prep.accelerate_until;
    873                      time_var = 2.0f*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    874                      prep.ramp_type = RAMP_CRUISE;
    875                      prep.current_speed = prep.maximum_speed;
    876                    } else { // Mid-deceleration override ramp.
    877          						mm_remaining -= time_var*(prep.current_speed - 0.5f*speed_var);
    878                      prep.current_speed -= speed_var;
    879                    }
    880                    break;
    881                  case RAMP_ACCEL:
    882                    // NOTE: Acceleration ramp only computes during first do-while loop.
    883                    speed_var = pl_block->acceleration*time_var;
    884                    mm_remaining -= time_var*(prep.current_speed + 0.5f*speed_var);
    885                    if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    886                      // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
    887                      mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
    888                      time_var = 2.0f*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    889                      if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    890                      else { prep.ramp_type = RAMP_CRUISE; }
    891                      prep.current_speed = prep.maximum_speed;
    892                    } else { // Acceleration only.
    893                      prep.current_speed += speed_var;
    894                    }
    895                    break;
    896                  case RAMP_CRUISE:
    897                    // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
    898                    // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To
    899                    //   prevent this, simply enforce a minimum speed threshold in the planner.
    900                    mm_var = mm_remaining - prep.maximum_speed*time_var;
    901                    if (mm_var < prep.decelerate_after) { // End of cruise.
    902                      // Cruise-deceleration junction or end of block.
    903                      time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
    904                      mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
    905                      prep.ramp_type = RAMP_DECEL;
    906                    } else { // Cruising only.
    907                      mm_remaining = mm_var;
    908                    }
    909                    break;
    910                  default: // case RAMP_DECEL:
    911                    // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
    912                    speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
    913                    if (prep.current_speed > speed_var) { // Check if at or below zero speed.
    914                      // Compute distance from end of segment to end of block.
    915                      mm_var = mm_remaining - time_var*(prep.current_speed - 0.5f*speed_var); // (mm)
    916                      if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
    917                        mm_remaining = mm_var;
    918                        prep.current_speed -= speed_var;
    919                        break; // Segment complete. Exit switch-case statement. Continue do-while loop.
    920                      }
    921                    }
    922                    // Otherwise, at end of block or end of forced-deceleration.
    923                    time_var = 2.0f*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    924                    mm_remaining = prep.mm_complete;
    925                    prep.current_speed = prep.exit_speed;
    926                }
    927                dt += time_var; // Add computed ramp time to total segment time.
    928                if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
    929                else {
    930                  if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
    931                    // Increase segment time to ensure at least one step in segment. Override and loop
    932                    // through distance calculations until minimum_mm or mm_complete.
    933                    dt_max += DT_SEGMENT;
    934                    time_var = dt_max - dt;
    935                  } else {
    936                    break; // **Complete** Exit loop. Segment execution time maxed.
    937                  }
    938                }
    939              } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
    940          
    941              #ifdef VARIABLE_SPINDLE
    942                /* -----------------------------------------------------------------------------------
    943                  Compute spindle speed PWM output for step segment
    944                */
    945          
    946                if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
    947                  if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
    948                    float rpm = pl_block->spindle_speed;
    949                    // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.        
    950                    if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
    951                    // If current_speed is zero, then may need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE)
    952                    // but this would be instantaneous only and during a motion. May not matter at all.
    953                    prep.current_spindle_pwm = spindle_compute_pwm_value(rpm);
    954                  }
    955                  else {
    956                    sys.spindle_speed = 0.0;
    957                    prep.current_spindle_pwm = SPINDLE_PWM_OFF_VALUE;
    958                  }
    959                  bit_false(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    960                }
    961                prep_segment->spindle_pwm = prep.current_spindle_pwm; // Reload segment PWM value
    962          
    963              #endif
    964              
    965              /* -----------------------------------------------------------------------------------
    966                 Compute segment step rate, steps to execute, and apply necessary rate corrections.
    967                 NOTE: Steps are computed by direct scalar conversion of the millimeter distance
    968                 remaining in the block, rather than incrementally tallying the steps executed per
    969                 segment. This helps in removing floating point round-off issues of several additions.
    970                 However, since floats have only 7.2 significant digits, long moves with extremely
    971                 high step counts can exceed the precision of floats, which can lead to lost steps.
    972                 Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
    973                 supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    974              */
    975              float step_dist_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
    976              float n_steps_remaining = ceilf(step_dist_remaining); // Round-up current steps remaining
    977              float last_n_steps_remaining = ceilf(prep.steps_remaining); // Round-up last steps remaining
    978          	prep_segment->n_step = (uint16_t)(last_n_steps_remaining - n_steps_remaining); // Compute number of steps to execute.
    979          
    980              // Bail if we are at the end of a feed hold and don't have a step to execute.
    981              if (prep_segment->n_step == 0) {
    982                if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) {
    983                  // Less than one step to decelerate to zero speed, but already very close. AMASS
    984                  // requires full steps to execute. So, just bail.
    985                  bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    986                  #ifdef PARKING_ENABLE
    987                    if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
    988                  #endif
    989                  return; // Segment not generated, but current step data still retained.
    990                }
    991              }
    992          
    993              // Compute segment step rate. Since steps are integers and mm distances traveled are not,
    994              // the end of every segment can have a partial step of varying magnitudes that are not
    995              // executed, because the stepper ISR requires whole steps due to the AMASS algorithm. To
    996              // compensate, we track the time to execute the previous segment's partial step and simply
    997              // apply it with the partial step distance to the current segment, so that it minutely
    998              // adjusts the whole segment rate to keep step output exact. These rate adjustments are
    999              // typically very small and do not adversely effect performance, but ensures that Grbl
   1000              // outputs the exact acceleration and velocity profiles as computed by the planner.
   1001              dt += prep.dt_remainder; // Apply previous segment partial step execute time
   1002              float inv_rate = dt/(last_n_steps_remaining - step_dist_remaining); // Compute adjusted step rate inverse
   1003          
   1004              // Compute CPU cycles per step for the prepped segment.
   1005           ////???	uint32_t cycles = (uint32_t)ceilf((TICKS_PER_MICROSECOND * 1000000) *inv_rate * 60); // (cycles/step)
   1006          uint32_t cycles = 1000;////????
   1007              #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
   1008                // Compute step timing and multi-axis smoothing level.
   1009                // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
   1010                if (cycles < AMASS_LEVEL1) 
   1011                { 
   1012                  prep_segment->amass_level = 0; 
   1013                }
   1014                else {
   1015                  if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
   1016                  else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
   1017                  else { prep_segment->amass_level = 3; }
   1018                  cycles >>= prep_segment->amass_level;
   1019                  prep_segment->n_step <<= prep_segment->amass_level;
   1020                }
   1021                if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
   1022                else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
   1023              #else
   1024                // Compute step timing and timer prescalar for normal step generation.
   1025                if (cycles < (1UL << 16)) { // < 65536  (4.1ms @ 16MHz)
   1026                  prep_segment->prescaler = 1; // prescaler: 0
   1027                  prep_segment->cycles_per_tick = cycles;
   1028                } else if (cycles < (1UL << 19)) { // < 524288 (32.8ms@16MHz)
   1029                  prep_segment->prescaler = 2; // prescaler: 8
   1030                  prep_segment->cycles_per_tick = cycles >> 3;
   1031                } else {
   1032                  prep_segment->prescaler = 3; // prescaler: 64
   1033                  if (cycles < (1UL << 22)) { // < 4194304 (262ms@16MHz)
   1034                    prep_segment->cycles_per_tick =  cycles >> 6;
   1035                  } else { // Just set the slowest speed possible. (Around 4 step/sec.)
   1036                    prep_segment->cycles_per_tick = 0xffff;
   1037                  }
   1038                }
   1039              #endif
   1040          
   1041              // Segment complete! Increment segment buffer indices, so stepper ISR can immediately execute it.
   1042              segment_buffer_head = segment_next_head;
   1043              if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
   1044          
   1045              // Update the appropriate planner and segment data.
   1046              pl_block->millimeters = mm_remaining;
   1047              prep.steps_remaining = n_steps_remaining;
   1048              prep.dt_remainder = (n_steps_remaining - step_dist_remaining)*inv_rate;
   1049          
   1050              // Check for exit conditions and flag to load next planner block.
   1051              if (mm_remaining == prep.mm_complete) {
   1052                // End of planner block or forced-termination. No more distance to be executed.
   1053                if (mm_remaining > 0.0f) { // At end of forced-termination.
   1054                  // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
   1055                  // the segment queue, where realtime protocol will set new state upon receiving the
   1056                  // cycle stop flag from the ISR. Prep_segment is blocked until then.
   1057                  bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
   1058                  #ifdef PARKING_ENABLE
   1059                    if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
   1060                  #endif
   1061                  return; // Bail!
   1062                } else { // End of planner block
   1063                  // The planner block is complete. All steps are set to be executed in the segment buffer.
   1064                  if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
   1065                    bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
   1066                    return;
   1067                  }
   1068                  pl_block = NULL; // Set pointer to indicate check and load next planner block.
   1069                  plan_discard_current_block();
   1070                }
   1071              }
   1072          
   1073            }
   1074          }
   1075          
   1076          
   1077          // Called by realtime status reporting to fetch the current speed being executed. This value
   1078          // however is not exactly the current speed, but the speed computed in the last step segment
   1079          // in the segment buffer. It will always be behind by up to the number of segment blocks (-1)
   1080          // divided by the ACCELERATION TICKS PER SECOND in seconds.
   1081          float st_get_realtime_rate()
   1082          {
   1083            if (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)){
   1084              return prep.current_speed;
   1085            }
   1086            return 0.0f;
   1087          }
   1088          
   1089          void TIM_Configuration(TIM_TypeDef* TIMER, u16 Period, u16 Prescaler, u8 PP)
   1090          {
   1091          	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
   1092           	NVIC_InitTypeDef NVIC_InitStructure;
   1093          
   1094          	TIM_TimeBaseStructure.TIM_Period = Period - 1;
   1095          	TIM_TimeBaseStructure.TIM_Prescaler = Prescaler - 1;
   1096          	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
   1097          	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   1098          	TIM_TimeBaseInit(TIMER, &TIM_TimeBaseStructure);
   1099          
   1100          	TIM_ClearITPendingBit(TIMER, TIM_IT_Update);
   1101          	TIM_ITConfig(TIMER, TIM_IT_Update, ENABLE);
   1102          	TIM_Cmd(TIMER, ENABLE);
   1103          
   1104          	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
   1105           	if (TIMER == TIM2) 
   1106                    { 
   1107                    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn; 
   1108                    }
   1109           	else if (TIMER == TIM3) 
   1110                    { 
   1111                    NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn; 
   1112                    }
   1113           	else if (TIMER == TIM4) 
   1114                    { 
   1115            ////????        NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn; 
   1116                    }
   1117          
   1118          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = PP;
   1119          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
   1120          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   1121          	NVIC_Init(&NVIC_InitStructure);
   1122          }
   1123          #endif


 
 
 0 bytes of memory

Errors: none
Warnings: none
