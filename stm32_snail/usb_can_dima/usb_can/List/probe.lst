###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         15/Sep/2021  14:34:10
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\probe.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EW528F.tmp
#        (D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\probe.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -D MSTEP_BRD -D
#        USE_USB_OTG_FS -D STM32F205xx -lcN
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Full.h" -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\.\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\dbg\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\core\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\drv\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\hdlc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\cdc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\ -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can\List\probe.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can\Obj\probe.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\probe.c
      1          /*
      2            probe.c - code pertaining to probing methods
      3            Part of Grbl
      4          
      5            Copyright (c) 2014-2016 Sungeun K. Jeon for Gnea Research LLC
      6          
      7            Grbl is free software: you can redistribute it and/or modify
      8            it under the terms of the GNU General Public License as published by
      9            the Free Software Foundation, either version 3 of the License, or
     10            (at your option) any later version.
     11          
     12            Grbl is distributed in the hope that it will be useful,
     13            but WITHOUT ANY WARRANTY; without even the implied warranty of
     14            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15            GNU General Public License for more details.
     16          
     17            You should have received a copy of the GNU General Public License
     18            along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
     19          */
     20          
     21          #include "my_grbl.h"
     22          
     23          
     24          // Inverts the probe pin state depending on user settings and probing cycle mode.
     25          uint8_t probe_invert_mask;
     26          
     27          
     28          // Probe pin initialization routine.
     29          void probe_init()
     30          {
     31          #if 0
     32          	GPIO_InitTypeDef GPIO_InitStructure;
     33          	RCC_APB2PeriphClockCmd(RCC_PROBE_PORT, ENABLE);
     34          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     35          #ifdef DISABLE_PROBE_PIN_PULL_UP
     36          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
     37          #else
     38          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
     39          #endif
     40          	GPIO_InitStructure.GPIO_Pin = PROBE_MASK;
     41          	GPIO_Init(PROBE_PORT, &GPIO_InitStructure);
     42            probe_configure_invert_mask(false); // Initialize invert mask.
     43          #endif
     44          }
     45          
     46          
     47          // Called by probe_init() and the mc_probe() routines. Sets up the probe pin invert mask to
     48          // appropriately set the pin logic according to setting for normal-high/normal-low operation
     49          // and the probing cycle modes for toward-workpiece/away-from-workpiece.
     50          void probe_configure_invert_mask(uint8_t is_probe_away)
     51          {
     52            probe_invert_mask = 0; // Initialize as zero.
     53            if (bit_isfalse(settings.flags,BITFLAG_INVERT_PROBE_PIN)) { probe_invert_mask ^= PROBE_MASK; }
     54            if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
     55          }
     56          
     57          
     58          // Returns the probe pin state. Triggered = true. Called by gcode parser and probe state monitor.
     59          uint8_t probe_get_state() 
     60          { 
     61          ////???	return ((GPIO_ReadInputData(PROBE_PORT) & PROBE_MASK) ^ probe_invert_mask) != 0;
     62           return 0;       
     63          }
     64          
     65          
     66          // Monitors probe pin state and records the system position when detected. Called by the
     67          // stepper ISR per ISR tick.
     68          // NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
     69          void probe_state_monitor()
     70          {
     71          #if 0  
     72            if (probe_get_state()) {
     73              sys_probe_state = PROBE_OFF;
     74              memcpy(sys_probe_position, sys_position, sizeof(sys_position));
     75              bit_true(sys_rt_exec_state, EXEC_MOTION_CANCEL);
     76            }
     77          #endif  
     78          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   probe_configure_invert_mask
       0   probe_get_state
       0   probe_init
       0   probe_state_monitor


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
      34  probe_configure_invert_mask
       4  probe_get_state
       2  probe_init
       1  probe_invert_mask
       2  probe_state_monitor

 
  1 byte  in section .bss
 50 bytes in section .text
 
 50 bytes of CODE memory
  1 byte  of DATA memory

Errors: none
Warnings: none
