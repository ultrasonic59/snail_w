###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         13/Oct/2021  19:41:18
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\stepper.c
#    Command line =
#        -f C:\Users\vova\AppData\Local\Temp\EW301D.tmp
#        (D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\stepper.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -D USEUSB -D MSTEP_BRD -D
#        USE_USB_OTG_FS -D STM32F205xx -lcN
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\List
#        --diag_suppress Pa082,pe191 -o
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\.\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\board\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\freertos\source\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\freertos\source\port\ARM_CM3\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\dbg\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\libraries\STM32F2xx_StdPeriph_Driver\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\core\inc\
#        -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\drv\inc\
#        -I D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\inc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\hdlc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\..\common\usb\cdc\ -I
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\ -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\List\stepper.lst
#    Object file  =
#        D:\proj\velograph\snail\stm32_snail\usb_can_dima\usb_can_dima\Obj\stepper.o
#
###############################################################################

D:\proj\velograph\snail\stm32_snail\usb_can_dima\src\my_grbl\stepper.c
      1          /*
      2            stepper.c - stepper motor driver: executes motion plans using stepper motors
      3            Part of Grbl
      4          
      5            Copyright (c) 2011-2016 Sungeun K. Jeon for Gnea Research LLC
      6            Copyright (c) 2009-2011 Simen Svale Skogsrud
      7          
      8            Grbl is free software: you can redistribute it and/or modify
      9            it under the terms of the GNU General Public License as published by
     10            the Free Software Foundation, either version 3 of the License, or
     11            (at your option) any later version.
     12          
     13            Grbl is distributed in the hope that it will be useful,
     14            but WITHOUT ANY WARRANTY; without even the implied warranty of
     15            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16            GNU General Public License for more details.
     17          
     18            You should have received a copy of the GNU General Public License
     19            along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
     20          */
     21          
     22          #include "my_grbl.h"
     23          
     24          #if 0
     25          ////typedef int bool;
     26          #include "stm32f10x_rcc.h"
     27          #include "stm32f10x_tim.h"
     28          ////#include "stm32f10x_nvic.h"
     29          
     30          #include "misc.h"
     31          void TIM_Configuration(TIM_TypeDef* TIMER, u16 Period, u16 Prescaler, u8 PP);
     32          #endif
     33          
     34          #define X_DIRECTION_BIT 3
     35          #define Y_DIRECTION_BIT 4
     36          #define Z_DIRECTION_BIT 5
     37          
     38          // Some useful constants.
     39          #define DT_SEGMENT (1.0f/(ACCELERATION_TICKS_PER_SECOND*60.0f)) // min/segment
     40          #define REQ_MM_INCREMENT_SCALAR 1.25f
     41          #define RAMP_ACCEL 0
     42          #define RAMP_CRUISE 1
     43          #define RAMP_DECEL 2
     44          #define RAMP_DECEL_OVERRIDE 3
     45          
     46          #define PREP_FLAG_RECALCULATE bit(0)
     47          #define PREP_FLAG_HOLD_PARTIAL_BLOCK bit(1)
     48          #define PREP_FLAG_PARKING bit(2)
     49          #define PREP_FLAG_DECEL_OVERRIDE bit(3)
     50          const PORTPINDEF step_pin_mask[N_AXIS] =
     51          {
     52          	1 << X_STEP_BIT,
     53          	1 << Y_STEP_BIT,
     54          	1 << Z_STEP_BIT,
     55          
     56          };
     57          const PORTPINDEF direction_pin_mask[N_AXIS] =
     58          {
     59          	1 << X_DIRECTION_BIT,
     60          	1 << Y_DIRECTION_BIT,
     61          	1 << Z_DIRECTION_BIT,
     62          };
     63          
     64          #if 0
     65          
     66          #if 0
     67          const PORTPINDEF limit_pin_mask[N_AXIS] =
     68          {
     69          	1 << X_LIMIT_BIT,
     70          	1 << Y_LIMIT_BIT,
     71          	1 << Z_LIMIT_BIT,
     72          };
     73          #endif
     74          // Define Adaptive Multi-Axis Step-Smoothing(AMASS) levels and cutoff frequencies. The highest level
     75          // frequency bin starts at 0Hz and ends at its cutoff frequency. The next lower level frequency bin
     76          // starts at the next higher cutoff frequency, and so on. The cutoff frequencies for each level must
     77          // be considered carefully against how much it over-drives the stepper ISR, the accuracy of the 16-bit
     78          // timer, and the CPU overhead. Level 0 (no AMASS, normal operation) frequency bin starts at the
     79          // Level 1 cutoff frequency and up to as fast as the CPU allows (over 30kHz in limited testing).
     80          // NOTE: AMASS cutoff frequency multiplied by ISR overdrive factor must not exceed maximum step frequency.
     81          // NOTE: Current settings are set to overdrive the ISR to no more than 16kHz, balancing CPU overhead
     82          // and timer accuracy.  Do not alter these settings unless you know what you are doing.
     83          #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
     84          	#define MAX_AMASS_LEVEL 3
     85          	// AMASS_LEVEL0: Normal operation. No AMASS. No upper cutoff frequency. Starts at LEVEL1 cutoff frequency.
     86          	#define AMASS_LEVEL1 (F_CPU/8000) // Over-drives ISR (x2). Defined as F_CPU/(Cutoff frequency in Hz)
     87          	#define AMASS_LEVEL2 (F_CPU/4000) // Over-drives ISR (x4)
     88          	#define AMASS_LEVEL3 (F_CPU/2000) // Over-drives ISR (x8)
     89          
     90            #if MAX_AMASS_LEVEL <= 0
     91              error "AMASS must have 1 or more levels to operate correctly."
     92            #endif
     93          #endif
     94          
     95          
     96          // Stores the planner block Bresenham algorithm execution data for the segments in the segment
     97          // buffer. Normally, this buffer is partially in-use, but, for the worst case scenario, it will
     98          // never exceed the number of accessible stepper buffer segments (SEGMENT_BUFFER_SIZE-1).
     99          // NOTE: This data is copied from the prepped planner blocks so that the planner blocks may be
    100          // discarded when entirely consumed and completed by the segment buffer. Also, AMASS alters this
    101          // data for its own use.
    102          typedef struct {
    103            uint32_t steps[N_AXIS];
    104            uint32_t step_event_count;
    105            uint8_t direction_bits;
    106            #ifdef VARIABLE_SPINDLE
    107              uint8_t is_pwm_rate_adjusted; // Tracks motions that require constant laser power/rate
    108            #endif
    109          } st_block_t;
    110          static st_block_t st_block_buffer[SEGMENT_BUFFER_SIZE-1];
    111          
    112          // Primary stepper segment ring buffer. Contains small, short line segments for the stepper
    113          // algorithm to execute, which are "checked-out" incrementally from the first block in the
    114          // planner buffer. Once "checked-out", the steps in the segments buffer cannot be modified by
    115          // the planner, where the remaining planner block steps still can.
    116          typedef struct {
    117            uint16_t n_step;           // Number of step events to be executed for this segment
    118            uint16_t cycles_per_tick;  // Step distance traveled per ISR tick, aka step rate.
    119            uint8_t  st_block_index;   // Stepper block data index. Uses this information to execute this segment.
    120            #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    121              uint8_t amass_level;    // Indicates AMASS level for the ISR to execute this segment
    122            #else
    123              uint8_t prescaler;      // Without AMASS, a prescaler is required to adjust for slow timing.
    124            #endif
    125            #ifdef VARIABLE_SPINDLE
    126              uint8_t spindle_pwm;
    127            #endif
    128          } segment_t;
    129          static segment_t segment_buffer[SEGMENT_BUFFER_SIZE];
    130          
    131          // Stepper ISR data struct. Contains the running data for the main stepper ISR.
    132          typedef struct {
    133            // Used by the bresenham line algorithm
    134            uint32_t counter_x,        // Counter variables for the bresenham line tracer
    135                     counter_y,
    136                     counter_z;
    137            #ifdef STEP_PULSE_DELAY
    138              uint8_t step_bits;  // Stores out_bits output to complete the step pulse delay
    139            #endif
    140          
    141            uint8_t execute_step;     // Flags step execution for each interrupt.
    142            uint8_t step_pulse_time;  // Step pulse reset time after step rise
    143          
    144            PORTPINDEF step_outbits;         // The next stepping-bits to be output
    145            PORTPINDEF dir_outbits;
    146            #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    147              uint32_t steps[N_AXIS];
    148            #endif
    149          
    150            uint16_t step_count;       // Steps remaining in line segment motion
    151            uint8_t exec_block_index; // Tracks the current st_block index. Change indicates new block.
    152            st_block_t *exec_block;   // Pointer to the block data for the segment being executed
    153            segment_t *exec_segment;  // Pointer to the segment being executed
    154          } stepper_t;
    155          static stepper_t st;
    156          
    157          // Step segment ring buffer indices
    158          static volatile uint8_t segment_buffer_tail;
    159          static uint8_t segment_buffer_head;
    160          static uint8_t segment_next_head;
    161          
    162          // Step and direction port invert masks.
    163          static PORTPINDEF step_port_invert_mask;
    164          static PORTPINDEF dir_port_invert_mask;
    165          
    166          // Used to avoid ISR nesting of the "Stepper Driver Interrupt". Should never occur though.
    167          static volatile uint8_t busy;
    168          
    169          // Pointers for the step segment being prepped from the planner buffer. Accessed only by the
    170          // main program. Pointers may be planning segments or planner blocks ahead of what being executed.
    171          static plan_block_t *pl_block;     // Pointer to the planner block being prepped
    172          static st_block_t *st_prep_block;  // Pointer to the stepper block data being prepped
    173          
    174          // Segment preparation data struct. Contains all the necessary information to compute new segments
    175          // based on the current executing planner block.
    176          typedef struct {
    177            uint8_t st_block_index;  // Index of stepper common data block being prepped
    178            uint8_t recalculate_flag;
    179          
    180            float dt_remainder;
    181            float steps_remaining;
    182            float step_per_mm;
    183            float req_mm_increment;
    184          
    185            #ifdef PARKING_ENABLE
    186              uint8_t last_st_block_index;
    187              float last_steps_remaining;
    188              float last_step_per_mm;
    189              float last_dt_remainder;
    190            #endif
    191          
    192            uint8_t ramp_type;      // Current segment ramp state
    193            float mm_complete;      // End of velocity profile from end of current planner block in (mm).
    194                                    // NOTE: This value must coincide with a step(no mantissa) when converted.
    195            float current_speed;    // Current speed at the end of the segment buffer (mm/min)
    196            float maximum_speed;    // Maximum speed of executing block. Not always nominal speed. (mm/min)
    197            float exit_speed;       // Exit speed of executing block (mm/min)
    198            float accelerate_until; // Acceleration ramp end measured from end of block (mm)
    199            float decelerate_after; // Deceleration ramp start measured from end of block (mm)
    200          
    201            #ifdef VARIABLE_SPINDLE
    202              float inv_rate;    // Used by PWM laser mode to speed up segment calculations.
    203              uint8_t current_spindle_pwm;
    204            #endif
    205          } st_prep_t;
    206          static st_prep_t prep;
    207          
    208          
    209          /*    BLOCK VELOCITY PROFILE DEFINITION
    210                    __________________________
    211                   /|                        |\     _________________         ^
    212                  / |                        | \   /|               |\        |
    213                 /  |                        |  \ / |               | \       s
    214                /   |                        |   |  |               |  \      p
    215               /    |                        |   |  |               |   \     e
    216              +-----+------------------------+---+--+---------------+----+    e
    217              |               BLOCK 1            ^      BLOCK 2          |    d
    218                                                 |
    219                            time ----->      EXAMPLE: Block 2 entry speed is at max junction velocity
    220          
    221            The planner block buffer is planned assuming constant acceleration velocity profiles and are
    222            continuously joined at block junctions as shown above. However, the planner only actively computes
    223            the block entry speeds for an optimal velocity plan, but does not compute the block internal
    224            velocity profiles. These velocity profiles are computed ad-hoc as they are executed by the
    225            stepper algorithm and consists of only 7 possible types of profiles: cruise-only, cruise-
    226            deceleration, acceleration-cruise, acceleration-only, deceleration-only, full-trapezoid, and
    227            triangle(no cruise).
    228          
    229                                                  maximum_speed (< nominal_speed) ->  +
    230                              +--------+ <- maximum_speed (= nominal_speed)          /|\
    231                             /          \                                           / | \
    232           current_speed -> +            \                                         /  |  + <- exit_speed
    233                            |             + <- exit_speed                         /   |  |
    234                            +-------------+                     current_speed -> +----+--+
    235                             time -->  ^  ^                                           ^  ^
    236                                       |  |                                           |  |
    237                          decelerate_after(in mm)                             decelerate_after(in mm)
    238                              ^           ^                                           ^  ^
    239                              |           |                                           |  |
    240                          accelerate_until(in mm)                             accelerate_until(in mm)
    241          
    242            The step segment buffer computes the executing block velocity profile and tracks the critical
    243            parameters for the stepper algorithm to accurately trace the profile. These critical parameters
    244            are shown and defined in the above illustration.
    245          */
    246          
    247          
    248          // Stepper state initialization. Cycle should only start if the st.cycle_start flag is
    249          // enabled. Startup init and limits call this function but shouldn't start the cycle.
    250          void st_wake_up()????????
    251          {
    252            // Enable stepper drivers.
    253            if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) 
    254            { 
    255          	  SetStepperDisableBit();
    256            }
    257            else 
    258            { 
    259          	  ResetStepperDisableBit(); 
    260            }
    261          
    262            // Initialize stepper output bits to ensure first ISR call does not step.
    263            st.step_outbits = step_port_invert_mask;
    264          
    265            // Initialize step pulse timing from settings. Here to ensure updating after re-writing.
    266            #ifdef STEP_PULSE_DELAY
    267              // Set total step pulse time after direction pin set. Ad hoc computation from oscilloscope.
    268              st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);
    269              // Set delay between direction pin write and step command.
    270              OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
    271            #else // Normal operation
    272              // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
    273              st.step_pulse_time = (settings.pulse_microseconds)*TICKS_PER_MICROSECOND;
    274            #endif
    275          
    276            // Enable Stepper Driver Interrupt
    277            TIM3->ARR = st.step_pulse_time - 1;
    278            TIM3->EGR = TIM_PSCReloadMode_Immediate;
    279            TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
    280          
    281            TIM2->ARR = st.exec_segment->cycles_per_tick - 1;
    282            /* Set the Autoreload value */
    283          #ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        
    284            TIM2->PSC = st.exec_segment->prescaler;
    285          #endif
    286            TIM2->EGR = TIM_PSCReloadMode_Immediate;
    287            NVIC_EnableIRQ(TIM2_IRQn);
    288          }
    289          
    290          
    291          // Stepper shutdown
    292          void st_go_idle()
    293          {
    294            // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
    295            NVIC_DisableIRQ(TIM2_IRQn);
    296          
    297            busy = false;
    298          
    299            // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
    300            bool pin_state = false; // Keep enabled.
    301            if (((settings.stepper_idle_lock_time != 0xff) || sys_rt_exec_alarm || sys.state == STATE_SLEEP) && sys.state != STATE_HOMING) {
    302              // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    303              // stop and not drift from residual inertial forces at the end of the last movement.
    304              delay__ms(settings.stepper_idle_lock_time);
    305              pin_state = true; // Override. Disable steppers.
    306            }
    307            if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    308            if (pin_state) 
    309            { 
    310          	  SetStepperDisableBit();
    311            }
    312            else 
    313            { 
    314          	  ResetStepperDisableBit();
    315            }
    316          }
    317          
    318          
    319          /* "The Stepper Driver Interrupt" - This timer interrupt is the workhorse of Grbl. Grbl employs
    320             the venerable Bresenham line algorithm to manage and exactly synchronize multi-axis moves.
    321             Unlike the popular DDA algorithm, the Bresenham algorithm is not susceptible to numerical
    322             round-off errors and only requires fast integer counters, meaning low computational overhead
    323             and maximizing the Arduino's capabilities. However, the downside of the Bresenham algorithm
    324             is, for certain multi-axis motions, the non-dominant axes may suffer from un-smooth step
    325             pulse trains, or aliasing, which can lead to strange audible noises or shaking. This is
    326             particularly noticeable or may cause motion issues at low step frequencies (0-5kHz), but
    327             is usually not a physical problem at higher frequencies, although audible.
    328               To improve Bresenham multi-axis performance, Grbl uses what we call an Adaptive Multi-Axis
    329             Step Smoothing (AMASS) algorithm, which does what the name implies. At lower step frequencies,
    330             AMASS artificially increases the Bresenham resolution without effecting the algorithm's
    331             innate exactness. AMASS adapts its resolution levels automatically depending on the step
    332             frequency to be executed, meaning that for even lower step frequencies the step smoothing
    333             level increases. Algorithmically, AMASS is acheived by a simple bit-shifting of the Bresenham
    334             step count for each AMASS level. For example, for a Level 1 step smoothing, we bit shift
    335             the Bresenham step event count, effectively multiplying it by 2, while the axis step counts
    336             remain the same, and then double the stepper ISR frequency. In effect, we are allowing the
    337             non-dominant Bresenham axes step in the intermediate ISR tick, while the dominant axis is
    338             stepping every two ISR ticks, rather than every ISR tick in the traditional sense. At AMASS
    339             Level 2, we simply bit-shift again, so the non-dominant Bresenham axes can step within any
    340             of the four ISR ticks, the dominant axis steps every four ISR ticks, and quadruple the
    341             stepper ISR frequency. And so on. This, in effect, virtually eliminates multi-axis aliasing
    342             issues with the Bresenham algorithm and does not significantly alter Grbl's performance, but
    343             in fact, more efficiently utilizes unused CPU cycles overall throughout all configurations.
    344               AMASS retains the Bresenham algorithm exactness by requiring that it always executes a full
    345             Bresenham step, regardless of AMASS Level. Meaning that for an AMASS Level 2, all four
    346             intermediate steps must be completed such that baseline Bresenham (Level 0) count is always
    347             retained. Similarly, AMASS Level 3 means all eight intermediate steps must be executed.
    348             Although the AMASS Levels are in reality arbitrary, where the baseline Bresenham counts can
    349             be multiplied by any integer value, multiplication by powers of two are simply used to ease
    350             CPU overhead with bitshift integer operations.
    351               This interrupt is simple and dumb by design. All the computational heavy-lifting, as in
    352             determining accelerations, is performed elsewhere. This interrupt pops pre-computed segments,
    353             defined as constant velocity over n number of steps, from the step segment buffer and then
    354             executes them by pulsing the stepper pins appropriately via the Bresenham algorithm. This
    355             ISR is supported by The Stepper Port Reset Interrupt which it uses to reset the stepper port
    356             after each pulse. The bresenham line tracer algorithm controls all stepper outputs
    357             simultaneously with these two interrupts.
    358          
    359             NOTE: This interrupt must be as efficient as possible and complete before the next ISR tick,
    360             which for Grbl must be less than 33.3usec (@30kHz ISR rate). Oscilloscope measured time in
    361             ISR is 5usec typical and 25usec maximum, well below requirement.
    362             NOTE: This ISR expects at least one step to be executed per segment.
    363          */
    364          // TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller
    365          // int8 variables and update position counters only when a segment completes. This can get complicated
    366          // with probing and homing cycles that require true real-time positions.
    367          void TIM2_IRQHandler(void)
    368          {
    369          	if ((TIM2->SR & 0x0001) != 0)                  // check interrupt source
    370          	{
    371          		TIM2->SR &= ~(1 << 0);                          // clear UIF flag
    372          		TIM2->CNT = 0;
    373          	}
    374          	else
    375          	{
    376          		return;
    377          	}
    378          
    379            if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
    380            GPIO_Write(DIRECTION_PORT, (GPIO_ReadOutputData(DIRECTION_PORT) & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK));
    381            TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
    382          
    383            // Then pulse the stepping pins
    384            #ifdef STEP_PULSE_DELAY
    385              st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwriting.
    386            #else  // Normal operation
    387          	GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | st.step_outbits);
    388            #endif
    389          
    390            // Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after
    391            // exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.
    392             NVIC_EnableIRQ(TIM3_IRQn);
    393          
    394            busy = true;
    395          
    396            // If there is no step segment, attempt to pop one from the stepper buffer
    397            if (st.exec_segment == NULL) {
    398              // Anything in the buffer? If so, load and initialize next step segment.
    399              if (segment_buffer_head != segment_buffer_tail) {
    400                // Initialize new step segment and load number of steps to execute
    401                st.exec_segment = &segment_buffer[segment_buffer_tail];
    402          
    403                // Initialize step segment timing per step and load number of steps to execute.
    404          	  TIM2->ARR = st.exec_segment->cycles_per_tick - 1;
    405          	  /* Set the Autoreload value */
    406          #ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        
    407          	  TIM2->PSC = st.exec_segment->prescaler;
    408          #endif
    409                st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
    410                // If the new segment starts a new planner block, initialize stepper variables and counters.
    411                // NOTE: When the segment data index changes, this indicates a new planner block.
    412                if ( st.exec_block_index != st.exec_segment->st_block_index ) {
    413                  st.exec_block_index = st.exec_segment->st_block_index;
    414                  st.exec_block = &st_block_buffer[st.exec_block_index];
    415          
    416                  // Initialize Bresenham line and distance counters
    417                  st.counter_x = st.counter_y = st.counter_z = (st.exec_block->step_event_count >> 1);
    418                }
    419                st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask;
    420          
    421                #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    422                  // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
    423                  st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
    424                  st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
    425                  st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
    426                #endif
    427          
    428                #ifdef VARIABLE_SPINDLE
    429                  // Set real-time spindle output as segment is loaded, just prior to the first step.
    430                  spindle_set_speed(st.exec_segment->spindle_pwm);
    431                #endif
    432          
    433              } else {
    434                // Segment buffer empty. Shutdown.
    435                st_go_idle();
    436                // Ensure pwm is set properly upon completion of rate-controlled motion.
    437                #ifdef VARIABLE_SPINDLE
    438                if (st.exec_block->is_pwm_rate_adjusted) { spindle_set_speed(SPINDLE_PWM_OFF_VALUE); }
    439                #endif
    440                system_set_exec_state_flag(EXEC_CYCLE_STOP); // Flag main program for cycle end
    441                return; // Nothing to do but exit.
    442              }
    443            }
    444          
    445          
    446            // Check probing state.
    447            if (sys_probe_state == PROBE_ACTIVE) { probe_state_monitor(); }
    448          
    449            // Reset step out bits.
    450            st.step_outbits = 0;
    451          
    452            // Execute step displacement profile by Bresenham line algorithm
    453            #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    454              st.counter_x += st.steps[X_AXIS];
    455            #else
    456              st.counter_x += st.exec_block->steps[X_AXIS];
    457            #endif
    458            if (st.counter_x > st.exec_block->step_event_count) {
    459              st.step_outbits |= (1<<X_STEP_BIT);
    460              st.counter_x -= st.exec_block->step_event_count;
    461              if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys_position[X_AXIS]--; }
    462              else { sys_position[X_AXIS]++; }
    463            }
    464            #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    465              st.counter_y += st.steps[Y_AXIS];
    466            #else
    467              st.counter_y += st.exec_block->steps[Y_AXIS];
    468            #endif
    469            if (st.counter_y > st.exec_block->step_event_count) {
    470              st.step_outbits |= (1<<Y_STEP_BIT);
    471              st.counter_y -= st.exec_block->step_event_count;
    472              if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys_position[Y_AXIS]--; }
    473              else { sys_position[Y_AXIS]++; }
    474            }
    475            #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    476              st.counter_z += st.steps[Z_AXIS];
    477            #else
    478              st.counter_z += st.exec_block->steps[Z_AXIS];
    479            #endif
    480            if (st.counter_z > st.exec_block->step_event_count) {
    481              st.step_outbits |= (1<<Z_STEP_BIT);
    482              st.counter_z -= st.exec_block->step_event_count;
    483              if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys_position[Z_AXIS]--; }
    484              else { sys_position[Z_AXIS]++; }
    485            }
    486          
    487            // During a homing cycle, lock out and prevent desired axes from moving.
    488            if (sys.state == STATE_HOMING) { st.step_outbits &= sys.homing_axis_lock; }
    489          
    490            st.step_count--; // Decrement step events count
    491            if (st.step_count == 0) {
    492              // Segment is complete. Discard current segment and advance segment indexing.
    493              st.exec_segment = NULL;
    494              uint8_t segment_tail_next = segment_buffer_tail + 1;
    495              if (segment_tail_next == SEGMENT_BUFFER_SIZE)
    496              {
    497                segment_tail_next = 0;
    498              }
    499              segment_buffer_tail = segment_tail_next;
    500            }
    501          
    502            st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask
    503            busy = false;
    504          }
    505          
    506          
    507          /* The Stepper Port Reset Interrupt: Timer0 OVF interrupt handles the falling edge of the step
    508             pulse. This should always trigger before the next Timer1 COMPA interrupt and independently
    509             finish, if Timer1 is disabled after completing a move.
    510             NOTE: Interrupt collisions between the serial and stepper interrupts can cause delays by
    511             a few microseconds, if they execute right before one another. Not a big deal, but can
    512             cause issues at high step rates if another high frequency asynchronous interrupt is
    513             added to Grbl.
    514          */
    515          // This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
    516          // a step. This ISR resets the motor port after a short period (settings.pulse_microseconds)
    517          // completing one step cycle.
    518          void TIM3_IRQHandler(void)
    519          {
    520          	if ((TIM3->SR & 0x0001) != 0)                  // check interrupt source
    521          	{
    522          		TIM3->SR &= ~(1<<0);                          // clear UIF flag
    523          		TIM3->CNT = 0;
    524           		NVIC_DisableIRQ(TIM3_IRQn);
    525              // Reset stepping pins (leave the direction pins)
    526          		GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK));
    527          	}
    528          }
    529          
    530          
    531          // Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
    532          void st_generate_step_dir_invert_masks()
    533          {
    534            uint8_t idx;
    535            step_port_invert_mask = 0;
    536            dir_port_invert_mask = 0;
    537            for (idx=0; idx<N_AXIS; idx++) {
    538              if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= step_pin_mask[idx]; }
    539              if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= direction_pin_mask[idx]; }
    540            }
    541          }
    542          
    543          
    544          // Reset and clear stepper subsystem variables
    545          void st_reset()
    546          {
    547            // Initialize stepper driver idle state.
    548            st_go_idle();
    549          
    550            // Initialize stepper algorithm variables.
    551            memset(&prep, 0, sizeof(st_prep_t));
    552            memset(&st, 0, sizeof(stepper_t));
    553            st.exec_segment = NULL;
    554            pl_block = NULL;  // Planner block pointer used by segment buffer
    555            segment_buffer_tail = 0;
    556            segment_buffer_head = 0; // empty = tail
    557            segment_next_head = 1;
    558            busy = false;
    559          
    560            st_generate_step_dir_invert_masks();
    561            st.dir_outbits = dir_port_invert_mask; // Initialize direction bits to default.
    562          
    563            // Initialize step and direction port pins.
    564            GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK));
    565            GPIO_Write(DIRECTION_PORT, (GPIO_ReadOutputData(DIRECTION_PORT) & ~DIRECTION_MASK) | (dir_port_invert_mask & DIRECTION_MASK));
    566          }
    567          
    568          // Initialize and start the stepper motor subsystem
    569          void stepper_init()
    570          {
    571            // Configure step and direction interface pins
    572          	GPIO_InitTypeDef GPIO_InitStructure;
    573          	RCC_APB2PeriphClockCmd(RCC_STEPPERS_DISABLE_PORT, ENABLE);
    574          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    575          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    576          	GPIO_InitStructure.GPIO_Pin = STEPPERS_DISABLE_MASK;
    577          	GPIO_Init(STEPPERS_DISABLE_PORT, &GPIO_InitStructure);
    578          
    579          	RCC_APB2PeriphClockCmd(RCC_STEP_PORT, ENABLE);
    580          	GPIO_InitStructure.GPIO_Pin = STEP_MASK;
    581          	GPIO_Init(STEP_PORT, &GPIO_InitStructure);
    582          
    583          	RCC_APB2PeriphClockCmd(RCC_DIRECTION_PORT, ENABLE);
    584          	GPIO_InitStructure.GPIO_Pin = DIRECTION_MASK;
    585          	GPIO_Init(DIRECTION_PORT, &GPIO_InitStructure);
    586            
    587            // Configurating TIM2
    588            RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
    589          	// RCC->APB1ENR |= RCC_APB1Periph_TIM2;
    590          	TIM_Configuration(TIM2, 1, 1, 1);
    591          
    592            // Configurating TIM3
    593            RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
    594          	// RCC->APB1ENR |= RCC_APB1Periph_TIM3;
    595          	TIM_Configuration(TIM3, 1, 1, 1);
    596          
    597            // Stop/Distable TIM2 & TIM3 here
    598           	NVIC_DisableIRQ(TIM3_IRQn);
    599           	NVIC_DisableIRQ(TIM2_IRQn);
    600          }
    601          
    602          
    603          // Called by planner_recalculate() when the executing block is updated by the new plan.
    604          void st_update_plan_block_parameters()
    605          {
    606            if (pl_block != NULL) { // Ignore if at start of a new block.
    607              prep.recalculate_flag |= PREP_FLAG_RECALCULATE;
    608              pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
    609              pl_block = NULL; // Flag st_prep_segment() to load and check active velocity profile.
    610            }
    611          }
    612          
    613          
    614          // Increments the step segment buffer block data ring buffer.
    615          static uint8_t st_next_block_index(uint8_t block_index)
    616          {
    617            block_index++;
    618            if ( block_index == (SEGMENT_BUFFER_SIZE-1) ) { return(0); }
    619            return(block_index);
    620          }
    621          
    622          
    623          #ifdef PARKING_ENABLE
    624            // Changes the run state of the step segment buffer to execute the special parking motion.
    625            void st_parking_setup_buffer()
    626            {
    627              // Store step execution data of partially completed block, if necessary.
    628              if (prep.recalculate_flag & PREP_FLAG_HOLD_PARTIAL_BLOCK) {
    629                prep.last_st_block_index = prep.st_block_index;
    630                prep.last_steps_remaining = prep.steps_remaining;
    631                prep.last_dt_remainder = prep.dt_remainder;
    632                prep.last_step_per_mm = prep.step_per_mm;
    633              }
    634              // Set flags to execute a parking motion
    635              prep.recalculate_flag |= PREP_FLAG_PARKING;
    636              prep.recalculate_flag &= ~(PREP_FLAG_RECALCULATE);
    637              pl_block = NULL; // Always reset parking motion to reload new block.
    638            }
    639          
    640          
    641            // Restores the step segment buffer to the normal run state after a parking motion.
    642            void st_parking_restore_buffer()
    643            {
    644              // Restore step execution data and flags of partially completed block, if necessary.
    645              if (prep.recalculate_flag & PREP_FLAG_HOLD_PARTIAL_BLOCK) {
    646                st_prep_block = &st_block_buffer[prep.last_st_block_index];
    647                prep.st_block_index = prep.last_st_block_index;
    648                prep.steps_remaining = prep.last_steps_remaining;
    649                prep.dt_remainder = prep.last_dt_remainder;
    650                prep.step_per_mm = prep.last_step_per_mm;
    651                prep.recalculate_flag = (PREP_FLAG_HOLD_PARTIAL_BLOCK | PREP_FLAG_RECALCULATE);
    652                prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm; // Recompute this value.
    653              } else {
    654                prep.recalculate_flag = false;
    655              }
    656              pl_block = NULL; // Set to reload next block.
    657            }
    658          #endif
    659          
    660          
    661          /* Prepares step segment buffer. Continuously called from main program.
    662          
    663             The segment buffer is an intermediary buffer interface between the execution of steps
    664             by the stepper algorithm and the velocity profiles generated by the planner. The stepper
    665             algorithm only executes steps within the segment buffer and is filled by the main program
    666             when steps are "checked-out" from the first block in the planner buffer. This keeps the
    667             step execution and planning optimization processes atomic and protected from each other.
    668             The number of steps "checked-out" from the planner buffer and the number of segments in
    669             the segment buffer is sized and computed such that no operation in the main program takes
    670             longer than the time it takes the stepper algorithm to empty it before refilling it.
    671             Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
    672             NOTE: Computation units are in steps, millimeters, and minutes.
    673          */
    674          void st_prep_buffer()
    675          {
    676            // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
    677            if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }
    678          
    679            while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
    680          
    681              // Determine if we need to load a new planner block or if the block needs to be recomputed.
    682              if (pl_block == NULL) {
    683          
    684                // Query planner for a queued block
    685                if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) { 
    686                  pl_block = plan_get_system_motion_block(); 
    687                  }
    688                else { 
    689                  pl_block = plan_get_current_block(); 
    690                  }
    691                if (pl_block == NULL) { // No planner blocks. Exit.
    692                  return; 
    693                  } 
    694          
    695                // Check if we need to only recompute the velocity profile or load a new block.
    696                if (prep.recalculate_flag & PREP_FLAG_RECALCULATE) {
    697          
    698                  #ifdef PARKING_ENABLE
    699                    if (prep.recalculate_flag & PREP_FLAG_PARKING) { prep.recalculate_flag &= ~(PREP_FLAG_RECALCULATE); }
    700                    else { prep.recalculate_flag = false; }
    701                  #else
    702                    prep.recalculate_flag = false;
    703                  #endif
    704          
    705                } else {
    706          
    707                  // Load the Bresenham stepping data for the block.
    708                  prep.st_block_index = st_next_block_index(prep.st_block_index);
    709          
    710                  // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
    711                  // when the segment buffer completes the planner block, it may be discarded when the
    712                  // segment buffer finishes the prepped block, but the stepper ISR is still executing it.
    713                  st_prep_block = &st_block_buffer[prep.st_block_index];
    714                  st_prep_block->direction_bits = pl_block->direction_bits;
    715                  uint8_t idx;
    716                  #ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    717                    for (idx=0; idx<N_AXIS; idx++) { st_prep_block->steps[idx] = (pl_block->steps[idx] << 1); }
    718                    st_prep_block->step_event_count = (pl_block->step_event_count << 1);
    719                  #else
    720                    // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS
    721                    // level, such that we never divide beyond the original data anywhere in the algorithm.
    722                    // If the original data is divided, we can lose a step from integer roundoff.
    723                    for (idx=0; idx<N_AXIS; idx++) { st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL; }
    724                    st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
    725                  #endif
    726          
    727                  // Initialize segment buffer data for generating the segments.
    728                  prep.steps_remaining = (float)pl_block->step_event_count;
    729                  prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
    730                  prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
    731                  prep.dt_remainder = 0.0f; // Reset for new segment block
    732          
    733                  if ((sys.step_control & STEP_CONTROL_EXECUTE_HOLD) || (prep.recalculate_flag & PREP_FLAG_DECEL_OVERRIDE)) {
    734                    // New block loaded mid-hold. Override planner block entry speed to enforce deceleration.
    735                    prep.current_speed = prep.exit_speed;
    736                    pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed;
    737                    prep.recalculate_flag &= ~(PREP_FLAG_DECEL_OVERRIDE);
    738                  } else {
    739                    prep.current_speed = sqrtf(pl_block->entry_speed_sqr);
    740                  }
    741          #ifdef VARIABLE_SPINDLE
    742                  // Setup laser mode variables. PWM rate adjusted motions will always complete a motion with the
    743                  // spindle off. 
    744                  st_prep_block->is_pwm_rate_adjusted = false;
    745                  if (settings.flags & BITFLAG_LASER_MODE) {
    746                    if (pl_block->condition & PL_COND_FLAG_SPINDLE_CCW) {
    747                      // Pre-compute inverse programmed rate to speed up PWM updating per step segment.
    748                      prep.inv_rate = 1.0f / pl_block->programmed_rate;
    749                      st_prep_block->is_pwm_rate_adjusted = true;
    750                    }
    751                  }
    752          #endif
    753                }
    754          
    755          			/* ---------------------------------------------------------------------------------
    756          			 Compute the velocity profile of a new planner block based on its entry and exit
    757          			 speeds, or recompute the profile of a partially-completed planner block if the
    758          			 planner has updated it. For a commanded forced-deceleration, such as from a feed
    759          			 hold, override the planner velocities and decelerate to the target exit speed.
    760          			*/
    761          			prep.mm_complete = 0.0f; // Default velocity profile complete at 0.0mm from end of block.
    762          			float inv_2_accel = 0.5f/pl_block->acceleration;
    763          			if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { // [Forced Deceleration to Zero Velocity]
    764          				// Compute velocity profile parameters for a feed hold in-progress. This profile overrides
    765          				// the planner block profile, enforcing a deceleration to zero speed.
    766          				prep.ramp_type = RAMP_DECEL;
    767          				// Compute decelerate distance relative to end of block.
    768          				float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
    769          				if (decel_dist < 0.0f) {
    770          					// Deceleration through entire planner block. End of feed hold is not in this block.
    771          					prep.exit_speed = sqrtf(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
    772          				} else {
    773          					prep.mm_complete = decel_dist; // End of feed hold.
    774          					prep.exit_speed = 0.0f;
    775          				}
    776          			} else { // [Normal Operation]
    777          				// Compute or recompute velocity profile parameters of the prepped planner block.
    778          				prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
    779          				prep.accelerate_until = pl_block->millimeters;
    780          
    781          				float exit_speed_sqr;
    782          				float nominal_speed;
    783                  if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
    784                    prep.exit_speed = exit_speed_sqr = 0.0f; // Enforce stop at end of system motion.
    785                  } else {
    786                    exit_speed_sqr = plan_get_exec_block_exit_speed_sqr();
    787                    prep.exit_speed = sqrtf(exit_speed_sqr);
    788                  }
    789          
    790                  nominal_speed = plan_compute_profile_nominal_speed(pl_block);
    791          				float nominal_speed_sqr = nominal_speed*nominal_speed;
    792          				float intersect_distance =
    793          								0.5f*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
    794          
    795                  if (pl_block->entry_speed_sqr > nominal_speed_sqr) { // Only occurs during override reductions.
    796                    prep.accelerate_until = pl_block->millimeters - inv_2_accel*(pl_block->entry_speed_sqr-nominal_speed_sqr);
    797                    if (prep.accelerate_until <= 0.0f) { // Deceleration-only.
    798                      prep.ramp_type = RAMP_DECEL;
    799                      // prep.decelerate_after = pl_block->millimeters;
    800                      // prep.maximum_speed = prep.current_speed;
    801          
    802                      // Compute override block exit speed since it doesn't match the planner exit speed.
    803                      prep.exit_speed = sqrtf(pl_block->entry_speed_sqr - 2*pl_block->acceleration*pl_block->millimeters);
    804                      prep.recalculate_flag |= PREP_FLAG_DECEL_OVERRIDE; // Flag to load next block as deceleration override.
    805          
    806                      // TODO: Determine correct handling of parameters in deceleration-only.
    807                      // Can be tricky since entry speed will be current speed, as in feed holds.
    808                      // Also, look into near-zero speed handling issues with this.
    809          
    810                    } else {
    811                      // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
    812                      prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr); // Should always be >= 0.0 due to planner reinit.
    813          						prep.maximum_speed = nominal_speed;
    814                      prep.ramp_type = RAMP_DECEL_OVERRIDE;
    815                    }
    816          				} else if (intersect_distance > 0.0f) {
    817          					if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
    818          						// NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
    819          						prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
    820          						if (prep.decelerate_after < intersect_distance) { // Trapezoid type
    821          							prep.maximum_speed = nominal_speed;
    822          							if (pl_block->entry_speed_sqr == nominal_speed_sqr) {
    823          								// Cruise-deceleration or cruise-only type.
    824          								prep.ramp_type = RAMP_CRUISE;
    825          							} else {
    826          								// Full-trapezoid or acceleration-cruise types
    827          								prep.accelerate_until -= inv_2_accel*(nominal_speed_sqr-pl_block->entry_speed_sqr);
    828          							}
    829          						} else { // Triangle type
    830          							prep.accelerate_until = intersect_distance;
    831          							prep.decelerate_after = intersect_distance;
    832          							prep.maximum_speed = sqrtf(2.0f*pl_block->acceleration*intersect_distance+exit_speed_sqr);
    833          						}
    834          					} else { // Deceleration-only type
    835                      prep.ramp_type = RAMP_DECEL;
    836                      // prep.decelerate_after = pl_block->millimeters;
    837                      // prep.maximum_speed = prep.current_speed;
    838          					}
    839          				} else { // Acceleration-only type
    840          					prep.accelerate_until = 0.0f;
    841          					// prep.decelerate_after = 0.0f;
    842          					prep.maximum_speed = prep.exit_speed;
    843          				}
    844          			}
    845                
    846                #ifdef VARIABLE_SPINDLE
    847                  bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); // Force update whenever updating block.
    848                #endif
    849              }
    850              
    851              // Initialize new segment
    852              segment_t *prep_segment = &segment_buffer[segment_buffer_head];
    853          
    854              // Set new segment to point to the current segment data block.
    855              prep_segment->st_block_index = prep.st_block_index;
    856          
    857              /*------------------------------------------------------------------------------------
    858                  Compute the average velocity of this new segment by determining the total distance
    859                traveled over the segment time DT_SEGMENT. The following code first attempts to create
    860                a full segment based on the current ramp conditions. If the segment time is incomplete
    861                when terminating at a ramp state change, the code will continue to loop through the
    862                progressing ramp states to fill the remaining segment execution time. However, if
    863                an incomplete segment terminates at the end of the velocity profile, the segment is
    864                considered completed despite having a truncated execution time less than DT_SEGMENT.
    865                  The velocity profile is always assumed to progress through the ramp sequence:
    866                acceleration ramp, cruising state, and deceleration ramp. Each ramp's travel distance
    867                may range from zero to the length of the block. Velocity profiles can end either at
    868                the end of planner block (typical) or mid-block at the end of a forced deceleration,
    869                such as from a feed hold.
    870              */
    871              float dt_max = DT_SEGMENT; // Maximum segment time
    872              float dt = 0.0f; // Initialize segment time
    873              float time_var = dt_max; // Time worker variable
    874              float mm_var; // mm-Distance worker variable
    875              float speed_var; // Speed worker variable
    876              float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    877              float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    878              if (minimum_mm < 0.0f) { minimum_mm = 0.0f; }
    879          
    880              do {
    881                switch (prep.ramp_type) {
    882                  case RAMP_DECEL_OVERRIDE:
    883                    speed_var = pl_block->acceleration*time_var;
    884          					if (prep.current_speed-prep.maximum_speed <= speed_var) {
    885                      // Cruise or cruise-deceleration types only for deceleration override.
    886          						mm_remaining = prep.accelerate_until;
    887                      time_var = 2.0f*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    888                      prep.ramp_type = RAMP_CRUISE;
    889                      prep.current_speed = prep.maximum_speed;
    890                    } else { // Mid-deceleration override ramp.
    891          						mm_remaining -= time_var*(prep.current_speed - 0.5f*speed_var);
    892                      prep.current_speed -= speed_var;
    893                    }
    894                    break;
    895                  case RAMP_ACCEL:
    896                    // NOTE: Acceleration ramp only computes during first do-while loop.
    897                    speed_var = pl_block->acceleration*time_var;
    898                    mm_remaining -= time_var*(prep.current_speed + 0.5f*speed_var);
    899                    if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    900                      // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
    901                      mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
    902                      time_var = 2.0f*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    903                      if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    904                      else { prep.ramp_type = RAMP_CRUISE; }
    905                      prep.current_speed = prep.maximum_speed;
    906                    } else { // Acceleration only.
    907                      prep.current_speed += speed_var;
    908                    }
    909                    break;
    910                  case RAMP_CRUISE:
    911                    // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
    912                    // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To
    913                    //   prevent this, simply enforce a minimum speed threshold in the planner.
    914                    mm_var = mm_remaining - prep.maximum_speed*time_var;
    915                    if (mm_var < prep.decelerate_after) { // End of cruise.
    916                      // Cruise-deceleration junction or end of block.
    917                      time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
    918                      mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
    919                      prep.ramp_type = RAMP_DECEL;
    920                    } else { // Cruising only.
    921                      mm_remaining = mm_var;
    922                    }
    923                    break;
    924                  default: // case RAMP_DECEL:
    925                    // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
    926                    speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
    927                    if (prep.current_speed > speed_var) { // Check if at or below zero speed.
    928                      // Compute distance from end of segment to end of block.
    929                      mm_var = mm_remaining - time_var*(prep.current_speed - 0.5f*speed_var); // (mm)
    930                      if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
    931                        mm_remaining = mm_var;
    932                        prep.current_speed -= speed_var;
    933                        break; // Segment complete. Exit switch-case statement. Continue do-while loop.
    934                      }
    935                    }
    936                    // Otherwise, at end of block or end of forced-deceleration.
    937                    time_var = 2.0f*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    938                    mm_remaining = prep.mm_complete;
    939                    prep.current_speed = prep.exit_speed;
    940                }
    941                dt += time_var; // Add computed ramp time to total segment time.
    942                if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
    943                else {
    944                  if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
    945                    // Increase segment time to ensure at least one step in segment. Override and loop
    946                    // through distance calculations until minimum_mm or mm_complete.
    947                    dt_max += DT_SEGMENT;
    948                    time_var = dt_max - dt;
    949                  } else {
    950                    break; // **Complete** Exit loop. Segment execution time maxed.
    951                  }
    952                }
    953              } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
    954          
    955              #ifdef VARIABLE_SPINDLE
    956                /* -----------------------------------------------------------------------------------
    957                  Compute spindle speed PWM output for step segment
    958                */
    959          
    960                if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
    961                  if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
    962                    float rpm = pl_block->spindle_speed;
    963                    // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.        
    964                    if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
    965                    // If current_speed is zero, then may need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE)
    966                    // but this would be instantaneous only and during a motion. May not matter at all.
    967                    prep.current_spindle_pwm = spindle_compute_pwm_value(rpm);
    968                  }
    969                  else {
    970                    sys.spindle_speed = 0.0;
    971                    prep.current_spindle_pwm = SPINDLE_PWM_OFF_VALUE;
    972                  }
    973                  bit_false(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    974                }
    975                prep_segment->spindle_pwm = prep.current_spindle_pwm; // Reload segment PWM value
    976          
    977              #endif
    978              
    979              /* -----------------------------------------------------------------------------------
    980                 Compute segment step rate, steps to execute, and apply necessary rate corrections.
    981                 NOTE: Steps are computed by direct scalar conversion of the millimeter distance
    982                 remaining in the block, rather than incrementally tallying the steps executed per
    983                 segment. This helps in removing floating point round-off issues of several additions.
    984                 However, since floats have only 7.2 significant digits, long moves with extremely
    985                 high step counts can exceed the precision of floats, which can lead to lost steps.
    986                 Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
    987                 supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    988              */
    989              float step_dist_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
    990              float n_steps_remaining = ceilf(step_dist_remaining); // Round-up current steps remaining
    991              float last_n_steps_remaining = ceilf(prep.steps_remaining); // Round-up last steps remaining
    992          	prep_segment->n_step = (uint16_t)(last_n_steps_remaining - n_steps_remaining); // Compute number of steps to execute.
    993          
    994              // Bail if we are at the end of a feed hold and don't have a step to execute.
    995              if (prep_segment->n_step == 0) {
    996                if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) {
    997                  // Less than one step to decelerate to zero speed, but already very close. AMASS
    998                  // requires full steps to execute. So, just bail.
    999                  bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
   1000                  #ifdef PARKING_ENABLE
   1001                    if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
   1002                  #endif
   1003                  return; // Segment not generated, but current step data still retained.
   1004                }
   1005              }
   1006          
   1007              // Compute segment step rate. Since steps are integers and mm distances traveled are not,
   1008              // the end of every segment can have a partial step of varying magnitudes that are not
   1009              // executed, because the stepper ISR requires whole steps due to the AMASS algorithm. To
   1010              // compensate, we track the time to execute the previous segment's partial step and simply
   1011              // apply it with the partial step distance to the current segment, so that it minutely
   1012              // adjusts the whole segment rate to keep step output exact. These rate adjustments are
   1013              // typically very small and do not adversely effect performance, but ensures that Grbl
   1014              // outputs the exact acceleration and velocity profiles as computed by the planner.
   1015              dt += prep.dt_remainder; // Apply previous segment partial step execute time
   1016              float inv_rate = dt/(last_n_steps_remaining - step_dist_remaining); // Compute adjusted step rate inverse
   1017          
   1018              // Compute CPU cycles per step for the prepped segment.
   1019           ////???	uint32_t cycles = (uint32_t)ceilf((TICKS_PER_MICROSECOND * 1000000) *inv_rate * 60); // (cycles/step)
   1020          uint32_t cycles = 1000;////????
   1021              #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
   1022                // Compute step timing and multi-axis smoothing level.
   1023                // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
   1024                if (cycles < AMASS_LEVEL1) 
   1025                { 
   1026                  prep_segment->amass_level = 0; 
   1027                }
   1028                else {
   1029                  if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
   1030                  else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
   1031                  else { prep_segment->amass_level = 3; }
   1032                  cycles >>= prep_segment->amass_level;
   1033                  prep_segment->n_step <<= prep_segment->amass_level;
   1034                }
   1035                if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
   1036                else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
   1037              #else
   1038                // Compute step timing and timer prescalar for normal step generation.
   1039                if (cycles < (1UL << 16)) { // < 65536  (4.1ms @ 16MHz)
   1040                  prep_segment->prescaler = 1; // prescaler: 0
   1041                  prep_segment->cycles_per_tick = cycles;
   1042                } else if (cycles < (1UL << 19)) { // < 524288 (32.8ms@16MHz)
   1043                  prep_segment->prescaler = 2; // prescaler: 8
   1044                  prep_segment->cycles_per_tick = cycles >> 3;
   1045                } else {
   1046                  prep_segment->prescaler = 3; // prescaler: 64
   1047                  if (cycles < (1UL << 22)) { // < 4194304 (262ms@16MHz)
   1048                    prep_segment->cycles_per_tick =  cycles >> 6;
   1049                  } else { // Just set the slowest speed possible. (Around 4 step/sec.)
   1050                    prep_segment->cycles_per_tick = 0xffff;
   1051                  }
   1052                }
   1053              #endif
   1054          
   1055              // Segment complete! Increment segment buffer indices, so stepper ISR can immediately execute it.
   1056              segment_buffer_head = segment_next_head;
   1057              if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
   1058          
   1059              // Update the appropriate planner and segment data.
   1060              pl_block->millimeters = mm_remaining;
   1061              prep.steps_remaining = n_steps_remaining;
   1062              prep.dt_remainder = (n_steps_remaining - step_dist_remaining)*inv_rate;
   1063          
   1064              // Check for exit conditions and flag to load next planner block.
   1065              if (mm_remaining == prep.mm_complete) {
   1066                // End of planner block or forced-termination. No more distance to be executed.
   1067                if (mm_remaining > 0.0f) { // At end of forced-termination.
   1068                  // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
   1069                  // the segment queue, where realtime protocol will set new state upon receiving the
   1070                  // cycle stop flag from the ISR. Prep_segment is blocked until then.
   1071                  bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
   1072                  #ifdef PARKING_ENABLE
   1073                    if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
   1074                  #endif
   1075                  return; // Bail!
   1076                } else { // End of planner block
   1077                  // The planner block is complete. All steps are set to be executed in the segment buffer.
   1078                  if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
   1079                    bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
   1080                    return;
   1081                  }
   1082                  pl_block = NULL; // Set pointer to indicate check and load next planner block.
   1083                  plan_discard_current_block();
   1084                }
   1085              }
   1086          
   1087            }
   1088          }
   1089          
   1090          
   1091          // Called by realtime status reporting to fetch the current speed being executed. This value
   1092          // however is not exactly the current speed, but the speed computed in the last step segment
   1093          // in the segment buffer. It will always be behind by up to the number of segment blocks (-1)
   1094          // divided by the ACCELERATION TICKS PER SECOND in seconds.
   1095          float st_get_realtime_rate()
   1096          {
   1097            if (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)){
   1098              return prep.current_speed;
   1099            }
   1100            return 0.0f;
   1101          }
   1102          
   1103          void TIM_Configuration(TIM_TypeDef* TIMER, u16 Period, u16 Prescaler, u8 PP)
   1104          {
   1105          	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
   1106           	NVIC_InitTypeDef NVIC_InitStructure;
   1107          
   1108          	TIM_TimeBaseStructure.TIM_Period = Period - 1;
   1109          	TIM_TimeBaseStructure.TIM_Prescaler = Prescaler - 1;
   1110          	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
   1111          	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   1112          	TIM_TimeBaseInit(TIMER, &TIM_TimeBaseStructure);
   1113          
   1114          	TIM_ClearITPendingBit(TIMER, TIM_IT_Update);
   1115          	TIM_ITConfig(TIMER, TIM_IT_Update, ENABLE);
   1116          	TIM_Cmd(TIMER, ENABLE);
   1117          
   1118          	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
   1119           	if (TIMER == TIM2) 
   1120                    { 
   1121                    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn; 
   1122                    }
   1123           	else if (TIMER == TIM3) 
   1124                    { 
   1125                    NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn; 
   1126                    }
   1127           	else if (TIMER == TIM4) 
   1128                    { 
   1129            ////????        NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn; 
   1130                    }
   1131          
   1132          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = PP;
   1133          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
   1134          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   1135          	NVIC_Init(&NVIC_InitStructure);
   1136          }
   1137          #endif


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  direction_pin_mask
       8  step_pin_mask

 
 16 bytes in section .rodata
 
 16 bytes of CONST memory

Errors: none
Warnings: none
