; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave --gnu -o.\temp\obj\f1c100s_pwm.o --asm_dir=.\Temp\Lst\ --list_dir=.\Temp\Lst\ --depend=.\temp\obj\f1c100s_pwm.d --cpu=ARM9E --apcs=interwork -O0 -Otime --diag_suppress=9931 -I.\users\include -I.\..\machine\include -I.\..\periph\include -I.\..\include -I.\..\emwin\Include -I.\..\tinyusb\src -I.\..\tinyusb\hw -I.\..\display -I.\..\lib\display_gfx -I.\..\lib\printf -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Atmel\SAM9260 -D__RTX -D__UVISION_VERSION=536 -DPCB_TINY200V1 -DCFG_TUSB_MCU=OPT_MCU_F1C100S -DCFG_TUSB_OS=OPT_OS_RTX4 --omf_browse=.\temp\obj\f1c100s_pwm.crf ..\periph\f1c100s_pwm.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  pwm_init PROC
;;;3      
;;;4      void pwm_init(uint8_t ch, pwm_mode_e mode, uint8_t active_level, pwm_prescaller_e psc) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a07001          MOV      r7,r1
00000c  e1a08002          MOV      r8,r2
000010  e1a06003          MOV      r6,r3
;;;5          pwm_disable(ch);
000014  e1a00004          MOV      r0,r4
000018  ebfffffe          BL       pwm_disable
;;;6          uint32_t val = read32(PWM_BASE);
00001c  e59f0044          LDR      r0,|L1.104|
000020  ebfffffe          BL       read32
000024  e1a05000          MOV      r5,r0
;;;7          val &= ~(0x3FF << (ch * 15));
000028  e0640204          RSB      r0,r4,r4,LSL #4
00002c  e59f1038          LDR      r1,|L1.108|
000030  e1c55011          BIC      r5,r5,r1,LSL r0
;;;8          val |= (mode | (active_level << 5) | psc) << (ch * 15);
000034  e1870288          ORR      r0,r7,r8,LSL #5
000038  e1800006          ORR      r0,r0,r6
00003c  e0641204          RSB      r1,r4,r4,LSL #4
000040  e1855110          ORR      r5,r5,r0,LSL r1
;;;9          write32(PWM_BASE, val);
000044  e1a01005          MOV      r1,r5
000048  e59f0018          LDR      r0,|L1.104|
00004c  ebfffffe          BL       write32
;;;10     }
000050  e8bd81f0          POP      {r4-r8,pc}
;;;11     
                          ENDP

                  read32 PROC
;;;19     
;;;20     static __inline uint32_t read32(uint32_t addr)
000054  e1a01000          MOV      r1,r0
;;;21     {
;;;22       return (*((volatile uint32_t*)(addr)));
000058  e5910000          LDR      r0,[r1,#0]
;;;23     }
00005c  e12fff1e          BX       lr
;;;24     
                          ENDP

                  write32 PROC
;;;39     
;;;40     static __inline void write32(uint32_t addr, uint32_t value)
000060  e5801000          STR      r1,[r0,#0]
;;;41     {
;;;42       *((volatile uint32_t*)(addr)) = value;
;;;43     }
000064  e12fff1e          BX       lr
;;;44     
                          ENDP

                  |L1.104|
                          DCD      0x01c21000
                  |L1.108|
                          DCD      0x000003ff

                          AREA ||i.pwm_disable||, COMGROUP=pwm_disable, CODE, READONLY, ALIGN=2

                  pwm_disable PROC
;;;29     
;;;30     inline void pwm_disable(uint8_t ch) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
;;;31         write32(PWM_BASE, (read32(PWM_BASE) & ~(1 << (4 + ch * 15))));
000008  e59f0044          LDR      r0,|L13.84|
00000c  ebfffffe          BL       read32
000010  e0641204          RSB      r1,r4,r4,LSL #4
000014  e2811004          ADD      r1,r1,#4
000018  e3a02001          MOV      r2,#1
00001c  e1c05112          BIC      r5,r0,r2,LSL r1
000020  e1a01005          MOV      r1,r5
000024  e59f0028          LDR      r0,|L13.84|
000028  ebfffffe          BL       write32
;;;32         write32(PWM_BASE, (read32(PWM_BASE) & ~(1 << (6 + ch * 15))));
00002c  e59f0020          LDR      r0,|L13.84|
000030  ebfffffe          BL       read32
000034  e0641204          RSB      r1,r4,r4,LSL #4
000038  e2811006          ADD      r1,r1,#6
00003c  e3a02001          MOV      r2,#1
000040  e1c05112          BIC      r5,r0,r2,LSL r1
000044  e1a01005          MOV      r1,r5
000048  e59f0004          LDR      r0,|L13.84|
00004c  ebfffffe          BL       write32
;;;33     }
000050  e8bd8070          POP      {r4-r6,pc}
;;;34     
                          ENDP

                  |L13.84|
                          DCD      0x01c21000

                          AREA ||i.pwm_set_period||, COMGROUP=pwm_set_period, CODE, READONLY, ALIGN=2

                  pwm_set_period PROC
;;;11     
;;;12     inline void pwm_set_period(uint8_t ch, uint16_t val) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;13         uint32_t reg  = PWM_BASE + PWM_CH0 + ch * 4;
00000c  e59f0024          LDR      r0,|L20.56|
000010  e0807104          ADD      r7,r0,r4,LSL #2
;;;14         uint32_t temp = read32(reg);
000014  e1a00007          MOV      r0,r7
000018  ebfffffe          BL       read32
00001c  e1a06000          MOV      r6,r0
;;;15     		temp&= (uint32_t)( ~(0xFFFFU << 16));
000020  e1a06806          LSL      r6,r6,#16
000024  e1a06826          LSR      r6,r6,#16
;;;16         write32(reg, temp | ((uint32_t)val << 16));
000028  e1861805          ORR      r1,r6,r5,LSL #16
00002c  e1a00007          MOV      r0,r7
000030  ebfffffe          BL       write32
;;;17     }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;18     
                          ENDP

                  |L20.56|
                          DCD      0x01c21004

                          AREA ||i.pwm_set_pulse_len||, COMGROUP=pwm_set_pulse_len, CODE, READONLY, ALIGN=2

                  pwm_set_pulse_len PROC
;;;18     
;;;19     inline void pwm_set_pulse_len(uint8_t ch, uint16_t val) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;20         uint32_t reg  = PWM_BASE + PWM_CH0 + ch * 4;
00000c  e59f0020          LDR      r0,|L27.52|
000010  e0806104          ADD      r6,r0,r4,LSL #2
;;;21         uint32_t temp = read32(reg) & ~0xFFFF;
000014  e1a00006          MOV      r0,r6
000018  ebfffffe          BL       read32
00001c  e1a07820          LSR      r7,r0,#16
000020  e1a07807          LSL      r7,r7,#16
;;;22         write32(reg, temp | val);
000024  e1871005          ORR      r1,r7,r5
000028  e1a00006          MOV      r0,r6
00002c  ebfffffe          BL       write32
;;;23     }
000030  e8bd81f0          POP      {r4-r8,pc}
;;;24     
                          ENDP

                  |L27.52|
                          DCD      0x01c21004

                          AREA ||i.pwm_enable||, COMGROUP=pwm_enable, CODE, READONLY, ALIGN=2

                  pwm_enable PROC
;;;24     
;;;25     inline void pwm_enable(uint8_t ch) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
;;;26         write32(PWM_BASE, (read32(PWM_BASE) | (1 << (6 + ch * 15))));
000008  e59f0044          LDR      r0,|L34.84|
00000c  ebfffffe          BL       read32
000010  e0641204          RSB      r1,r4,r4,LSL #4
000014  e2811006          ADD      r1,r1,#6
000018  e3a02001          MOV      r2,#1
00001c  e1805112          ORR      r5,r0,r2,LSL r1
000020  e1a01005          MOV      r1,r5
000024  e59f0028          LDR      r0,|L34.84|
000028  ebfffffe          BL       write32
;;;27         write32(PWM_BASE, (read32(PWM_BASE) | (1 << (4 + ch * 15))));
00002c  e59f0020          LDR      r0,|L34.84|
000030  ebfffffe          BL       read32
000034  e0641204          RSB      r1,r4,r4,LSL #4
000038  e2811004          ADD      r1,r1,#4
00003c  e3a02001          MOV      r2,#1
000040  e1805112          ORR      r5,r0,r2,LSL r1
000044  e1a01005          MOV      r1,r5
000048  e59f0004          LDR      r0,|L34.84|
00004c  ebfffffe          BL       write32
;;;28     }
000050  e8bd8070          POP      {r4-r6,pc}
;;;29     
                          ENDP

                  |L34.84|
                          DCD      0x01c21000

                          AREA ||i.pwm_pulse_start||, COMGROUP=pwm_pulse_start, CODE, READONLY, ALIGN=2

                  pwm_pulse_start PROC
;;;34     
;;;35     inline void pwm_pulse_start(uint8_t ch) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
;;;36         write32(PWM_BASE, (read32(PWM_BASE) | (1 << (8 + ch * 15))));
000008  e59f0020          LDR      r0,|L41.48|
00000c  ebfffffe          BL       read32
000010  e0641204          RSB      r1,r4,r4,LSL #4
000014  e2811008          ADD      r1,r1,#8
000018  e3a02001          MOV      r2,#1
00001c  e1805112          ORR      r5,r0,r2,LSL r1
000020  e1a01005          MOV      r1,r5
000024  e59f0004          LDR      r0,|L41.48|
000028  ebfffffe          BL       write32
;;;37     }
00002c  e8bd8070          POP      {r4-r6,pc}
                          ENDP

                  |L41.48|
                          DCD      0x01c21000
