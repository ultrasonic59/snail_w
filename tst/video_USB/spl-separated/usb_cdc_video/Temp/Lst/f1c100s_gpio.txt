; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave --gnu -o.\temp\obj\f1c100s_gpio.o --asm_dir=.\Temp\Lst\ --list_dir=.\Temp\Lst\ --depend=.\temp\obj\f1c100s_gpio.d --cpu=ARM9E --apcs=interwork -O0 -Otime --diag_suppress=9931 -I.\users\include -I.\..\machine\include -I.\..\periph\include -I.\..\include -I.\..\emwin\Include -I.\..\tinyusb\src -I.\..\tinyusb\hw -I.\..\display -I.\..\lib\display_gfx -I.\..\lib\printf -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Atmel\SAM9260 -D__RTX -D__UVISION_VERSION=536 -DPCB_TINY200V1 -DCFG_TUSB_MCU=OPT_MCU_F1C100S -DCFG_TUSB_OS=OPT_OS_RTX4 --omf_browse=.\temp\obj\f1c100s_gpio.crf ..\periph\f1c100s_gpio.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  gpio_pin_init PROC
;;;16     // Configure single GPIO pin
;;;17     void gpio_pin_init(
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;18         uint32_t port,
;;;19         uint8_t pin_n,
;;;20         gpio_mode_e mode,
;;;21         gpio_pull_e pull,
;;;22         gpio_drv_e drv) {
000004  e1a06000          MOV      r6,r0
000008  e1a04001          MOV      r4,r1
00000c  e1a07002          MOV      r7,r2
000010  e1a08003          MOV      r8,r3
000014  e59d9020          LDR      r9,[sp,#0x20]
;;;23         uint32_t reg = 0;
000018  e3a0a000          MOV      r10,#0
;;;24         uint32_t val = 0;
00001c  e3a05000          MOV      r5,#0
;;;25     
;;;26         // Set pin mode
;;;27         reg = port + GPIO_CFG0 + (pin_n / 8) * 4; // Get CFG register address
000020  e1a00004          MOV      r0,r4
000024  e1a01fc4          ASR      r1,r4,#31
000028  e0841ea1          ADD      r1,r4,r1,LSR #29
00002c  e1a011c1          ASR      r1,r1,#3
000030  e086a101          ADD      r10,r6,r1,LSL #2
;;;28         val = read32(reg);
000034  e1a0000a          MOV      r0,r10
000038  ebfffffe          BL       read32
00003c  e1a05000          MOV      r5,r0
;;;29         val &= ~(0x7 << ((pin_n % 8) * 4)); // Clear mode bits
000040  e1a00004          MOV      r0,r4
000044  e1a01fc4          ASR      r1,r4,#31
000048  e0841ea1          ADD      r1,r4,r1,LSR #29
00004c  e1a011c1          ASR      r1,r1,#3
000050  e0441181          SUB      r1,r4,r1,LSL #3
000054  e1a01101          LSL      r1,r1,#2
000058  e3a02007          MOV      r2,#7
00005c  e1c55112          BIC      r5,r5,r2,LSL r1
;;;30         val |= ((mode & 0x7) << ((pin_n % 8) * 4)); // Set new mode
000060  e1a00004          MOV      r0,r4
000064  e1a01fc4          ASR      r1,r4,#31
000068  e0841ea1          ADD      r1,r4,r1,LSR #29
00006c  e1a011c1          ASR      r1,r1,#3
000070  e0441181          SUB      r1,r4,r1,LSL #3
000074  e1a01101          LSL      r1,r1,#2
000078  e2072007          AND      r2,r7,#7
00007c  e1855112          ORR      r5,r5,r2,LSL r1
;;;31         write32(reg, val);
000080  e1a01005          MOV      r1,r5
000084  e1a0000a          MOV      r0,r10
000088  ebfffffe          BL       write32
;;;32     
;;;33         // Set drive strength
;;;34         reg = port + GPIO_DRV0 + (pin_n / 16) * 4;
00008c  e1a00004          MOV      r0,r4
000090  e1a01fc4          ASR      r1,r4,#31
000094  e0841e21          ADD      r1,r4,r1,LSR #28
000098  e1a01241          ASR      r1,r1,#4
00009c  e2862014          ADD      r2,r6,#0x14
0000a0  e082a101          ADD      r10,r2,r1,LSL #2
;;;35         val = read32(reg);
0000a4  e1a0000a          MOV      r0,r10
0000a8  ebfffffe          BL       read32
0000ac  e1a05000          MOV      r5,r0
;;;36         val &= ~(0x3 << ((pin_n % 16) * 2));
0000b0  e1a00004          MOV      r0,r4
0000b4  e1a01fc4          ASR      r1,r4,#31
0000b8  e0841e21          ADD      r1,r4,r1,LSR #28
0000bc  e1a01241          ASR      r1,r1,#4
0000c0  e0441201          SUB      r1,r4,r1,LSL #4
0000c4  e1a01081          LSL      r1,r1,#1
0000c8  e3a02003          MOV      r2,#3
0000cc  e1c55112          BIC      r5,r5,r2,LSL r1
;;;37         val |= ((drv & 0x3) << ((pin_n % 16) * 2));
0000d0  e1a00004          MOV      r0,r4
0000d4  e1a01fc4          ASR      r1,r4,#31
0000d8  e0841e21          ADD      r1,r4,r1,LSR #28
0000dc  e1a01241          ASR      r1,r1,#4
0000e0  e0441201          SUB      r1,r4,r1,LSL #4
0000e4  e1a01081          LSL      r1,r1,#1
0000e8  e2092003          AND      r2,r9,#3
0000ec  e1855112          ORR      r5,r5,r2,LSL r1
;;;38         write32(reg, val);
0000f0  e1a01005          MOV      r1,r5
0000f4  e1a0000a          MOV      r0,r10
0000f8  ebfffffe          BL       write32
;;;39     
;;;40         // Set pull configuration
;;;41         reg = port + GPIO_PUL0 + (pin_n / 16) * 4;
0000fc  e1a00004          MOV      r0,r4
000100  e1a01fc4          ASR      r1,r4,#31
000104  e0841e21          ADD      r1,r4,r1,LSR #28
000108  e1a01241          ASR      r1,r1,#4
00010c  e286201c          ADD      r2,r6,#0x1c
000110  e082a101          ADD      r10,r2,r1,LSL #2
;;;42         val = read32(reg);
000114  e1a0000a          MOV      r0,r10
000118  ebfffffe          BL       read32
00011c  e1a05000          MOV      r5,r0
;;;43         val &= ~(0x3 << ((pin_n % 16) * 2));
000120  e1a00004          MOV      r0,r4
000124  e1a01fc4          ASR      r1,r4,#31
000128  e0841e21          ADD      r1,r4,r1,LSR #28
00012c  e1a01241          ASR      r1,r1,#4
000130  e0441201          SUB      r1,r4,r1,LSL #4
000134  e1a01081          LSL      r1,r1,#1
000138  e3a02003          MOV      r2,#3
00013c  e1c55112          BIC      r5,r5,r2,LSL r1
;;;44         val |= ((pull & 0x3) << ((pin_n % 16) * 2));
000140  e1a00004          MOV      r0,r4
000144  e1a01fc4          ASR      r1,r4,#31
000148  e0841e21          ADD      r1,r4,r1,LSR #28
00014c  e1a01241          ASR      r1,r1,#4
000150  e0441201          SUB      r1,r4,r1,LSL #4
000154  e1a01081          LSL      r1,r1,#1
000158  e2082003          AND      r2,r8,#3
00015c  e1855112          ORR      r5,r5,r2,LSL r1
;;;45         write32(reg, val);
000160  e1a01005          MOV      r1,r5
000164  e1a0000a          MOV      r0,r10
000168  ebfffffe          BL       write32
;;;46     }
00016c  e8bd87f0          POP      {r4-r10,pc}
;;;47     
                          ENDP

                  gpio_init PROC
;;;4      // Configure multiple gpio pins
;;;5      void gpio_init(
000170  e92d43f8          PUSH     {r3-r9,lr}
;;;6          uint32_t port,
;;;7          uint32_t pin_mask,
;;;8          gpio_mode_e mode,
;;;9          gpio_pull_e pull,
;;;10         gpio_drv_e drv) {
000174  e1a06000          MOV      r6,r0
000178  e1a05001          MOV      r5,r1
00017c  e1a07002          MOV      r7,r2
000180  e1a08003          MOV      r8,r3
000184  e59d9020          LDR      r9,[sp,#0x20]
;;;11         for(uint8_t i = 0; i < 32; i++) {
000188  e3a04000          MOV      r4,#0
00018c  ea00000b          B        |L1.448|
                  |L1.400|
;;;12             if(pin_mask & (1U << i)) gpio_pin_init(port, i, mode, pull, drv);
000190  e3a00001          MOV      r0,#1
000194  e0050410          AND      r0,r5,r0,LSL r4
000198  e3500000          CMP      r0,#0
00019c  0a000005          BEQ      |L1.440|
0001a0  e1a03008          MOV      r3,r8
0001a4  e1a02007          MOV      r2,r7
0001a8  e1a01004          MOV      r1,r4
0001ac  e1a00006          MOV      r0,r6
0001b0  e58d9000          STR      r9,[sp,#0]
0001b4  ebfffffe          BL       gpio_pin_init
                  |L1.440|
0001b8  e2840001          ADD      r0,r4,#1              ;11
0001bc  e20040ff          AND      r4,r0,#0xff           ;11
                  |L1.448|
0001c0  e3540020          CMP      r4,#0x20              ;11
0001c4  bafffff1          BLT      |L1.400|
;;;13         }
;;;14     }
0001c8  e8bd83f8          POP      {r3-r9,pc}
;;;15     
                          ENDP

                  eint_pin_init PROC
;;;79     
;;;80     void eint_pin_init(uint32_t int_port, uint8_t pin_n, eint_trigger_mode_e trg) {
0001cc  e92d41f0          PUSH     {r4-r8,lr}
0001d0  e1a04000          MOV      r4,r0
0001d4  e1a06001          MOV      r6,r1
0001d8  e1a07002          MOV      r7,r2
;;;81         uint32_t reg = int_port + GPIO_INT_CFG0 + (pin_n / 6) * 4;
0001dc  e3a01006          MOV      r1,#6
0001e0  e1a00006          MOV      r0,r6
0001e4  ebfffffe          BL       __aeabi_idivmod
0001e8  e0848100          ADD      r8,r4,r0,LSL #2
;;;82         uint32_t val = read32(reg);
0001ec  e1a00008          MOV      r0,r8
0001f0  ebfffffe          BL       read32
0001f4  e1a05000          MOV      r5,r0
;;;83         val &= ~(0xF << ((pin_n % 6) * 4));
0001f8  e3a01006          MOV      r1,#6
0001fc  e1a00006          MOV      r0,r6
000200  ebfffffe          BL       __aeabi_idivmod
000204  e1a00101          LSL      r0,r1,#2
000208  e3a0100f          MOV      r1,#0xf
00020c  e1c55011          BIC      r5,r5,r1,LSL r0
;;;84         val |= ((trg & 0x7) << ((pin_n % 6) * 4));
000210  e3a01006          MOV      r1,#6
000214  e1a00006          MOV      r0,r6
000218  ebfffffe          BL       __aeabi_idivmod
00021c  e1a00101          LSL      r0,r1,#2
000220  e2071007          AND      r1,r7,#7
000224  e1855011          ORR      r5,r5,r1,LSL r0
;;;85         write32(reg, val);
000228  e1a01005          MOV      r1,r5
00022c  e1a00008          MOV      r0,r8
000230  ebfffffe          BL       write32
;;;86     }
000234  e8bd81f0          POP      {r4-r8,pc}
;;;87     
                          ENDP

                  eint_debounce_config PROC
;;;95     
;;;96     void eint_debounce_config(
000238  e92d4070          PUSH     {r4-r6,lr}
;;;97         uint32_t int_port,
;;;98         eint_debounce_src_e deb_src,
;;;99         eint_debounce_div_e deb_div) {
00023c  e1a04000          MOV      r4,r0
000240  e1a05001          MOV      r5,r1
000244  e1a06002          MOV      r6,r2
;;;100        write32(int_port + GPIO_INT_DEB, deb_src | (deb_div << 4));
000248  e1851206          ORR      r1,r5,r6,LSL #4
00024c  e2840018          ADD      r0,r4,#0x18
000250  ebfffffe          BL       write32
;;;101    }
000254  e8bd8070          POP      {r4-r6,pc}
;;;102    
                          ENDP

                  read32 PROC
;;;19     
;;;20     static __inline uint32_t read32(uint32_t addr)
000258  e1a01000          MOV      r1,r0
;;;21     {
;;;22       return (*((volatile uint32_t*)(addr)));
00025c  e5910000          LDR      r0,[r1,#0]
;;;23     }
000260  e12fff1e          BX       lr
;;;24     
                          ENDP

                  write32 PROC
;;;39     
;;;40     static __inline void write32(uint32_t addr, uint32_t value)
000264  e5801000          STR      r1,[r0,#0]
;;;41     {
;;;42       *((volatile uint32_t*)(addr)) = value;
;;;43     }
000268  e12fff1e          BX       lr
;;;44     
                          ENDP


                          AREA ||i.gpio_read||, COMGROUP=gpio_read, CODE, READONLY, ALIGN=2

                  gpio_read PROC
;;;47     
;;;48     inline uint32_t gpio_read(uint32_t port) {
000000  e92d4010          PUSH     {r4,lr}
000004  e1a04000          MOV      r4,r0
;;;49         return (read32(port + GPIO_DATA));
000008  e2840010          ADD      r0,r4,#0x10
00000c  ebfffffe          BL       read32
;;;50     }
000010  e8bd8010          POP      {r4,pc}
;;;51     
                          ENDP


                          AREA ||i.gpio_pin_get||, COMGROUP=gpio_pin_get, CODE, READONLY, ALIGN=2

                  gpio_pin_get PROC
;;;51     
;;;52     inline uint8_t gpio_pin_get(uint32_t port, uint8_t pin_n) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;53         return ((read32(port + GPIO_DATA) >> pin_n) & 0x1);
00000c  e2840010          ADD      r0,r4,#0x10
000010  ebfffffe          BL       read32
000014  e1a00530          LSR      r0,r0,r5
000018  e2000001          AND      r0,r0,#1
;;;54     }
00001c  e8bd8070          POP      {r4-r6,pc}
;;;55     
                          ENDP


                          AREA ||i.gpio_write||, COMGROUP=gpio_write, CODE, READONLY, ALIGN=2

                  gpio_write PROC
;;;55     
;;;56     inline void gpio_write(uint32_t port, uint32_t val) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;57         write32(port + GPIO_DATA, val);
00000c  e1a01005          MOV      r1,r5
000010  e2840010          ADD      r0,r4,#0x10
000014  ebfffffe          BL       write32
;;;58     }
000018  e8bd8070          POP      {r4-r6,pc}
;;;59     
                          ENDP


                          AREA ||i.gpio_set||, COMGROUP=gpio_set, CODE, READONLY, ALIGN=2

                  gpio_set PROC
;;;59     
;;;60     inline void gpio_set(uint32_t port, uint32_t pin_mask) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;61         write32(port + GPIO_DATA, (read32(port + GPIO_DATA) | (pin_mask)));
00000c  e2840010          ADD      r0,r4,#0x10
000010  ebfffffe          BL       read32
000014  e1806005          ORR      r6,r0,r5
000018  e1a01006          MOV      r1,r6
00001c  e2840010          ADD      r0,r4,#0x10
000020  ebfffffe          BL       write32
;;;62     }
000024  e8bd8070          POP      {r4-r6,pc}
;;;63     
                          ENDP


                          AREA ||i.gpio_clear||, COMGROUP=gpio_clear, CODE, READONLY, ALIGN=2

                  gpio_clear PROC
;;;63     
;;;64     inline void gpio_clear(uint32_t port, uint32_t pin_mask) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;65         write32(port + GPIO_DATA, (read32(port + GPIO_DATA) & (~pin_mask)));
00000c  e2840010          ADD      r0,r4,#0x10
000010  ebfffffe          BL       read32
000014  e1c06005          BIC      r6,r0,r5
000018  e1a01006          MOV      r1,r6
00001c  e2840010          ADD      r0,r4,#0x10
000020  ebfffffe          BL       write32
;;;66     }
000024  e8bd8070          POP      {r4-r6,pc}
;;;67     
                          ENDP


                          AREA ||i.gpio_pin_set||, COMGROUP=gpio_pin_set, CODE, READONLY, ALIGN=2

                  gpio_pin_set PROC
;;;67     
;;;68     inline void gpio_pin_set(uint32_t port, uint8_t pin_n) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;69         write32(port + GPIO_DATA, (read32(port + GPIO_DATA) | (1 << pin_n)));
00000c  e2840010          ADD      r0,r4,#0x10
000010  ebfffffe          BL       read32
000014  e3a01001          MOV      r1,#1
000018  e1806511          ORR      r6,r0,r1,LSL r5
00001c  e1a01006          MOV      r1,r6
000020  e2840010          ADD      r0,r4,#0x10
000024  ebfffffe          BL       write32
;;;70     }
000028  e8bd8070          POP      {r4-r6,pc}
;;;71     
                          ENDP


                          AREA ||i.gpio_pin_clear||, COMGROUP=gpio_pin_clear, CODE, READONLY, ALIGN=2

                  gpio_pin_clear PROC
;;;71     
;;;72     inline void gpio_pin_clear(uint32_t port, uint8_t pin_n) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;73         write32(port + GPIO_DATA, (read32(port + GPIO_DATA) & (~(1 << pin_n))));
00000c  e2840010          ADD      r0,r4,#0x10
000010  ebfffffe          BL       read32
000014  e3a01001          MOV      r1,#1
000018  e1c06511          BIC      r6,r0,r1,LSL r5
00001c  e1a01006          MOV      r1,r6
000020  e2840010          ADD      r0,r4,#0x10
000024  ebfffffe          BL       write32
;;;74     }
000028  e8bd8070          POP      {r4-r6,pc}
;;;75     
                          ENDP


                          AREA ||i.gpio_pin_toggle||, COMGROUP=gpio_pin_toggle, CODE, READONLY, ALIGN=2

                  gpio_pin_toggle PROC
;;;75     
;;;76     inline void gpio_pin_toggle(uint32_t port, uint8_t pin_n) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;77         write32(port + GPIO_DATA, (read32(port + GPIO_DATA) ^ (1 << pin_n)));
00000c  e2840010          ADD      r0,r4,#0x10
000010  ebfffffe          BL       read32
000014  e3a01001          MOV      r1,#1
000018  e0206511          EOR      r6,r0,r1,LSL r5
00001c  e1a01006          MOV      r1,r6
000020  e2840010          ADD      r0,r4,#0x10
000024  ebfffffe          BL       write32
;;;78     }
000028  e8bd8070          POP      {r4-r6,pc}
;;;79     
                          ENDP


                          AREA ||i.eint_pin_enable||, COMGROUP=eint_pin_enable, CODE, READONLY, ALIGN=2

                  eint_pin_enable PROC
;;;87     
;;;88     inline void eint_pin_enable(uint32_t int_port, uint8_t pin_n) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;89         write32(int_port + GPIO_INT_CTRL, (read32(int_port + GPIO_INT_CTRL) | (1 << pin_n)));
00000c  e2840010          ADD      r0,r4,#0x10
000010  ebfffffe          BL       read32
000014  e3a01001          MOV      r1,#1
000018  e1806511          ORR      r6,r0,r1,LSL r5
00001c  e1a01006          MOV      r1,r6
000020  e2840010          ADD      r0,r4,#0x10
000024  ebfffffe          BL       write32
;;;90     }
000028  e8bd8070          POP      {r4-r6,pc}
;;;91     
                          ENDP


                          AREA ||i.eint_pin_disable||, COMGROUP=eint_pin_disable, CODE, READONLY, ALIGN=2

                  eint_pin_disable PROC
;;;91     
;;;92     inline void eint_pin_disable(uint32_t int_port, uint8_t pin_n) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;93         write32(int_port + GPIO_INT_CTRL, (read32(int_port + GPIO_INT_CTRL) & (~(1 << pin_n))));
00000c  e2840010          ADD      r0,r4,#0x10
000010  ebfffffe          BL       read32
000014  e3a01001          MOV      r1,#1
000018  e1c06511          BIC      r6,r0,r1,LSL r5
00001c  e1a01006          MOV      r1,r6
000020  e2840010          ADD      r0,r4,#0x10
000024  ebfffffe          BL       write32
;;;94     }
000028  e8bd8070          POP      {r4-r6,pc}
;;;95     
                          ENDP


                          AREA ||i.eint_get_status||, COMGROUP=eint_get_status, CODE, READONLY, ALIGN=2

                  eint_get_status PROC
;;;102    
;;;103    inline uint32_t eint_get_status(uint32_t int_port) {
000000  e92d4010          PUSH     {r4,lr}
000004  e1a04000          MOV      r4,r0
;;;104        return (read32(int_port + GPIO_INT_STA));
000008  e2840014          ADD      r0,r4,#0x14
00000c  ebfffffe          BL       read32
;;;105    }
000010  e8bd8010          POP      {r4,pc}
;;;106    
                          ENDP


                          AREA ||i.eint_pin_get_status||, COMGROUP=eint_pin_get_status, CODE, READONLY, ALIGN=2

                  eint_pin_get_status PROC
;;;106    
;;;107    inline uint8_t eint_pin_get_status(uint32_t int_port, uint8_t pin_n) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;108        return (read32(int_port + GPIO_INT_STA) >> pin_n) & 0x1;
00000c  e2840014          ADD      r0,r4,#0x14
000010  ebfffffe          BL       read32
000014  e1a00530          LSR      r0,r0,r5
000018  e2000001          AND      r0,r0,#1
;;;109    }
00001c  e8bd8070          POP      {r4-r6,pc}
;;;110    
                          ENDP


                          AREA ||i.eint_pin_clear_status||, COMGROUP=eint_pin_clear_status, CODE, READONLY, ALIGN=2

                  eint_pin_clear_status PROC
;;;110    
;;;111    inline void eint_pin_clear_status(uint32_t int_port, uint8_t pin_n) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;112        set32(int_port + GPIO_INT_STA, (0x1 << pin_n));
00000c  e2840014          ADD      r0,r4,#0x14
000010  ebfffffe          BL       read32
000014  e3a01001          MOV      r1,#1
000018  e1806511          ORR      r6,r0,r1,LSL r5
00001c  e1a01006          MOV      r1,r6
000020  e2840014          ADD      r0,r4,#0x14
000024  ebfffffe          BL       write32
;;;113    }
000028  e8bd8070          POP      {r4-r6,pc}
                          ENDP

