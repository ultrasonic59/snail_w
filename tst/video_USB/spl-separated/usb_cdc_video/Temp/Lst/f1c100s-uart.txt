; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave --gnu -o.\temp\obj\f1c100s-uart.o --asm_dir=.\Temp\Lst\ --list_dir=.\Temp\Lst\ --depend=.\temp\obj\f1c100s-uart.d --cpu=ARM9E --apcs=interwork -O0 -Otime --diag_suppress=9931 -I.\users\include -I.\..\machine\include -I.\..\periph\include -I.\..\include -I.\..\emwin\Include -I.\..\tinyusb\src -I.\..\tinyusb\hw -I.\..\display -I.\..\lib\display_gfx -I.\..\lib\printf -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Atmel\SAM9260 -D__RTX -D__UVISION_VERSION=536 -DPCB_TINY200V1 -DCFG_TUSB_MCU=OPT_MCU_F1C100S -DCFG_TUSB_OS=OPT_OS_RTX4 --omf_browse=.\temp\obj\f1c100s-uart.crf ..\machine\f1c100s-uart.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  uart_irq_handler PROC
;;;189    
;;;190    static void uart_irq_handler(UART_MOD_TypeDef* module)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;191    {
000004  e1a04000          MOV      r4,r0
;;;192      uint32_t addr, val, iir, nMax, index;
;;;193      uint8_t const* pTxData;
;;;194      void (*pfCallback)(void);
;;;195    
;;;196      addr = module->regs_base;
000008  e5945000          LDR      r5,[r4,#0]
;;;197      iir = (read32(addr + UART_IIR_REG) & 0x0F);
00000c  e2850008          ADD      r0,r5,#8
000010  ebfffffe          BL       read32
000014  e200000f          AND      r0,r0,#0xf
000018  e58d0000          STR      r0,[sp,#0]
;;;198      switch (iir) {
00001c  e59d0000          LDR      r0,[sp,#0]
000020  e3500006          CMP      r0,#6
000024  0a00000c          BEQ      |L1.92|
000028  ca000006          BGT      |L1.72|
00002c  e3500000          CMP      r0,#0
000030  0a000059          BEQ      |L1.412|
000034  e3500002          CMP      r0,#2
000038  0a00002f          BEQ      |L1.252|
00003c  e3500004          CMP      r0,#4
000040  1a00005f          BNE      |L1.452|
000044  ea000009          B        |L1.112|
                  |L1.72|
000048  e3500007          CMP      r0,#7
00004c  0a000057          BEQ      |L1.432|
000050  e350000c          CMP      r0,#0xc
000054  1a00005a          BNE      |L1.452|
000058  ea000006          B        |L1.120|
                  |L1.92|
;;;199        case 0x06:  // receiver line status
00005c  e1a00000          MOV      r0,r0
;;;200          val = read32(addr + UART_LSR_REG);
000060  e2850014          ADD      r0,r5,#0x14
000064  ebfffffe          BL       read32
000068  e1a06000          MOV      r6,r0
;;;201          break;
00006c  ea000054          B        |L1.452|
                  |L1.112|
;;;202        case 0x04:
000070  e1a00000          MOV      r0,r0
;;;203        case 0x0c:
000074  e1a00000          MOV      r0,r0
                  |L1.120|
;;;204          val = read32(addr + UART_LSR_REG);
000078  e2850014          ADD      r0,r5,#0x14
00007c  ebfffffe          BL       read32
000080  e1a06000          MOV      r6,r0
;;;205          index = module->in_offset;
000084  e1d492b4          LDRH     r9,[r4,#0x24]
;;;206          while (val & 0x01) {
000088  ea000012          B        |L1.216|
                  |L1.140|
;;;207            if (val & 0x80) {
00008c  e2060080          AND      r0,r6,#0x80
000090  e3500000          CMP      r0,#0
000094  0a000003          BEQ      |L1.168|
;;;208              val = read32(addr + UART_RBR_REG);
000098  e1a00005          MOV      r0,r5
00009c  ebfffffe          BL       read32
0000a0  e1a06000          MOV      r6,r0
0000a4  ea000008          B        |L1.204|
                  |L1.168|
;;;209            } else {
;;;210              val = read32(addr + UART_RBR_REG);
0000a8  e1a00005          MOV      r0,r5
0000ac  ebfffffe          BL       read32
0000b0  e1a06000          MOV      r6,r0
;;;211              // push to soft-fifo
;;;212              module->rx_fifo[(index++) & RX_FIFO_MSK] = (uint8_t)val;
0000b4  e1a00009          MOV      r0,r9
0000b8  e2899001          ADD      r9,r9,#1
0000bc  e1a00b00          LSL      r0,r0,#22
0000c0  e1a00b20          LSR      r0,r0,#22
0000c4  e2842028          ADD      r2,r4,#0x28
0000c8  e7c26000          STRB     r6,[r2,r0]
                  |L1.204|
;;;213            }
;;;214            val = read32(addr + UART_LSR_REG);
0000cc  e2850014          ADD      r0,r5,#0x14
0000d0  ebfffffe          BL       read32
0000d4  e1a06000          MOV      r6,r0
                  |L1.216|
0000d8  e2060001          AND      r0,r6,#1              ;206
0000dc  e3500000          CMP      r0,#0                 ;206
0000e0  1affffe9          BNE      |L1.140|
;;;215          }
;;;216          module->in_offset = index;
0000e4  e1c492b4          STRH     r9,[r4,#0x24]
;;;217          pfCallback = module->rxCallback;
0000e8  e594700c          LDR      r7,[r4,#0xc]
;;;218          if (pfCallback) {
0000ec  e3570000          CMP      r7,#0
0000f0  0a000000          BEQ      |L1.248|
;;;219            pfCallback();
0000f4  e12fff37          BLX      r7
                  |L1.248|
;;;220          }
;;;221          break;
0000f8  ea000031          B        |L1.452|
                  |L1.252|
;;;222        case 0x02:  // THR empty
0000fc  e1a00000          MOV      r0,r0
;;;223          if (module->txLength > 0) {
000100  e5940020          LDR      r0,[r4,#0x20]
000104  e3500000          CMP      r0,#0
000108  0a000016          BEQ      |L1.360|
;;;224            nMax = (32 - (read32(addr + UART_TFL_REG) & 0x1F));
00010c  e2850080          ADD      r0,r5,#0x80
000110  ebfffffe          BL       read32
000114  e200001f          AND      r0,r0,#0x1f
000118  e2608020          RSB      r8,r0,#0x20
;;;225            if (nMax > module->txLength)
00011c  e5940020          LDR      r0,[r4,#0x20]
000120  e1500008          CMP      r0,r8
000124  2a000000          BCS      |L1.300|
;;;226              nMax = module->txLength;
000128  e5948020          LDR      r8,[r4,#0x20]
                  |L1.300|
;;;227            pTxData = module->pTxData;
00012c  e594a01c          LDR      r10,[r4,#0x1c]
;;;228            for (unsigned i = 0; i < nMax; i++) {
000130  e3a0b000          MOV      r11,#0
000134  ea000003          B        |L1.328|
                  |L1.312|
;;;229              write32(addr + UART_THR_REG, pTxData[i]);
000138  e7da100b          LDRB     r1,[r10,r11]
00013c  e1a00005          MOV      r0,r5
000140  ebfffffe          BL       write32
000144  e28bb001          ADD      r11,r11,#1            ;228
                  |L1.328|
000148  e15b0008          CMP      r11,r8                ;228
00014c  3afffff9          BCC      |L1.312|
;;;230            }
;;;231            module->pTxData = &pTxData[nMax];
000150  e08a0008          ADD      r0,r10,r8
000154  e584001c          STR      r0,[r4,#0x1c]
;;;232            module->txLength -= nMax;
000158  e5940020          LDR      r0,[r4,#0x20]
00015c  e0400008          SUB      r0,r0,r8
000160  e5840020          STR      r0,[r4,#0x20]
000164  ea00000b          B        |L1.408|
                  |L1.360|
;;;233          } else {
;;;234            val = read32(addr + UART_IER_REG);
000168  e2850004          ADD      r0,r5,#4
00016c  ebfffffe          BL       read32
000170  e1a06000          MOV      r6,r0
;;;235            write32(addr + UART_IER_REG, (val & ~(1 << 1)));
000174  e3c61002          BIC      r1,r6,#2
000178  e2850004          ADD      r0,r5,#4
00017c  ebfffffe          BL       write32
;;;236            module->isTxBusy = 0;
000180  e3a00000          MOV      r0,#0
000184  e5c40018          STRB     r0,[r4,#0x18]
;;;237            pfCallback = module->txEndCallback;
000188  e5947008          LDR      r7,[r4,#8]
;;;238            if (pfCallback) {
00018c  e3570000          CMP      r7,#0
000190  0a000000          BEQ      |L1.408|
;;;239              pfCallback();
000194  e12fff37          BLX      r7
                  |L1.408|
;;;240            }
;;;241          }
;;;242          break;
000198  ea000009          B        |L1.452|
                  |L1.412|
;;;243        case 0x00: // modem status
00019c  e1a00000          MOV      r0,r0
;;;244          val = read32(addr + UART_MSR_REG);
0001a0  e2850018          ADD      r0,r5,#0x18
0001a4  ebfffffe          BL       read32
0001a8  e1a06000          MOV      r6,r0
;;;245          break;
0001ac  ea000004          B        |L1.452|
                  |L1.432|
;;;246        case 0x07: //busy detect
0001b0  e1a00000          MOV      r0,r0
;;;247          val = read32(addr + UART_USR_REG);
0001b4  e285007c          ADD      r0,r5,#0x7c
0001b8  ebfffffe          BL       read32
0001bc  e1a06000          MOV      r6,r0
;;;248          break;
0001c0  e1a00000          MOV      r0,r0
                  |L1.452|
0001c4  e1a00000          MOV      r0,r0                 ;201
;;;249      }
;;;250    }
0001c8  e8bd8ff8          POP      {r3-r11,pc}
;;;251    
                          ENDP

                  uart0_irq PROC
;;;96     
;;;97     static void uart0_irq(void)
0001cc  e92d4010          PUSH     {r4,lr}
;;;98     {
;;;99       uart_irq_handler(&modules[0]);
0001d0  e59f0580          LDR      r0,|L1.1880|
0001d4  ebfffffe          BL       uart_irq_handler
;;;100    }
0001d8  e8bd8010          POP      {r4,pc}
;;;101    
                          ENDP

                  uart1_irq PROC
;;;102    static void uart1_irq(void)
0001dc  e92d4010          PUSH     {r4,lr}
;;;103    {
;;;104      uart_irq_handler(&modules[1]);
0001e0  e59f0574          LDR      r0,|L1.1884|
0001e4  ebfffffe          BL       uart_irq_handler
;;;105    }
0001e8  e8bd8010          POP      {r4,pc}
;;;106    
                          ENDP

                  uart2_irq PROC
;;;107    static void uart2_irq(void)
0001ec  e92d4010          PUSH     {r4,lr}
;;;108    {
;;;109      uart_irq_handler(&modules[2]);
0001f0  e59f0568          LDR      r0,|L1.1888|
0001f4  ebfffffe          BL       uart_irq_handler
;;;110    }
0001f8  e8bd8010          POP      {r4,pc}
;;;111    
                          ENDP

                  uart_init_regs PROC
;;;251    
;;;252    static void uart_init_regs(UART_MOD_TypeDef* module)
0001fc  e92d4070          PUSH     {r4-r6,lr}
;;;253    {
000200  e1a05000          MOV      r5,r0
;;;254      uint32_t addr, val;
;;;255    
;;;256      /* 配置UART参数115200-8-1-0 */
;;;257      addr = module->regs_base;
000204  e5954000          LDR      r4,[r5,#0]
;;;258      write32(addr + UART_IER_REG, 0x0);
000208  e3a01000          MOV      r1,#0
00020c  e2840004          ADD      r0,r4,#4
000210  ebfffffe          BL       write32
;;;259      write32(addr + UART_FCR_REG, (2 << 6) | (1 << 4) | 7);
000214  e3a01097          MOV      r1,#0x97
000218  e2840008          ADD      r0,r4,#8
00021c  ebfffffe          BL       write32
;;;260      write32(addr + UART_MCR_REG, 0x0);
000220  e3a01000          MOV      r1,#0
000224  e2840010          ADD      r0,r4,#0x10
000228  ebfffffe          BL       write32
;;;261      while (read32(addr + UART_USR_REG) & 1);
00022c  e1a00000          MOV      r0,r0
                  |L1.560|
000230  e284007c          ADD      r0,r4,#0x7c
000234  ebfffffe          BL       read32
000238  e2000001          AND      r0,r0,#1
00023c  e3500000          CMP      r0,#0
000240  1afffffa          BNE      |L1.560|
;;;262      write32(addr + UART_LCR_REG, 0x83);
000244  e3a01083          MOV      r1,#0x83
000248  e284000c          ADD      r0,r4,#0xc
00024c  ebfffffe          BL       write32
;;;263      val = (6250000UL / module->baudrate);
000250  e5951010          LDR      r1,[r5,#0x10]
000254  e59f0508          LDR      r0,|L1.1892|
000258  ebfffffe          BL       __aeabi_uidivmod
00025c  e1a06000          MOV      r6,r0
;;;264      write32(addr + UART_DLL_REG, ((val >> 0) & 0xff));
000260  e20610ff          AND      r1,r6,#0xff
000264  e1a00004          MOV      r0,r4
000268  ebfffffe          BL       write32
;;;265      write32(addr + UART_DLH_REG, ((val >> 8) & 0xff));
00026c  e1a00806          LSL      r0,r6,#16
000270  e1a01c20          LSR      r1,r0,#24
000274  e2840004          ADD      r0,r4,#4
000278  ebfffffe          BL       write32
;;;266      write32(addr + UART_LCR_REG, 0x03);
00027c  e3a01003          MOV      r1,#3
000280  e284000c          ADD      r0,r4,#0xc
000284  ebfffffe          BL       write32
;;;267      write32(addr + UART_IER_REG, (1 << 2) | (1 << 0));
000288  e3a01005          MOV      r1,#5
00028c  e2840004          ADD      r0,r4,#4
000290  ebfffffe          BL       write32
;;;268    }
000294  e8bd8070          POP      {r4-r6,pc}
;;;269    
                          ENDP

                  uart0_init PROC
;;;111    
;;;112    static void uart0_init(UART_MOD_TypeDef* module)
000298  e92d4070          PUSH     {r4-r6,lr}
;;;113    {
00029c  e1a05000          MOV      r5,r0
;;;114      uint32_t reg_addr, reg_value;
;;;115    
;;;116      // 开启时钟
;;;117      reg_addr = F1C100S_CCU_BASE + CCU_BUS_CLK_GATE2;
0002a0  e59f64c0          LDR      r6,|L1.1896|
;;;118      reg_value = read32(reg_addr);
0002a4  e1a00006          MOV      r0,r6
0002a8  ebfffffe          BL       read32
0002ac  e1a04000          MOV      r4,r0
;;;119      reg_value |= (1U << 20);
0002b0  e3844601          ORR      r4,r4,#0x100000
;;;120      write32(reg_addr, reg_value);
0002b4  e1a01004          MOV      r1,r4
0002b8  e1a00006          MOV      r0,r6
0002bc  ebfffffe          BL       write32
;;;121    
;;;122      // 退出复位状态
;;;123      reg_addr = F1C100S_CCU_BASE + CCU_BUS_SOFT_RST2;
0002c0  e2866f9a          ADD      r6,r6,#0x268
;;;124      reg_value = read32(reg_addr);
0002c4  e1a00006          MOV      r0,r6
0002c8  ebfffffe          BL       read32
0002cc  e1a04000          MOV      r4,r0
;;;125      reg_value |= (1U << 20);
0002d0  e3844601          ORR      r4,r4,#0x100000
;;;126      write32(reg_addr, reg_value);
0002d4  e1a01004          MOV      r1,r4
0002d8  e1a00006          MOV      r0,r6
0002dc  ebfffffe          BL       write32
;;;127    
;;;128      // 配置管脚功能
;;;129      gpio_f1c100s_set_cfg(&GPIO_PE, 0, 5);
0002e0  e3a02005          MOV      r2,#5
0002e4  e3a01000          MOV      r1,#0
0002e8  e59f047c          LDR      r0,|L1.1900|
0002ec  ebfffffe          BL       gpio_f1c100s_set_cfg
;;;130      gpio_f1c100s_set_cfg(&GPIO_PE, 1, 5);
0002f0  e3a02005          MOV      r2,#5
0002f4  e3a01001          MOV      r1,#1
0002f8  e59f046c          LDR      r0,|L1.1900|
0002fc  ebfffffe          BL       gpio_f1c100s_set_cfg
;;;131      gpio_f1c100s_set_pull(&GPIO_PE, 0, GPIO_PULL_UP);
000300  e3a02000          MOV      r2,#0
000304  e1a01002          MOV      r1,r2
000308  e59f045c          LDR      r0,|L1.1900|
00030c  ebfffffe          BL       gpio_f1c100s_set_pull
;;;132      gpio_f1c100s_set_pull(&GPIO_PE, 1, GPIO_PULL_UP);
000310  e3a02000          MOV      r2,#0
000314  e3a01001          MOV      r1,#1
000318  e59f044c          LDR      r0,|L1.1900|
00031c  ebfffffe          BL       gpio_f1c100s_set_pull
;;;133    
;;;134      // 配置串口模块寄存器
;;;135      uart_init_regs(module);
000320  e1a00005          MOV      r0,r5
000324  ebfffffe          BL       uart_init_regs
;;;136    
;;;137      // 配置中断
;;;138      f1c100s_intc_set_isr(F1C100S_IRQ_UART0, uart0_irq);
000328  e59f1440          LDR      r1,|L1.1904|
00032c  e3a00001          MOV      r0,#1
000330  ebfffffe          BL       f1c100s_intc_set_isr
;;;139      f1c100s_intc_enable_irq(F1C100S_IRQ_UART0);
000334  e3a00001          MOV      r0,#1
000338  ebfffffe          BL       f1c100s_intc_enable_irq
;;;140    }
00033c  e8bd8070          POP      {r4-r6,pc}
;;;141    
                          ENDP

                  uart1_init PROC
;;;142    static void uart1_init(UART_MOD_TypeDef* module)
000340  e92d4070          PUSH     {r4-r6,lr}
;;;143    {
000344  e1a05000          MOV      r5,r0
;;;144      uint32_t reg_addr, reg_value;
;;;145    
;;;146      // 开启时钟
;;;147      reg_addr = F1C100S_CCU_BASE + CCU_BUS_CLK_GATE2;
000348  e59f6418          LDR      r6,|L1.1896|
;;;148      reg_value = read32(reg_addr);
00034c  e1a00006          MOV      r0,r6
000350  ebfffffe          BL       read32
000354  e1a04000          MOV      r4,r0
;;;149      reg_value |= (1U << 21);
000358  e3844602          ORR      r4,r4,#0x200000
;;;150      write32(reg_addr, reg_value);
00035c  e1a01004          MOV      r1,r4
000360  e1a00006          MOV      r0,r6
000364  ebfffffe          BL       write32
;;;151    
;;;152      // 退出复位状态
;;;153      reg_addr = F1C100S_CCU_BASE + CCU_BUS_SOFT_RST2;
000368  e2866f9a          ADD      r6,r6,#0x268
;;;154      reg_value = read32(reg_addr);
00036c  e1a00006          MOV      r0,r6
000370  ebfffffe          BL       read32
000374  e1a04000          MOV      r4,r0
;;;155      reg_value |= (1U << 21);
000378  e3844602          ORR      r4,r4,#0x200000
;;;156      write32(reg_addr, reg_value);
00037c  e1a01004          MOV      r1,r4
000380  e1a00006          MOV      r0,r6
000384  ebfffffe          BL       write32
;;;157    
;;;158      // 配置串口模块寄存器
;;;159      uart_init_regs(module);
000388  e1a00005          MOV      r0,r5
00038c  ebfffffe          BL       uart_init_regs
;;;160    
;;;161      // 配置中断
;;;162      f1c100s_intc_set_isr(F1C100S_IRQ_UART1, uart1_irq);
000390  e59f13dc          LDR      r1,|L1.1908|
000394  e3a00002          MOV      r0,#2
000398  ebfffffe          BL       f1c100s_intc_set_isr
;;;163      f1c100s_intc_enable_irq(F1C100S_IRQ_UART1);
00039c  e3a00002          MOV      r0,#2
0003a0  ebfffffe          BL       f1c100s_intc_enable_irq
;;;164    }
0003a4  e8bd8070          POP      {r4-r6,pc}
;;;165    
                          ENDP

                  uart2_init PROC
;;;166    static void uart2_init(UART_MOD_TypeDef* module)
0003a8  e92d4070          PUSH     {r4-r6,lr}
;;;167    {
0003ac  e1a05000          MOV      r5,r0
;;;168      uint32_t reg_addr, reg_value;
;;;169    
;;;170      // 开启时钟
;;;171      reg_addr = F1C100S_CCU_BASE + CCU_BUS_CLK_GATE2;
0003b0  e59f63b0          LDR      r6,|L1.1896|
;;;172      reg_value = read32(reg_addr);
0003b4  e1a00006          MOV      r0,r6
0003b8  ebfffffe          BL       read32
0003bc  e1a04000          MOV      r4,r0
;;;173      reg_value |= (1U << 22);
0003c0  e3844501          ORR      r4,r4,#0x400000
;;;174      write32(reg_addr, reg_value);
0003c4  e1a01004          MOV      r1,r4
0003c8  e1a00006          MOV      r0,r6
0003cc  ebfffffe          BL       write32
;;;175    
;;;176      // 退出复位状态
;;;177      reg_addr = F1C100S_CCU_BASE + CCU_BUS_SOFT_RST2;
0003d0  e2866f9a          ADD      r6,r6,#0x268
;;;178      reg_value = read32(reg_addr);
0003d4  e1a00006          MOV      r0,r6
0003d8  ebfffffe          BL       read32
0003dc  e1a04000          MOV      r4,r0
;;;179      reg_value |= (1U << 22);
0003e0  e3844501          ORR      r4,r4,#0x400000
;;;180      write32(reg_addr, reg_value);
0003e4  e1a01004          MOV      r1,r4
0003e8  e1a00006          MOV      r0,r6
0003ec  ebfffffe          BL       write32
;;;181    
;;;182      // 配置串口模块寄存器
;;;183      uart_init_regs(module);
0003f0  e1a00005          MOV      r0,r5
0003f4  ebfffffe          BL       uart_init_regs
;;;184    
;;;185      // 配置中断
;;;186      f1c100s_intc_set_isr(F1C100S_IRQ_UART2, uart2_irq);
0003f8  e59f1378          LDR      r1,|L1.1912|
0003fc  e3a00003          MOV      r0,#3
000400  ebfffffe          BL       f1c100s_intc_set_isr
;;;187      f1c100s_intc_enable_irq(F1C100S_IRQ_UART2);
000404  e3a00003          MOV      r0,#3
000408  ebfffffe          BL       f1c100s_intc_enable_irq
;;;188    }
00040c  e8bd8070          POP      {r4-r6,pc}
;;;189    
                          ENDP

                  f1c100s_uart_init PROC
;;;275    */
;;;276    bool_t f1c100s_uart_init(uint8_t mid)
000410  e92d4070          PUSH     {r4-r6,lr}
;;;277    {
000414  e1a05000          MOV      r5,r0
;;;278      UART_MOD_TypeDef* module = &modules[mid];
000418  e0850105          ADD      r0,r5,r5,LSL #2
00041c  e0800385          ADD      r0,r0,r5,LSL #7
000420  e59f1330          LDR      r1,|L1.1880|
000424  e0814180          ADD      r4,r1,r0,LSL #3
;;;279    
;;;280      if (module->init) {
000428  e5940004          LDR      r0,[r4,#4]
00042c  e3500000          CMP      r0,#0
000430  0a000004          BEQ      |L1.1096|
;;;281        module->init(module);
000434  e5941004          LDR      r1,[r4,#4]
000438  e1a00004          MOV      r0,r4
00043c  e12fff31          BLX      r1
;;;282        return TRUE;
000440  e3a00001          MOV      r0,#1
                  |L1.1092|
;;;283      }
;;;284      return FALSE;
;;;285    }
000444  e8bd8070          POP      {r4-r6,pc}
                  |L1.1096|
000448  e3a00000          MOV      r0,#0                 ;284
00044c  eafffffc          B        |L1.1092|
;;;286    
                          ENDP

                  f1c100s_uart_readFifo PROC
;;;293    */
;;;294    int  f1c100s_uart_readFifo(uint8_t mid, uint8_t buf[], unsigned int max)
000450  e92d47f0          PUSH     {r4-r10,lr}
;;;295    {
000454  e1a09000          MOV      r9,r0
000458  e1a08001          MOV      r8,r1
00045c  e1a05002          MOV      r5,r2
;;;296      UART_MOD_TypeDef* module = &modules[mid];
000460  e0890109          ADD      r0,r9,r9,LSL #2
000464  e0800389          ADD      r0,r0,r9,LSL #7
000468  e59f12e8          LDR      r1,|L1.1880|
00046c  e0814180          ADD      r4,r1,r0,LSL #3
;;;297      unsigned int total, cpynum;
;;;298      uint32_t in_offset;
;;;299    
;;;300      in_offset = (module->in_offset & RX_FIFO_MSK);
000470  e1d402b4          LDRH     r0,[r4,#0x24]
000474  e3c0ab3f          BIC      r10,r0,#0xfc00
;;;301      if (module->out_offset == in_offset) {
000478  e1d402b6          LDRH     r0,[r4,#0x26]
00047c  e150000a          CMP      r0,r10
000480  1a000001          BNE      |L1.1164|
;;;302        /* 接收FIFO为空 */
;;;303        return 0;
000484  e3a00000          MOV      r0,#0
                  |L1.1160|
;;;304      }
;;;305    
;;;306      total = (RX_FIFO_MSK & (in_offset - module->out_offset));
;;;307      if (total > max) {
;;;308        total = max;
;;;309      } else {
;;;310        max = total;
;;;311      }
;;;312    
;;;313      if (module->out_offset + max >= RX_FIFO_SIZ) {
;;;314        cpynum = (RX_FIFO_SIZ - module->out_offset);
;;;315        memcpy(buf, &module->rx_fifo[module->out_offset], cpynum);
;;;316        module->out_offset = 0;
;;;317        buf += cpynum;
;;;318        max -= cpynum;
;;;319      }
;;;320    
;;;321      if (max > 0) {
;;;322        memcpy(buf, &module->rx_fifo[module->out_offset], max);
;;;323        module->out_offset += max;
;;;324      }
;;;325    
;;;326      return total;
;;;327    }
000488  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1164|
00048c  e1d402b6          LDRH     r0,[r4,#0x26]         ;306
000490  e04a0000          SUB      r0,r10,r0             ;306
000494  e1a06b00          LSL      r6,r0,#22             ;306
000498  e1a06b26          LSR      r6,r6,#22             ;306
00049c  e1560005          CMP      r6,r5                 ;307
0004a0  9a000001          BLS      |L1.1196|
0004a4  e1a06005          MOV      r6,r5                 ;308
0004a8  ea000000          B        |L1.1200|
                  |L1.1196|
0004ac  e1a05006          MOV      r5,r6                 ;310
                  |L1.1200|
0004b0  e1d402b6          LDRH     r0,[r4,#0x26]         ;313
0004b4  e0800005          ADD      r0,r0,r5              ;313
0004b8  e3500b01          CMP      r0,#0x400             ;313
0004bc  3a00000b          BCC      |L1.1264|
0004c0  e1d402b6          LDRH     r0,[r4,#0x26]         ;314
0004c4  e2607b01          RSB      r7,r0,#0x400          ;314
0004c8  e1d402b6          LDRH     r0,[r4,#0x26]         ;315
0004cc  e2842028          ADD      r2,r4,#0x28           ;315
0004d0  e0801002          ADD      r1,r0,r2              ;315
0004d4  e1a02007          MOV      r2,r7                 ;315
0004d8  e1a00008          MOV      r0,r8                 ;315
0004dc  ebfffffe          BL       __aeabi_memcpy
0004e0  e3a00000          MOV      r0,#0                 ;316
0004e4  e1c402b6          STRH     r0,[r4,#0x26]         ;316
0004e8  e0888007          ADD      r8,r8,r7              ;317
0004ec  e0455007          SUB      r5,r5,r7              ;318
                  |L1.1264|
0004f0  e3550000          CMP      r5,#0                 ;321
0004f4  0a000008          BEQ      |L1.1308|
0004f8  e1d402b6          LDRH     r0,[r4,#0x26]         ;322
0004fc  e2842028          ADD      r2,r4,#0x28           ;322
000500  e0801002          ADD      r1,r0,r2              ;322
000504  e1a02005          MOV      r2,r5                 ;322
000508  e1a00008          MOV      r0,r8                 ;322
00050c  ebfffffe          BL       __aeabi_memcpy
000510  e1d402b6          LDRH     r0,[r4,#0x26]         ;323
000514  e0800005          ADD      r0,r0,r5              ;323
000518  e1c402b6          STRH     r0,[r4,#0x26]         ;323
                  |L1.1308|
00051c  e1a00006          MOV      r0,r6                 ;326
000520  eaffffd8          B        |L1.1160|
;;;328    
                          ENDP

                  f1c100s_uart_clearfifo PROC
;;;333    */
;;;334    void f1c100s_uart_clearfifo(uint8_t mid)
000524  e92d4070          PUSH     {r4-r6,lr}
;;;335    {
000528  e1a04000          MOV      r4,r0
;;;336      UART_MOD_TypeDef* module = &modules[mid];
00052c  e0841104          ADD      r1,r4,r4,LSL #2
000530  e0811384          ADD      r1,r1,r4,LSL #7
000534  e59f221c          LDR      r2,|L1.1880|
000538  e0825181          ADD      r5,r2,r1,LSL #3
;;;337      CPU_SR_DECL;
;;;338    
;;;339      CPU_ENTER_CRITICAL();
00053c  e1a00000          MOV      r0,r0
000540  ebfffffe          BL       __fast_enter_critical
000544  e1a00000          MOV      r0,r0
;;;340      module->in_offset = module->out_offset = 0;
000548  e3a01000          MOV      r1,#0
00054c  e1c512b6          STRH     r1,[r5,#0x26]
000550  e1c512b4          STRH     r1,[r5,#0x24]
;;;341      CPU_EXIT_CRITICAL();
000554  e1a00000          MOV      r0,r0
000558  e1a00000          MOV      r0,r0
00055c  e121f000          MSR      CPSR_c,r0
000560  e1a00000          MOV      r0,r0
000564  e1a00000          MOV      r0,r0
;;;342    }
000568  e8bd8070          POP      {r4-r6,pc}
;;;343    
                          ENDP

                  f1c100s_uart_setBaudrate PROC
;;;349    */
;;;350    void f1c100s_uart_setBaudrate(uint8_t mid, uint32_t baud)
00056c  e92d4070          PUSH     {r4-r6,lr}
;;;351    {
000570  e1a06000          MOV      r6,r0
000574  e1a05001          MOV      r5,r1
;;;352      UART_MOD_TypeDef* module = &modules[mid];
000578  e0860106          ADD      r0,r6,r6,LSL #2
00057c  e0800386          ADD      r0,r0,r6,LSL #7
000580  e59f11d0          LDR      r1,|L1.1880|
000584  e0814180          ADD      r4,r1,r0,LSL #3
;;;353    
;;;354      if (__swap_byte(1, &module->isTxBusy))
000588  e2841018          ADD      r1,r4,#0x18
00058c  e3a00001          MOV      r0,#1
000590  ebfffffe          BL       __swap_byte
000594  e3500000          CMP      r0,#0
000598  0a000000          BEQ      |L1.1440|
                  |L1.1436|
;;;355        return;
;;;356    
;;;357      if (module->baudrate != baud) {
;;;358        module->baudrate = baud;
;;;359        uart_init_regs(module);
;;;360      }
;;;361      module->isTxBusy = 0;
;;;362    }
00059c  e8bd8070          POP      {r4-r6,pc}
                  |L1.1440|
0005a0  e5940010          LDR      r0,[r4,#0x10]         ;357
0005a4  e1500005          CMP      r0,r5                 ;357
0005a8  0a000002          BEQ      |L1.1464|
0005ac  e5845010          STR      r5,[r4,#0x10]         ;358
0005b0  e1a00004          MOV      r0,r4                 ;359
0005b4  ebfffffe          BL       uart_init_regs
                  |L1.1464|
0005b8  e3a00000          MOV      r0,#0                 ;361
0005bc  e5c40018          STRB     r0,[r4,#0x18]         ;361
0005c0  e1a00000          MOV      r0,r0
0005c4  eafffff4          B        |L1.1436|
;;;363    
                          ENDP

                  f1c100s_uart_getBaudrate PROC
;;;368    */
;;;369    uint32_t f1c100s_uart_getBaudrate(uint8_t mid)
0005c8  e1a01000          MOV      r1,r0
;;;370    {
;;;371      UART_MOD_TypeDef* module = &modules[mid];
0005cc  e0810101          ADD      r0,r1,r1,LSL #2
0005d0  e0800381          ADD      r0,r0,r1,LSL #7
0005d4  e59f317c          LDR      r3,|L1.1880|
0005d8  e0832180          ADD      r2,r3,r0,LSL #3
;;;372    
;;;373      return module->baudrate;
0005dc  e5920010          LDR      r0,[r2,#0x10]
;;;374    }
0005e0  e12fff1e          BX       lr
;;;375    
                          ENDP

                  f1c100s_uart_asyncTx PROC
;;;382    */
;;;383    void f1c100s_uart_asyncTx(uint8_t mid, const void* ptr, unsigned int len)
0005e4  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;384    {
0005e8  e1a09001          MOV      r9,r1
0005ec  e1a04002          MOV      r4,r2
;;;385      UART_MOD_TypeDef* module = &modules[mid];
0005f0  e59d0000          LDR      r0,[sp,#0]
0005f4  e0801100          ADD      r1,r0,r0,LSL #2
0005f8  e0810380          ADD      r0,r1,r0,LSL #7
0005fc  e59f1154          LDR      r1,|L1.1880|
000600  e0818180          ADD      r8,r1,r0,LSL #3
;;;386      uint8_t const* pTxData = ptr;
000604  e1a0a009          MOV      r10,r9
;;;387      uint32_t addr, nMax;
;;;388      CPU_SR_DECL;
;;;389    
;;;390      if ((ptr == 0) || (len <= 0))
000608  e3590000          CMP      r9,#0
00060c  0a000001          BEQ      |L1.1560|
000610  e3540000          CMP      r4,#0
000614  1a000000          BNE      |L1.1564|
                  |L1.1560|
;;;391        return;
;;;392    
;;;393      if (__swap_byte(1, &module->isTxBusy))
;;;394        return;
;;;395    
;;;396      addr = module->regs_base;
;;;397      nMax = (32 - (read32(addr + UART_TFL_REG) & 0x1F));
;;;398      if (nMax > len)
;;;399        nMax = len;
;;;400      for (unsigned i = 0; i < nMax; i++) {
;;;401        write32(addr + UART_THR_REG, pTxData[i]);
;;;402      }
;;;403      module->pTxData = &pTxData[nMax];
;;;404      module->txLength = (len - nMax);
;;;405    
;;;406      CPU_ENTER_CRITICAL();
;;;407      write32(addr + UART_IER_REG, (read32(addr + UART_IER_REG) | (1 << 1)));
;;;408      CPU_EXIT_CRITICAL();
;;;409    }
000618  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.1564|
00061c  e2881018          ADD      r1,r8,#0x18           ;393
000620  e3a00001          MOV      r0,#1                 ;393
000624  ebfffffe          BL       __swap_byte
000628  e3500000          CMP      r0,#0                 ;393
00062c  0a000000          BEQ      |L1.1588|
000630  eafffff8          B        |L1.1560|
                  |L1.1588|
000634  e5985000          LDR      r5,[r8,#0]            ;396
000638  e2850080          ADD      r0,r5,#0x80           ;397
00063c  ebfffffe          BL       read32
000640  e200001f          AND      r0,r0,#0x1f           ;397
000644  e2606020          RSB      r6,r0,#0x20           ;397
000648  e1560004          CMP      r6,r4                 ;398
00064c  9a000000          BLS      |L1.1620|
000650  e1a06004          MOV      r6,r4                 ;399
                  |L1.1620|
000654  e3a0b000          MOV      r11,#0                ;400
000658  ea000003          B        |L1.1644|
                  |L1.1628|
00065c  e7da100b          LDRB     r1,[r10,r11]          ;401
000660  e1a00005          MOV      r0,r5                 ;401
000664  ebfffffe          BL       write32
000668  e28bb001          ADD      r11,r11,#1            ;400
                  |L1.1644|
00066c  e15b0006          CMP      r11,r6                ;400
000670  3afffff9          BCC      |L1.1628|
000674  e08a0006          ADD      r0,r10,r6             ;403
000678  e588001c          STR      r0,[r8,#0x1c]         ;403
00067c  e0440006          SUB      r0,r4,r6              ;404
000680  e5880020          STR      r0,[r8,#0x20]         ;404
000684  e1a00000          MOV      r0,r0                 ;406
000688  ebfffffe          BL       __fast_enter_critical
00068c  e1a07000          MOV      r7,r0                 ;406
000690  e1a00000          MOV      r0,r0                 ;406
000694  e2850004          ADD      r0,r5,#4              ;407
000698  ebfffffe          BL       read32
00069c  e380b002          ORR      r11,r0,#2             ;407
0006a0  e1a0100b          MOV      r1,r11                ;407
0006a4  e2850004          ADD      r0,r5,#4              ;407
0006a8  ebfffffe          BL       write32
0006ac  e1a00000          MOV      r0,r0                 ;408
0006b0  e1a00000          MOV      r0,r0                 ;408
0006b4  e121f007          MSR      CPSR_c,r7             ;408
0006b8  e1a00000          MOV      r0,r0                 ;408
0006bc  e1a00000          MOV      r0,r0                 ;408
0006c0  e1a00000          MOV      r0,r0
0006c4  eaffffd3          B        |L1.1560|
;;;410    
                          ENDP

                  f1c100s_uart_setRxCallback PROC
;;;416    */
;;;417    void f1c100s_uart_setRxCallback(uint8_t mid, void (*pf)(void))
0006c8  e0803100          ADD      r3,r0,r0,LSL #2
;;;418    {
;;;419      UART_MOD_TypeDef* module = &modules[mid];
0006cc  e0833380          ADD      r3,r3,r0,LSL #7
0006d0  e59fc080          LDR      r12,|L1.1880|
0006d4  e08c2183          ADD      r2,r12,r3,LSL #3
;;;420      module->rxCallback = pf;
0006d8  e582100c          STR      r1,[r2,#0xc]
;;;421    }
0006dc  e12fff1e          BX       lr
;;;422    
                          ENDP

                  f1c100s_uart_setTxCallback PROC
;;;428    */
;;;429    void f1c100s_uart_setTxCallback(uint8_t mid, void (*pf)(void))
0006e0  e0803100          ADD      r3,r0,r0,LSL #2
;;;430    {
;;;431      UART_MOD_TypeDef* module = &modules[mid];
0006e4  e0833380          ADD      r3,r3,r0,LSL #7
0006e8  e59fc068          LDR      r12,|L1.1880|
0006ec  e08c2183          ADD      r2,r12,r3,LSL #3
;;;432      module->txEndCallback = pf;
0006f0  e5821008          STR      r1,[r2,#8]
;;;433    }
0006f4  e12fff1e          BX       lr
;;;434    
                          ENDP

                  f1c100s_uart_isTxEnd PROC
;;;440    */
;;;441    bool_t f1c100s_uart_isTxEnd(uint8_t mid)
0006f8  e1a01000          MOV      r1,r0
;;;442    {
;;;443      UART_MOD_TypeDef* module = &modules[mid];
0006fc  e0810101          ADD      r0,r1,r1,LSL #2
000700  e0800381          ADD      r0,r0,r1,LSL #7
000704  e59f304c          LDR      r3,|L1.1880|
000708  e0832180          ADD      r2,r3,r0,LSL #3
;;;444      return !module->isTxBusy;
00070c  e5d20018          LDRB     r0,[r2,#0x18]
000710  e3500000          CMP      r0,#0
000714  1a000001          BNE      |L1.1824|
000718  e3a00001          MOV      r0,#1
                  |L1.1820|
;;;445    }
00071c  e12fff1e          BX       lr
                  |L1.1824|
000720  e3a00000          MOV      r0,#0                 ;444
000724  eafffffc          B        |L1.1820|
;;;446    
                          ENDP

                  __fast_enter_critical PROC
;;;52     #define CPU_ENTER_CRITICAL()  do{cpu_sr = __fast_enter_critical();}while(0)
;;;53     static inline ubase_t __fast_enter_critical(void)
000728  e10f0000          MRS      r0,APSR ; formerly CPSR
;;;54     {
;;;55       ubase_t cpu_sr, tmp_sr;
;;;56       __asm volatile {
;;;57         MRS cpu_sr, CPSR
;;;58         ORR tmp_sr, cpu_sr, #0xC0
00072c  e38010c0          ORR      r1,r0,#0xc0
;;;59         MSR CPSR_c, tmp_sr
000730  e121f001          MSR      CPSR_c,r1
;;;60       }
;;;61       return cpu_sr;
;;;62     }
000734  e12fff1e          BX       lr
;;;63     #endif
                          ENDP

                  __swap_byte PROC
;;;84     
;;;85     static inline uint8_t __swap_byte(uint8_t newval, uint8_t volatile* pmem)
000738  e1a02000          MOV      r2,r0
;;;86     {
;;;87       uint8_t oldval;
;;;88       __asm volatile {
;;;89         SWPB  oldval, newval, [pmem]
00073c  e1410092          SWPB     r0,r2,[r1]
;;;90       };
;;;91       return oldval;
;;;92     }
000740  e12fff1e          BX       lr
;;;93     
                          ENDP

                  read32 PROC
;;;19     
;;;20     static __inline uint32_t read32(uint32_t addr)
000744  e1a01000          MOV      r1,r0
;;;21     {
;;;22       return (*((volatile uint32_t*)(addr)));
000748  e5910000          LDR      r0,[r1,#0]
;;;23     }
00074c  e12fff1e          BX       lr
;;;24     
                          ENDP

                  write32 PROC
;;;39     
;;;40     static __inline void write32(uint32_t addr, uint32_t value)
000750  e5801000          STR      r1,[r0,#0]
;;;41     {
;;;42       *((volatile uint32_t*)(addr)) = value;
;;;43     }
000754  e12fff1e          BX       lr
;;;44     
                          ENDP

                  |L1.1880|
                          DCD      modules
                  |L1.1884|
                          DCD      modules+0x428
                  |L1.1888|
                          DCD      modules+0x850
                  |L1.1892|
                          DCD      0x005f5e10
                  |L1.1896|
                          DCD      0x01c20068
                  |L1.1900|
                          DCD      GPIO_PE
                  |L1.1904|
                          DCD      uart0_irq
                  |L1.1908|
                          DCD      uart1_irq
                  |L1.1912|
                          DCD      uart2_irq

                          AREA ||.data||, DATA, ALIGN=2

                  modules
                          DCD      0x01c25000
                          DCD      uart0_init
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x0001c200
                          DCD      0x00000000
000018  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
000024  00000000          DCW      0x0000,0x0000
                          %        1024
                          DCD      0x01c25400
                          DCD      uart1_init
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x0001c200
                          DCD      0x00000000
000440  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
00044c  00000000          DCW      0x0000,0x0000
                          %        1024
                          DCD      0x01c25800
                          DCD      uart2_init
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x0001c200
                          DCD      0x00000000
000868  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
000874  00000000          DCW      0x0000,0x0000
                          %        1024
