; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave --gnu -o.\temp\obj\f1c100s_clock.o --asm_dir=.\Temp\Lst\ --list_dir=.\Temp\Lst\ --depend=.\temp\obj\f1c100s_clock.d --cpu=ARM9E --apcs=interwork -O0 -Otime --diag_suppress=9931 -I.\users\include -I.\..\machine\include -I.\..\periph\include -I.\..\include -I.\..\emwin\Include -I.\..\tinyusb\src -I.\..\tinyusb\hw -I.\..\display -I.\..\lib\display_gfx -I.\..\lib\printf -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Atmel\SAM9260 -D__RTX -D__UVISION_VERSION=536 -DPCB_TINY200V1 -DCFG_TUSB_MCU=OPT_MCU_F1C100S -DCFG_TUSB_OS=OPT_OS_RTX4 --omf_browse=.\temp\obj\f1c100s_clock.crf ..\periph\f1c100s_clock.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  clk_pll_is_locked PROC
;;;26     // Get PLL lock state
;;;27     uint8_t clk_pll_is_locked(pll_ch_e pll) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
;;;28         uint32_t val = read32(CCU_BASE + pll);
000008  e2840401          ADD      r0,r4,#0x1000000
00000c  e28008c2          ADD      r0,r0,#0xc20000
000010  ebfffffe          BL       read32
000014  e1a05000          MOV      r5,r0
;;;29         return ((val >> 28) & 0x1);
000018  e3a00001          MOV      r0,#1
00001c  e0000e25          AND      r0,r0,r5,LSR #28
;;;30     }
000020  e8bd8070          POP      {r4-r6,pc}
;;;31     
                          ENDP

                  pll_periph_init PROC
;;;180    // out = (24MHz*N) / M
;;;181    static void pll_periph_init(uint8_t mul, uint8_t div) {
000024  e92d4070          PUSH     {r4-r6,lr}
000028  e1a04000          MOV      r4,r0
00002c  e1a05001          MOV      r5,r1
;;;182        if((mul == 0) || (div == 0)) return;
000030  e3540000          CMP      r4,#0
000034  0a000001          BEQ      |L1.64|
000038  e3550000          CMP      r5,#0
00003c  1a000000          BNE      |L1.68|
                  |L1.64|
;;;183        if((mul > 32) || (div > 4)) return;
;;;184    
;;;185        // mul = n
;;;186        // div = m
;;;187    
;;;188        uint32_t val = read32(CCU_BASE + CCU_PLL_PERIPH_CTRL);
;;;189        val &= (0x1U << 31) | (0x1U << 28);
;;;190        val |= ((mul - 1) << 8) | ((div - 1) << 4) | (1 << 18); // do we need 24m output?
;;;191        write32(CCU_BASE + CCU_PLL_PERIPH_CTRL, val);
;;;192    }
000040  e8bd8070          POP      {r4-r6,pc}
                  |L1.68|
000044  e3540020          CMP      r4,#0x20              ;183
000048  ca000001          BGT      |L1.84|
00004c  e3550004          CMP      r5,#4                 ;183
000050  da000000          BLE      |L1.88|
                  |L1.84|
000054  eafffff9          B        |L1.64|
                  |L1.88|
000058  e59f0a58          LDR      r0,|L1.2744|
00005c  ebfffffe          BL       read32
000060  e1a06000          MOV      r6,r0                 ;188
000064  e2066209          AND      r6,r6,#0x90000000     ;189
000068  e2440001          SUB      r0,r4,#1              ;190
00006c  e1a00400          LSL      r0,r0,#8              ;190
000070  e2451001          SUB      r1,r5,#1              ;190
000074  e1800201          ORR      r0,r0,r1,LSL #4       ;190
000078  e3800701          ORR      r0,r0,#0x40000        ;190
00007c  e1866000          ORR      r6,r6,r0              ;190
000080  e1a01006          MOV      r1,r6                 ;191
000084  e59f0a2c          LDR      r0,|L1.2744|
000088  ebfffffe          BL       write32
00008c  e1a00000          MOV      r0,r0
000090  eaffffea          B        |L1.64|
;;;193    
                          ENDP

                  pll_video_init PROC
;;;148    // out = (24MHz*N) / M
;;;149    static void pll_video_init(pll_ch_e pll, uint8_t mul, uint8_t div) {
000094  e92d41f0          PUSH     {r4-r8,lr}
000098  e1a06000          MOV      r6,r0
00009c  e1a04001          MOV      r4,r1
0000a0  e1a05002          MOV      r5,r2
;;;150        if((mul == 0) || (div == 0)) return;
0000a4  e3540000          CMP      r4,#0
0000a8  0a000001          BEQ      |L1.180|
0000ac  e3550000          CMP      r5,#0
0000b0  1a000000          BNE      |L1.184|
                  |L1.180|
;;;151        if((mul > 128) || (div > 16)) return;
;;;152    
;;;153        // mul = n
;;;154        // div = m
;;;155    
;;;156        uint32_t val = read32(CCU_BASE + pll);
;;;157        val &= (0x1U << 31) | (0x1U << 28);
;;;158        val |= ((mul - 1) << 8) | (div - 1) | (1 << 24);
;;;159        write32(CCU_BASE + pll, val);
;;;160    }
0000b4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.184|
0000b8  e3540080          CMP      r4,#0x80              ;151
0000bc  ca000001          BGT      |L1.200|
0000c0  e3550010          CMP      r5,#0x10              ;151
0000c4  da000000          BLE      |L1.204|
                  |L1.200|
0000c8  eafffff9          B        |L1.180|
                  |L1.204|
0000cc  e2860401          ADD      r0,r6,#0x1000000      ;156
0000d0  e28008c2          ADD      r0,r0,#0xc20000       ;156
0000d4  ebfffffe          BL       read32
0000d8  e1a07000          MOV      r7,r0                 ;156
0000dc  e2077209          AND      r7,r7,#0x90000000     ;157
0000e0  e2450001          SUB      r0,r5,#1              ;158
0000e4  e2441001          SUB      r1,r4,#1              ;158
0000e8  e1800401          ORR      r0,r0,r1,LSL #8       ;158
0000ec  e3800401          ORR      r0,r0,#0x1000000      ;158
0000f0  e1877000          ORR      r7,r7,r0              ;158
0000f4  e2860401          ADD      r0,r6,#0x1000000      ;159
0000f8  e28008c2          ADD      r0,r0,#0xc20000       ;159
0000fc  e1a01007          MOV      r1,r7                 ;159
000100  ebfffffe          BL       write32
000104  e1a00000          MOV      r0,r0
000108  eaffffe9          B        |L1.180|
;;;161    
                          ENDP

                  pll_audio_init PROC
;;;122    // out = (24MHz*N*2) / M
;;;123    static void pll_audio_init(uint16_t mul, uint8_t div) {
00010c  e92d41f0          PUSH     {r4-r8,lr}
000110  e1a04000          MOV      r4,r0
000114  e1a05001          MOV      r5,r1
;;;124        if((mul == 0) || (div == 0)) return;
000118  e3540000          CMP      r4,#0
00011c  0a000001          BEQ      |L1.296|
000120  e3550000          CMP      r5,#0
000124  1a000000          BNE      |L1.300|
                  |L1.296|
;;;125        if((mul > 256) || (div > 32)) return;
;;;126    
;;;127        uint8_t n = (uint8_t)(mul / 2); // mul = n*2
;;;128        // div = m
;;;129    
;;;130        uint32_t val = read32(CCU_BASE + CCU_PLL_AUDIO_CTRL);
;;;131        val &= (0x1U << 31) | (0x1U << 28);
;;;132        val |= ((n - 1) << 8) | (div - 1);
;;;133        write32(CCU_BASE + CCU_PLL_AUDIO_CTRL, val);
;;;134    }
000128  e8bd81f0          POP      {r4-r8,pc}
                  |L1.300|
00012c  e3540c01          CMP      r4,#0x100             ;125
000130  ca000001          BGT      |L1.316|
000134  e3550020          CMP      r5,#0x20              ;125
000138  da000000          BLE      |L1.320|
                  |L1.316|
00013c  eafffff9          B        |L1.296|
                  |L1.320|
000140  e1a00004          MOV      r0,r4                 ;127
000144  e0841fa0          ADD      r1,r4,r0,LSR #31      ;127
000148  e1a01b81          LSL      r1,r1,#23             ;127
00014c  e1a07c21          LSR      r7,r1,#24             ;127
000150  e59f0964          LDR      r0,|L1.2748|
000154  ebfffffe          BL       read32
000158  e1a06000          MOV      r6,r0                 ;130
00015c  e2066209          AND      r6,r6,#0x90000000     ;131
000160  e2450001          SUB      r0,r5,#1              ;132
000164  e2471001          SUB      r1,r7,#1              ;132
000168  e1800401          ORR      r0,r0,r1,LSL #8       ;132
00016c  e1866000          ORR      r6,r6,r0              ;132
000170  e1a01006          MOV      r1,r6                 ;133
000174  e59f0940          LDR      r0,|L1.2748|
000178  ebfffffe          BL       write32
00017c  e1a00000          MOV      r0,r0
000180  eaffffe8          B        |L1.296|
;;;135    
                          ENDP

                  pll_cpu_init PROC
;;;77     // out = (24MHz*N*K) / (M*P)
;;;78     static void pll_cpu_init(uint8_t mul, uint8_t div) {
000184  e92d47f0          PUSH     {r4-r10,lr}
000188  e1a08000          MOV      r8,r0
00018c  e1a07001          MOV      r7,r1
;;;79         if((mul == 0) || (div == 0)) return;
000190  e3580000          CMP      r8,#0
000194  0a000001          BEQ      |L1.416|
000198  e3570000          CMP      r7,#0
00019c  1a000000          BNE      |L1.420|
                  |L1.416|
;;;80         if((mul > 128) || (div > 16)) return;
;;;81     
;;;82         uint8_t n, k, m, p;
;;;83         // mul = n*k
;;;84         // n = 1..32
;;;85         // k = 1..4
;;;86         for(k = 1; k <= 4; k++) {
;;;87             n = mul / k;
;;;88             if((n < 32) && (n * k == mul)) break;
;;;89         }
;;;90         if(n * k != mul) return;
;;;91         // div = m*p
;;;92         // m = 1..4
;;;93         // k = 1,2,4
;;;94         for(m = 1; m <= 4; m++) {
;;;95             p = div / m;
;;;96             if(((p == 1) || (p == 2) || (p == 4)) && (m * p == div)) break;
;;;97         }
;;;98         if(m * p != div) return;
;;;99     
;;;100        p--;
;;;101        if(p == 3) p = 2;
;;;102    
;;;103        uint32_t val = read32(CCU_BASE + CCU_PLL_CPU_CTRL);
;;;104        val &= (0x1U << 31) | (0x1U << 28);
;;;105        val |= ((n - 1) << 8) | ((k - 1) << 4) | (m - 1) | (p << 16);
;;;106        write32(CCU_BASE + CCU_PLL_CPU_CTRL, val);
;;;107    }
0001a0  e8bd87f0          POP      {r4-r10,pc}
                  |L1.420|
0001a4  e3580080          CMP      r8,#0x80              ;80
0001a8  ca000001          BGT      |L1.436|
0001ac  e3570010          CMP      r7,#0x10              ;80
0001b0  da000000          BLE      |L1.440|
                  |L1.436|
0001b4  eafffff9          B        |L1.416|
                  |L1.440|
0001b8  e3a05001          MOV      r5,#1                 ;86
0001bc  ea00000b          B        |L1.496|
                  |L1.448|
0001c0  e1a01005          MOV      r1,r5                 ;87
0001c4  e1a00008          MOV      r0,r8                 ;87
0001c8  ebfffffe          BL       __aeabi_idivmod
0001cc  e20090ff          AND      r9,r0,#0xff           ;87
0001d0  e3590020          CMP      r9,#0x20              ;88
0001d4  aa000003          BGE      |L1.488|
0001d8  e0000599          MUL      r0,r9,r5              ;88
0001dc  e1500008          CMP      r0,r8                 ;88
0001e0  1a000000          BNE      |L1.488|
0001e4  ea000003          B        |L1.504|
                  |L1.488|
0001e8  e2850001          ADD      r0,r5,#1              ;86
0001ec  e20050ff          AND      r5,r0,#0xff           ;86
                  |L1.496|
0001f0  e3550004          CMP      r5,#4                 ;86
0001f4  dafffff1          BLE      |L1.448|
                  |L1.504|
0001f8  e1a00000          MOV      r0,r0                 ;88
0001fc  e0000599          MUL      r0,r9,r5              ;90
000200  e1500008          CMP      r0,r8                 ;90
000204  0a000000          BEQ      |L1.524|
000208  eaffffe4          B        |L1.416|
                  |L1.524|
00020c  e3a06001          MOV      r6,#1                 ;94
000210  ea00000f          B        |L1.596|
                  |L1.532|
000214  e1a01006          MOV      r1,r6                 ;95
000218  e1a00007          MOV      r0,r7                 ;95
00021c  ebfffffe          BL       __aeabi_idivmod
000220  e20040ff          AND      r4,r0,#0xff           ;95
000224  e3540001          CMP      r4,#1                 ;96
000228  0a000003          BEQ      |L1.572|
00022c  e3540002          CMP      r4,#2                 ;96
000230  0a000001          BEQ      |L1.572|
000234  e3540004          CMP      r4,#4                 ;96
000238  1a000003          BNE      |L1.588|
                  |L1.572|
00023c  e0000496          MUL      r0,r6,r4              ;96
000240  e1500007          CMP      r0,r7                 ;96
000244  1a000000          BNE      |L1.588|
000248  ea000003          B        |L1.604|
                  |L1.588|
00024c  e2860001          ADD      r0,r6,#1              ;94
000250  e20060ff          AND      r6,r0,#0xff           ;94
                  |L1.596|
000254  e3560004          CMP      r6,#4                 ;94
000258  daffffed          BLE      |L1.532|
                  |L1.604|
00025c  e1a00000          MOV      r0,r0                 ;96
000260  e0000496          MUL      r0,r6,r4              ;98
000264  e1500007          CMP      r0,r7                 ;98
000268  0a000000          BEQ      |L1.624|
00026c  eaffffcb          B        |L1.416|
                  |L1.624|
000270  e2440001          SUB      r0,r4,#1              ;100
000274  e20040ff          AND      r4,r0,#0xff           ;100
000278  e3540003          CMP      r4,#3                 ;101
00027c  1a000000          BNE      |L1.644|
000280  e3a04002          MOV      r4,#2                 ;101
                  |L1.644|
000284  e59f0834          LDR      r0,|L1.2752|
000288  ebfffffe          BL       read32
00028c  e1a0a000          MOV      r10,r0                ;103
000290  e20aa209          AND      r10,r10,#0x90000000   ;104
000294  e2490001          SUB      r0,r9,#1              ;105
000298  e1a00400          LSL      r0,r0,#8              ;105
00029c  e2451001          SUB      r1,r5,#1              ;105
0002a0  e1800201          ORR      r0,r0,r1,LSL #4       ;105
0002a4  e2461001          SUB      r1,r6,#1              ;105
0002a8  e1800001          ORR      r0,r0,r1              ;105
0002ac  e1800804          ORR      r0,r0,r4,LSL #16      ;105
0002b0  e18aa000          ORR      r10,r10,r0            ;105
0002b4  e1a0100a          MOV      r1,r10                ;106
0002b8  e59f0800          LDR      r0,|L1.2752|
0002bc  ebfffffe          BL       write32
0002c0  e1a00000          MOV      r0,r0
0002c4  eaffffb5          B        |L1.416|
;;;108    
                          ENDP

                  clk_pll_init PROC
;;;33     // out = 24MHz * mul / div
;;;34     void clk_pll_init(pll_ch_e pll, uint8_t mul, uint8_t div) {
0002c8  e92d4070          PUSH     {r4-r6,lr}
0002cc  e1a06000          MOV      r6,r0
0002d0  e1a04001          MOV      r4,r1
0002d4  e1a05002          MOV      r5,r2
;;;35         switch(pll) {
0002d8  e3560018          CMP      r6,#0x18
0002dc  0a000018          BEQ      |L1.836|
0002e0  ca000006          BGT      |L1.768|
0002e4  e3560000          CMP      r6,#0
0002e8  0a000009          BEQ      |L1.788|
0002ec  e3560008          CMP      r6,#8
0002f0  0a00000c          BEQ      |L1.808|
0002f4  e3560010          CMP      r6,#0x10
0002f8  1a00001d          BNE      |L1.884|
0002fc  ea00000e          B        |L1.828|
                  |L1.768|
000300  e3560020          CMP      r6,#0x20
000304  0a000013          BEQ      |L1.856|
000308  e3560028          CMP      r6,#0x28
00030c  1a000018          BNE      |L1.884|
000310  ea000012          B        |L1.864|
                  |L1.788|
;;;36         case PLL_CPU:
000314  e1a00000          MOV      r0,r0
;;;37             pll_cpu_init(mul, div);
000318  e1a01005          MOV      r1,r5
00031c  e1a00004          MOV      r0,r4
000320  ebfffffe          BL       pll_cpu_init
;;;38             break;
000324  ea000014          B        |L1.892|
                  |L1.808|
;;;39         case PLL_AUDIO:
000328  e1a00000          MOV      r0,r0
;;;40             pll_audio_init(mul, div);
00032c  e1a01005          MOV      r1,r5
000330  e1a00004          MOV      r0,r4
000334  ebfffffe          BL       pll_audio_init
;;;41             break;
000338  ea00000f          B        |L1.892|
                  |L1.828|
;;;42         case PLL_VIDEO:
00033c  e1a00000          MOV      r0,r0
;;;43         case PLL_VE:
000340  e1a00000          MOV      r0,r0
                  |L1.836|
;;;44             pll_video_init(pll, mul, div);
000344  e1a02005          MOV      r2,r5
000348  e1a01004          MOV      r1,r4
00034c  e1a00006          MOV      r0,r6
000350  ebfffffe          BL       pll_video_init
;;;45             break;
000354  ea000008          B        |L1.892|
                  |L1.856|
;;;46         case PLL_DDR:
000358  e1a00000          MOV      r0,r0
;;;47             break; // TODO:
00035c  ea000006          B        |L1.892|
                  |L1.864|
;;;48         case PLL_PERIPH:
000360  e1a00000          MOV      r0,r0
;;;49             pll_periph_init(mul, div);
000364  e1a01005          MOV      r1,r5
000368  e1a00004          MOV      r0,r4
00036c  ebfffffe          BL       pll_periph_init
;;;50             break;
000370  ea000001          B        |L1.892|
                  |L1.884|
;;;51         default:
000374  e1a00000          MOV      r0,r0
;;;52             break;
000378  e1a00000          MOV      r0,r0
                  |L1.892|
00037c  e1a00000          MOV      r0,r0                 ;38
;;;53         }
;;;54     }
000380  e8bd8070          POP      {r4-r6,pc}
;;;55     
                          ENDP

                  pll_periph_get_freq PROC
;;;193    
;;;194    static uint32_t pll_periph_get_freq(void) {
000384  e92d4070          PUSH     {r4-r6,lr}
;;;195        uint32_t reg = read32(CCU_BASE + CCU_PLL_PERIPH_CTRL);
000388  e59f0728          LDR      r0,|L1.2744|
00038c  ebfffffe          BL       read32
000390  e1a04000          MOV      r4,r0
;;;196    
;;;197        uint32_t mul = (reg >> 8) & 0x1F;
000394  e3a0001f          MOV      r0,#0x1f
000398  e0005424          AND      r5,r0,r4,LSR #8
;;;198        uint32_t div = (reg >> 4) & 0x3;
00039c  e3a00003          MOV      r0,#3
0003a0  e0006224          AND      r6,r0,r4,LSR #4
;;;199    
;;;200        return (24000000 * (mul + 1) / (div + 1));
0003a4  e2851001          ADD      r1,r5,#1
0003a8  e59f2714          LDR      r2,|L1.2756|
0003ac  e0000291          MUL      r0,r1,r2
0003b0  e2861001          ADD      r1,r6,#1
0003b4  ebfffffe          BL       __aeabi_uidivmod
;;;201    }
0003b8  e8bd8070          POP      {r4-r6,pc}
;;;202    
                          ENDP

                  pll_ddr_get_freq PROC
;;;203    static uint32_t pll_ddr_get_freq(void) {
0003bc  e92d41f0          PUSH     {r4-r8,lr}
;;;204        uint32_t reg = read32(CCU_BASE + CCU_PLL_DDR_CTRL);
0003c0  e59f0700          LDR      r0,|L1.2760|
0003c4  ebfffffe          BL       read32
0003c8  e1a04000          MOV      r4,r0
;;;205    
;;;206        uint32_t n = (reg >> 8) & 0x1F;
0003cc  e3a0001f          MOV      r0,#0x1f
0003d0  e0005424          AND      r5,r0,r4,LSR #8
;;;207        uint32_t k = (reg >> 4) & 0x3;
0003d4  e3a00003          MOV      r0,#3
0003d8  e0006224          AND      r6,r0,r4,LSR #4
;;;208        uint32_t m = (reg >> 0) & 0x3;
0003dc  e2047003          AND      r7,r4,#3
;;;209    
;;;210        return (24000000 * (n + 1) * (k + 1) / (m + 1));
0003e0  e2851001          ADD      r1,r5,#1
0003e4  e59f26d8          LDR      r2,|L1.2756|
0003e8  e0010192          MUL      r1,r2,r1
0003ec  e2862001          ADD      r2,r6,#1
0003f0  e0000291          MUL      r0,r1,r2
0003f4  e2871001          ADD      r1,r7,#1
0003f8  ebfffffe          BL       __aeabi_uidivmod
;;;211    }
0003fc  e8bd81f0          POP      {r4-r8,pc}
;;;212    
                          ENDP

                  pll_video_get_freq PROC
;;;161    
;;;162    static uint32_t pll_video_get_freq(pll_ch_e pll) {
000400  e92d41f0          PUSH     {r4-r8,lr}
000404  e1a05000          MOV      r5,r0
;;;163        uint32_t reg = read32(CCU_BASE + pll);
000408  e2850401          ADD      r0,r5,#0x1000000
00040c  e28008c2          ADD      r0,r0,#0xc20000
000410  ebfffffe          BL       read32
000414  e1a04000          MOV      r4,r0
;;;164    
;;;165        if((reg & (0x1U << 24)) == 0) {
000418  e2040401          AND      r0,r4,#0x1000000
00041c  e3500000          CMP      r0,#0
000420  1a000006          BNE      |L1.1088|
;;;166            // Fractional mode
;;;167            if(reg & (0x1U << 25))
000424  e2040402          AND      r0,r4,#0x2000000
000428  e3500000          CMP      r0,#0
00042c  0a000001          BEQ      |L1.1080|
;;;168                return 297000000;
000430  e59f0694          LDR      r0,|L1.2764|
                  |L1.1076|
;;;169            else
;;;170                return 270000000;
;;;171        } else {
;;;172            // Integer mode
;;;173            uint32_t mul = (reg >> 8) & 0x7F;
;;;174            uint32_t div = (reg >> 0) & 0xF;
;;;175    
;;;176            return (24000000 * (mul + 1) / (div + 1));
;;;177        }
;;;178    }
000434  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1080|
000438  e59f0690          LDR      r0,|L1.2768|
00043c  eafffffc          B        |L1.1076|
                  |L1.1088|
000440  e3a0007f          MOV      r0,#0x7f              ;173
000444  e0006424          AND      r6,r0,r4,LSR #8       ;173
000448  e204700f          AND      r7,r4,#0xf            ;174
00044c  e2861001          ADD      r1,r6,#1              ;176
000450  e59f266c          LDR      r2,|L1.2756|
000454  e0000291          MUL      r0,r1,r2              ;176
000458  e2871001          ADD      r1,r7,#1              ;176
00045c  ebfffffe          BL       __aeabi_uidivmod
000460  eafffff3          B        |L1.1076|
;;;179    
                          ENDP

                  pll_audio_get_freq PROC
;;;135    
;;;136    static uint32_t pll_audio_get_freq(void) {
000464  e92d4070          PUSH     {r4-r6,lr}
;;;137        uint32_t reg = read32(CCU_BASE + CCU_PLL_AUDIO_CTRL);
000468  e59f064c          LDR      r0,|L1.2748|
00046c  ebfffffe          BL       read32
000470  e1a04000          MOV      r4,r0
;;;138    
;;;139        uint32_t mul = (reg >> 8) & 0x7F;
000474  e3a0007f          MOV      r0,#0x7f
000478  e0005424          AND      r5,r0,r4,LSR #8
;;;140        uint32_t div = (reg >> 0) & 0x1F;
00047c  e204601f          AND      r6,r4,#0x1f
;;;141    
;;;142        if(reg & (1 << 24)) // SDM
000480  e2040401          AND      r0,r4,#0x1000000
000484  e3500000          CMP      r0,#0
000488  0a000000          BEQ      |L1.1168|
;;;143            mul &= 0xF;
00048c  e205500f          AND      r5,r5,#0xf
                  |L1.1168|
;;;144    
;;;145        return (24000000 * 2 * (mul + 1) / (div + 1));
000490  e2851001          ADD      r1,r5,#1
000494  e59f2638          LDR      r2,|L1.2772|
000498  e0000291          MUL      r0,r1,r2
00049c  e2861001          ADD      r1,r6,#1
0004a0  ebfffffe          BL       __aeabi_uidivmod
;;;146    }
0004a4  e8bd8070          POP      {r4-r6,pc}
;;;147    
                          ENDP

                  pll_cpu_get_freq PROC
;;;108    
;;;109    static uint32_t pll_cpu_get_freq(void) {
0004a8  e92d41f0          PUSH     {r4-r8,lr}
;;;110        uint32_t reg = read32(CCU_BASE + CCU_PLL_CPU_CTRL);
0004ac  e59f060c          LDR      r0,|L1.2752|
0004b0  ebfffffe          BL       read32
0004b4  e1a04000          MOV      r4,r0
;;;111    
;;;112        uint32_t n = (reg >> 8) & 0x1F;
0004b8  e3a0001f          MOV      r0,#0x1f
0004bc  e0006424          AND      r6,r0,r4,LSR #8
;;;113        uint32_t k = (reg >> 4) & 0x3;
0004c0  e3a00003          MOV      r0,#3
0004c4  e0007224          AND      r7,r0,r4,LSR #4
;;;114        uint32_t m = (reg >> 0) & 0x3;
0004c8  e2048003          AND      r8,r4,#3
;;;115        uint32_t p = (reg >> 16) & 0x3;
0004cc  e0005824          AND      r5,r0,r4,LSR #16
;;;116    
;;;117        p = (1 << p);
0004d0  e3a00001          MOV      r0,#1
0004d4  e1a05510          LSL      r5,r0,r5
;;;118    
;;;119        return (24000000 * (n + 1) * (k + 1) / ((m + 1) * p));
0004d8  e2882001          ADD      r2,r8,#1
0004dc  e0010592          MUL      r1,r2,r5
0004e0  e2862001          ADD      r2,r6,#1
0004e4  e59f35d8          LDR      r3,|L1.2756|
0004e8  e0020293          MUL      r2,r3,r2
0004ec  e2873001          ADD      r3,r7,#1
0004f0  e0000392          MUL      r0,r2,r3
0004f4  ebfffffe          BL       __aeabi_uidivmod
;;;120    }
0004f8  e8bd81f0          POP      {r4-r8,pc}
;;;121    
                          ENDP

                  clk_pll_get_freq PROC
;;;55     
;;;56     uint32_t clk_pll_get_freq(pll_ch_e pll) {
0004fc  e92d4010          PUSH     {r4,lr}
000500  e1a04000          MOV      r4,r0
;;;57         if(!clk_pll_is_locked(pll)) return 0;
000504  e1a00004          MOV      r0,r4
000508  ebfffffe          BL       clk_pll_is_locked
00050c  e3500000          CMP      r0,#0
000510  1a000001          BNE      |L1.1308|
000514  e3a00000          MOV      r0,#0
                  |L1.1304|
;;;58     
;;;59         switch(pll) {
;;;60         case PLL_CPU:
;;;61             return pll_cpu_get_freq();
;;;62         case PLL_AUDIO:
;;;63             return pll_audio_get_freq();
;;;64         case PLL_VIDEO:
;;;65         case PLL_VE:
;;;66             return pll_video_get_freq(pll);
;;;67         case PLL_DDR:
;;;68             return pll_ddr_get_freq();
;;;69         case PLL_PERIPH:
;;;70             return pll_periph_get_freq();
;;;71         default:
;;;72             break;
;;;73         }
;;;74         return 0;
;;;75     }
000518  e8bd8010          POP      {r4,pc}
                  |L1.1308|
00051c  e3540018          CMP      r4,#0x18              ;59
000520  0a000014          BEQ      |L1.1400|
000524  ca000006          BGT      |L1.1348|
000528  e3540000          CMP      r4,#0                 ;59
00052c  0a000009          BEQ      |L1.1368|
000530  e3540008          CMP      r4,#8                 ;59
000534  0a00000a          BEQ      |L1.1380|
000538  e3540010          CMP      r4,#0x10              ;59
00053c  1a000016          BNE      |L1.1436|
000540  ea00000a          B        |L1.1392|
                  |L1.1348|
000544  e3540020          CMP      r4,#0x20              ;59
000548  0a00000d          BEQ      |L1.1412|
00054c  e3540028          CMP      r4,#0x28              ;59
000550  1a000011          BNE      |L1.1436|
000554  ea00000d          B        |L1.1424|
                  |L1.1368|
000558  e1a00000          MOV      r0,r0                 ;60
00055c  ebfffffe          BL       pll_cpu_get_freq
000560  eaffffec          B        |L1.1304|
                  |L1.1380|
000564  e1a00000          MOV      r0,r0                 ;62
000568  ebfffffe          BL       pll_audio_get_freq
00056c  eaffffe9          B        |L1.1304|
                  |L1.1392|
000570  e1a00000          MOV      r0,r0                 ;64
000574  e1a00000          MOV      r0,r0                 ;65
                  |L1.1400|
000578  e1a00004          MOV      r0,r4                 ;66
00057c  ebfffffe          BL       pll_video_get_freq
000580  eaffffe4          B        |L1.1304|
                  |L1.1412|
000584  e1a00000          MOV      r0,r0                 ;67
000588  ebfffffe          BL       pll_ddr_get_freq
00058c  eaffffe1          B        |L1.1304|
                  |L1.1424|
000590  e1a00000          MOV      r0,r0                 ;69
000594  ebfffffe          BL       pll_periph_get_freq
000598  eaffffde          B        |L1.1304|
                  |L1.1436|
00059c  e1a00000          MOV      r0,r0                 ;71
0005a0  e1a00000          MOV      r0,r0                 ;72
0005a4  e1a00000          MOV      r0,r0                 ;72
0005a8  e3a00000          MOV      r0,#0                 ;74
0005ac  eaffffd9          B        |L1.1304|
;;;76     
                          ENDP

                  clk_cpu_config PROC
;;;225    // CPU clock configuration
;;;226    void clk_cpu_config(clk_source_cpu_e source) {
0005b0  e92d4070          PUSH     {r4-r6,lr}
0005b4  e1a04000          MOV      r4,r0
;;;227        uint32_t reg = read32(CCU_BASE + CCU_CPU_CFG) & ~(0x3 << 16);
0005b8  e59f0518          LDR      r0,|L1.2776|
0005bc  ebfffffe          BL       read32
0005c0  e3c05803          BIC      r5,r0,#0x30000
;;;228        write32(CCU_BASE + CCU_CPU_CFG, reg | (source << 16));
0005c4  e1851804          ORR      r1,r5,r4,LSL #16
0005c8  e59f0508          LDR      r0,|L1.2776|
0005cc  ebfffffe          BL       write32
;;;229    }
0005d0  e8bd8070          POP      {r4-r6,pc}
;;;230    
                          ENDP

                  clk_cpu_get_freq PROC
;;;231    uint32_t clk_cpu_get_freq(void) {
0005d4  e92d4010          PUSH     {r4,lr}
;;;232        clk_source_cpu_e src = (clk_source_cpu_e)((read32(CCU_BASE + CCU_CPU_CFG) >> 16) & 0x3);
0005d8  e59f04f8          LDR      r0,|L1.2776|
0005dc  ebfffffe          BL       read32
0005e0  e3a01003          MOV      r1,#3
0005e4  e0014820          AND      r4,r1,r0,LSR #16
;;;233    
;;;234        switch(src) {
0005e8  e3540000          CMP      r4,#0
0005ec  0a000004          BEQ      |L1.1540|
0005f0  e3540001          CMP      r4,#1
0005f4  0a000005          BEQ      |L1.1552|
0005f8  e3540002          CMP      r4,#2
0005fc  1a00000a          BNE      |L1.1580|
000600  ea000005          B        |L1.1564|
                  |L1.1540|
;;;235        case CLK_CPU_SRC_LOSC:
000604  e1a00000          MOV      r0,r0
;;;236            return 32000; // ??
000608  e3a00c7d          MOV      r0,#0x7d00
                  |L1.1548|
;;;237        case CLK_CPU_SRC_OSC24M:
;;;238            return 24000000;
;;;239        case CLK_CPU_SRC_PLL_CPU:
;;;240            return clk_pll_get_freq(PLL_CPU);
;;;241        default:
;;;242            return 0;
;;;243        }
;;;244    }
00060c  e8bd8010          POP      {r4,pc}
                  |L1.1552|
000610  e1a00000          MOV      r0,r0                 ;237
000614  e59f04a8          LDR      r0,|L1.2756|
000618  eafffffb          B        |L1.1548|
                  |L1.1564|
00061c  e1a00000          MOV      r0,r0                 ;239
000620  e3a00000          MOV      r0,#0                 ;240
000624  ebfffffe          BL       clk_pll_get_freq
000628  eafffff7          B        |L1.1548|
                  |L1.1580|
00062c  e1a00000          MOV      r0,r0                 ;241
000630  e3a00000          MOV      r0,#0                 ;242
000634  eafffff4          B        |L1.1548|
;;;245    
                          ENDP

                  clk_hclk_config PROC
;;;246    // HCLK = CPUCLK / div
;;;247    void clk_hclk_config(uint8_t div) {
000638  e92d4070          PUSH     {r4-r6,lr}
00063c  e1a04000          MOV      r4,r0
;;;248        if((div == 0) || (div > 4)) return;
000640  e3540000          CMP      r4,#0
000644  0a000001          BEQ      |L1.1616|
000648  e3540004          CMP      r4,#4
00064c  da000000          BLE      |L1.1620|
                  |L1.1616|
;;;249    
;;;250        uint32_t val = read32(CCU_BASE + CCU_AHB_APB_CFG) & ~(0x3 << 16);
;;;251        write32(CCU_BASE + CCU_AHB_APB_CFG, val | ((div - 1) << 16));
;;;252    }
000650  e8bd8070          POP      {r4-r6,pc}
                  |L1.1620|
000654  e59f0480          LDR      r0,|L1.2780|
000658  ebfffffe          BL       read32
00065c  e3c05803          BIC      r5,r0,#0x30000        ;250
000660  e2440001          SUB      r0,r4,#1              ;251
000664  e1851800          ORR      r1,r5,r0,LSL #16      ;251
000668  e59f046c          LDR      r0,|L1.2780|
00066c  ebfffffe          BL       write32
000670  e1a00000          MOV      r0,r0
000674  eafffff5          B        |L1.1616|
;;;253    
                          ENDP

                  clk_hclk_get_freq PROC
;;;254    uint32_t clk_hclk_get_freq(void) {
000678  e92d4070          PUSH     {r4-r6,lr}
;;;255        uint8_t div = (read32(CCU_BASE + CCU_AHB_APB_CFG) >> 16) & 0x3;
00067c  e59f0458          LDR      r0,|L1.2780|
000680  ebfffffe          BL       read32
000684  e3a01003          MOV      r1,#3
000688  e0014820          AND      r4,r1,r0,LSR #16
;;;256    
;;;257        return (clk_cpu_get_freq() / (div + 1));
00068c  ebfffffe          BL       clk_cpu_get_freq
000690  e1a05000          MOV      r5,r0
000694  e2841001          ADD      r1,r4,#1
000698  ebfffffe          BL       __aeabi_uidivmod
;;;258    }
00069c  e8bd8070          POP      {r4-r6,pc}
;;;259    
                          ENDP

                  clk_ahb_config PROC
;;;260    // AHB = (src or src/prediv)/div
;;;261    void clk_ahb_config(clk_source_ahb_e src, uint8_t prediv, uint8_t div) {
0006a0  e92d41f0          PUSH     {r4-r8,lr}
0006a4  e1a06000          MOV      r6,r0
0006a8  e1a05001          MOV      r5,r1
0006ac  e1a04002          MOV      r4,r2
;;;262        if((prediv == 0) || (prediv > 4)) return;
0006b0  e3550000          CMP      r5,#0
0006b4  0a000001          BEQ      |L1.1728|
0006b8  e3550004          CMP      r5,#4
0006bc  da000000          BLE      |L1.1732|
                  |L1.1728|
;;;263        if((div == 0) || ((div > 4) && (div != 8)) || (div == 3)) return;
;;;264        if(div == 4) div = 3;
;;;265        if(div == 8) div = 4;
;;;266    
;;;267        uint32_t val = read32(CCU_BASE + CCU_AHB_APB_CFG) & ~((0x3 << 12) | (0xF << 4));
;;;268        write32(
;;;269            CCU_BASE + CCU_AHB_APB_CFG, val | (src << 12) | ((prediv - 1) << 6) | ((div - 1) << 4));
;;;270    }
0006c0  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1732|
0006c4  e3540000          CMP      r4,#0                 ;263
0006c8  0a000005          BEQ      |L1.1764|
0006cc  e3540004          CMP      r4,#4                 ;263
0006d0  da000001          BLE      |L1.1756|
0006d4  e3540008          CMP      r4,#8                 ;263
0006d8  1a000001          BNE      |L1.1764|
                  |L1.1756|
0006dc  e3540003          CMP      r4,#3                 ;263
0006e0  1a000000          BNE      |L1.1768|
                  |L1.1764|
0006e4  eafffff5          B        |L1.1728|
                  |L1.1768|
0006e8  e3540004          CMP      r4,#4                 ;264
0006ec  1a000000          BNE      |L1.1780|
0006f0  e3a04003          MOV      r4,#3                 ;264
                  |L1.1780|
0006f4  e3540008          CMP      r4,#8                 ;265
0006f8  1a000000          BNE      |L1.1792|
0006fc  e3a04004          MOV      r4,#4                 ;265
                  |L1.1792|
000700  e59f03d4          LDR      r0,|L1.2780|
000704  ebfffffe          BL       read32
000708  e3c07a03          BIC      r7,r0,#0x3000         ;267
00070c  e3c770f0          BIC      r7,r7,#0xf0           ;267
000710  e1870606          ORR      r0,r7,r6,LSL #12      ;268
000714  e2452001          SUB      r2,r5,#1              ;268
000718  e1800302          ORR      r0,r0,r2,LSL #6       ;268
00071c  e2442001          SUB      r2,r4,#1              ;268
000720  e1801202          ORR      r1,r0,r2,LSL #4       ;268
000724  e59f03b0          LDR      r0,|L1.2780|
000728  ebfffffe          BL       write32
00072c  e1a00000          MOV      r0,r0
000730  eaffffe2          B        |L1.1728|
;;;271    
                          ENDP

                  clk_ahb_get_freq PROC
;;;272    uint32_t clk_ahb_get_freq(void) {
000734  e92d41f0          PUSH     {r4-r8,lr}
;;;273        clk_source_ahb_e src = ( clk_source_ahb_e)((read32(CCU_BASE + CCU_AHB_APB_CFG) >> 12) & 0x3);
000738  e59f039c          LDR      r0,|L1.2780|
00073c  ebfffffe          BL       read32
000740  e3a01003          MOV      r1,#3
000744  e0015620          AND      r5,r1,r0,LSR #12
;;;274    
;;;275        uint8_t div    = (read32(CCU_BASE + CCU_AHB_APB_CFG) >> 4) & 0x3;
000748  e59f038c          LDR      r0,|L1.2780|
00074c  ebfffffe          BL       read32
000750  e3a01003          MOV      r1,#3
000754  e0014220          AND      r4,r1,r0,LSR #4
;;;276        uint8_t prediv = (read32(CCU_BASE + CCU_AHB_APB_CFG) >> 6) & 0x3;
000758  e59f037c          LDR      r0,|L1.2780|
00075c  ebfffffe          BL       read32
000760  e3a01003          MOV      r1,#3
000764  e0016320          AND      r6,r1,r0,LSR #6
;;;277    
;;;278        div = (1 << div);
000768  e3a00001          MOV      r0,#1
00076c  e1a00410          LSL      r0,r0,r4
000770  e20040ff          AND      r4,r0,#0xff
;;;279    
;;;280        switch(src) {
000774  e3550000          CMP      r5,#0
000778  0a000006          BEQ      |L1.1944|
00077c  e3550001          CMP      r5,#1
000780  0a000009          BEQ      |L1.1964|
000784  e3550002          CMP      r5,#2
000788  0a00000c          BEQ      |L1.1984|
00078c  e3550003          CMP      r5,#3
000790  1a00001a          BNE      |L1.2048|
000794  ea00000f          B        |L1.2008|
                  |L1.1944|
;;;281        case CLK_AHB_SRC_LOSC:
000798  e1a00000          MOV      r0,r0
;;;282            return (32000 / div);
00079c  e1a01004          MOV      r1,r4
0007a0  e3a00c7d          MOV      r0,#0x7d00
0007a4  ebfffffe          BL       __aeabi_idivmod
                  |L1.1960|
;;;283        case CLK_AHB_SRC_OSC24M:
;;;284            return (24000000 / div);
;;;285        case CLK_AHB_SRC_CPUCLK:
;;;286            return (clk_cpu_get_freq() / div);
;;;287        case CLK_AHB_SRC_PLL_PERIPH_PREDIV:
;;;288            return (clk_pll_get_freq(PLL_PERIPH) / (prediv + 1) / div);
;;;289        default:
;;;290            return 0;
;;;291        }
;;;292    }
0007a8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1964|
0007ac  e1a00000          MOV      r0,r0                 ;283
0007b0  e1a01004          MOV      r1,r4                 ;284
0007b4  e59f0308          LDR      r0,|L1.2756|
0007b8  ebfffffe          BL       __aeabi_idivmod
0007bc  eafffff9          B        |L1.1960|
                  |L1.1984|
0007c0  e1a00000          MOV      r0,r0                 ;285
0007c4  ebfffffe          BL       clk_cpu_get_freq
0007c8  e1a07000          MOV      r7,r0                 ;286
0007cc  e1a01004          MOV      r1,r4                 ;286
0007d0  ebfffffe          BL       __aeabi_uidivmod
0007d4  eafffff3          B        |L1.1960|
                  |L1.2008|
0007d8  e1a00000          MOV      r0,r0                 ;287
0007dc  e3a00028          MOV      r0,#0x28              ;288
0007e0  ebfffffe          BL       clk_pll_get_freq
0007e4  e1a08000          MOV      r8,r0                 ;288
0007e8  e2861001          ADD      r1,r6,#1              ;288
0007ec  ebfffffe          BL       __aeabi_uidivmod
0007f0  e1a07000          MOV      r7,r0                 ;288
0007f4  e1a01004          MOV      r1,r4                 ;288
0007f8  ebfffffe          BL       __aeabi_uidivmod
0007fc  eaffffe9          B        |L1.1960|
                  |L1.2048|
000800  e1a00000          MOV      r0,r0                 ;289
000804  e3a00000          MOV      r0,#0                 ;290
000808  eaffffe6          B        |L1.1960|
;;;293    
                          ENDP

                  clk_apb_config PROC
;;;294    // APB = AHB / div
;;;295    void clk_apb_config(clk_div_apb_e div) {
00080c  e92d4070          PUSH     {r4-r6,lr}
000810  e1a04000          MOV      r4,r0
;;;296        uint32_t val = read32(CCU_BASE + CCU_AHB_APB_CFG) & ~(0x3 << 8);
000814  e59f02c0          LDR      r0,|L1.2780|
000818  ebfffffe          BL       read32
00081c  e3c05c03          BIC      r5,r0,#0x300
;;;297        write32(CCU_BASE + CCU_AHB_APB_CFG, val | (div << 8));
000820  e1851404          ORR      r1,r5,r4,LSL #8
000824  e59f02b0          LDR      r0,|L1.2780|
000828  ebfffffe          BL       write32
;;;298    }
00082c  e8bd8070          POP      {r4-r6,pc}
;;;299    
                          ENDP

                  clk_apb_get_freq PROC
;;;300    uint32_t clk_apb_get_freq(void) {
000830  e92d4010          PUSH     {r4,lr}
;;;301        clk_div_apb_e div = (clk_div_apb_e)((read32(CCU_BASE + CCU_AHB_APB_CFG) >> 8) & 0x3);
000834  e59f02a0          LDR      r0,|L1.2780|
000838  ebfffffe          BL       read32
00083c  e3a01003          MOV      r1,#3
000840  e0014420          AND      r4,r1,r0,LSR #8
;;;302    
;;;303        switch(div) {
000844  e3540002          CMP      r4,#2
000848  0a000002          BEQ      |L1.2136|
00084c  e3540003          CMP      r4,#3
000850  1a000008          BNE      |L1.2168|
000854  ea000003          B        |L1.2152|
                  |L1.2136|
;;;304        case CLK_APB_DIV_4:
000858  e1a00000          MOV      r0,r0
;;;305            return clk_ahb_get_freq() / 4;
00085c  ebfffffe          BL       clk_ahb_get_freq
000860  e1a00120          LSR      r0,r0,#2
                  |L1.2148|
;;;306        case CLK_APB_DIV_8:
;;;307            return clk_ahb_get_freq() / 8;
;;;308        default:
;;;309            return clk_ahb_get_freq() / 2;
;;;310        }
;;;311    }
000864  e8bd8010          POP      {r4,pc}
                  |L1.2152|
000868  e1a00000          MOV      r0,r0                 ;306
00086c  ebfffffe          BL       clk_ahb_get_freq
000870  e1a001a0          LSR      r0,r0,#3              ;307
000874  eafffffa          B        |L1.2148|
                  |L1.2168|
000878  e1a00000          MOV      r0,r0                 ;308
00087c  ebfffffe          BL       clk_ahb_get_freq
000880  e1a000a0          LSR      r0,r0,#1              ;309
000884  eafffff6          B        |L1.2148|
;;;312    
                          ENDP

                  clk_de_config PROC
;;;313    // DEBE / DEFE clock configuration
;;;314    void clk_de_config(uint32_t reg, clk_source_de_e source, uint8_t div) {
000888  e92d41f0          PUSH     {r4-r8,lr}
00088c  e1a05000          MOV      r5,r0
000890  e1a07001          MOV      r7,r1
000894  e1a04002          MOV      r4,r2
;;;315        if((div == 0) || (div > 16)) return;
000898  e3540000          CMP      r4,#0
00089c  0a000001          BEQ      |L1.2216|
0008a0  e3540010          CMP      r4,#0x10
0008a4  da000000          BLE      |L1.2220|
                  |L1.2216|
;;;316    
;;;317        uint32_t val = read32(CCU_BASE + reg);
;;;318    
;;;319        val &= ~((0x7 << 24) | (0xF));
;;;320        val |= (source << 24) | (div - 1);
;;;321    
;;;322        write32(CCU_BASE + reg, val);
;;;323    }
0008a8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2220|
0008ac  e2850401          ADD      r0,r5,#0x1000000      ;317
0008b0  e28008c2          ADD      r0,r0,#0xc20000       ;317
0008b4  ebfffffe          BL       read32
0008b8  e1a06000          MOV      r6,r0                 ;317
0008bc  e3c6600f          BIC      r6,r6,#0xf            ;319
0008c0  e3c66407          BIC      r6,r6,#0x7000000      ;319
0008c4  e2440001          SUB      r0,r4,#1              ;320
0008c8  e1800c07          ORR      r0,r0,r7,LSL #24      ;320
0008cc  e1866000          ORR      r6,r6,r0              ;320
0008d0  e2850401          ADD      r0,r5,#0x1000000      ;322
0008d4  e28008c2          ADD      r0,r0,#0xc20000       ;322
0008d8  e1a01006          MOV      r1,r6                 ;322
0008dc  ebfffffe          BL       write32
0008e0  e1a00000          MOV      r0,r0
0008e4  eaffffef          B        |L1.2216|
;;;324    
                          ENDP

                  clk_tcon_config PROC
;;;325    // TCON clock configuration
;;;326    void clk_tcon_config(clk_source_vid_e source) {
0008e8  e92d4070          PUSH     {r4-r6,lr}
0008ec  e1a04000          MOV      r4,r0
;;;327        uint32_t val = read32(CCU_BASE + CCU_TCON_CLK) & ~(0x7 << 24);
0008f0  e59f01e8          LDR      r0,|L1.2784|
0008f4  ebfffffe          BL       read32
0008f8  e3c05407          BIC      r5,r0,#0x7000000
;;;328        write32(CCU_BASE + CCU_TCON_CLK, val | (source << 24));
0008fc  e1851c04          ORR      r1,r5,r4,LSL #24
000900  e59f01d8          LDR      r0,|L1.2784|
000904  ebfffffe          BL       write32
;;;329    }
000908  e8bd8070          POP      {r4-r6,pc}
;;;330    
                          ENDP

                  clk_tve_config PROC
;;;331    // Video encoder clock configuration
;;;332    void clk_tve_config(uint8_t div) { // TODO: source select
00090c  e92d4010          PUSH     {r4,lr}
000910  e1a04000          MOV      r4,r0
;;;333        if((div == 0) || (div > 16)) return;
000914  e3540000          CMP      r4,#0
000918  0a000001          BEQ      |L1.2340|
00091c  e3540010          CMP      r4,#0x10
000920  da000000          BLE      |L1.2344|
                  |L1.2340|
;;;334        write32(CCU_BASE + CCU_TVE_CLK, (0x80008100) | (div - 1));
;;;335    }
000924  e8bd8010          POP      {r4,pc}
                  |L1.2344|
000928  e2440001          SUB      r0,r4,#1              ;334
00092c  e3801102          ORR      r1,r0,#0x80000000     ;334
000930  e3811c81          ORR      r1,r1,#0x8100         ;334
000934  e59f01a8          LDR      r0,|L1.2788|
000938  ebfffffe          BL       write32
00093c  e1a00000          MOV      r0,r0
000940  eafffff7          B        |L1.2340|
;;;336    
                          ENDP

                  clk_tvd_config PROC
;;;337    // Video decoder clock configuration
;;;338    void clk_tvd_config(uint8_t div) { // TODO: source select
000944  e92d4010          PUSH     {r4,lr}
000948  e1a04000          MOV      r4,r0
;;;339        if((div == 0) || (div > 16)) return;
00094c  e3540000          CMP      r4,#0
000950  0a000001          BEQ      |L1.2396|
000954  e3540010          CMP      r4,#0x10
000958  da000000          BLE      |L1.2400|
                  |L1.2396|
;;;340        write32(CCU_BASE + CCU_TVD_CLK, (0x80000000) | (div - 1));
;;;341    }
00095c  e8bd8010          POP      {r4,pc}
                  |L1.2400|
000960  e2440001          SUB      r0,r4,#1              ;340
000964  e3801102          ORR      r1,r0,#0x80000000     ;340
000968  e59f0178          LDR      r0,|L1.2792|
00096c  ebfffffe          BL       write32
000970  e1a00000          MOV      r0,r0
000974  eafffff8          B        |L1.2396|
;;;342    
                          ENDP

                  clk_sdc_config PROC
;;;343    // SD card controller clock
;;;344    uint32_t clk_sdc_config(uint32_t reg, uint32_t freq) {
000978  e92d5ff0          PUSH     {r4-r12,lr}
00097c  e1a08000          MOV      r8,r0
000980  e1a06001          MOV      r6,r1
;;;345        uint32_t in_freq = 0;
000984  e3a0b000          MOV      r11,#0
;;;346        uint32_t reg_val = (uint32_t)(0x1U << 31);
000988  e3a04102          MOV      r4,#0x80000000
;;;347    
;;;348        if(freq <= 24000000) {
00098c  e59f0130          LDR      r0,|L1.2756|
000990  e1560000          CMP      r6,r0
000994  8a000002          BHI      |L1.2468|
;;;349            reg_val |= (0 << 24); // OSC24M
000998  e1a00000          MOV      r0,r0
;;;350            in_freq = 24000000;
00099c  e1a0b000          MOV      r11,r0
0009a0  ea000003          B        |L1.2484|
                  |L1.2468|
;;;351        } else {
;;;352            reg_val |= (1 << 24); // PLL_PERIPH
0009a4  e3844401          ORR      r4,r4,#0x1000000
;;;353            in_freq = clk_pll_get_freq(PLL_PERIPH);
0009a8  e3a00028          MOV      r0,#0x28
0009ac  ebfffffe          BL       clk_pll_get_freq
0009b0  e1a0b000          MOV      r11,r0
                  |L1.2484|
;;;354        }
;;;355    
;;;356        uint8_t div = in_freq / freq;
0009b4  e1a01006          MOV      r1,r6
0009b8  e1a0000b          MOV      r0,r11
0009bc  ebfffffe          BL       __aeabi_uidivmod
0009c0  e20050ff          AND      r5,r0,#0xff
;;;357        if(in_freq % freq) div++;
0009c4  e1a01006          MOV      r1,r6
0009c8  e1a0000b          MOV      r0,r11
0009cc  ebfffffe          BL       __aeabi_uidivmod
0009d0  e3510000          CMP      r1,#0
0009d4  0a000001          BEQ      |L1.2528|
0009d8  e2850001          ADD      r0,r5,#1
0009dc  e20050ff          AND      r5,r0,#0xff
                  |L1.2528|
;;;358    
;;;359        uint8_t prediv = 0;
0009e0  e3a07000          MOV      r7,#0
;;;360        while(div > 16) {
0009e4  ea000009          B        |L1.2576|
                  |L1.2536|
;;;361            prediv++;
0009e8  e2870001          ADD      r0,r7,#1
0009ec  e20070ff          AND      r7,r0,#0xff
;;;362            if(prediv > 3) return 0;
0009f0  e3570003          CMP      r7,#3
0009f4  da000001          BLE      |L1.2560|
0009f8  e3a00000          MOV      r0,#0
                  |L1.2556|
;;;363            div = (div + 1) / 2;
;;;364        }
;;;365    
;;;366        /* determine delays */
;;;367        uint8_t samp_phase = 0;
;;;368        uint8_t out_phase  = 0;
;;;369        if(freq <= 400000) {
;;;370            out_phase  = 0;
;;;371            samp_phase = 0;
;;;372        } else if(freq <= 25000000) {
;;;373            out_phase  = 0;
;;;374            samp_phase = 5;
;;;375        } else if(freq <= 52000000) {
;;;376            out_phase  = 3;
;;;377            samp_phase = 4;
;;;378        } else { /* freq > 52000000 */
;;;379            out_phase  = 1;
;;;380            samp_phase = 4;
;;;381        }
;;;382        reg_val |= (samp_phase << 20) | (out_phase << 8);
;;;383        reg_val |= (prediv << 16) | ((div - 1) << 0);
;;;384    
;;;385        write32(CCU_BASE + reg, reg_val);
;;;386    
;;;387        return in_freq / div;
;;;388    }
0009fc  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.2560|
000a00  e2850001          ADD      r0,r5,#1              ;363
000a04  e0801fa0          ADD      r1,r0,r0,LSR #31      ;363
000a08  e1a01b81          LSL      r1,r1,#23             ;363
000a0c  e1a05c21          LSR      r5,r1,#24             ;363
                  |L1.2576|
000a10  e3550010          CMP      r5,#0x10              ;360
000a14  cafffff3          BGT      |L1.2536|
000a18  e3a09000          MOV      r9,#0                 ;367
000a1c  e3a0a000          MOV      r10,#0                ;368
000a20  e59f00c4          LDR      r0,|L1.2796|
000a24  e1560000          CMP      r6,r0                 ;369
000a28  8a000001          BHI      |L1.2612|
000a2c  e1a00000          MOV      r0,r0                 ;370
000a30  ea00000d          B        |L1.2668|
                  |L1.2612|
000a34  e59f00b4          LDR      r0,|L1.2800|
000a38  e1560000          CMP      r6,r0                 ;372
000a3c  8a000002          BHI      |L1.2636|
000a40  e3a0a000          MOV      r10,#0                ;373
000a44  e3a09005          MOV      r9,#5                 ;374
000a48  ea000007          B        |L1.2668|
                  |L1.2636|
000a4c  e59f00a0          LDR      r0,|L1.2804|
000a50  e1560000          CMP      r6,r0                 ;375
000a54  8a000002          BHI      |L1.2660|
000a58  e3a0a003          MOV      r10,#3                ;376
000a5c  e3a09004          MOV      r9,#4                 ;377
000a60  ea000001          B        |L1.2668|
                  |L1.2660|
000a64  e3a0a001          MOV      r10,#1                ;379
000a68  e3a09004          MOV      r9,#4                 ;380
                  |L1.2668|
000a6c  e1a00a09          LSL      r0,r9,#20             ;382
000a70  e180040a          ORR      r0,r0,r10,LSL #8      ;382
000a74  e1844000          ORR      r4,r4,r0              ;382
000a78  e2450001          SUB      r0,r5,#1              ;383
000a7c  e1800807          ORR      r0,r0,r7,LSL #16      ;383
000a80  e1844000          ORR      r4,r4,r0              ;383
000a84  e2880401          ADD      r0,r8,#0x1000000      ;385
000a88  e28008c2          ADD      r0,r0,#0xc20000       ;385
000a8c  e1a01004          MOV      r1,r4                 ;385
000a90  ebfffffe          BL       write32
000a94  e1a01005          MOV      r1,r5                 ;387
000a98  e1a0000b          MOV      r0,r11                ;387
000a9c  ebfffffe          BL       __aeabi_uidivmod
000aa0  eaffffd5          B        |L1.2556|
;;;389    
                          ENDP

                  read32 PROC
;;;19     
;;;20     static __inline uint32_t read32(uint32_t addr)
000aa4  e1a01000          MOV      r1,r0
;;;21     {
;;;22       return (*((volatile uint32_t*)(addr)));
000aa8  e5910000          LDR      r0,[r1,#0]
;;;23     }
000aac  e12fff1e          BX       lr
;;;24     
                          ENDP

                  write32 PROC
;;;39     
;;;40     static __inline void write32(uint32_t addr, uint32_t value)
000ab0  e5801000          STR      r1,[r0,#0]
;;;41     {
;;;42       *((volatile uint32_t*)(addr)) = value;
;;;43     }
000ab4  e12fff1e          BX       lr
;;;44     
                          ENDP

                  |L1.2744|
                          DCD      0x01c20028
                  |L1.2748|
                          DCD      0x01c20008
                  |L1.2752|
                          DCD      0x01c20000
                  |L1.2756|
                          DCD      0x016e3600
                  |L1.2760|
                          DCD      0x01c20020
                  |L1.2764|
                          DCD      0x11b3dc40
                  |L1.2768|
                          DCD      0x1017df80
                  |L1.2772|
                          DCD      0x02dc6c00
                  |L1.2776|
                          DCD      0x01c20050
                  |L1.2780|
                          DCD      0x01c20054
                  |L1.2784|
                          DCD      0x01c20118
                  |L1.2788|
                          DCD      0x01c20120
                  |L1.2792|
                          DCD      0x01c20124
                  |L1.2796|
                          DCD      0x00061a80
                  |L1.2800|
                          DCD      0x017d7840
                  |L1.2804|
                          DCD      0x03197500

                          AREA ||i.clk_pll_enable||, COMGROUP=clk_pll_enable, CODE, READONLY, ALIGN=2

                  clk_pll_enable PROC
;;;15     // Enable PLL
;;;16     inline void clk_pll_enable(pll_ch_e pll) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
;;;17         write32(CCU_BASE + pll, (read32(CCU_BASE + pll) 
000008  e2840401          ADD      r0,r4,#0x1000000
00000c  e28008c2          ADD      r0,r0,#0xc20000
000010  ebfffffe          BL       read32
000014  e3805102          ORR      r5,r0,#0x80000000
000018  e2840401          ADD      r0,r4,#0x1000000
00001c  e28008c2          ADD      r0,r0,#0xc20000
000020  e1a01005          MOV      r1,r5
000024  ebfffffe          BL       write32
;;;18     			|(uint32_t)(0x1U << 31)));
;;;19     }
000028  e8bd8070          POP      {r4-r6,pc}
;;;20     
                          ENDP


                          AREA ||i.clk_pll_disable||, COMGROUP=clk_pll_disable, CODE, READONLY, ALIGN=2

                  clk_pll_disable PROC
;;;21     // Disable PLL
;;;22     inline void clk_pll_disable(pll_ch_e pll) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
;;;23         write32(CCU_BASE + pll, (read32(CCU_BASE + pll) & ~(0x1U << 31)));
000008  e2840401          ADD      r0,r4,#0x1000000
00000c  e28008c2          ADD      r0,r0,#0xc20000
000010  ebfffffe          BL       read32
000014  e3c05102          BIC      r5,r0,#0x80000000
000018  e2840401          ADD      r0,r4,#0x1000000
00001c  e28008c2          ADD      r0,r0,#0xc20000
000020  e1a01005          MOV      r1,r5
000024  ebfffffe          BL       write32
;;;24     }
000028  e8bd8070          POP      {r4-r6,pc}
;;;25     
                          ENDP


                          AREA ||i.clk_enable||, COMGROUP=clk_enable, CODE, READONLY, ALIGN=2

                  clk_enable PROC
;;;214    
;;;215    inline void clk_enable(uint32_t reg, uint8_t bit) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;216        set32(CCU_BASE + reg, (1 << bit));
00000c  e2840401          ADD      r0,r4,#0x1000000
000010  e28008c2          ADD      r0,r0,#0xc20000
000014  ebfffffe          BL       read32
000018  e3a01001          MOV      r1,#1
00001c  e1806511          ORR      r6,r0,r1,LSL r5
000020  e2840401          ADD      r0,r4,#0x1000000
000024  e28008c2          ADD      r0,r0,#0xc20000
000028  e1a01006          MOV      r1,r6
00002c  ebfffffe          BL       write32
;;;217    }
000030  e8bd8070          POP      {r4-r6,pc}
;;;218    
                          ENDP


                          AREA ||i.clk_disable||, COMGROUP=clk_disable, CODE, READONLY, ALIGN=2

                  clk_disable PROC
;;;218    
;;;219    inline void clk_disable(uint32_t reg, uint8_t bit) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;220        clear32(CCU_BASE + reg, (1 << bit));
00000c  e2840401          ADD      r0,r4,#0x1000000
000010  e28008c2          ADD      r0,r0,#0xc20000
000014  ebfffffe          BL       read32
000018  e3a01001          MOV      r1,#1
00001c  e1c06511          BIC      r6,r0,r1,LSL r5
000020  e2840401          ADD      r0,r4,#0x1000000
000024  e28008c2          ADD      r0,r0,#0xc20000
000028  e1a01006          MOV      r1,r6
00002c  ebfffffe          BL       write32
;;;221    }
000030  e8bd8070          POP      {r4-r6,pc}
;;;222    
                          ENDP


                          AREA ||i.clk_reset_set||, COMGROUP=clk_reset_set, CODE, READONLY, ALIGN=2

                  clk_reset_set PROC
;;;391    
;;;392    inline void clk_reset_set(uint32_t reg, uint8_t bit) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;393        clear32(CCU_BASE + reg, (1 << bit));
00000c  e2840401          ADD      r0,r4,#0x1000000
000010  e28008c2          ADD      r0,r0,#0xc20000
000014  ebfffffe          BL       read32
000018  e3a01001          MOV      r1,#1
00001c  e1c06511          BIC      r6,r0,r1,LSL r5
000020  e2840401          ADD      r0,r4,#0x1000000
000024  e28008c2          ADD      r0,r0,#0xc20000
000028  e1a01006          MOV      r1,r6
00002c  ebfffffe          BL       write32
;;;394    }
000030  e8bd8070          POP      {r4-r6,pc}
;;;395    
                          ENDP


                          AREA ||i.clk_reset_clear||, COMGROUP=clk_reset_clear, CODE, READONLY, ALIGN=2

                  clk_reset_clear PROC
;;;395    
;;;396    inline void clk_reset_clear(uint32_t reg, uint8_t bit) {
000000  e92d4070          PUSH     {r4-r6,lr}
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;397        set32(CCU_BASE + reg, (1 << bit));
00000c  e2840401          ADD      r0,r4,#0x1000000
000010  e28008c2          ADD      r0,r0,#0xc20000
000014  ebfffffe          BL       read32
000018  e3a01001          MOV      r1,#1
00001c  e1806511          ORR      r6,r0,r1,LSL r5
000020  e2840401          ADD      r0,r4,#0x1000000
000024  e28008c2          ADD      r0,r0,#0xc20000
000028  e1a01006          MOV      r1,r6
00002c  ebfffffe          BL       write32
;;;398    }
000030  e8bd8070          POP      {r4-r6,pc}
                          ENDP

