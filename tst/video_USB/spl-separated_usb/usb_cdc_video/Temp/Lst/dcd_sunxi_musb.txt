; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave --gnu -o.\temp\obj\dcd_sunxi_musb.o --asm_dir=.\Temp\Lst\ --list_dir=.\Temp\Lst\ --depend=.\temp\obj\dcd_sunxi_musb.d --cpu=ARM9E --apcs=interwork -O0 -Otime --diag_suppress=9931 -I.\users\include -I.\..\machine\include -I.\..\periph\include -I.\..\include -I.\..\emwin\Include -I.\..\tinyusb\src -I.\..\tinyusb\hw -I.\..\display -I.\..\lib\display_gfx -I.\..\lib\printf -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Atmel\SAM9260 -D__RTX -D__UVISION_VERSION=536 -DPCB_TINY200V1 -DCFG_TUSB_MCU=OPT_MCU_F1C100S -DCFG_TUSB_OS=OPT_OS_RTX4 --omf_browse=.\temp\obj\dcd_sunxi_musb.crf ..\tinyusb\src\portable\sunxi\dcd_sunxi_musb.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  usb_phy_write PROC
;;;73     
;;;74     static void usb_phy_write(int addr, int data, int len)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;75     {
000004  e1a0c000          MOV      r12,r0
000008  e1a04002          MOV      r4,r2
;;;76     	int j = 0, usbc_bit = 0;
00000c  e3a02000          MOV      r2,#0
000010  e3a03000          MOV      r3,#0
;;;77     	void *dest = (void *)USBC_REG_CSR(USBC0_BASE);
000014  e59f0818          LDR      r0,|L1.2100|
;;;78     
;;;79     	usbc_bit = 1 << (0 * 2);
000018  e3a03001          MOV      r3,#1
;;;80     	for (j = 0; j < len; j++)
00001c  e1a00000          MOV      r0,r0
000020  ea000028          B        |L1.200|
                  |L1.36|
;;;81     	{
;;;82     		/* set the bit address to be written */
;;;83     		USBC_ClrBit_Mask_l(dest, 0xff << 8);
000024  e1a00000          MOV      r0,r0
000028  e5905000          LDR      r5,[r0,#0]
00002c  e3c55cff          BIC      r5,r5,#0xff00
000030  e5805000          STR      r5,[r0,#0]
000034  e1a00000          MOV      r0,r0
;;;84     		USBC_SetBit_Mask_l(dest, (addr + j) << 8);
000038  e1a00000          MOV      r0,r0
00003c  e5905000          LDR      r5,[r0,#0]
000040  e08c6002          ADD      r6,r12,r2
000044  e1855406          ORR      r5,r5,r6,LSL #8
000048  e5805000          STR      r5,[r0,#0]
00004c  e1a00000          MOV      r0,r0
;;;85     
;;;86     		USBC_ClrBit_Mask_l(dest, usbc_bit);
000050  e1a00000          MOV      r0,r0
000054  e5905000          LDR      r5,[r0,#0]
000058  e1c55003          BIC      r5,r5,r3
00005c  e5805000          STR      r5,[r0,#0]
000060  e1a00000          MOV      r0,r0
;;;87     		/* set data bit */
;;;88     		if (data & 0x1)
000064  e2015001          AND      r5,r1,#1
000068  e3550000          CMP      r5,#0
00006c  0a000004          BEQ      |L1.132|
;;;89     			USBC_SetBit_Mask_l(dest, 1 << 7);
000070  e1a00000          MOV      r0,r0
000074  e5905000          LDR      r5,[r0,#0]
000078  e3855080          ORR      r5,r5,#0x80
00007c  e5805000          STR      r5,[r0,#0]
000080  ea000004          B        |L1.152|
                  |L1.132|
;;;90     		else
;;;91     			USBC_ClrBit_Mask_l(dest, 1 << 7);
000084  e1a00000          MOV      r0,r0
000088  e5905000          LDR      r5,[r0,#0]
00008c  e3c55080          BIC      r5,r5,#0x80
000090  e5805000          STR      r5,[r0,#0]
000094  e1a00000          MOV      r0,r0
                  |L1.152|
;;;92     
;;;93     		USBC_SetBit_Mask_l(dest, usbc_bit);
000098  e1a00000          MOV      r0,r0
00009c  e5905000          LDR      r5,[r0,#0]
0000a0  e1855003          ORR      r5,r5,r3
0000a4  e5805000          STR      r5,[r0,#0]
0000a8  e1a00000          MOV      r0,r0
;;;94     
;;;95     		USBC_ClrBit_Mask_l(dest, usbc_bit);
0000ac  e1a00000          MOV      r0,r0
0000b0  e5905000          LDR      r5,[r0,#0]
0000b4  e1c55003          BIC      r5,r5,r3
0000b8  e5805000          STR      r5,[r0,#0]
0000bc  e1a00000          MOV      r0,r0
;;;96     
;;;97     		data >>= 1;
0000c0  e1a010c1          ASR      r1,r1,#1
0000c4  e2822001          ADD      r2,r2,#1              ;80
                  |L1.200|
0000c8  e1520004          CMP      r2,r4                 ;80
0000cc  baffffd4          BLT      |L1.36|
;;;98     	}
;;;99     }
0000d0  e8bd8070          POP      {r4-r6,pc}
;;;100    
                          ENDP

                  delay_ms PROC
;;;101    static void delay_ms(uint32_t ms)
0000d4  e92d41f0          PUSH     {r4-r8,lr}
;;;102    {
0000d8  e1a05000          MOV      r5,r0
;;;103    #if CFG_TUSB_OS == OPT_OS_NONE
;;;104      int now = board_millis();
;;;105      while (board_millis() - now <= ms) asm("nop");
;;;106    #else
;;;107      osal_task_delay(ms);
0000dc  e1a04005          MOV      r4,r5
0000e0  e1a07824          LSR      r7,r4,#16
0000e4  e1a06804          LSL      r6,r4,#16
0000e8  e1a06826          LSR      r6,r6,#16
0000ec  ea000001          B        |L1.248|
                  |L1.240|
0000f0  e59f0740          LDR      r0,|L1.2104|
0000f4  ebfffffe          BL       os_dly_wait
                  |L1.248|
0000f8  e2570000          SUBS     r0,r7,#0
0000fc  e2471001          SUB      r1,r7,#1
000100  e1a07801          LSL      r7,r1,#16
000104  e1a07827          LSR      r7,r7,#16
000108  1afffff8          BNE      |L1.240|
00010c  e1a00006          MOV      r0,r6
000110  ebfffffe          BL       os_dly_wait
000114  e1a00000          MOV      r0,r0
;;;108    #endif
;;;109    }
000118  e8bd81f0          POP      {r4-r8,pc}
;;;110    
                          ENDP

                  USBC_HardwareReset PROC
;;;111    static void USBC_HardwareReset(void)
00011c  e92d4010          PUSH     {r4,lr}
;;;112    {
;;;113      // Reset phy and controller
;;;114      USBC_REG_set_bit_l(USBPHY_CLK_RST_BIT, USBPHY_CLK_REG);
000120  e59f0714          LDR      r0,|L1.2108|
000124  e59000cc          LDR      r0,[r0,#0xcc]
000128  e3800001          ORR      r0,r0,#1
00012c  e59f1708          LDR      r1,|L1.2108|
000130  e58100cc          STR      r0,[r1,#0xcc]
;;;115    	USBC_REG_set_bit_l(BUS_RST_USB_BIT, BUS_CLK_RST_REG);
000134  e1a00001          MOV      r0,r1
000138  e59002c0          LDR      r0,[r0,#0x2c0]
00013c  e3800401          ORR      r0,r0,#0x1000000
000140  e58102c0          STR      r0,[r1,#0x2c0]
;;;116      delay_ms(2);
000144  e3a00002          MOV      r0,#2
000148  ebfffffe          BL       delay_ms
;;;117    
;;;118    	USBC_REG_set_bit_l(USBPHY_CLK_GAT_BIT, USBPHY_CLK_REG);
00014c  e59f06e8          LDR      r0,|L1.2108|
000150  e59000cc          LDR      r0,[r0,#0xcc]
000154  e3800002          ORR      r0,r0,#2
000158  e59f16dc          LDR      r1,|L1.2108|
00015c  e58100cc          STR      r0,[r1,#0xcc]
;;;119      USBC_REG_set_bit_l(USBPHY_CLK_RST_BIT, USBPHY_CLK_REG);
000160  e1a00001          MOV      r0,r1
000164  e59000cc          LDR      r0,[r0,#0xcc]
000168  e3800001          ORR      r0,r0,#1
00016c  e58100cc          STR      r0,[r1,#0xcc]
;;;120    
;;;121    	USBC_REG_set_bit_l(BUS_CLK_USB_BIT, BUS_CLK_GATE0_REG);
000170  e1a00001          MOV      r0,r1
000174  e5900060          LDR      r0,[r0,#0x60]
000178  e3800401          ORR      r0,r0,#0x1000000
00017c  e5810060          STR      r0,[r1,#0x60]
;;;122    	USBC_REG_set_bit_l(BUS_RST_USB_BIT, BUS_CLK_RST_REG);
000180  e1a00001          MOV      r0,r1
000184  e59002c0          LDR      r0,[r0,#0x2c0]
000188  e3800401          ORR      r0,r0,#0x1000000
00018c  e58102c0          STR      r0,[r1,#0x2c0]
;;;123    }
000190  e8bd8010          POP      {r4,pc}
;;;124    
                          ENDP

                  USBC_PhyConfig PROC
;;;125    static void USBC_PhyConfig(void)
000194  e92d4010          PUSH     {r4,lr}
;;;126    {
;;;127    	/* Regulation 45 ohms */
;;;128    	usb_phy_write(0x0c, 0x01, 1);
000198  e3a02001          MOV      r2,#1
00019c  e1a01002          MOV      r1,r2
0001a0  e3a0000c          MOV      r0,#0xc
0001a4  ebfffffe          BL       usb_phy_write
;;;129    
;;;130    	/* adjust PHY's magnitude and rate */
;;;131    	usb_phy_write(0x20, 0x14, 5);
0001a8  e3a02005          MOV      r2,#5
0001ac  e3a01014          MOV      r1,#0x14
0001b0  e3a00020          MOV      r0,#0x20
0001b4  ebfffffe          BL       usb_phy_write
;;;132    
;;;133    	/* threshold adjustment disconnect */
;;;134    	usb_phy_write(0x2a, 3, 2);
0001b8  e3a02002          MOV      r2,#2
0001bc  e3a01003          MOV      r1,#3
0001c0  e3a0002a          MOV      r0,#0x2a
0001c4  ebfffffe          BL       usb_phy_write
;;;135    
;;;136    	return;
;;;137    }
0001c8  e8bd8010          POP      {r4,pc}
;;;138    
                          ENDP

                  USBC_ConfigFIFO_Base PROC
;;;139    static void USBC_ConfigFIFO_Base(void)
0001cc  e3a01507          MOV      r1,#0x1c00000
;;;140    {
;;;141    	u32 reg_value;
;;;142    
;;;143    	/* config usb fifo, 8kb mode */
;;;144    	reg_value = USBC_Readl(SUNXI_SRAMC_BASE + 0x04);
0001d0  e5910004          LDR      r0,[r1,#4]
;;;145    	reg_value &= ~(0x03 << 0);
0001d4  e3c00003          BIC      r0,r0,#3
;;;146    	reg_value |= (1 << 0);
0001d8  e3800001          ORR      r0,r0,#1
;;;147    	USBC_Writel(reg_value, SUNXI_SRAMC_BASE + 0x04);
0001dc  e5810004          STR      r0,[r1,#4]
;;;148    }
0001e0  e12fff1e          BX       lr
;;;149    
                          ENDP

                  USBC_WakeUp_ClearChangeDetect PROC
;;;150    static unsigned int USBC_WakeUp_ClearChangeDetect(unsigned int reg_val)
0001e4  e1a01000          MOV      r1,r0
;;;151    {
;;;152    	unsigned int temp = reg_val;
0001e8  e1a00001          MOV      r0,r1
;;;153        /* vbus, id, dpdm, these bit is set 1 to clear, so we clear these bit when operate other bits */
;;;154    	temp &= ~(1 << USBC_BP_ISCR_VBUS_CHANGE_DETECT);
0001ec  e3c00040          BIC      r0,r0,#0x40
;;;155    	temp &= ~(1 << USBC_BP_ISCR_ID_CHANGE_DETECT);
0001f0  e3c00020          BIC      r0,r0,#0x20
;;;156    	temp &= ~(1 << USBC_BP_ISCR_DPDM_CHANGE_DETECT);
0001f4  e3c00010          BIC      r0,r0,#0x10
;;;157    
;;;158    	return temp;
;;;159    }
0001f8  e12fff1e          BX       lr
;;;160    
                          ENDP

                  USBC_EnableDpDmPullUp PROC
;;;161    static void USBC_EnableDpDmPullUp(void)
0001fc  e92d4010          PUSH     {r4,lr}
;;;162    {
;;;163    	u32 reg_val = USBC_Readl(USBC_REG_ISCR(USBC0_BASE));
000200  e59f0638          LDR      r0,|L1.2112|
000204  e5904000          LDR      r4,[r0,#0]
;;;164    	reg_val |= (1 << USBC_BP_ISCR_DPDM_PULLUP_EN);
000208  e3844801          ORR      r4,r4,#0x10000
;;;165    	reg_val |= 3<<USBC_BP_ISCR_VBUS_VALID_SRC;
00020c  e3844b03          ORR      r4,r4,#0xc00
;;;166    	reg_val = USBC_WakeUp_ClearChangeDetect(reg_val);
000210  e1a00004          MOV      r0,r4
000214  ebfffffe          BL       USBC_WakeUp_ClearChangeDetect
000218  e1a04000          MOV      r4,r0
;;;167    	USBC_Writel(reg_val, USBC_REG_ISCR(USBC0_BASE));
00021c  e59f061c          LDR      r0,|L1.2112|
000220  e5804000          STR      r4,[r0,#0]
;;;168    }
000224  e8bd8010          POP      {r4,pc}
;;;169    
                          ENDP

                  USBC_ForceIdToHigh PROC
;;;170    static void USBC_ForceIdToHigh(void)
000228  e92d4010          PUSH     {r4,lr}
;;;171    {
;;;172    	/* first write 00, then write 10 */
;;;173    	u32 reg_val = USBC_Readl(USBC_REG_ISCR(USBC0_BASE));
00022c  e59f060c          LDR      r0,|L1.2112|
000230  e5904000          LDR      r4,[r0,#0]
;;;174    	reg_val |= (0x03 << USBC_BP_ISCR_FORCE_ID);
000234  e3844903          ORR      r4,r4,#0xc000
;;;175    	reg_val = USBC_WakeUp_ClearChangeDetect(reg_val);
000238  e1a00004          MOV      r0,r4
00023c  ebfffffe          BL       USBC_WakeUp_ClearChangeDetect
000240  e1a04000          MOV      r4,r0
;;;176    	USBC_Writel(reg_val, USBC_REG_ISCR(USBC0_BASE));
000244  e59f05f4          LDR      r0,|L1.2112|
000248  e5804000          STR      r4,[r0,#0]
;;;177    }
00024c  e8bd8010          POP      {r4,pc}
;;;178    
                          ENDP

                  USBC_ForceVbusValidToHigh PROC
;;;179    static void USBC_ForceVbusValidToHigh(void)
000250  e92d4010          PUSH     {r4,lr}
;;;180    {
;;;181    	/* first write 00, then write 11 */
;;;182    	u32 reg_val = USBC_Readl(USBC_REG_ISCR(USBC0_BASE));
000254  e59f05e4          LDR      r0,|L1.2112|
000258  e5904000          LDR      r4,[r0,#0]
;;;183    	reg_val |= (0x03 << USBC_BP_ISCR_FORCE_VBUS_VALID);
00025c  e3844a03          ORR      r4,r4,#0x3000
;;;184    	reg_val = USBC_WakeUp_ClearChangeDetect(reg_val);
000260  e1a00004          MOV      r0,r4
000264  ebfffffe          BL       USBC_WakeUp_ClearChangeDetect
000268  e1a04000          MOV      r4,r0
;;;185    	USBC_Writel(reg_val, USBC_REG_ISCR(USBC0_BASE));
00026c  e59f05cc          LDR      r0,|L1.2112|
000270  e5804000          STR      r4,[r0,#0]
;;;186    }
000274  e8bd8010          POP      {r4,pc}
;;;187    
                          ENDP

                  USBC_SelectBus PROC
;;;188    void USBC_SelectBus(u32 io_type, u32 ep_type, u32 ep_index)
000278  e92d4010          PUSH     {r4,lr}
;;;189    {
00027c  e1a03000          MOV      r3,r0
;;;190    	u32 reg_val = 0;
000280  e3a00000          MOV      r0,#0
;;;191    
;;;192    	reg_val = USBC_Readb(USBC_REG_VEND0(USBC0_BASE));
000284  e59fc5b8          LDR      r12,|L1.2116|
000288  e5dc0043          LDRB     r0,[r12,#0x43]
;;;193    	if (io_type == USBC_IO_TYPE_DMA) {
00028c  e3530001          CMP      r3,#1
000290  1a00000a          BNE      |L1.704|
;;;194    		if (ep_type == USBC_EP_TYPE_TX) {
000294  e3510002          CMP      r1,#2
000298  1a000003          BNE      |L1.684|
;;;195    			reg_val |= ((ep_index - 0x01) << 1) << USBC_BP_VEND0_DRQ_SEL;  //drq_sel
00029c  e242c001          SUB      r12,r2,#1
0002a0  e180010c          ORR      r0,r0,r12,LSL #2
;;;196    			reg_val |= 0x1<<USBC_BP_VEND0_BUS_SEL;   //io_dma
0002a4  e3800001          ORR      r0,r0,#1
0002a8  ea000005          B        |L1.708|
                  |L1.684|
;;;197    		} else {
;;;198    			reg_val |= ((ep_index << 1) - 0x01) << USBC_BP_VEND0_DRQ_SEL;
0002ac  e3a0c001          MOV      r12,#1
0002b0  e06cc082          RSB      r12,r12,r2,LSL #1
0002b4  e180008c          ORR      r0,r0,r12,LSL #1
;;;199    			reg_val |= 0x1<<USBC_BP_VEND0_BUS_SEL;
0002b8  e3800001          ORR      r0,r0,#1
0002bc  ea000000          B        |L1.708|
                  |L1.704|
;;;200    		}
;;;201    	} else {
;;;202    		//reg_val &= ~(0x1 << USBC_BP_VEND0_DRQ_SEL);  //clear drq_sel, select pio
;;;203    		reg_val &= 0x00;  // clear drq_sel, select pio
0002c0  e3a00000          MOV      r0,#0
                  |L1.708|
;;;204    	}
;;;205    
;;;206    	/* in 1667 1673 and later ic, FIFO_BUS_SEL bit(bit24 of reg0x40 for host/device)
;;;207    	 * is fixed to 1, the hw guarantee that it's ok for cpu/inner_dma/outer_dma transfer */
;;;208    
;;;209    //	reg_val |= 0x1<<USBC_BP_VEND0_BUS_SEL;  //for 1663 set 1: enable dma, set 0: enable fifo
;;;210    
;;;211    	USBC_Writeb(reg_val, USBC_REG_VEND0(USBC0_BASE));
0002c4  e59f4578          LDR      r4,|L1.2116|
0002c8  e5c40043          STRB     r0,[r4,#0x43]
;;;212    }
0002cc  e8bd8010          POP      {r4,pc}
;;;213    
                          ENDP

                  USBC_SelectActiveEp PROC
;;;214    static void USBC_SelectActiveEp(u8 ep_index)
0002d0  e59f156c          LDR      r1,|L1.2116|
;;;215    {
;;;216    	USBC_Writeb(ep_index, USBC_REG_EPIND(USBC0_BASE));
0002d4  e5c10042          STRB     r0,[r1,#0x42]
;;;217    }
0002d8  e12fff1e          BX       lr
;;;218    
                          ENDP

                  USBC_GetActiveEp PROC
;;;219    static u8 USBC_GetActiveEp(void)
0002dc  e59f0560          LDR      r0,|L1.2116|
;;;220    {
;;;221    	return USBC_Readb(USBC_REG_EPIND(USBC0_BASE));
0002e0  e5d00042          LDRB     r0,[r0,#0x42]
;;;222    }
0002e4  e12fff1e          BX       lr
;;;223    
                          ENDP

                  __USBC_Dev_ep0_SendStall PROC
;;;224    static void __USBC_Dev_ep0_SendStall(void)
0002e8  e59f0554          LDR      r0,|L1.2116|
;;;225    {
;;;226    	USBC_REG_set_bit_w(USBC_BP_CSR0_D_SEND_STALL, USBC_REG_CSR0(USBC0_BASE));
0002ec  e1d008b2          LDRH     r0,[r0,#0x82]
0002f0  e3800020          ORR      r0,r0,#0x20
0002f4  e59f1548          LDR      r1,|L1.2116|
0002f8  e1c108b2          STRH     r0,[r1,#0x82]
;;;227    }
0002fc  e12fff1e          BX       lr
;;;228    
                          ENDP

                  __USBC_Dev_ep0_ClearStall PROC
;;;229    static void __USBC_Dev_ep0_ClearStall(void)
000300  e59f053c          LDR      r0,|L1.2116|
;;;230    {
;;;231    	USBC_REG_clear_bit_w(USBC_BP_CSR0_D_SEND_STALL, USBC_REG_CSR0(USBC0_BASE));
000304  e1d008b2          LDRH     r0,[r0,#0x82]
000308  e3c00020          BIC      r0,r0,#0x20
00030c  e59f1530          LDR      r1,|L1.2116|
000310  e1c108b2          STRH     r0,[r1,#0x82]
;;;232    	USBC_REG_clear_bit_w(USBC_BP_CSR0_D_SENT_STALL, USBC_REG_CSR0(USBC0_BASE));
000314  e1a00001          MOV      r0,r1
000318  e1d008b2          LDRH     r0,[r0,#0x82]
00031c  e3c00004          BIC      r0,r0,#4
000320  e1c108b2          STRH     r0,[r1,#0x82]
;;;233    }
000324  e12fff1e          BX       lr
;;;234    
                          ENDP

                  USBC_Dev_Ctrl_ClearSetupEnd PROC
;;;235    static void USBC_Dev_Ctrl_ClearSetupEnd(void)
000328  e59f0514          LDR      r0,|L1.2116|
;;;236    {
;;;237    	USBC_REG_set_bit_w(USBC_BP_CSR0_D_SERVICED_SETUP_END, USBC_REG_CSR0(USBC0_BASE));
00032c  e1d008b2          LDRH     r0,[r0,#0x82]
000330  e3800080          ORR      r0,r0,#0x80
000334  e59f1508          LDR      r1,|L1.2116|
000338  e1c108b2          STRH     r0,[r1,#0x82]
;;;238    }
00033c  e12fff1e          BX       lr
;;;239    
                          ENDP

                  USBC_Dev_SetAddress PROC
;;;240    static void USBC_Dev_SetAddress(u8 address)
000340  e59f14fc          LDR      r1,|L1.2116|
;;;241    {
;;;242    	USBC_Writeb(address, USBC_REG_FADDR(USBC0_BASE));
000344  e5c10098          STRB     r0,[r1,#0x98]
;;;243    }
000348  e12fff1e          BX       lr
;;;244    
                          ENDP

                  __USBC_Dev_Tx_SendStall PROC
;;;245    static void __USBC_Dev_Tx_SendStall(void)
00034c  e59f04f0          LDR      r0,|L1.2116|
;;;246    {
;;;247    	//send stall, and fifo is flushed automatically
;;;248    	USBC_REG_set_bit_w(USBC_BP_TXCSR_D_SEND_STALL, USBC_REG_TXCSR(USBC0_BASE));
000350  e1d008b2          LDRH     r0,[r0,#0x82]
000354  e3800010          ORR      r0,r0,#0x10
000358  e59f14e4          LDR      r1,|L1.2116|
00035c  e1c108b2          STRH     r0,[r1,#0x82]
;;;249    }
000360  e12fff1e          BX       lr
;;;250    static u32 __USBC_Dev_Tx_IsEpStall(void)
                          ENDP

                  __USBC_Dev_Tx_IsEpStall PROC
000364  e59f04d8          LDR      r0,|L1.2116|
;;;251    {
;;;252    	return USBC_REG_test_bit_w(USBC_BP_TXCSR_D_SENT_STALL, USBC_REG_TXCSR(USBC0_BASE));
000368  e1d008b2          LDRH     r0,[r0,#0x82]
00036c  e2000020          AND      r0,r0,#0x20
;;;253    }
000370  e12fff1e          BX       lr
;;;254    static void __USBC_Dev_Tx_ClearStall(void)
                          ENDP

                  __USBC_Dev_Tx_ClearStall PROC
000374  e59f14c8          LDR      r1,|L1.2116|
;;;255    {
;;;256    	u32 reg_val = USBC_Readw(USBC_REG_TXCSR(USBC0_BASE));
000378  e1d108b2          LDRH     r0,[r1,#0x82]
;;;257    	reg_val &= ~((1 << USBC_BP_TXCSR_D_SENT_STALL)|(1 << USBC_BP_TXCSR_D_SEND_STALL)|(1<<USBC_BP_TXCSR_D_UNDER_RUN));
00037c  e3c00034          BIC      r0,r0,#0x34
;;;258      reg_val |= (1 << USBC_BP_TXCSR_D_CLEAR_DATA_TOGGLE);
000380  e3800040          ORR      r0,r0,#0x40
;;;259    	USBC_Writew(reg_val, USBC_REG_TXCSR(USBC0_BASE));
000384  e1c108b2          STRH     r0,[r1,#0x82]
;;;260    }
000388  e12fff1e          BX       lr
;;;261    
                          ENDP

                  __USBC_Dev_Rx_SendStall PROC
;;;262    static void __USBC_Dev_Rx_SendStall(void)
00038c  e59f04b0          LDR      r0,|L1.2116|
;;;263    {
;;;264    	USBC_REG_set_bit_w(USBC_BP_RXCSR_D_SEND_STALL, USBC_REG_RXCSR(USBC0_BASE));
000390  e1d008b6          LDRH     r0,[r0,#0x86]
000394  e3800020          ORR      r0,r0,#0x20
000398  e59f14a4          LDR      r1,|L1.2116|
00039c  e1c108b6          STRH     r0,[r1,#0x86]
;;;265    }
0003a0  e12fff1e          BX       lr
;;;266    
                          ENDP

                  __USBC_Dev_Rx_IsEpStall PROC
;;;267    static u32 __USBC_Dev_Rx_IsEpStall(void)
0003a4  e59f0498          LDR      r0,|L1.2116|
;;;268    {
;;;269    	return USBC_REG_test_bit_w(USBC_BP_RXCSR_D_SENT_STALL, USBC_REG_RXCSR(USBC0_BASE));
0003a8  e1d008b6          LDRH     r0,[r0,#0x86]
0003ac  e2000040          AND      r0,r0,#0x40
;;;270    }
0003b0  e12fff1e          BX       lr
;;;271    
                          ENDP

                  __USBC_Dev_Rx_ClearStall PROC
;;;272    static void __USBC_Dev_Rx_ClearStall(void)
0003b4  e59f1488          LDR      r1,|L1.2116|
;;;273    {
;;;274    	u32 reg_val = USBC_Readw(USBC_REG_RXCSR(USBC0_BASE));
0003b8  e1d108b6          LDRH     r0,[r1,#0x86]
;;;275    	reg_val &= ~((1 << USBC_BP_RXCSR_D_SENT_STALL)|(1 << USBC_BP_RXCSR_D_SEND_STALL)|(1<<USBC_BP_RXCSR_D_OVERRUN));
0003bc  e3c00064          BIC      r0,r0,#0x64
;;;276      reg_val |= (1 << USBC_BP_RXCSR_D_CLEAR_DATA_TOGGLE);
0003c0  e3800080          ORR      r0,r0,#0x80
;;;277    	USBC_Writew(reg_val, USBC_REG_RXCSR(USBC0_BASE));
0003c4  e1c108b6          STRH     r0,[r1,#0x86]
;;;278    }
0003c8  e12fff1e          BX       lr
;;;279    
                          ENDP

                  USBC_Dev_QueryTransferMode PROC
;;;280    static tusb_speed_t USBC_Dev_QueryTransferMode(void)
0003cc  e59f0470          LDR      r0,|L1.2116|
;;;281    {
;;;282    	if (USBC_REG_test_bit_b(USBC_BP_POWER_D_HIGH_SPEED_FLAG, USBC_REG_PCTL(USBC0_BASE)))
0003d0  e5d00040          LDRB     r0,[r0,#0x40]
0003d4  e2000010          AND      r0,r0,#0x10
0003d8  e3500000          CMP      r0,#0
0003dc  0a000001          BEQ      |L1.1000|
;;;283    		return TUSB_SPEED_HIGH;
0003e0  e3a00002          MOV      r0,#2
                  |L1.996|
;;;284      else
;;;285    		return TUSB_SPEED_FULL;
;;;286    }
0003e4  e12fff1e          BX       lr
                  |L1.1000|
0003e8  e3a00000          MOV      r0,#0                 ;285
0003ec  eafffffc          B        |L1.996|
;;;287    
                          ENDP

                  __USBC_Dev_ep0_ReadDataHalf PROC
;;;288    static void __USBC_Dev_ep0_ReadDataHalf(void)
0003f0  e3a00040          MOV      r0,#0x40
;;;289    {
;;;290    	USBC_Writew(1<<USBC_BP_CSR0_D_SERVICED_RX_PKT_READY, USBC_REG_CSR0(USBC0_BASE));
0003f4  e59f1448          LDR      r1,|L1.2116|
0003f8  e1c108b2          STRH     r0,[r1,#0x82]
;;;291    }
0003fc  e12fff1e          BX       lr
;;;292    
                          ENDP

                  __USBC_Dev_ep0_ReadDataComplete PROC
;;;293    static void __USBC_Dev_ep0_ReadDataComplete(void)
000400  e3a00048          MOV      r0,#0x48
;;;294    {
;;;295    	USBC_Writew((1<<USBC_BP_CSR0_D_SERVICED_RX_PKT_READY) | (1<<USBC_BP_CSR0_D_DATA_END),
000404  e59f1438          LDR      r1,|L1.2116|
000408  e1c108b2          STRH     r0,[r1,#0x82]
;;;296    	USBC_REG_CSR0(USBC0_BASE));
;;;297    }
00040c  e12fff1e          BX       lr
;;;298    
                          ENDP

                  __USBC_Dev_ep0_WriteDataHalf PROC
;;;299    
;;;300    static void __USBC_Dev_ep0_WriteDataHalf(void)
000410  e3a00002          MOV      r0,#2
;;;301    {
;;;302    	USBC_Writew(1<<USBC_BP_CSR0_D_TX_PKT_READY, USBC_REG_CSR0(USBC0_BASE));
000414  e59f1428          LDR      r1,|L1.2116|
000418  e1c108b2          STRH     r0,[r1,#0x82]
;;;303    }
00041c  e12fff1e          BX       lr
;;;304    
                          ENDP

                  __USBC_Dev_ep0_WriteDataComplete PROC
;;;305    static void __USBC_Dev_ep0_WriteDataComplete(void)
000420  e3a0000a          MOV      r0,#0xa
;;;306    {
;;;307    	USBC_Writew((1<<USBC_BP_CSR0_D_TX_PKT_READY) | (1<<USBC_BP_CSR0_D_DATA_END),
000424  e59f1418          LDR      r1,|L1.2116|
000428  e1c108b2          STRH     r0,[r1,#0x82]
;;;308    	USBC_REG_CSR0(USBC0_BASE));
;;;309    }
00042c  e12fff1e          BX       lr
;;;310    
                          ENDP

                  __USBC_Dev_Tx_WriteDataComplete PROC
;;;311    static void __USBC_Dev_Tx_WriteDataComplete(void)
000430  e3a00001          MOV      r0,#1
;;;312    {
;;;313    	USBC_Writeb((1 << USBC_BP_TXCSR_D_TX_READY), USBC_REG_TXCSR(USBC0_BASE));
000434  e59f1408          LDR      r1,|L1.2116|
000438  e5c10082          STRB     r0,[r1,#0x82]
;;;314    }
00043c  e12fff1e          BX       lr
;;;315    
                          ENDP

                  __USBC_Dev_Rx_ReadDataComplete PROC
;;;316    static void __USBC_Dev_Rx_ReadDataComplete(void)
000440  e3a00000          MOV      r0,#0
;;;317    {
;;;318    	USBC_Writeb(0, USBC_REG_RXCSR(USBC0_BASE));
000444  e59f13f8          LDR      r1,|L1.2116|
000448  e5c10086          STRB     r0,[r1,#0x86]
;;;319    }
00044c  e12fff1e          BX       lr
;;;320    
                          ENDP

                  __USBC_Dev_Rx_IsReadDataReady PROC
;;;321    static u32 __USBC_Dev_Rx_IsReadDataReady(void)
000450  e59f03ec          LDR      r0,|L1.2116|
;;;322    {
;;;323    	return USBC_REG_test_bit_w(USBC_BP_RXCSR_D_RX_PKT_READY, USBC_REG_RXCSR(USBC0_BASE));
000454  e1d008b6          LDRH     r0,[r0,#0x86]
000458  e2000001          AND      r0,r0,#1
;;;324    }
00045c  e12fff1e          BX       lr
;;;325    
                          ENDP

                  USBC_INT_EnableTxEp PROC
;;;326    /* open a tx ep's interrupt */
;;;327    static void USBC_INT_EnableTxEp(u8 ep_index)
000460  e59f13dc          LDR      r1,|L1.2116|
;;;328    {
;;;329    	USBC_REG_set_bit_w(ep_index, USBC_REG_INTTxE(USBC0_BASE));
000464  e1d114b8          LDRH     r1,[r1,#0x48]
000468  e3a02001          MOV      r2,#1
00046c  e1811012          ORR      r1,r1,r2,LSL r0
000470  e59f23cc          LDR      r2,|L1.2116|
000474  e1c214b8          STRH     r1,[r2,#0x48]
;;;330    }
000478  e12fff1e          BX       lr
;;;331    
                          ENDP

                  USBC_INT_EnableRxEp PROC
;;;332    /* open a rx ep's interrupt */
;;;333    static void USBC_INT_EnableRxEp(u8 ep_index)
00047c  e59f13c0          LDR      r1,|L1.2116|
;;;334    {
;;;335    	USBC_REG_set_bit_w(ep_index, USBC_REG_INTRxE(USBC0_BASE));
000480  e1d114ba          LDRH     r1,[r1,#0x4a]
000484  e3a02001          MOV      r2,#1
000488  e1811012          ORR      r1,r1,r2,LSL r0
00048c  e59f23b0          LDR      r2,|L1.2116|
000490  e1c214ba          STRH     r1,[r2,#0x4a]
;;;336    }
000494  e12fff1e          BX       lr
;;;337    
                          ENDP

                  USBC_INT_DisableTxEp PROC
;;;338    /* close a tx ep's interrupt */
;;;339    static void USBC_INT_DisableTxEp(u8 ep_index)
000498  e59f13a4          LDR      r1,|L1.2116|
;;;340    {
;;;341    	USBC_REG_clear_bit_w(ep_index, USBC_REG_INTTxE(USBC0_BASE));
00049c  e1d114b8          LDRH     r1,[r1,#0x48]
0004a0  e3a02001          MOV      r2,#1
0004a4  e1c11012          BIC      r1,r1,r2,LSL r0
0004a8  e59f2394          LDR      r2,|L1.2116|
0004ac  e1c214b8          STRH     r1,[r2,#0x48]
;;;342    }
0004b0  e12fff1e          BX       lr
;;;343    
                          ENDP

                  USBC_INT_DisableRxEp PROC
;;;344    /* close a rx ep's interrupt */
;;;345    static void USBC_INT_DisableRxEp(u8 ep_index)
0004b4  e59f1388          LDR      r1,|L1.2116|
;;;346    {
;;;347    	USBC_REG_clear_bit_w(ep_index, USBC_REG_INTRxE(USBC0_BASE));
0004b8  e1d114ba          LDRH     r1,[r1,#0x4a]
0004bc  e3a02001          MOV      r2,#1
0004c0  e1c11012          BIC      r1,r1,r2,LSL r0
0004c4  e59f2378          LDR      r2,|L1.2116|
0004c8  e1c214ba          STRH     r1,[r2,#0x4a]
;;;348    }
0004cc  e12fff1e          BX       lr
;;;349    
                          ENDP

                  update_free_block_list PROC
;;;362    
;;;363    static inline int update_free_block_list(free_block_t *blks, unsigned num, uint_fast16_t addr, uint_fast16_t size)
0004d0  e92d41fc          PUSH     {r2-r8,lr}
;;;364    {
0004d4  e1a05000          MOV      r5,r0
0004d8  e1a06001          MOV      r6,r1
0004dc  e1a07002          MOV      r7,r2
0004e0  e1a08003          MOV      r8,r3
;;;365      free_block_t *p = find_containing_block(blks, blks + num, addr);
0004e4  e1a01005          MOV      r1,r5
0004e8  e0853186          ADD      r3,r5,r6,LSL #3
0004ec  e1a02007          MOV      r2,r7
0004f0  e1a00001          MOV      r0,r1
0004f4  ea000000          B        |L1.1276|
                  |L1.1272|
0004f8  e2800008          ADD      r0,r0,#8
                  |L1.1276|
0004fc  e1500003          CMP      r0,r3
000500  2a000005          BCS      |L1.1308|
000504  e590c000          LDR      r12,[r0,#0]
000508  e15c0002          CMP      r12,r2
00050c  8afffff9          BHI      |L1.1272|
000510  e590c004          LDR      r12,[r0,#4]
000514  e15c0002          CMP      r12,r2
000518  9afffff6          BLS      |L1.1272|
                  |L1.1308|
00051c  e1a00000          MOV      r0,r0
000520  e1a04000          MOV      r4,r0
;;;366      TU_ASSERT(p != blks + num, -2);
000524  e1a00000          MOV      r0,r0
000528  e0850186          ADD      r0,r5,r6,LSL #3
00052c  e1500004          CMP      r0,r4
000530  1a000007          BNE      |L1.1364|
000534  e59f230c          LDR      r2,|L1.2120|
000538  e59f130c          LDR      r1,|L1.2124|
00053c  e28f0fc3          ADR      r0,|L1.2128|
000540  ebfffffe          BL       __2printf
000544  e1a00000          MOV      r0,r0
000548  e1a00000          MOV      r0,r0
00054c  e3e00001          MVN      r0,#1
                  |L1.1360|
;;;367      if (p->beg == addr) {
;;;368        /* Shrink block */
;;;369        p->beg = addr + size;
;;;370        if (p->beg != p->end) return 0;
;;;371        /* remove block */
;;;372        free_block_t *end = blks + num;
;;;373        while (p + 1 < end) {
;;;374          *p = *(p + 1);
;;;375          ++p;
;;;376        }
;;;377        return -1;
;;;378      } else {
;;;379        /* Split into 2 blocks */
;;;380        free_block_t tmp = {
;;;381          .beg = addr + size,
;;;382          .end = p->end
;;;383        };
;;;384        p->end = addr;
;;;385        if (p->beg == p->end) {
;;;386          if (tmp.beg != tmp.end) {
;;;387            *p = tmp;
;;;388            return 0;
;;;389          }
;;;390          /* remove block */
;;;391          free_block_t *end = blks + num;
;;;392          while (p + 1 < end) {
;;;393            *p = *(p + 1);
;;;394            ++p;
;;;395          }
;;;396          return -1;
;;;397        }
;;;398        if (tmp.beg == tmp.end) return 0;
;;;399        blks[num] = tmp;
;;;400        return 1;
;;;401      }
;;;402    }
000550  e8bd81fc          POP      {r2-r8,pc}
                  |L1.1364|
000554  e1a00000          MOV      r0,r0                 ;366
000558  e5940000          LDR      r0,[r4,#0]            ;367
00055c  e1500007          CMP      r0,r7                 ;367
000560  1a000011          BNE      |L1.1452|
000564  e0870008          ADD      r0,r7,r8              ;369
000568  e5840000          STR      r0,[r4,#0]            ;369
00056c  e8940005          LDM      r4,{r0,r2}            ;370
000570  e1500002          CMP      r0,r2                 ;370
000574  0a000001          BEQ      |L1.1408|
000578  e3a00000          MOV      r0,#0                 ;370
00057c  eafffff3          B        |L1.1360|
                  |L1.1408|
000580  e0851186          ADD      r1,r5,r6,LSL #3       ;372
000584  ea000003          B        |L1.1432|
                  |L1.1416|
000588  e5940008          LDR      r0,[r4,#8]            ;374
00058c  e594200c          LDR      r2,[r4,#0xc]          ;374
000590  e8840005          STM      r4,{r0,r2}            ;374
000594  e2844008          ADD      r4,r4,#8              ;375
                  |L1.1432|
000598  e2840008          ADD      r0,r4,#8              ;373
00059c  e1500001          CMP      r0,r1                 ;373
0005a0  3afffff8          BCC      |L1.1416|
0005a4  e3e00000          MVN      r0,#0                 ;377
0005a8  eaffffe8          B        |L1.1360|
                  |L1.1452|
0005ac  e1a00000          MOV      r0,r0                 ;378
0005b0  e0870008          ADD      r0,r7,r8              ;380
0005b4  e58d0000          STR      r0,[sp,#0]            ;380
0005b8  e5940004          LDR      r0,[r4,#4]            ;380
0005bc  e58d0004          STR      r0,[sp,#4]            ;380
0005c0  e5847004          STR      r7,[r4,#4]            ;384
0005c4  e8940003          LDM      r4,{r0,r1}            ;385
0005c8  e1500001          CMP      r0,r1                 ;385
0005cc  1a000011          BNE      |L1.1560|
0005d0  e89d0005          LDM      sp,{r0,r2}            ;386
0005d4  e1500002          CMP      r0,r2                 ;386
0005d8  0a000003          BEQ      |L1.1516|
0005dc  e89d0005          LDM      sp,{r0,r2}            ;387
0005e0  e8840005          STM      r4,{r0,r2}            ;387
0005e4  e3a00000          MOV      r0,#0                 ;388
0005e8  eaffffd8          B        |L1.1360|
                  |L1.1516|
0005ec  e0851186          ADD      r1,r5,r6,LSL #3       ;391
0005f0  ea000003          B        |L1.1540|
                  |L1.1524|
0005f4  e5940008          LDR      r0,[r4,#8]            ;393
0005f8  e594200c          LDR      r2,[r4,#0xc]          ;393
0005fc  e8840005          STM      r4,{r0,r2}            ;393
000600  e2844008          ADD      r4,r4,#8              ;394
                  |L1.1540|
000604  e2840008          ADD      r0,r4,#8              ;392
000608  e1500001          CMP      r0,r1                 ;392
00060c  3afffff8          BCC      |L1.1524|
000610  e3e00000          MVN      r0,#0                 ;396
000614  eaffffcd          B        |L1.1360|
                  |L1.1560|
000618  e1a00000          MOV      r0,r0                 ;397
00061c  e1cd00d0          LDRD     r0,r1,[sp,#0]         ;398
000620  e1500001          CMP      r0,r1                 ;398
000624  1a000001          BNE      |L1.1584|
000628  e3a00000          MOV      r0,#0                 ;398
00062c  eaffffc7          B        |L1.1360|
                  |L1.1584|
000630  e0850186          ADD      r0,r5,r6,LSL #3       ;399
000634  e89d0006          LDM      sp,{r1,r2}            ;399
000638  e8800006          STM      r0,{r1,r2}            ;399
00063c  e3a00001          MOV      r0,#1                 ;400
000640  eaffffc2          B        |L1.1360|
;;;403    
                          ENDP

                  find_free_memory PROC
;;;427    
;;;428    static unsigned find_free_memory(uint_fast16_t size_in_log2_minus3)
000644  e92d4ff0          PUSH     {r4-r11,lr}
;;;429    {
000648  e24dd044          SUB      sp,sp,#0x44
00064c  e1a0a000          MOV      r10,r0
;;;430      free_block_t free_blocks[2 * (TUP_DCD_ENDPOINT_MAX - 1)];
;;;431      unsigned num_blocks = 1;
000650  e3a05001          MOV      r5,#1
;;;432      /* Backup current EP to restore later */
;;;433      u8 backup_ep = USBC_GetActiveEp();
000654  ebfffffe          BL       USBC_GetActiveEp
000658  e58d0010          STR      r0,[sp,#0x10]
;;;434    
;;;435      /* Initialize free memory block list */
;;;436      free_blocks[0].beg = 64 / 8;
00065c  e3a00008          MOV      r0,#8
000660  e58d0014          STR      r0,[sp,#0x14]
;;;437      free_blocks[0].end = (USB_FIFO_SIZE_KB << 10) / 8; /* 2KiB / 8 bytes */
000664  e3a00c02          MOV      r0,#0x200
000668  e58d0018          STR      r0,[sp,#0x18]
;;;438      for (int i = 1; i < TUP_DCD_ENDPOINT_MAX; ++i) {
00066c  e3a08001          MOV      r8,#1
000670  ea000041          B        |L1.1916|
                  |L1.1652|
;;;439        uint_fast16_t addr;
;;;440        int num;
;;;441        USBC_SelectActiveEp(i);
000674  e20800ff          AND      r0,r8,#0xff
000678  ebfffffe          BL       USBC_SelectActiveEp
;;;442        addr = USBC_Readw(USBC_REG_TXFIFOAD(USBC0_BASE));
00067c  e59f01c0          LDR      r0,|L1.2116|
000680  e1d099b2          LDRH     r9,[r0,#0x92]
;;;443        if (addr) {
000684  e3590000          CMP      r9,#0
000688  0a00001b          BEQ      |L1.1788|
;;;444          unsigned sz  = USBC_Readb(USBC_REG_TXFIFOSZ(USBC0_BASE));
00068c  e5d0b090          LDRB     r11,[r0,#0x90]
;;;445          unsigned sft = (sz & USB_TXFIFOSZ_SIZE_M) + ((sz & USB_TXFIFOSZ_DPB) ? 1: 0);
000690  e20b000f          AND      r0,r11,#0xf
000694  e20b1010          AND      r1,r11,#0x10
000698  e0800221          ADD      r0,r0,r1,LSR #4
00069c  e58d0004          STR      r0,[sp,#4]
;;;446          num = update_free_block_list(free_blocks, num_blocks, addr, 1 << sft);
0006a0  e3a01001          MOV      r1,#1
0006a4  e59d0004          LDR      r0,[sp,#4]
0006a8  e1a03011          LSL      r3,r1,r0
0006ac  e1a02009          MOV      r2,r9
0006b0  e1a01005          MOV      r1,r5
0006b4  e28d0014          ADD      r0,sp,#0x14
0006b8  ebfffffe          BL       update_free_block_list
0006bc  e1a04000          MOV      r4,r0
;;;447          TU_ASSERT(-2 < num, 0);
0006c0  e1a00000          MOV      r0,r0
0006c4  e3740002          CMN      r4,#2
0006c8  ca000008          BGT      |L1.1776|
0006cc  e59f2194          LDR      r2,|L1.2152|
0006d0  e59f1194          LDR      r1,|L1.2156|
0006d4  e28f0f5d          ADR      r0,|L1.2128|
0006d8  ebfffffe          BL       __2printf
0006dc  e1a00000          MOV      r0,r0
0006e0  e1a00000          MOV      r0,r0
0006e4  e3a00000          MOV      r0,#0
                  |L1.1768|
0006e8  e28dd044          ADD      sp,sp,#0x44
;;;448          num_blocks += num;
;;;449          print_block_list(free_blocks, num_blocks);
;;;450        }
;;;451        addr = USBC_Readw(USBC_REG_RXFIFOAD(USBC0_BASE));
;;;452        if (addr) {
;;;453          unsigned sz  = USBC_Readb(USBC_REG_RXFIFOSZ(USBC0_BASE));
;;;454          unsigned sft = (sz & USB_RXFIFOSZ_SIZE_M) + ((sz & USB_RXFIFOSZ_DPB) ? 1: 0);
;;;455          num = update_free_block_list(free_blocks, num_blocks, addr, 1 << sft);
;;;456          TU_ASSERT(-2 < num, 0);
;;;457          num_blocks += num;
;;;458          print_block_list(free_blocks, num_blocks);
;;;459        }
;;;460      }
;;;461      print_block_list(free_blocks, num_blocks);
;;;462    
;;;463      USBC_SelectActiveEp(backup_ep);
;;;464    
;;;465      /* Find the best fit memory block */
;;;466      uint_fast16_t size_in_8byte_unit = 1 << size_in_log2_minus3;
;;;467      free_block_t const *min = NULL;
;;;468      uint_fast16_t    min_sz = 0xFFFFu;
;;;469      free_block_t const *end = &free_blocks[num_blocks];
;;;470      for (free_block_t const *cur = &free_blocks[0]; cur < end; ++cur) {
;;;471        uint_fast16_t sz = free_block_size(cur);
;;;472        if (sz < size_in_8byte_unit) continue;
;;;473        if (size_in_8byte_unit == sz) return cur->beg;
;;;474        if (sz < min_sz) min = cur;
;;;475      }
;;;476      TU_ASSERT(min, 0);
;;;477      return min->beg;
;;;478    }
0006ec  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.1776|
0006f0  e1a00000          MOV      r0,r0                 ;447
0006f4  e0855004          ADD      r5,r5,r4              ;448
0006f8  e1a00000          MOV      r0,r0                 ;450
                  |L1.1788|
0006fc  e59f0140          LDR      r0,|L1.2116|
000700  e1d099b6          LDRH     r9,[r0,#0x96]         ;451
000704  e3590000          CMP      r9,#0                 ;452
000708  0a00001a          BEQ      |L1.1912|
00070c  e5d0b094          LDRB     r11,[r0,#0x94]        ;453
000710  e20b000f          AND      r0,r11,#0xf           ;454
000714  e20b1010          AND      r1,r11,#0x10          ;454
000718  e0800221          ADD      r0,r0,r1,LSR #4       ;454
00071c  e58d0004          STR      r0,[sp,#4]            ;454
000720  e3a01001          MOV      r1,#1                 ;455
000724  e59d0004          LDR      r0,[sp,#4]            ;455
000728  e1a03011          LSL      r3,r1,r0              ;455
00072c  e1a02009          MOV      r2,r9                 ;455
000730  e1a01005          MOV      r1,r5                 ;455
000734  e28d0014          ADD      r0,sp,#0x14           ;455
000738  ebfffffe          BL       update_free_block_list
00073c  e1a04000          MOV      r4,r0                 ;455
000740  e1a00000          MOV      r0,r0                 ;456
000744  e3740002          CMN      r4,#2                 ;456
000748  ca000007          BGT      |L1.1900|
00074c  e3a02f72          MOV      r2,#0x1c8             ;456
000750  e59f1114          LDR      r1,|L1.2156|
000754  e28f00f4          ADR      r0,|L1.2128|
000758  ebfffffe          BL       __2printf
00075c  e1a00000          MOV      r0,r0                 ;456
000760  e1a00000          MOV      r0,r0                 ;456
000764  e3a00000          MOV      r0,#0                 ;456
000768  eaffffde          B        |L1.1768|
                  |L1.1900|
00076c  e1a00000          MOV      r0,r0                 ;456
000770  e0855004          ADD      r5,r5,r4              ;457
000774  e1a00000          MOV      r0,r0                 ;459
                  |L1.1912|
000778  e2888001          ADD      r8,r8,#1              ;438
                  |L1.1916|
00077c  e3580004          CMP      r8,#4                 ;438
000780  baffffbb          BLT      |L1.1652|
000784  e59d0010          LDR      r0,[sp,#0x10]         ;463
000788  ebfffffe          BL       USBC_SelectActiveEp
00078c  e3a00001          MOV      r0,#1                 ;466
000790  e1a06a10          LSL      r6,r0,r10             ;466
000794  e3a07000          MOV      r7,#0                 ;467
000798  e0600800          RSB      r0,r0,r0,LSL #16      ;468
00079c  e58d000c          STR      r0,[sp,#0xc]          ;468
0007a0  e28d0014          ADD      r0,sp,#0x14           ;469
0007a4  e0800185          ADD      r0,r0,r5,LSL #3       ;469
0007a8  e58d0008          STR      r0,[sp,#8]            ;469
0007ac  e28d1014          ADD      r1,sp,#0x14           ;470
0007b0  ea000011          B        |L1.2044|
                  |L1.1972|
0007b4  e1a00000          MOV      r0,r0                 ;471
0007b8  e5910004          LDR      r0,[r1,#4]            ;471
0007bc  e5913000          LDR      r3,[r1,#0]            ;471
0007c0  e0400003          SUB      r0,r0,r3              ;471
0007c4  e1a02000          MOV      r2,r0                 ;471
0007c8  e1520006          CMP      r2,r6                 ;472
0007cc  2a000000          BCS      |L1.2004|
0007d0  ea000008          B        |L1.2040|
                  |L1.2004|
0007d4  e1560002          CMP      r6,r2                 ;473
0007d8  1a000001          BNE      |L1.2020|
0007dc  e5910000          LDR      r0,[r1,#0]            ;473
0007e0  eaffffc0          B        |L1.1768|
                  |L1.2020|
0007e4  e59d000c          LDR      r0,[sp,#0xc]          ;474
0007e8  e1520000          CMP      r2,r0                 ;474
0007ec  2a000000          BCS      |L1.2036|
0007f0  e1a07001          MOV      r7,r1                 ;474
                  |L1.2036|
0007f4  e1a00000          MOV      r0,r0                 ;472
                  |L1.2040|
0007f8  e2811008          ADD      r1,r1,#8              ;470
                  |L1.2044|
0007fc  e59d0008          LDR      r0,[sp,#8]            ;470
000800  e1510000          CMP      r1,r0                 ;470
000804  3affffea          BCC      |L1.1972|
000808  e1a00000          MOV      r0,r0                 ;476
00080c  e3570000          CMP      r7,#0                 ;476
000810  1a000016          BNE      |L1.2160|
000814  e3a02f77          MOV      r2,#0x1dc             ;476
000818  e59f104c          LDR      r1,|L1.2156|
00081c  e28f002c          ADR      r0,|L1.2128|
000820  ebfffffe          BL       __2printf
000824  e1a00000          MOV      r0,r0                 ;476
000828  e1a00000          MOV      r0,r0                 ;476
00082c  e3a00000          MOV      r0,#0                 ;476
000830  eaffffac          B        |L1.1768|
                  |L1.2100|
                          DCD      0x01c13410
                  |L1.2104|
                          DCD      0x0000fffe
                  |L1.2108|
                          DCD      0x01c20000
                  |L1.2112|
                          DCD      0x01c13400
                  |L1.2116|
                          DCD      0x01c13000
                  |L1.2120|
                          DCD      0x0000016e
                  |L1.2124|
                          DCD      __func__
                  |L1.2128|
000850  25732025          DCB      "%s %d: ASSERT FAILED\r\n",0
000854  643a2041
000858  53534552
00085c  54204641
000860  494c4544
000864  0d0a00  
000867  00                DCB      0
                  |L1.2152|
                          DCD      0x000001bf
                  |L1.2156|
                          DCD      |symbol_number.16|
                  |L1.2160|
000870  e1a00000          MOV      r0,r0                 ;476
000874  e5970000          LDR      r0,[r7,#0]            ;477
000878  eaffff9a          B        |L1.1768|
;;;479    
                          ENDP

                  pipe_write_packet PROC
;;;480    static void pipe_write_packet(void *buff, volatile void *fifo, unsigned cnt)
00087c  e92d41f0          PUSH     {r4-r8,lr}
;;;481    {
000880  e1a03000          MOV      r3,r0
;;;482     	u32 len = 0;
000884  e3a0c000          MOV      r12,#0
;;;483    	u32 i32 = 0;
000888  e3a05000          MOV      r5,#0
;;;484    	u32 i8  = 0;
00088c  e3a06000          MOV      r6,#0
;;;485    	u8  *buf8  = 0;
000890  e3a04000          MOV      r4,#0
;;;486    	u32 *buf32 = 0;
000894  e3a00000          MOV      r0,#0
;;;487    
;;;488    	//--<1>-- adjust data
;;;489    	buf32 = buff;
000898  e1a00003          MOV      r0,r3
;;;490    	len   = cnt;
00089c  e1a0c002          MOV      r12,r2
;;;491    
;;;492    	i32 = len >> 2;
0008a0  e1a0512c          LSR      r5,r12,#2
;;;493    	i8  = len & 0x03;
0008a4  e20c6003          AND      r6,r12,#3
;;;494    
;;;495    	//--<2>-- deal with 4byte part
;;;496    	while (i32--) {
0008a8  ea000001          B        |L1.2228|
                  |L1.2220|
;;;497    		USBC_Writel(*buf32++, fifo);
0008ac  e4907004          LDR      r7,[r0],#4
0008b0  e5817000          STR      r7,[r1,#0]
                  |L1.2228|
0008b4  e2557000          SUBS     r7,r5,#0              ;496
0008b8  e2455001          SUB      r5,r5,#1              ;496
0008bc  1afffffa          BNE      |L1.2220|
;;;498    	}
;;;499    
;;;500    	//--<3>-- deal with no 4byte part
;;;501    	buf8 = (u8 *)buf32;
0008c0  e1a04000          MOV      r4,r0
;;;502    	while (i8--) {
0008c4  ea000001          B        |L1.2256|
                  |L1.2248|
;;;503    		USBC_Writeb(*buf8++, fifo);
0008c8  e4d47001          LDRB     r7,[r4],#1
0008cc  e5c17000          STRB     r7,[r1,#0]
                  |L1.2256|
0008d0  e2567000          SUBS     r7,r6,#0              ;502
0008d4  e2466001          SUB      r6,r6,#1              ;502
0008d8  1afffffa          BNE      |L1.2248|
;;;504    	}
;;;505    }
0008dc  e8bd81f0          POP      {r4-r8,pc}
;;;506    
                          ENDP

                  pipe_read_packet PROC
;;;507    static void pipe_read_packet(void *buff, volatile void *fifo, unsigned cnt)
0008e0  e92d41f0          PUSH     {r4-r8,lr}
;;;508    {
0008e4  e1a03000          MOV      r3,r0
;;;509    	u32 len = 0;
0008e8  e3a0c000          MOV      r12,#0
;;;510    	u32 i32 = 0;
0008ec  e3a05000          MOV      r5,#0
;;;511    	u32 i8  = 0;
0008f0  e3a06000          MOV      r6,#0
;;;512    	u8  *buf8  = 0;
0008f4  e3a04000          MOV      r4,#0
;;;513    	u32 *buf32 = 0;
0008f8  e3a00000          MOV      r0,#0
;;;514    
;;;515    	//--<1>-- adjust data
;;;516    	buf32 = buff;
0008fc  e1a00003          MOV      r0,r3
;;;517    	len   = cnt;
000900  e1a0c002          MOV      r12,r2
;;;518    
;;;519    	i32 = len >> 2;
000904  e1a0512c          LSR      r5,r12,#2
;;;520    	i8  = len & 0x03;
000908  e20c6003          AND      r6,r12,#3
;;;521    
;;;522    	//--<2>-- deal with 4byte part
;;;523    	while (i32--) {
00090c  ea000001          B        |L1.2328|
                  |L1.2320|
;;;524    		*buf32++ = USBC_Readl(fifo);
000910  e5917000          LDR      r7,[r1,#0]
000914  e4807004          STR      r7,[r0],#4
                  |L1.2328|
000918  e2557000          SUBS     r7,r5,#0              ;523
00091c  e2455001          SUB      r5,r5,#1              ;523
000920  1afffffa          BNE      |L1.2320|
;;;525    	}
;;;526    
;;;527    	//--<3>-- deal with no 4byte part
;;;528    	buf8 = (u8 *)buf32;
000924  e1a04000          MOV      r4,r0
;;;529    	while (i8--) {
000928  ea000001          B        |L1.2356|
                  |L1.2348|
;;;530    		*buf8++ = USBC_Readb(fifo);
00092c  e5d17000          LDRB     r7,[r1,#0]
000930  e4c47001          STRB     r7,[r4],#1
                  |L1.2356|
000934  e2567000          SUBS     r7,r6,#0              ;529
000938  e2466001          SUB      r6,r6,#1              ;529
00093c  1afffffa          BNE      |L1.2348|
;;;531    	}
;;;532    }
000940  e8bd81f0          POP      {r4-r8,pc}
;;;533    
                          ENDP

                  pipe_read_write_packet_ff PROC
;;;534    static void pipe_read_write_packet_ff(tu_fifo_t *f, volatile void *fifo, unsigned len, unsigned dir)
000944  e92d43fe          PUSH     {r1-r9,lr}
;;;535    {
000948  e1a08000          MOV      r8,r0
00094c  e1a09001          MOV      r9,r1
000950  e1a04002          MOV      r4,r2
000954  e1a05003          MOV      r5,r3
;;;536      static const struct {
;;;537        void (*tu_fifo_get_info)(tu_fifo_t *f, tu_fifo_buffer_info_t *info);
;;;538        void (*tu_fifo_advance)(tu_fifo_t *f, uint16_t n);
;;;539        void (*pipe_read_write)(void *buf, volatile void *fifo, unsigned len);
;;;540      } ops[] = {
;;;541        /* OUT */ {tu_fifo_get_write_info,tu_fifo_advance_write_pointer,pipe_read_packet},
;;;542        /* IN  */ {tu_fifo_get_read_info, tu_fifo_advance_read_pointer, pipe_write_packet},
;;;543      };
;;;544      tu_fifo_buffer_info_t info;
;;;545      ops[dir].tu_fifo_get_info(f, &info);
000958  e0850085          ADD      r0,r5,r5,LSL #1
00095c  e59f1880          LDR      r1,|L1.4580|
000960  e7912100          LDR      r2,[r1,r0,LSL #2]
000964  e1a0100d          MOV      r1,sp
000968  e1a00008          MOV      r0,r8
00096c  e12fff32          BLX      r2
;;;546      unsigned total_len = len;
000970  e1a07004          MOV      r7,r4
;;;547      len = TU_MIN(total_len, info.len_lin);
000974  e1dd00b0          LDRH     r0,[sp,#0]
000978  e1500007          CMP      r0,r7
00097c  9a000001          BLS      |L1.2440|
000980  e1a00007          MOV      r0,r7
000984  ea000000          B        |L1.2444|
                  |L1.2440|
000988  e1dd00b0          LDRH     r0,[sp,#0]
                  |L1.2444|
00098c  e1a04000          MOV      r4,r0
;;;548      ops[dir].pipe_read_write(info.ptr_lin, fifo, len);
000990  e0851085          ADD      r1,r5,r5,LSL #1
000994  e59f2848          LDR      r2,|L1.4580|
000998  e0821101          ADD      r1,r2,r1,LSL #2
00099c  e59d0004          LDR      r0,[sp,#4]
0009a0  e1a02004          MOV      r2,r4
0009a4  e5913008          LDR      r3,[r1,#8]
0009a8  e1a01009          MOV      r1,r9
0009ac  e12fff33          BLX      r3
;;;549      unsigned rem = total_len - len;
0009b0  e0476004          SUB      r6,r7,r4
;;;550      if (rem) {
0009b4  e3560000          CMP      r6,#0
0009b8  0a00000f          BEQ      |L1.2556|
;;;551        len = TU_MIN(rem, info.len_wrap);
0009bc  e1dd00b2          LDRH     r0,[sp,#2]
0009c0  e1500006          CMP      r0,r6
0009c4  9a000001          BLS      |L1.2512|
0009c8  e1a00006          MOV      r0,r6
0009cc  ea000000          B        |L1.2516|
                  |L1.2512|
0009d0  e1dd00b2          LDRH     r0,[sp,#2]
                  |L1.2516|
0009d4  e1a04000          MOV      r4,r0
;;;552        ops[dir].pipe_read_write(info.ptr_wrap, fifo, len);
0009d8  e0851085          ADD      r1,r5,r5,LSL #1
0009dc  e59f2800          LDR      r2,|L1.4580|
0009e0  e0821101          ADD      r1,r2,r1,LSL #2
0009e4  e59d0008          LDR      r0,[sp,#8]
0009e8  e1a02004          MOV      r2,r4
0009ec  e5913008          LDR      r3,[r1,#8]
0009f0  e1a01009          MOV      r1,r9
0009f4  e12fff33          BLX      r3
;;;553        rem -= len;
0009f8  e0466004          SUB      r6,r6,r4
                  |L1.2556|
;;;554      }
;;;555      ops[dir].tu_fifo_advance(f, total_len - rem);
0009fc  e0470006          SUB      r0,r7,r6
000a00  e1a01800          LSL      r1,r0,#16
000a04  e1a01821          LSR      r1,r1,#16
000a08  e0850085          ADD      r0,r5,r5,LSL #1
000a0c  e59f37d0          LDR      r3,|L1.4580|
000a10  e0830100          ADD      r0,r3,r0,LSL #2
000a14  e5902004          LDR      r2,[r0,#4]
000a18  e1a00008          MOV      r0,r8
000a1c  e12fff32          BLX      r2
;;;556    }
000a20  e8bd83fe          POP      {r1-r9,pc}
;;;557    
                          ENDP

                  process_setup_packet PROC
;;;561    
;;;562    static void process_setup_packet(uint8_t rhport)
000a24  e92d43fe          PUSH     {r1-r9,lr}
;;;563    {
000a28  e1a04000          MOV      r4,r0
;;;564      uint32_t *p = (uint32_t*)&_dcd.setup_packet;
000a2c  e59f67b4          LDR      r6,|L1.4584|
;;;565      p[0]        = USBC_Readl(USBC_REG_EPFIFO0(USBC0_BASE));
000a30  e51f01f4          LDR      r0,|L1.2116|
000a34  e5900000          LDR      r0,[r0,#0]
000a38  e5860000          STR      r0,[r6,#0]
;;;566      p[1]        = USBC_Readl(USBC_REG_EPFIFO0(USBC0_BASE));
000a3c  e51f0200          LDR      r0,|L1.2116|
000a40  e5900000          LDR      r0,[r0,#0]
000a44  e5860004          STR      r0,[r6,#4]
;;;567    
;;;568      _dcd.pipe0.buf       = NULL;
000a48  e286100b          ADD      r1,r6,#0xb
000a4c  e3a00000          MOV      r0,#0
000a50  ebfffffe          BL       __aeabi_uwrite4
;;;569      _dcd.pipe0.length    = 0;
000a54  e3a00000          MOV      r0,#0
000a58  e2861000          ADD      r1,r6,#0
000a5c  e5c1000f          STRB     r0,[r1,#0xf]
000a60  e5c10010          STRB     r0,[r1,#0x10]
;;;570      _dcd.pipe0.remaining = 0;
000a64  e5c10011          STRB     r0,[r1,#0x11]
000a68  e5c10012          STRB     r0,[r1,#0x12]
;;;571      dcd_event_setup_received(rhport, (const uint8_t*)(uintptr_t)&_dcd.setup_packet, true);
000a6c  e2817000          ADD      r7,r1,#0
000a70  e3a08001          MOV      r8,#1
000a74  e59f2770          LDR      r2,|L1.4588|
000a78  e8920007          LDM      r2,{r0-r2}  ; <Data2>, <Data2>, <Data2>
000a7c  e88d0007          STM      sp,{r0-r2}
000a80  e5cd4000          STRB     r4,[sp,#0]
000a84  e3a02008          MOV      r2,#8
000a88  e1a01007          MOV      r1,r7
000a8c  e28d0004          ADD      r0,sp,#4
000a90  ebfffffe          BL       __aeabi_memcpy
000a94  e1a01008          MOV      r1,r8
000a98  e1a0000d          MOV      r0,sp
000a9c  ebfffffe          BL       dcd_event_handler
000aa0  e1a00000          MOV      r0,r0
;;;572    
;;;573      const unsigned len    = _dcd.setup_packet.wLength;
000aa4  e2860000          ADD      r0,r6,#0
000aa8  e1d050b6          LDRH     r5,[r0,#6]  ; _dcd
;;;574      _dcd.remaining_ctrl   = len;
000aac  e1c050b8          STRH     r5,[r0,#8]  ; _dcd
;;;575      const unsigned dir_in = tu_edpt_dir(_dcd.setup_packet.bmRequestType);
000ab0  e2801000          ADD      r1,r0,#0
000ab4  e5d10000          LDRB     r0,[r1,#0]  ; _dcd
000ab8  e2001080          AND      r1,r0,#0x80
000abc  e1a013a1          LSR      r1,r1,#7
000ac0  e1a09001          MOV      r9,r1
;;;576      /* Clear RX FIFO and reverse the transaction direction */
;;;577      if (len && dir_in) __USBC_Dev_ep0_ReadDataHalf();
000ac4  e3550000          CMP      r5,#0
000ac8  0a000002          BEQ      |L1.2776|
000acc  e3590000          CMP      r9,#0
000ad0  0a000000          BEQ      |L1.2776|
000ad4  ebfffffe          BL       __USBC_Dev_ep0_ReadDataHalf
                  |L1.2776|
;;;578    }
000ad8  e8bd83fe          POP      {r1-r9,pc}
;;;579    
                          ENDP

                  handle_xfer_in PROC
;;;580    static bool handle_xfer_in(uint_fast8_t ep_addr)
000adc  e92d5ff0          PUSH     {r4-r12,lr}
;;;581    {
000ae0  e1a04000          MOV      r4,r0
;;;582      unsigned epnum_minus1 = tu_edpt_number(ep_addr) - 1;
000ae4  e20400ff          AND      r0,r4,#0xff
000ae8  e3c01080          BIC      r1,r0,#0x80
000aec  e2417001          SUB      r7,r1,#1
;;;583      pipe_state_t  *pipe = &_dcd.pipe[tu_edpt_dir(ep_addr)][epnum_minus1];
000af0  e1a00000          MOV      r0,r0
000af4  e2040080          AND      r0,r4,#0x80
000af8  e1a003a0          LSR      r0,r0,#7
000afc  e0600180          RSB      r0,r0,r0,LSL #3
000b00  e59f16e8          LDR      r1,|L1.4592|
000b04  e0810180          ADD      r0,r1,r0,LSL #3
000b08  e0805187          ADD      r5,r0,r7,LSL #3
;;;584      const unsigned rem  = pipe->remaining;
000b0c  e5d50007          LDRB     r0,[r5,#7]
000b10  e5d51006          LDRB     r1,[r5,#6]
000b14  e1818400          ORR      r8,r1,r0,LSL #8
;;;585    
;;;586      if (!rem) {
000b18  e3580000          CMP      r8,#0
000b1c  1a000004          BNE      |L1.2868|
;;;587        pipe->buf = NULL;
000b20  e1a01005          MOV      r1,r5
000b24  e3a00000          MOV      r0,#0
000b28  ebfffffe          BL       __aeabi_uwrite4
;;;588        return true;
000b2c  e3a00001          MOV      r0,#1
                  |L1.2864|
;;;589      }
;;;590    
;;;591      const unsigned mps = USBC_Readw(USBC_REG_TXMAXP(USBC0_BASE));
;;;592      const unsigned len = TU_MIN(mps, rem);
;;;593      uint8_t          *buf = pipe->buf;
;;;594      // TU_LOG1("   %p mps %d len %d rem %d\n", buf, mps, len, rem);
;;;595      if (len) {
;;;596        volatile void* addr = (volatile void*)(USBC_REG_EPFIFO1(USBC0_BASE) + (epnum_minus1 << 2));
;;;597        if (_dcd.pipe_buf_is_fifo[TUSB_DIR_IN] & TU_BIT(epnum_minus1)) {
;;;598          pipe_read_write_packet_ff((tu_fifo_t *)buf, addr, len, TUSB_DIR_IN);
;;;599        } else {
;;;600          pipe_write_packet(buf, addr, len);
;;;601          pipe->buf       = buf + len;
;;;602        }
;;;603        pipe->remaining = rem - len;
;;;604      }
;;;605      __USBC_Dev_Tx_WriteDataComplete();
;;;606      // TU_LOG1(" TXCSRL%d = %x %d\n", epnum_minus1 + 1, regs->TXCSRL, rem - len);
;;;607      return false;
;;;608    }
000b30  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.2868|
000b34  e51f02f8          LDR      r0,|L1.2116|
000b38  e1d0a8b0          LDRH     r10,[r0,#0x80]        ;591
000b3c  e15a0008          CMP      r10,r8                ;592
000b40  2a000001          BCS      |L1.2892|
000b44  e1a0000a          MOV      r0,r10                ;592
000b48  ea000000          B        |L1.2896|
                  |L1.2892|
000b4c  e1a00008          MOV      r0,r8                 ;592
                  |L1.2896|
000b50  e1a06000          MOV      r6,r0                 ;592
000b54  e1a00005          MOV      r0,r5                 ;593
000b58  ebfffffe          BL       __aeabi_uread4
000b5c  e1a09000          MOV      r9,r0                 ;593
000b60  e3560000          CMP      r6,#0                 ;595
000b64  0a00001b          BEQ      |L1.3032|
000b68  e59f0684          LDR      r0,|L1.4596|
000b6c  e080b107          ADD      r11,r0,r7,LSL #2      ;596
000b70  e59f0670          LDR      r0,|L1.4584|
000b74  e1d008b6          LDRH     r0,[r0,#0x86]         ;597
000b78  e3a01001          MOV      r1,#1                 ;597
000b7c  e0000711          AND      r0,r0,r1,LSL r7       ;597
000b80  e3500000          CMP      r0,#0                 ;597
000b84  0a000005          BEQ      |L1.2976|
000b88  e3a03001          MOV      r3,#1                 ;598
000b8c  e1a02006          MOV      r2,r6                 ;598
000b90  e1a0100b          MOV      r1,r11                ;598
000b94  e1a00009          MOV      r0,r9                 ;598
000b98  ebfffffe          BL       pipe_read_write_packet_ff
000b9c  ea000006          B        |L1.3004|
                  |L1.2976|
000ba0  e1a02006          MOV      r2,r6                 ;600
000ba4  e1a0100b          MOV      r1,r11                ;600
000ba8  e1a00009          MOV      r0,r9                 ;600
000bac  ebfffffe          BL       pipe_write_packet
000bb0  e0890006          ADD      r0,r9,r6              ;601
000bb4  e1a01005          MOV      r1,r5                 ;601
000bb8  ebfffffe          BL       __aeabi_uwrite4
                  |L1.3004|
000bbc  e0480006          SUB      r0,r8,r6              ;603
000bc0  e1a00800          LSL      r0,r0,#16             ;603
000bc4  e1a00820          LSR      r0,r0,#16             ;603
000bc8  e5c50006          STRB     r0,[r5,#6]            ;603
000bcc  e1a00420          LSR      r0,r0,#8              ;603
000bd0  e5c50007          STRB     r0,[r5,#7]            ;603
000bd4  e1a00000          MOV      r0,r0                 ;604
                  |L1.3032|
000bd8  ebfffffe          BL       __USBC_Dev_Tx_WriteDataComplete
000bdc  e3a00000          MOV      r0,#0                 ;607
000be0  eaffffd2          B        |L1.2864|
;;;609    
                          ENDP

                  handle_xfer_out PROC
;;;610    static bool handle_xfer_out(uint_fast8_t ep_addr)
000be4  e92d4ff8          PUSH     {r3-r11,lr}
;;;611    {
000be8  e1a09000          MOV      r9,r0
;;;612      unsigned epnum_minus1 = tu_edpt_number(ep_addr) - 1;
000bec  e20900ff          AND      r0,r9,#0xff
000bf0  e3c01080          BIC      r1,r0,#0x80
000bf4  e241a001          SUB      r10,r1,#1
;;;613      pipe_state_t  *pipe = &_dcd.pipe[tu_edpt_dir(ep_addr)][epnum_minus1];
000bf8  e20900ff          AND      r0,r9,#0xff
000bfc  e2001080          AND      r1,r0,#0x80
000c00  e1a013a1          LSR      r1,r1,#7
000c04  e0610181          RSB      r0,r1,r1,LSL #3
000c08  e59f15e0          LDR      r1,|L1.4592|
000c0c  e0810180          ADD      r0,r1,r0,LSL #3
000c10  e080618a          ADD      r6,r0,r10,LSL #3
;;;614      // TU_LOG1(" RXCSRL%d = %x\n", epnum_minus1 + 1, regs->RXCSRL);
;;;615    
;;;616      TU_ASSERT(__USBC_Dev_Rx_IsReadDataReady());
000c14  e1a00000          MOV      r0,r0
000c18  ebfffffe          BL       __USBC_Dev_Rx_IsReadDataReady
000c1c  e3500000          CMP      r0,#0
000c20  1a000007          BNE      |L1.3140|
000c24  e3a02f9a          MOV      r2,#0x268
000c28  e59f15c8          LDR      r1,|L1.4600|
000c2c  e24f0ff9          ADR      r0,|L1.2128|
000c30  ebfffffe          BL       __2printf
000c34  e1a00000          MOV      r0,r0
000c38  e1a00000          MOV      r0,r0
000c3c  e3a00000          MOV      r0,#0
                  |L1.3136|
;;;617    
;;;618      const unsigned mps = USBC_Readw(USBC_REG_RXMAXP(USBC0_BASE));
;;;619      const unsigned rem = pipe->remaining;
;;;620      const unsigned vld = USBC_Readw(USBC_REG_RXCOUNT(USBC0_BASE));
;;;621      const unsigned len = TU_MIN(TU_MIN(rem, mps), vld);
;;;622      uint8_t          *buf = pipe->buf;
;;;623      if (len) {
;;;624        volatile void* addr = (volatile void*)(USBC_REG_EPFIFO1(USBC0_BASE) + (epnum_minus1 << 2));
;;;625        if (_dcd.pipe_buf_is_fifo[TUSB_DIR_OUT] & TU_BIT(epnum_minus1)) {
;;;626          pipe_read_write_packet_ff((tu_fifo_t *)buf, addr, len, TUSB_DIR_OUT);
;;;627        } else {
;;;628          pipe_read_packet(buf, addr, len);
;;;629          pipe->buf       = buf + len;
;;;630        }
;;;631        pipe->remaining = rem - len;
;;;632      }
;;;633      if ((len < mps) || (rem == len)) {
;;;634        pipe->buf = NULL;
;;;635        return NULL != buf;
;;;636      }
;;;637      __USBC_Dev_Rx_ReadDataComplete();
;;;638      return false;
;;;639    }
000c40  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.3140|
000c44  e1a00000          MOV      r0,r0                 ;616
000c48  e51f040c          LDR      r0,|L1.2116|
000c4c  e1d078b4          LDRH     r7,[r0,#0x84]         ;618
000c50  e5d60007          LDRB     r0,[r6,#7]            ;619
000c54  e5d61006          LDRB     r1,[r6,#6]            ;619
000c58  e1815400          ORR      r5,r1,r0,LSL #8       ;619
000c5c  e51f0420          LDR      r0,|L1.2116|
000c60  e1d0b8b8          LDRH     r11,[r0,#0x88]        ;620
000c64  e1550007          CMP      r5,r7                 ;621
000c68  2a000001          BCS      |L1.3188|
000c6c  e1a00005          MOV      r0,r5                 ;621
000c70  ea000000          B        |L1.3192|
                  |L1.3188|
000c74  e1a00007          MOV      r0,r7                 ;621
                  |L1.3192|
000c78  e150000b          CMP      r0,r11                ;621
000c7c  2a000005          BCS      |L1.3224|
000c80  e1550007          CMP      r5,r7                 ;621
000c84  2a000001          BCS      |L1.3216|
000c88  e1a00005          MOV      r0,r5                 ;621
000c8c  ea000002          B        |L1.3228|
                  |L1.3216|
000c90  e1a00007          MOV      r0,r7                 ;621
000c94  ea000000          B        |L1.3228|
                  |L1.3224|
000c98  e1a0000b          MOV      r0,r11                ;621
                  |L1.3228|
000c9c  e1a04000          MOV      r4,r0                 ;621
000ca0  e1a00006          MOV      r0,r6                 ;622
000ca4  ebfffffe          BL       __aeabi_uread4
000ca8  e1a08000          MOV      r8,r0                 ;622
000cac  e3540000          CMP      r4,#0                 ;623
000cb0  0a00001c          BEQ      |L1.3368|
000cb4  e59f0538          LDR      r0,|L1.4596|
000cb8  e080010a          ADD      r0,r0,r10,LSL #2      ;624
000cbc  e58d0000          STR      r0,[sp,#0]            ;624
000cc0  e59f0520          LDR      r0,|L1.4584|
000cc4  e1d008b4          LDRH     r0,[r0,#0x84]         ;625  ; _dcd
000cc8  e3a01001          MOV      r1,#1                 ;625
000ccc  e0000a11          AND      r0,r0,r1,LSL r10      ;625
000cd0  e3500000          CMP      r0,#0                 ;625
000cd4  0a000005          BEQ      |L1.3312|
000cd8  e3a03000          MOV      r3,#0                 ;626
000cdc  e1a02004          MOV      r2,r4                 ;626
000ce0  e1a00008          MOV      r0,r8                 ;626
000ce4  e59d1000          LDR      r1,[sp,#0]            ;626
000ce8  ebfffffe          BL       pipe_read_write_packet_ff
000cec  ea000006          B        |L1.3340|
                  |L1.3312|
000cf0  e1a02004          MOV      r2,r4                 ;628
000cf4  e1a00008          MOV      r0,r8                 ;628
000cf8  e59d1000          LDR      r1,[sp,#0]            ;628
000cfc  ebfffffe          BL       pipe_read_packet
000d00  e0880004          ADD      r0,r8,r4              ;629
000d04  e1a01006          MOV      r1,r6                 ;629
000d08  ebfffffe          BL       __aeabi_uwrite4
                  |L1.3340|
000d0c  e0450004          SUB      r0,r5,r4              ;631
000d10  e1a00800          LSL      r0,r0,#16             ;631
000d14  e1a00820          LSR      r0,r0,#16             ;631
000d18  e5c60006          STRB     r0,[r6,#6]            ;631
000d1c  e1a00420          LSR      r0,r0,#8              ;631
000d20  e5c60007          STRB     r0,[r6,#7]            ;631
000d24  e1a00000          MOV      r0,r0                 ;632
                  |L1.3368|
000d28  e1540007          CMP      r4,r7                 ;633
000d2c  3a000001          BCC      |L1.3384|
000d30  e1550004          CMP      r5,r4                 ;633
000d34  1a000008          BNE      |L1.3420|
                  |L1.3384|
000d38  e1a01006          MOV      r1,r6                 ;634
000d3c  e3a00000          MOV      r0,#0                 ;634
000d40  ebfffffe          BL       __aeabi_uwrite4
000d44  e3580000          CMP      r8,#0                 ;635
000d48  0a000001          BEQ      |L1.3412|
000d4c  e3a00001          MOV      r0,#1                 ;635
000d50  eaffffba          B        |L1.3136|
                  |L1.3412|
000d54  e3a00000          MOV      r0,#0                 ;635
000d58  eaffffb8          B        |L1.3136|
                  |L1.3420|
000d5c  ebfffffe          BL       __USBC_Dev_Rx_ReadDataComplete
000d60  e3a00000          MOV      r0,#0                 ;638
000d64  eaffffb5          B        |L1.3136|
;;;640    
                          ENDP

                  edpt_n_xfer PROC
;;;641    static bool edpt_n_xfer(uint8_t rhport, uint8_t ep_addr, uint8_t *buffer, uint16_t total_bytes)
000d68  e92d5ff0          PUSH     {r4-r12,lr}
;;;642    {
000d6c  e1a0b000          MOV      r11,r0
000d70  e1a04001          MOV      r4,r1
000d74  e1a07002          MOV      r7,r2
000d78  e1a05003          MOV      r5,r3
;;;643      (void)rhport;
;;;644    
;;;645      unsigned epnum_minus1 = tu_edpt_number(ep_addr) - 1;
000d7c  e1a00000          MOV      r0,r0
000d80  e3c40080          BIC      r0,r4,#0x80
000d84  e2409001          SUB      r9,r0,#1
;;;646      unsigned dir_in       = tu_edpt_dir(ep_addr);
000d88  e1a00000          MOV      r0,r0
000d8c  e2040080          AND      r0,r4,#0x80
000d90  e1a003a0          LSR      r0,r0,#7
000d94  e1a08000          MOV      r8,r0
;;;647    
;;;648      pipe_state_t *pipe = &_dcd.pipe[dir_in][epnum_minus1];
000d98  e0680188          RSB      r0,r8,r8,LSL #3
000d9c  e59f144c          LDR      r1,|L1.4592|
000da0  e0810180          ADD      r0,r1,r0,LSL #3
000da4  e0806189          ADD      r6,r0,r9,LSL #3
;;;649      pipe->buf          = buffer;
000da8  e1a01006          MOV      r1,r6
000dac  e1a00007          MOV      r0,r7
000db0  ebfffffe          BL       __aeabi_uwrite4
;;;650      pipe->length       = total_bytes;
000db4  e5c65004          STRB     r5,[r6,#4]
000db8  e1a00425          LSR      r0,r5,#8
000dbc  e5c60005          STRB     r0,[r6,#5]
;;;651      pipe->remaining    = total_bytes;
000dc0  e5c65006          STRB     r5,[r6,#6]
000dc4  e1a00425          LSR      r0,r5,#8
000dc8  e5c60007          STRB     r0,[r6,#7]
;;;652    
;;;653      USBC_SelectActiveEp(tu_edpt_number(ep_addr));
000dcc  e1a00000          MOV      r0,r0
000dd0  e3c40080          BIC      r0,r4,#0x80
000dd4  e1a0a000          MOV      r10,r0
000dd8  ebfffffe          BL       USBC_SelectActiveEp
;;;654    
;;;655      if (dir_in) {
000ddc  e3580000          CMP      r8,#0
000de0  0a000002          BEQ      |L1.3568|
;;;656        handle_xfer_in(ep_addr);
000de4  e1a00004          MOV      r0,r4
000de8  ebfffffe          BL       handle_xfer_in
000dec  ea000003          B        |L1.3584|
                  |L1.3568|
;;;657      } else {
;;;658        if (__USBC_Dev_Rx_IsReadDataReady())
000df0  ebfffffe          BL       __USBC_Dev_Rx_IsReadDataReady
000df4  e3500000          CMP      r0,#0
000df8  0a000000          BEQ      |L1.3584|
;;;659          __USBC_Dev_Rx_ReadDataComplete();
000dfc  ebfffffe          BL       __USBC_Dev_Rx_ReadDataComplete
                  |L1.3584|
;;;660      }
;;;661      return true;
000e00  e3a00001          MOV      r0,#1
;;;662    }
000e04  e8bd9ff0          POP      {r4-r12,pc}
;;;663    
                          ENDP

                  edpt0_xfer PROC
;;;664    static bool edpt0_xfer(uint8_t rhport, uint8_t ep_addr, uint8_t *buffer, uint16_t total_bytes)
000e08  e92d4ffe          PUSH     {r1-r11,lr}
;;;665    {
000e0c  e1a08000          MOV      r8,r0
000e10  e1a05001          MOV      r5,r1
000e14  e1a09002          MOV      r9,r2
000e18  e1a04003          MOV      r4,r3
;;;666      (void)rhport;
;;;667      TU_ASSERT(total_bytes <= 64); /* Current implementation supports for only up to 64 bytes. */
000e1c  e1a00000          MOV      r0,r0
000e20  e3540040          CMP      r4,#0x40
000e24  da000007          BLE      |L1.3656|
000e28  e59f23cc          LDR      r2,|L1.4604|
000e2c  e59f13cc          LDR      r1,|L1.4608|
000e30  e59f03cc          LDR      r0,|L1.4612|
000e34  ebfffffe          BL       __2printf
000e38  e1a00000          MOV      r0,r0
000e3c  e1a00000          MOV      r0,r0
000e40  e3a00000          MOV      r0,#0
                  |L1.3652|
;;;668    
;;;669      const unsigned req = _dcd.setup_packet.bmRequestType;
;;;670      TU_ASSERT(req != REQUEST_TYPE_INVALID || total_bytes == 0);
;;;671    
;;;672      USBC_SelectActiveEp(0);
;;;673    
;;;674      if (req == REQUEST_TYPE_INVALID || _dcd.status_out) {
;;;675        /* STATUS OUT stage.
;;;676         * MUSB controller automatically handles STATUS OUT packets without
;;;677         * software helps. We do not have to do anything. And STATUS stage
;;;678         * may have already finished and received the next setup packet
;;;679         * without calling this function, so we have no choice but to
;;;680         * invoke the callback function of status packet here. */
;;;681        // TU_LOG1(" STATUS OUT CSRL0 = %x\n", CSRL0);
;;;682        _dcd.status_out = 0;
;;;683        if (req == REQUEST_TYPE_INVALID) {
;;;684          dcd_event_xfer_complete(rhport, ep_addr, total_bytes, XFER_RESULT_SUCCESS, false);
;;;685        } else {
;;;686          /* The next setup packet has already been received, it aborts
;;;687           * invoking callback function to avoid confusing TUSB stack. */
;;;688          TU_LOG1("Drop CONTROL_STAGE_ACK\n");
;;;689        }
;;;690        return true;
;;;691      }
;;;692      const unsigned dir_in = tu_edpt_dir(ep_addr);
;;;693      if (tu_edpt_dir(req) == dir_in) { /* DATA stage */
;;;694        TU_ASSERT(total_bytes <= _dcd.remaining_ctrl);
;;;695        const unsigned rem = _dcd.remaining_ctrl;
;;;696        const unsigned len = TU_MIN(TU_MIN(rem, 64), total_bytes);
;;;697        if (dir_in) {
;;;698          pipe_write_packet(buffer, (volatile void*) USBC_REG_EPFIFO0(USBC0_BASE), len);
;;;699    
;;;700          _dcd.pipe0.buf       = buffer + len;
;;;701          _dcd.pipe0.length    = len;
;;;702          _dcd.pipe0.remaining = 0;
;;;703    
;;;704          _dcd.remaining_ctrl  = rem - len;
;;;705          if ((len < 64) || (rem == len)) {
;;;706            _dcd.setup_packet.bmRequestType = REQUEST_TYPE_INVALID; /* Change to STATUS/SETUP stage */
;;;707            _dcd.status_out = 1;
;;;708            /* Flush TX FIFO and reverse the transaction direction. */
;;;709            __USBC_Dev_ep0_WriteDataComplete();
;;;710          } else {
;;;711            __USBC_Dev_ep0_WriteDataHalf();
;;;712          }
;;;713          // TU_LOG1(" IN CSRL0 = %x\n", CSRL0);
;;;714        } else {
;;;715          // TU_LOG1(" OUT CSRL0 = %x\n", CSRL0);
;;;716          _dcd.pipe0.buf       = buffer;
;;;717          _dcd.pipe0.length    = len;
;;;718          _dcd.pipe0.remaining = len;
;;;719          __USBC_Dev_ep0_ReadDataHalf();
;;;720        }
;;;721      } else if (dir_in) {
;;;722        // TU_LOG1(" STATUS IN CSRL0 = %x\n", CSRL0);
;;;723        _dcd.pipe0.buf = NULL;
;;;724        _dcd.pipe0.length    = 0;
;;;725        _dcd.pipe0.remaining = 0;
;;;726        /* Clear RX FIFO and reverse the transaction direction */
;;;727        __USBC_Dev_ep0_ReadDataComplete();
;;;728      }
;;;729      return true;
;;;730    }
000e44  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.3656|
000e48  e1a00000          MOV      r0,r0                 ;667
000e4c  e59f0394          LDR      r0,|L1.4584|
000e50  e5d06000          LDRB     r6,[r0,#0]            ;669  ; _dcd
000e54  e1a00000          MOV      r0,r0                 ;670
000e58  e35600ff          CMP      r6,#0xff              ;670
000e5c  1a000009          BNE      |L1.3720|
000e60  e3540000          CMP      r4,#0                 ;670
000e64  0a000007          BEQ      |L1.3720|
000e68  e59f2398          LDR      r2,|L1.4616|
000e6c  e59f138c          LDR      r1,|L1.4608|
000e70  e59f038c          LDR      r0,|L1.4612|
000e74  ebfffffe          BL       __2printf
000e78  e1a00000          MOV      r0,r0                 ;670
000e7c  e1a00000          MOV      r0,r0                 ;670
000e80  e3a00000          MOV      r0,#0                 ;670
000e84  eaffffee          B        |L1.3652|
                  |L1.3720|
000e88  e1a00000          MOV      r0,r0                 ;670
000e8c  e3a00000          MOV      r0,#0                 ;672
000e90  ebfffffe          BL       USBC_SelectActiveEp
000e94  e35600ff          CMP      r6,#0xff              ;674
000e98  0a000003          BEQ      |L1.3756|
000e9c  e59f0344          LDR      r0,|L1.4584|
000ea0  e5d0000a          LDRB     r0,[r0,#0xa]          ;674  ; _dcd
000ea4  e3500000          CMP      r0,#0                 ;674
000ea8  0a000018          BEQ      |L1.3856|
                  |L1.3756|
000eac  e3a00000          MOV      r0,#0                 ;682
000eb0  e59f1330          LDR      r1,|L1.4584|
000eb4  e5c1000a          STRB     r0,[r1,#0xa]          ;682  ; _dcd
000eb8  e35600ff          CMP      r6,#0xff              ;683
000ebc  1a00000f          BNE      |L1.3840|
000ec0  e3a0a000          MOV      r10,#0                ;684
000ec4  e1a0b00a          MOV      r11,r10               ;684
000ec8  e59f033c          LDR      r0,|L1.4620|
000ecc  e8900006          LDM      r0,{r1,r2}            ;684  ; <Data3>, <Data3>, <Data3>
000ed0  e5900008          LDR      r0,[r0,#8]            ;684
000ed4  e58d0008          STR      r0,[sp,#8]            ;684
000ed8  e88d0006          STM      sp,{r1,r2}            ;684
000edc  e5cd8000          STRB     r8,[sp,#0]            ;684
000ee0  e5cd5004          STRB     r5,[sp,#4]            ;684
000ee4  e58d4008          STR      r4,[sp,#8]            ;684
000ee8  e5cda005          STRB     r10,[sp,#5]           ;684
000eec  e1a0100b          MOV      r1,r11                ;684
000ef0  e1a0000d          MOV      r0,sp                 ;684
000ef4  ebfffffe          BL       dcd_event_handler
000ef8  e1a00000          MOV      r0,r0                 ;684
000efc  ea000001          B        |L1.3848|
                  |L1.3840|
000f00  e28f0fc2          ADR      r0,|L1.4624|
000f04  ebfffffe          BL       __2printf
                  |L1.3848|
000f08  e3a00001          MOV      r0,#1                 ;690
000f0c  eaffffcc          B        |L1.3652|
                  |L1.3856|
000f10  e1a00000          MOV      r0,r0                 ;692
000f14  e2050080          AND      r0,r5,#0x80           ;692
000f18  e1a073a0          LSR      r7,r0,#7              ;692
000f1c  e1a00000          MOV      r0,r0                 ;692
000f20  e20600ff          AND      r0,r6,#0xff           ;693
000f24  e2001080          AND      r1,r0,#0x80           ;693
000f28  e1a013a1          LSR      r1,r1,#7              ;693
000f2c  e1510007          CMP      r1,r7                 ;693
000f30  1a00004f          BNE      |L1.4212|
000f34  e1a00000          MOV      r0,r0                 ;694
000f38  e59f02a8          LDR      r0,|L1.4584|
000f3c  e1d000b8          LDRH     r0,[r0,#8]            ;694  ; _dcd
000f40  e1500004          CMP      r0,r4                 ;694
000f44  aa000007          BGE      |L1.3944|
000f48  e59f22d8          LDR      r2,|L1.4648|
000f4c  e59f12ac          LDR      r1,|L1.4608|
000f50  e59f02ac          LDR      r0,|L1.4612|
000f54  ebfffffe          BL       __2printf
000f58  e1a00000          MOV      r0,r0                 ;694
000f5c  e1a00000          MOV      r0,r0                 ;694
000f60  e3a00000          MOV      r0,#0                 ;694
000f64  eaffffb6          B        |L1.3652|
                  |L1.3944|
000f68  e1a00000          MOV      r0,r0                 ;694
000f6c  e59f0274          LDR      r0,|L1.4584|
000f70  e1d0b0b8          LDRH     r11,[r0,#8]           ;695  ; _dcd
000f74  e35b0040          CMP      r11,#0x40             ;696
000f78  2a000001          BCS      |L1.3972|
000f7c  e1a0000b          MOV      r0,r11                ;696
000f80  ea000000          B        |L1.3976|
                  |L1.3972|
000f84  e3a00040          MOV      r0,#0x40              ;696
                  |L1.3976|
000f88  e1500004          CMP      r0,r4                 ;696
000f8c  2a000005          BCS      |L1.4008|
000f90  e35b0040          CMP      r11,#0x40             ;696
000f94  2a000001          BCS      |L1.4000|
000f98  e1a0000b          MOV      r0,r11                ;696
000f9c  ea000002          B        |L1.4012|
                  |L1.4000|
000fa0  e3a00040          MOV      r0,#0x40              ;696
000fa4  ea000000          B        |L1.4012|
                  |L1.4008|
000fa8  e1a00004          MOV      r0,r4                 ;696
                  |L1.4012|
000fac  e1a0a000          MOV      r10,r0                ;696
000fb0  e3570000          CMP      r7,#0                 ;697
000fb4  0a00001e          BEQ      |L1.4148|
000fb8  e1a0200a          MOV      r2,r10                ;698
000fbc  e51f1780          LDR      r1,|L1.2116|
000fc0  e1a00009          MOV      r0,r9                 ;698
000fc4  ebfffffe          BL       pipe_write_packet
000fc8  e089000a          ADD      r0,r9,r10             ;700
000fcc  e59f1258          LDR      r1,|L1.4652|
000fd0  ebfffffe          BL       __aeabi_uwrite4
000fd4  e1a0080a          LSL      r0,r10,#16            ;701
000fd8  e1a00820          LSR      r0,r0,#16             ;701
000fdc  e59f1204          LDR      r1,|L1.4584|
000fe0  e5c1000f          STRB     r0,[r1,#0xf]          ;701
000fe4  e1a00420          LSR      r0,r0,#8              ;701
000fe8  e5c10010          STRB     r0,[r1,#0x10]         ;701
000fec  e3a00000          MOV      r0,#0                 ;702
000ff0  e5c10011          STRB     r0,[r1,#0x11]         ;702
000ff4  e5c10012          STRB     r0,[r1,#0x12]         ;702
000ff8  e04b000a          SUB      r0,r11,r10            ;704
000ffc  e1c100b8          STRH     r0,[r1,#8]            ;704  ; _dcd
001000  e35a0040          CMP      r10,#0x40             ;705
001004  3a000001          BCC      |L1.4112|
001008  e15b000a          CMP      r11,r10               ;705
00100c  1a000006          BNE      |L1.4140|
                  |L1.4112|
001010  e3a000ff          MOV      r0,#0xff              ;706
001014  e59f11cc          LDR      r1,|L1.4584|
001018  e5c10000          STRB     r0,[r1,#0]            ;706  ; _dcd
00101c  e3a00001          MOV      r0,#1                 ;707
001020  e5c1000a          STRB     r0,[r1,#0xa]          ;707  ; _dcd
001024  ebfffffe          BL       __USBC_Dev_ep0_WriteDataComplete
001028  ea000010          B        |L1.4208|
                  |L1.4140|
00102c  ebfffffe          BL       __USBC_Dev_ep0_WriteDataHalf
001030  ea00000e          B        |L1.4208|
                  |L1.4148|
001034  e59f11f0          LDR      r1,|L1.4652|
001038  e1a00009          MOV      r0,r9                 ;716
00103c  ebfffffe          BL       __aeabi_uwrite4
001040  e1a0080a          LSL      r0,r10,#16            ;717
001044  e1a00820          LSR      r0,r0,#16             ;717
001048  e59f1198          LDR      r1,|L1.4584|
00104c  e5c1000f          STRB     r0,[r1,#0xf]          ;717
001050  e1a00420          LSR      r0,r0,#8              ;717
001054  e5c10010          STRB     r0,[r1,#0x10]         ;717
001058  e1a0080a          LSL      r0,r10,#16            ;718
00105c  e1a00820          LSR      r0,r0,#16             ;718
001060  e5c10011          STRB     r0,[r1,#0x11]         ;718
001064  e1a00420          LSR      r0,r0,#8              ;718
001068  e5c10012          STRB     r0,[r1,#0x12]         ;718
00106c  ebfffffe          BL       __USBC_Dev_ep0_ReadDataHalf
                  |L1.4208|
001070  ea00000b          B        |L1.4260|
                  |L1.4212|
001074  e3570000          CMP      r7,#0                 ;721
001078  0a000009          BEQ      |L1.4260|
00107c  e59f11a8          LDR      r1,|L1.4652|
001080  e3a00000          MOV      r0,#0                 ;723
001084  ebfffffe          BL       __aeabi_uwrite4
001088  e3a00000          MOV      r0,#0                 ;724
00108c  e59f1154          LDR      r1,|L1.4584|
001090  e5c1000f          STRB     r0,[r1,#0xf]          ;724
001094  e5c10010          STRB     r0,[r1,#0x10]         ;724
001098  e5c10011          STRB     r0,[r1,#0x11]         ;725
00109c  e5c10012          STRB     r0,[r1,#0x12]         ;725
0010a0  ebfffffe          BL       __USBC_Dev_ep0_ReadDataComplete
                  |L1.4260|
0010a4  e3a00001          MOV      r0,#1                 ;729
0010a8  eaffff65          B        |L1.3652|
;;;731    
                          ENDP

                  process_ep0 PROC
;;;732    static void process_ep0(uint8_t rhport)
0010ac  e92d4ff0          PUSH     {r4-r11,lr}
;;;733    {
0010b0  e24dd01c          SUB      sp,sp,#0x1c
0010b4  e1a04000          MOV      r4,r0
;;;734      USBC_SelectActiveEp(0);
0010b8  e3a00000          MOV      r0,#0
0010bc  ebfffffe          BL       USBC_SelectActiveEp
;;;735      uint_fast8_t csrl = USBC_Readw(USBC_REG_CSR0(USBC0_BASE));
0010c0  e51f0884          LDR      r0,|L1.2116|
0010c4  e1d068b2          LDRH     r6,[r0,#0x82]
;;;736    
;;;737      // TU_LOG1(" EP0 CSRL0 = %x\n", csrl);
;;;738    
;;;739      if (csrl & USB_CSRL0_STALLED) {
0010c8  e2060004          AND      r0,r6,#4
0010cc  e3500000          CMP      r0,#0
0010d0  0a000002          BEQ      |L1.4320|
;;;740        /* Returned STALL packet to HOST. */
;;;741        __USBC_Dev_ep0_ClearStall();
0010d4  ebfffffe          BL       __USBC_Dev_ep0_ClearStall
                  |L1.4312|
;;;742        return;
;;;743      }
;;;744    
;;;745      unsigned req = _dcd.setup_packet.bmRequestType;
;;;746      if (csrl & USB_CSRL0_SETEND) {
;;;747        // TU_LOG1("   ABORT by the next packets\n");
;;;748        USBC_Dev_Ctrl_ClearSetupEnd();
;;;749        if (req != REQUEST_TYPE_INVALID && _dcd.pipe0.buf) {
;;;750          /* DATA stage was aborted by receiving STATUS or SETUP packet. */
;;;751          _dcd.pipe0.buf = NULL;
;;;752          _dcd.setup_packet.bmRequestType = REQUEST_TYPE_INVALID;
;;;753          dcd_event_xfer_complete(rhport,
;;;754                                  req & TUSB_DIR_IN_MASK,
;;;755                                  _dcd.pipe0.length - _dcd.pipe0.remaining,
;;;756                                  XFER_RESULT_SUCCESS, true);
;;;757        }
;;;758        req = REQUEST_TYPE_INVALID;
;;;759        if (!(csrl & USB_CSRL0_RXRDY)) return; /* Received SETUP packet */
;;;760      }
;;;761    
;;;762      if (csrl & USB_CSRL0_RXRDY) {
;;;763        /* Received SETUP or DATA OUT packet */
;;;764        if (req == REQUEST_TYPE_INVALID) {
;;;765          /* SETUP */
;;;766          TU_ASSERT(sizeof(tusb_control_request_t) == USBC_Readw(USBC_REG_COUNT0(USBC0_BASE)),);
;;;767          process_setup_packet(rhport);
;;;768          return;
;;;769        }
;;;770        if (_dcd.pipe0.buf) {
;;;771          /* DATA OUT */
;;;772          const unsigned vld = USBC_Readw(USBC_REG_COUNT0(USBC0_BASE));
;;;773          const unsigned rem = _dcd.pipe0.remaining;
;;;774          const unsigned len = TU_MIN(TU_MIN(rem, 64), vld);
;;;775          pipe_read_packet(_dcd.pipe0.buf, (volatile void*)USBC_REG_EPFIFO0(USBC0_BASE), len);
;;;776    
;;;777          _dcd.pipe0.remaining = rem - len;
;;;778          _dcd.remaining_ctrl -= len;
;;;779    
;;;780          _dcd.pipe0.buf = NULL;
;;;781          dcd_event_xfer_complete(rhport,
;;;782                                  tu_edpt_addr(0, TUSB_DIR_OUT),
;;;783                                  _dcd.pipe0.length - _dcd.pipe0.remaining,
;;;784                                  XFER_RESULT_SUCCESS, true);
;;;785        }
;;;786        return;
;;;787      }
;;;788    
;;;789      /* When CSRL0 is zero, it means that completion of sending a any length packet
;;;790       * or receiving a zero length packet. */
;;;791      if (req != REQUEST_TYPE_INVALID && !tu_edpt_dir(req)) {
;;;792        /* STATUS IN */
;;;793        if (*(const uint16_t*)(uintptr_t)&_dcd.setup_packet == 0x0500) {
;;;794          /* The address must be changed on completion of the control transfer. */
;;;795    	  USBC_Dev_SetAddress((uint8_t)_dcd.setup_packet.wValue);
;;;796        }
;;;797        _dcd.setup_packet.bmRequestType = REQUEST_TYPE_INVALID;
;;;798        dcd_event_xfer_complete(rhport,
;;;799                                tu_edpt_addr(0, TUSB_DIR_IN),
;;;800                                _dcd.pipe0.length - _dcd.pipe0.remaining,
;;;801                                XFER_RESULT_SUCCESS, true);
;;;802        return;
;;;803      }
;;;804      if (_dcd.pipe0.buf) {
;;;805        /* DATA IN */
;;;806        _dcd.pipe0.buf = NULL;
;;;807        dcd_event_xfer_complete(rhport,
;;;808                                tu_edpt_addr(0, TUSB_DIR_IN),
;;;809                                _dcd.pipe0.length - _dcd.pipe0.remaining,
;;;810                                XFER_RESULT_SUCCESS, true);
;;;811      }
;;;812    }
0010d8  e28dd01c          ADD      sp,sp,#0x1c
0010dc  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.4320|
0010e0  e59f0100          LDR      r0,|L1.4584|
0010e4  e5d05000          LDRB     r5,[r0,#0]            ;745  ; _dcd
0010e8  e2060010          AND      r0,r6,#0x10           ;746
0010ec  e3500000          CMP      r0,#0                 ;746
0010f0  0a00002a          BEQ      |L1.4512|
0010f4  ebfffffe          BL       USBC_Dev_Ctrl_ClearSetupEnd
0010f8  e35500ff          CMP      r5,#0xff              ;749
0010fc  0a000022          BEQ      |L1.4492|
001100  e59f0124          LDR      r0,|L1.4652|
001104  ebfffffe          BL       __aeabi_uread4
001108  e3500000          CMP      r0,#0                 ;749
00110c  0a00001e          BEQ      |L1.4492|
001110  e59f1114          LDR      r1,|L1.4652|
001114  e3a00000          MOV      r0,#0                 ;751
001118  ebfffffe          BL       __aeabi_uwrite4
00111c  e3a000ff          MOV      r0,#0xff              ;752
001120  e59f10c0          LDR      r1,|L1.4584|
001124  e5c10000          STRB     r0,[r1,#0]            ;752  ; _dcd
001128  e2057080          AND      r7,r5,#0x80           ;753
00112c  e281100b          ADD      r1,r1,#0xb            ;753
001130  e5d10005          LDRB     r0,[r1,#5]            ;753
001134  e5d11004          LDRB     r1,[r1,#4]            ;753
001138  e1810400          ORR      r0,r1,r0,LSL #8       ;753
00113c  e59f10a4          LDR      r1,|L1.4584|
001140  e5d12012          LDRB     r2,[r1,#0x12]         ;753
001144  e5d11011          LDRB     r1,[r1,#0x11]         ;753
001148  e1811402          ORR      r1,r1,r2,LSL #8       ;753
00114c  e0408001          SUB      r8,r0,r1              ;753
001150  e3a09000          MOV      r9,#0                 ;753
001154  e3a0a001          MOV      r10,#1                ;753
001158  e59f20ac          LDR      r2,|L1.4620|
00115c  e8920007          LDM      r2,{r0-r2}            ;753  ; <Data3>, <Data3>, <Data3>
001160  e28d3010          ADD      r3,sp,#0x10           ;753
001164  e8830007          STM      r3,{r0-r2}            ;753
001168  e5cd4010          STRB     r4,[sp,#0x10]         ;753
00116c  e5cd7014          STRB     r7,[sp,#0x14]         ;753
001170  e58d8018          STR      r8,[sp,#0x18]         ;753
001174  e5cd9015          STRB     r9,[sp,#0x15]         ;753
001178  e1a0100a          MOV      r1,r10                ;753
00117c  e28d0010          ADD      r0,sp,#0x10           ;753
001180  ebfffffe          BL       dcd_event_handler
001184  e1a00000          MOV      r0,r0                 ;753
001188  e1a00000          MOV      r0,r0                 ;753
                  |L1.4492|
00118c  e3a050ff          MOV      r5,#0xff              ;758
001190  e2060001          AND      r0,r6,#1              ;759
001194  e3500000          CMP      r0,#0                 ;759
001198  1a000000          BNE      |L1.4512|
00119c  eaffffcd          B        |L1.4312|
                  |L1.4512|
0011a0  e2060001          AND      r0,r6,#1              ;762
0011a4  e3500000          CMP      r0,#0                 ;762
0011a8  0a00007c          BEQ      |L1.5024|
0011ac  e35500ff          CMP      r5,#0xff              ;764
0011b0  1a000024          BNE      |L1.4680|
0011b4  e1a00000          MOV      r0,r0                 ;766
0011b8  e51f097c          LDR      r0,|L1.2116|
0011bc  e1d008b8          LDRH     r0,[r0,#0x88]         ;766
0011c0  e3500008          CMP      r0,#8                 ;766
0011c4  0a00001b          BEQ      |L1.4664|
0011c8  e59f2060          LDR      r2,|L1.4656|
0011cc  e59f1060          LDR      r1,|L1.4660|
0011d0  e59f002c          LDR      r0,|L1.4612|
0011d4  ebfffffe          BL       __2printf
0011d8  e1a00000          MOV      r0,r0                 ;766
0011dc  e1a00000          MOV      r0,r0                 ;766
0011e0  eaffffbc          B        |L1.4312|
                  |L1.4580|
                          DCD      ops
                  |L1.4584|
                          DCD      _dcd
                  |L1.4588|
                          DCD      ||.constdata||+0xc
                  |L1.4592|
                          DCD      _dcd+0x13
                  |L1.4596|
                          DCD      0x01c13004
                  |L1.4600|
                          DCD      |symbol_number.18|
                  |L1.4604|
                          DCD      0x0000029b
                  |L1.4608|
                          DCD      |symbol_number.19|
                  |L1.4612|
                          DCD      ||.text||+0x850
                  |L1.4616|
                          DCD      0x0000029e
                  |L1.4620|
                          DCD      ||.constdata||+0x18
                  |L1.4624|
001210  44726f70          DCB      "Drop CONTROL_STAGE_ACK\n",0
001214  20434f4e
001218  54524f4c
00121c  5f535441
001220  47455f41
001224  434b0a00
                  |L1.4648|
                          DCD      0x000002b6
                  |L1.4652|
                          DCD      _dcd+0xb
                  |L1.4656|
                          DCD      0x000002fe
                  |L1.4660|
                          DCD      |symbol_number.20|
                  |L1.4664|
001238  e1a00000          MOV      r0,r0                 ;766
00123c  e1a00004          MOV      r0,r4                 ;767
001240  ebfffffe          BL       process_setup_packet
001244  eaffffa3          B        |L1.4312|
                  |L1.4680|
001248  e51f0024          LDR      r0,|L1.4652|
00124c  ebfffffe          BL       __aeabi_uread4
001250  e3500000          CMP      r0,#0                 ;770
001254  0a000050          BEQ      |L1.5020|
001258  e51f0a1c          LDR      r0,|L1.2116|
00125c  e1d008b8          LDRH     r0,[r0,#0x88]         ;772
001260  e58d0018          STR      r0,[sp,#0x18]         ;772
001264  e51f0084          LDR      r0,|L1.4584|
001268  e5d01012          LDRB     r1,[r0,#0x12]         ;773
00126c  e5d00011          LDRB     r0,[r0,#0x11]         ;773
001270  e1807401          ORR      r7,r0,r1,LSL #8       ;773
001274  e3570040          CMP      r7,#0x40              ;774
001278  2a000001          BCS      |L1.4740|
00127c  e1a01007          MOV      r1,r7                 ;774
001280  ea000000          B        |L1.4744|
                  |L1.4740|
001284  e3a01040          MOV      r1,#0x40              ;774
                  |L1.4744|
001288  e59d0018          LDR      r0,[sp,#0x18]         ;774
00128c  e1510000          CMP      r1,r0                 ;774
001290  2a000005          BCS      |L1.4780|
001294  e3570040          CMP      r7,#0x40              ;774
001298  2a000001          BCS      |L1.4772|
00129c  e1a00007          MOV      r0,r7                 ;774
0012a0  ea000002          B        |L1.4784|
                  |L1.4772|
0012a4  e3a00040          MOV      r0,#0x40              ;774
0012a8  ea000000          B        |L1.4784|
                  |L1.4780|
0012ac  e59d0018          LDR      r0,[sp,#0x18]         ;774
                  |L1.4784|
0012b0  e1a08000          MOV      r8,r0                 ;774
0012b4  e51f0090          LDR      r0,|L1.4652|
0012b8  ebfffffe          BL       __aeabi_uread4
0012bc  e1a09000          MOV      r9,r0                 ;775
0012c0  e1a02008          MOV      r2,r8                 ;775
0012c4  e51f1a88          LDR      r1,|L1.2116|
0012c8  ebfffffe          BL       pipe_read_packet
0012cc  e0470008          SUB      r0,r7,r8              ;777
0012d0  e1a00800          LSL      r0,r0,#16             ;777
0012d4  e1a00820          LSR      r0,r0,#16             ;777
0012d8  e51f10f8          LDR      r1,|L1.4584|
0012dc  e5c10011          STRB     r0,[r1,#0x11]         ;777
0012e0  e1a00420          LSR      r0,r0,#8              ;777
0012e4  e5c10012          STRB     r0,[r1,#0x12]         ;777
0012e8  e2810000          ADD      r0,r1,#0              ;778
0012ec  e1d000b8          LDRH     r0,[r0,#8]            ;778  ; _dcd
0012f0  e0400008          SUB      r0,r0,r8              ;778
0012f4  e1c100b8          STRH     r0,[r1,#8]            ;778  ; _dcd
0012f8  e281100b          ADD      r1,r1,#0xb            ;780
0012fc  e3a00000          MOV      r0,#0                 ;780
001300  ebfffffe          BL       __aeabi_uwrite4
001304  e1a0a004          MOV      r10,r4                ;781
001308  e3a00000          MOV      r0,#0                 ;781
00130c  e1a01000          MOV      r1,r0                 ;781
001310  e3510000          CMP      r1,#0                 ;781
001314  0a000001          BEQ      |L1.4896|
001318  e3a02080          MOV      r2,#0x80              ;781
00131c  ea000000          B        |L1.4900|
                  |L1.4896|
001320  e3a02000          MOV      r2,#0                 ;781
                  |L1.4900|
001324  e1829000          ORR      r9,r2,r0              ;781
001328  e51f0148          LDR      r0,|L1.4584|
00132c  e5d01010          LDRB     r1,[r0,#0x10]         ;781
001330  e5d0000f          LDRB     r0,[r0,#0xf]          ;781
001334  e1800401          ORR      r0,r0,r1,LSL #8       ;781
001338  e51f2114          LDR      r2,|L1.4652|
00133c  e5d21007          LDRB     r1,[r2,#7]            ;781
001340  e5d22006          LDRB     r2,[r2,#6]            ;781
001344  e1821401          ORR      r1,r2,r1,LSL #8       ;781
001348  e040b001          SUB      r11,r0,r1             ;781
00134c  e3a00000          MOV      r0,#0                 ;781
001350  e58d0010          STR      r0,[sp,#0x10]         ;781
001354  e3a00001          MOV      r0,#1                 ;781
001358  e58d0014          STR      r0,[sp,#0x14]         ;781
00135c  e51f2158          LDR      r2,|L1.4620|
001360  e5921000          LDR      r1,[r2,#0]            ;781  ; <Data3>, <Data3>, <Data3>
001364  e9920005          LDMIB    r2,{r0,r2}            ;781
001368  e58d0008          STR      r0,[sp,#8]            ;781
00136c  e58d200c          STR      r2,[sp,#0xc]          ;781
001370  e58d1004          STR      r1,[sp,#4]            ;781
001374  e5cda004          STRB     r10,[sp,#4]           ;781
001378  e5cd9008          STRB     r9,[sp,#8]            ;781
00137c  e58db00c          STR      r11,[sp,#0xc]         ;781
001380  e59d0010          LDR      r0,[sp,#0x10]         ;781
001384  e5cd0009          STRB     r0,[sp,#9]            ;781
001388  e59d1014          LDR      r1,[sp,#0x14]         ;781
00138c  e28d0004          ADD      r0,sp,#4              ;781
001390  ebfffffe          BL       dcd_event_handler
001394  e1a00000          MOV      r0,r0                 ;781
001398  e1a00000          MOV      r0,r0                 ;785
                  |L1.5020|
00139c  eaffff4d          B        |L1.4312|
                  |L1.5024|
0013a0  e35500ff          CMP      r5,#0xff              ;791
0013a4  0a00002f          BEQ      |L1.5224|
0013a8  e20500ff          AND      r0,r5,#0xff           ;791
0013ac  e2001080          AND      r1,r0,#0x80           ;791
0013b0  e1a013a1          LSR      r1,r1,#7              ;791
0013b4  e3510000          CMP      r1,#0                 ;791
0013b8  1a00002a          BNE      |L1.5224|
0013bc  e51f01dc          LDR      r0,|L1.4584|
0013c0  e1d000b0          LDRH     r0,[r0,#0]            ;793  ; _dcd
0013c4  e3500c05          CMP      r0,#0x500             ;793
0013c8  1a000002          BNE      |L1.5080|
0013cc  e51f11ec          LDR      r1,|L1.4584|
0013d0  e5d10002          LDRB     r0,[r1,#2]            ;795  ; _dcd
0013d4  ebfffffe          BL       USBC_Dev_SetAddress
                  |L1.5080|
0013d8  e3a000ff          MOV      r0,#0xff              ;797
0013dc  e51f11fc          LDR      r1,|L1.4584|
0013e0  e5c10000          STRB     r0,[r1,#0]            ;797  ; _dcd
0013e4  e1a08004          MOV      r8,r4                 ;798
0013e8  e3a00000          MOV      r0,#0                 ;798
0013ec  e3a01001          MOV      r1,#1                 ;798
0013f0  e3510000          CMP      r1,#0                 ;798
0013f4  0a000001          BEQ      |L1.5120|
0013f8  e3a02080          MOV      r2,#0x80              ;798
0013fc  ea000000          B        |L1.5124|
                  |L1.5120|
001400  e3a02000          MOV      r2,#0                 ;798
                  |L1.5124|
001404  e1827000          ORR      r7,r2,r0              ;798
001408  e51f11e4          LDR      r1,|L1.4652|
00140c  e5d10005          LDRB     r0,[r1,#5]            ;798
001410  e5d11004          LDRB     r1,[r1,#4]            ;798
001414  e1810400          ORR      r0,r1,r0,LSL #8       ;798
001418  e51f21f4          LDR      r2,|L1.4652|
00141c  e5d21007          LDRB     r1,[r2,#7]            ;798
001420  e5d22006          LDRB     r2,[r2,#6]            ;798
001424  e1821401          ORR      r1,r2,r1,LSL #8       ;798
001428  e0409001          SUB      r9,r0,r1              ;798
00142c  e3a0a000          MOV      r10,#0                ;798
001430  e3a0b001          MOV      r11,#1                ;798
001434  e51f2230          LDR      r2,|L1.4620|
001438  e8920007          LDM      r2,{r0-r2}            ;798  ; <Data3>, <Data3>, <Data3>
00143c  e28d3010          ADD      r3,sp,#0x10           ;798
001440  e8830007          STM      r3,{r0-r2}            ;798
001444  e5cd8010          STRB     r8,[sp,#0x10]         ;798
001448  e5cd7014          STRB     r7,[sp,#0x14]         ;798
00144c  e58d9018          STR      r9,[sp,#0x18]         ;798
001450  e5cda015          STRB     r10,[sp,#0x15]        ;798
001454  e1a0100b          MOV      r1,r11                ;798
001458  e28d0010          ADD      r0,sp,#0x10           ;798
00145c  ebfffffe          BL       dcd_event_handler
001460  e1a00000          MOV      r0,r0                 ;798
001464  eaffff1b          B        |L1.4312|
                  |L1.5224|
001468  e51f0244          LDR      r0,|L1.4652|
00146c  ebfffffe          BL       __aeabi_uread4
001470  e3500000          CMP      r0,#0                 ;804
001474  0a000023          BEQ      |L1.5384|
001478  e51f1254          LDR      r1,|L1.4652|
00147c  e3a00000          MOV      r0,#0                 ;806
001480  ebfffffe          BL       __aeabi_uwrite4
001484  e1a08004          MOV      r8,r4                 ;807
001488  e3a00000          MOV      r0,#0                 ;807
00148c  e3a01001          MOV      r1,#1                 ;807
001490  e3510000          CMP      r1,#0                 ;807
001494  0a000001          BEQ      |L1.5280|
001498  e3a02080          MOV      r2,#0x80              ;807
00149c  ea000000          B        |L1.5284|
                  |L1.5280|
0014a0  e3a02000          MOV      r2,#0                 ;807
                  |L1.5284|
0014a4  e1827000          ORR      r7,r2,r0              ;807
0014a8  e51f02c8          LDR      r0,|L1.4584|
0014ac  e5d01010          LDRB     r1,[r0,#0x10]         ;807
0014b0  e5d0000f          LDRB     r0,[r0,#0xf]          ;807
0014b4  e1800401          ORR      r0,r0,r1,LSL #8       ;807
0014b8  e51f2294          LDR      r2,|L1.4652|
0014bc  e5d21007          LDRB     r1,[r2,#7]            ;807
0014c0  e5d22006          LDRB     r2,[r2,#6]            ;807
0014c4  e1821401          ORR      r1,r2,r1,LSL #8       ;807
0014c8  e0409001          SUB      r9,r0,r1              ;807
0014cc  e3a0a000          MOV      r10,#0                ;807
0014d0  e3a0b001          MOV      r11,#1                ;807
0014d4  e51f22d0          LDR      r2,|L1.4620|
0014d8  e8920007          LDM      r2,{r0-r2}            ;807  ; <Data3>, <Data3>, <Data3>
0014dc  e28d3010          ADD      r3,sp,#0x10           ;807
0014e0  e8830007          STM      r3,{r0-r2}            ;807
0014e4  e5cd8010          STRB     r8,[sp,#0x10]         ;807
0014e8  e5cd7014          STRB     r7,[sp,#0x14]         ;807
0014ec  e58d9018          STR      r9,[sp,#0x18]         ;807
0014f0  e5cda015          STRB     r10,[sp,#0x15]        ;807
0014f4  e1a0100b          MOV      r1,r11                ;807
0014f8  e28d0010          ADD      r0,sp,#0x10           ;807
0014fc  ebfffffe          BL       dcd_event_handler
001500  e1a00000          MOV      r0,r0                 ;807
001504  e1a00000          MOV      r0,r0                 ;807
                  |L1.5384|
001508  e1a00000          MOV      r0,r0
00150c  eafffef1          B        |L1.4312|
;;;813    
                          ENDP

                  process_edpt_n PROC
;;;814    static void process_edpt_n(uint8_t rhport, uint_fast8_t ep_addr)
001510  e92d4ff0          PUSH     {r4-r11,lr}
;;;815    {
001514  e24dd014          SUB      sp,sp,#0x14
001518  e1a05000          MOV      r5,r0
00151c  e1a04001          MOV      r4,r1
;;;816      bool completed;
;;;817      const unsigned dir_in     = tu_edpt_dir(ep_addr);
001520  e20400ff          AND      r0,r4,#0xff
001524  e2001080          AND      r1,r0,#0x80
001528  e1a013a1          LSR      r1,r1,#7
00152c  e1a07001          MOV      r7,r1
;;;818      const unsigned epn        = tu_edpt_number(ep_addr);
001530  e20400ff          AND      r0,r4,#0xff
001534  e3c01080          BIC      r1,r0,#0x80
001538  e58d1010          STR      r1,[sp,#0x10]
;;;819    
;;;820      USBC_SelectActiveEp(epn);
00153c  e59d0010          LDR      r0,[sp,#0x10]
001540  ebfffffe          BL       USBC_SelectActiveEp
;;;821    
;;;822      if (dir_in) {
001544  e3570000          CMP      r7,#0
001548  0a000009          BEQ      |L1.5492|
;;;823        // TU_LOG1(" TXCSRL%d = %x\n", epn_minus1 + 1, regs->TXCSRL);
;;;824        if (__USBC_Dev_Tx_IsEpStall()) {
00154c  ebfffffe          BL       __USBC_Dev_Tx_IsEpStall
001550  e3500000          CMP      r0,#0
001554  0a000002          BEQ      |L1.5476|
;;;825    	  __USBC_Dev_Tx_ClearStall();
001558  ebfffffe          BL       __USBC_Dev_Tx_ClearStall
                  |L1.5468|
;;;826          return;
;;;827        }
;;;828        completed = handle_xfer_in(ep_addr);
;;;829      } else {
;;;830        // TU_LOG1(" RXCSRL%d = %x\n", epn_minus1 + 1, regs->RXCSRL);
;;;831        if (__USBC_Dev_Rx_IsEpStall()) {
;;;832    	    __USBC_Dev_Rx_ClearStall();
;;;833          return;
;;;834        }
;;;835        completed = handle_xfer_out(ep_addr);
;;;836      }
;;;837    
;;;838      if (completed) {
;;;839        pipe_state_t *pipe = &_dcd.pipe[dir_in][tu_edpt_number(ep_addr) - 1];
;;;840        dcd_event_xfer_complete(rhport, ep_addr,
;;;841                                pipe->length - pipe->remaining,
;;;842                                XFER_RESULT_SUCCESS, true);
;;;843      }
;;;844    }
00155c  e28dd014          ADD      sp,sp,#0x14
001560  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.5476|
001564  e1a00004          MOV      r0,r4                 ;828
001568  ebfffffe          BL       handle_xfer_in
00156c  e1a06000          MOV      r6,r0                 ;828
001570  ea000007          B        |L1.5524|
                  |L1.5492|
001574  ebfffffe          BL       __USBC_Dev_Rx_IsEpStall
001578  e3500000          CMP      r0,#0                 ;831
00157c  0a000001          BEQ      |L1.5512|
001580  ebfffffe          BL       __USBC_Dev_Rx_ClearStall
001584  eafffff4          B        |L1.5468|
                  |L1.5512|
001588  e1a00004          MOV      r0,r4                 ;835
00158c  ebfffffe          BL       handle_xfer_out
001590  e1a06000          MOV      r6,r0                 ;835
                  |L1.5524|
001594  e3560000          CMP      r6,#0                 ;838
001598  0a00001e          BEQ      |L1.5656|
00159c  e20400ff          AND      r0,r4,#0xff           ;839
0015a0  e3c01080          BIC      r1,r0,#0x80           ;839
0015a4  e2410001          SUB      r0,r1,#1              ;839
0015a8  e0671187          RSB      r1,r7,r7,LSL #3       ;839
0015ac  e51f23c4          LDR      r2,|L1.4592|
0015b0  e0821181          ADD      r1,r2,r1,LSL #3       ;839
0015b4  e0818180          ADD      r8,r1,r0,LSL #3       ;839
0015b8  e20490ff          AND      r9,r4,#0xff           ;840
0015bc  e5d80005          LDRB     r0,[r8,#5]            ;840
0015c0  e5d81004          LDRB     r1,[r8,#4]            ;840
0015c4  e1810400          ORR      r0,r1,r0,LSL #8       ;840
0015c8  e5d81007          LDRB     r1,[r8,#7]            ;840
0015cc  e5d82006          LDRB     r2,[r8,#6]            ;840
0015d0  e1821401          ORR      r1,r2,r1,LSL #8       ;840
0015d4  e040a001          SUB      r10,r0,r1             ;840
0015d8  e3a00000          MOV      r0,#0                 ;840
0015dc  e3a0b001          MOV      r11,#1                ;840
0015e0  e58d000c          STR      r0,[sp,#0xc]          ;840
0015e4  e51f23e0          LDR      r2,|L1.4620|
0015e8  e8920007          LDM      r2,{r0-r2}            ;840  ; <Data3>, <Data3>, <Data3>
0015ec  e88d0007          STM      sp,{r0-r2}            ;840
0015f0  e5cd5000          STRB     r5,[sp,#0]            ;840
0015f4  e5cd9004          STRB     r9,[sp,#4]            ;840
0015f8  e58da008          STR      r10,[sp,#8]           ;840
0015fc  e59d000c          LDR      r0,[sp,#0xc]          ;840
001600  e5cd0005          STRB     r0,[sp,#5]            ;840
001604  e1a0100b          MOV      r1,r11                ;840
001608  e1a0000d          MOV      r0,sp                 ;840
00160c  ebfffffe          BL       dcd_event_handler
001610  e1a00000          MOV      r0,r0                 ;840
001614  e1a00000          MOV      r0,r0                 ;843
                  |L1.5656|
001618  e1a00000          MOV      r0,r0
00161c  eaffffce          B        |L1.5468|
;;;845    
                          ENDP

                  process_bus_reset PROC
;;;846    static void process_bus_reset(uint8_t rhport)
001620  e92d40fe          PUSH     {r1-r7,lr}
;;;847    {
001624  e1a04000          MOV      r4,r0
;;;848      /* When bmRequestType is REQUEST_TYPE_INVALID(0xFF),
;;;849       * a control transfer state is SETUP or STATUS stage. */
;;;850      _dcd.setup_packet.bmRequestType = REQUEST_TYPE_INVALID;
001628  e3a000ff          MOV      r0,#0xff
00162c  e51f144c          LDR      r1,|L1.4584|
001630  e5c10000          STRB     r0,[r1,#0]  ; _dcd
;;;851      _dcd.status_out = 0;
001634  e3a00000          MOV      r0,#0
001638  e5c1000a          STRB     r0,[r1,#0xa]  ; _dcd
;;;852      /* When pipe0.buf has not NULL, DATA stage works in progress. */
;;;853      _dcd.pipe0.buf = NULL;
00163c  e281100b          ADD      r1,r1,#0xb
001640  ebfffffe          BL       __aeabi_uwrite4
;;;854    
;;;855      USBC_Writew(1, USBC_REG_INTTxE(USBC0_BASE)); /* Enable only EP0 */
001644  e3a00001          MOV      r0,#1
001648  e51f1e0c          LDR      r1,|L1.2116|
00164c  e1c104b8          STRH     r0,[r1,#0x48]
;;;856      USBC_Writew(0, USBC_REG_INTRxE(USBC0_BASE));
001650  e3a00000          MOV      r0,#0
001654  e1c104ba          STRH     r0,[r1,#0x4a]
;;;857    
;;;858      dcd_event_bus_reset(rhport, USBC_Dev_QueryTransferMode(), true);
001658  ebfffffe          BL       USBC_Dev_QueryTransferMode
00165c  e1a06000          MOV      r6,r0
001660  e3a05001          MOV      r5,#1
001664  e59f28e4          LDR      r2,|L1.8016|
001668  e8920007          LDM      r2,{r0-r2}  ; <Data1>, <Data1>, <Data1>
00166c  e88d0007          STM      sp,{r0-r2}
001670  e5cd4000          STRB     r4,[sp,#0]
001674  e5cd6004          STRB     r6,[sp,#4]
001678  e1a01005          MOV      r1,r5
00167c  e1a0000d          MOV      r0,sp
001680  ebfffffe          BL       dcd_event_handler
001684  e1a00000          MOV      r0,r0
;;;859    }
001688  e8bd80fe          POP      {r1-r7,pc}
;;;860    
                          ENDP

                  dcd_int_handler PROC
;;;1168   
;;;1169   void dcd_int_handler(uint8_t rhport)
00168c  e92d43fe          PUSH     {r1-r9,lr}
;;;1170   {
001690  e1a04000          MOV      r4,r0
;;;1171     uint8_t is;
;;;1172     uint16_t txis, rxis;
;;;1173   
;;;1174     is   = USBC_Readb(USBC_REG_INTUSB(USBC0_BASE));   /* read interrupt status */
001694  e51f0e58          LDR      r0,|L1.2116|
001698  e5d0504c          LDRB     r5,[r0,#0x4c]
;;;1175     txis = USBC_Readw(USBC_REG_INTTx(USBC0_BASE)); /* read interrupt tx status */
00169c  e1d064b4          LDRH     r6,[r0,#0x44]
;;;1176     rxis = USBC_Readw(USBC_REG_INTRx(USBC0_BASE)); /* read interrupt rx status */
0016a0  e1d074b6          LDRH     r7,[r0,#0x46]
;;;1177   
;;;1178     is &= USBC_Readb(USBC_REG_INTUSBE(USBC0_BASE)); /* ignore disabled interrupts */
0016a4  e5d00050          LDRB     r0,[r0,#0x50]
0016a8  e0055000          AND      r5,r5,r0
;;;1179     USBC_Writeb(is, USBC_REG_INTUSB(USBC0_BASE)); /* sunxi musb requires a write to interrupt register to clear */
0016ac  e51f0e70          LDR      r0,|L1.2116|
0016b0  e5c0504c          STRB     r5,[r0,#0x4c]
;;;1180     if (is & USBC_INTUSB_DISCONNECT) {
0016b4  e2050020          AND      r0,r5,#0x20
0016b8  e3500000          CMP      r0,#0
0016bc  0a00000c          BEQ      |L1.5876|
;;;1181   	dcd_event_bus_signal(rhport, DCD_EVENT_UNPLUGGED, true);
0016c0  e3a08002          MOV      r8,#2
0016c4  e3a09001          MOV      r9,#1
0016c8  e3a00000          MOV      r0,#0
0016cc  e58d0000          STR      r0,[sp,#0]
0016d0  e58d0004          STR      r0,[sp,#4]
0016d4  e58d0008          STR      r0,[sp,#8]
0016d8  e5cd4000          STRB     r4,[sp,#0]
0016dc  e5cd8001          STRB     r8,[sp,#1]
0016e0  e1a01009          MOV      r1,r9
0016e4  e1a0000d          MOV      r0,sp
0016e8  ebfffffe          BL       dcd_event_handler
0016ec  e1a00000          MOV      r0,r0
0016f0  e1a00000          MOV      r0,r0
                  |L1.5876|
;;;1182     }
;;;1183     if (is & USBC_INTUSB_SOF) {
0016f4  e2050008          AND      r0,r5,#8
0016f8  e3500000          CMP      r0,#0
0016fc  0a00000c          BEQ      |L1.5940|
;;;1184       dcd_event_bus_signal(rhport, DCD_EVENT_SOF, true);
001700  e3a08003          MOV      r8,#3
001704  e3a09001          MOV      r9,#1
001708  e3a00000          MOV      r0,#0
00170c  e58d0000          STR      r0,[sp,#0]
001710  e58d0004          STR      r0,[sp,#4]
001714  e58d0008          STR      r0,[sp,#8]
001718  e5cd4000          STRB     r4,[sp,#0]
00171c  e5cd8001          STRB     r8,[sp,#1]
001720  e1a01009          MOV      r1,r9
001724  e1a0000d          MOV      r0,sp
001728  ebfffffe          BL       dcd_event_handler
00172c  e1a00000          MOV      r0,r0
001730  e1a00000          MOV      r0,r0
                  |L1.5940|
;;;1185     }
;;;1186     if (is & USBC_INTUSB_RESET) {
001734  e2050004          AND      r0,r5,#4
001738  e3500000          CMP      r0,#0
00173c  0a000005          BEQ      |L1.5976|
;;;1187       /* ep0 FADDR must be 0 when (re)entering peripheral mode */
;;;1188       USBC_SelectActiveEp(0);
001740  e3a00000          MOV      r0,#0
001744  ebfffffe          BL       USBC_SelectActiveEp
;;;1189       USBC_Dev_SetAddress(0);
001748  e3a00000          MOV      r0,#0
00174c  ebfffffe          BL       USBC_Dev_SetAddress
;;;1190       process_bus_reset(rhport);
001750  e1a00004          MOV      r0,r4
001754  ebfffffe          BL       process_bus_reset
                  |L1.5976|
;;;1191     }
;;;1192     if (is & USBC_INTUSB_RESUME) {
001758  e2050002          AND      r0,r5,#2
00175c  e3500000          CMP      r0,#0
001760  0a00000c          BEQ      |L1.6040|
;;;1193       dcd_event_bus_signal(rhport, DCD_EVENT_RESUME, true);
001764  e3a08005          MOV      r8,#5
001768  e3a09001          MOV      r9,#1
00176c  e3a00000          MOV      r0,#0
001770  e58d0000          STR      r0,[sp,#0]
001774  e58d0004          STR      r0,[sp,#4]
001778  e58d0008          STR      r0,[sp,#8]
00177c  e5cd4000          STRB     r4,[sp,#0]
001780  e5cd8001          STRB     r8,[sp,#1]
001784  e1a01009          MOV      r1,r9
001788  e1a0000d          MOV      r0,sp
00178c  ebfffffe          BL       dcd_event_handler
001790  e1a00000          MOV      r0,r0
001794  e1a00000          MOV      r0,r0
                  |L1.6040|
;;;1194     }
;;;1195     if (is & USBC_INTUSB_SUSPEND) {
001798  e2050001          AND      r0,r5,#1
00179c  e3500000          CMP      r0,#0
0017a0  0a00000c          BEQ      |L1.6104|
;;;1196       dcd_event_bus_signal(rhport, DCD_EVENT_SUSPEND, true);
0017a4  e3a08004          MOV      r8,#4
0017a8  e3a09001          MOV      r9,#1
0017ac  e3a00000          MOV      r0,#0
0017b0  e58d0000          STR      r0,[sp,#0]
0017b4  e58d0004          STR      r0,[sp,#4]
0017b8  e58d0008          STR      r0,[sp,#8]
0017bc  e5cd4000          STRB     r4,[sp,#0]
0017c0  e5cd8001          STRB     r8,[sp,#1]
0017c4  e1a01009          MOV      r1,r9
0017c8  e1a0000d          MOV      r0,sp
0017cc  ebfffffe          BL       dcd_event_handler
0017d0  e1a00000          MOV      r0,r0
0017d4  e1a00000          MOV      r0,r0
                  |L1.6104|
;;;1197     }
;;;1198   
;;;1199     txis &= USBC_Readw(USBC_REG_INTTxE(USBC0_BASE));
0017d8  e51f0f9c          LDR      r0,|L1.2116|
0017dc  e1d004b8          LDRH     r0,[r0,#0x48]
0017e0  e0066000          AND      r6,r6,r0
;;;1200     USBC_Writew(txis, USBC_REG_INTTx(USBC0_BASE));
0017e4  e51f0fa8          LDR      r0,|L1.2116|
0017e8  e1c064b4          STRH     r6,[r0,#0x44]
;;;1201     if (txis & USBC_INTTx_FLAG_EP0) {
0017ec  e2060001          AND      r0,r6,#1
0017f0  e3500000          CMP      r0,#0
0017f4  0a000002          BEQ      |L1.6148|
;;;1202       process_ep0(rhport);
0017f8  e1a00004          MOV      r0,r4
0017fc  ebfffffe          BL       process_ep0
;;;1203       txis &= ~TU_BIT(0);
001800  e3c66001          BIC      r6,r6,#1
                  |L1.6148|
;;;1204     }
;;;1205     while (txis) {
001804  ea000010          B        |L1.6220|
                  |L1.6152|
;;;1206       unsigned const num = __builtin_ctz(txis);
001808  e1a00006          MOV      r0,r6
00180c  ebfffffe          BL       __ARM_common_ctz
001810  e1a09000          MOV      r9,r0
;;;1207       process_edpt_n(rhport, tu_edpt_addr(num, TUSB_DIR_IN));
001814  e20900ff          AND      r0,r9,#0xff
001818  e3a01001          MOV      r1,#1
00181c  e3510000          CMP      r1,#0
001820  0a000001          BEQ      |L1.6188|
001824  e3a02080          MOV      r2,#0x80
001828  ea000000          B        |L1.6192|
                  |L1.6188|
00182c  e3a02000          MOV      r2,#0
                  |L1.6192|
001830  e1828000          ORR      r8,r2,r0
001834  e1a01008          MOV      r1,r8
001838  e1a00004          MOV      r0,r4
00183c  ebfffffe          BL       process_edpt_n
;;;1208       txis &= ~TU_BIT(num);
001840  e3a00001          MOV      r0,#1
001844  e1c66910          BIC      r6,r6,r0,LSL r9
;;;1209     }
001848  e1a00000          MOV      r0,r0
                  |L1.6220|
00184c  e3560000          CMP      r6,#0                 ;1205
001850  1affffec          BNE      |L1.6152|
;;;1210   
;;;1211     rxis &= USBC_Readw(USBC_REG_INTRxE(USBC0_BASE));
001854  e59f06f8          LDR      r0,|L1.8020|
001858  e1d004ba          LDRH     r0,[r0,#0x4a]
00185c  e0077000          AND      r7,r7,r0
;;;1212     USBC_Writew(rxis, USBC_REG_INTRx(USBC0_BASE));
001860  e59f06ec          LDR      r0,|L1.8020|
001864  e1c074b6          STRH     r7,[r0,#0x46]
;;;1213     while (rxis) {
001868  ea000010          B        |L1.6320|
                  |L1.6252|
;;;1214       unsigned const num = __builtin_ctz(rxis);
00186c  e1a00007          MOV      r0,r7
001870  ebfffffe          BL       __ARM_common_ctz
001874  e1a09000          MOV      r9,r0
;;;1215       process_edpt_n(rhport, tu_edpt_addr(num, TUSB_DIR_OUT));
001878  e20900ff          AND      r0,r9,#0xff
00187c  e3a01000          MOV      r1,#0
001880  e3510000          CMP      r1,#0
001884  0a000001          BEQ      |L1.6288|
001888  e3a02080          MOV      r2,#0x80
00188c  ea000000          B        |L1.6292|
                  |L1.6288|
001890  e3a02000          MOV      r2,#0
                  |L1.6292|
001894  e1828000          ORR      r8,r2,r0
001898  e1a01008          MOV      r1,r8
00189c  e1a00004          MOV      r0,r4
0018a0  ebfffffe          BL       process_edpt_n
;;;1216       rxis &= ~TU_BIT(num);
0018a4  e3a00001          MOV      r0,#1
0018a8  e1c77910          BIC      r7,r7,r0,LSL r9
;;;1217     }
0018ac  e1a00000          MOV      r0,r0
                  |L1.6320|
0018b0  e3570000          CMP      r7,#0                 ;1213
0018b4  1affffec          BNE      |L1.6252|
;;;1218   }
0018b8  e8bd83fe          POP      {r1-r9,pc}
;;;1219   
                          ENDP

                  usb_isr_handler PROC
;;;864    
;;;865    static void usb_isr_handler(void) {
0018bc  e92d4010          PUSH     {r4,lr}
;;;866    	dcd_int_handler(0);
0018c0  e3a00000          MOV      r0,#0
0018c4  ebfffffe          BL       dcd_int_handler
;;;867    }
0018c8  e8bd8010          POP      {r4,pc}
;;;868    
                          ENDP

                  dcd_connect PROC
;;;899    // Connect by enabling internal pull-up resistor on D+/D-
;;;900    void dcd_connect(uint8_t rhport)
0018cc  e59f1680          LDR      r1,|L1.8020|
;;;901    {
;;;902      (void)rhport;
;;;903      USBC_REG_set_bit_b(USBC_BP_POWER_D_SOFT_CONNECT, USBC_REG_PCTL(USBC0_BASE));
0018d0  e5d11040          LDRB     r1,[r1,#0x40]
0018d4  e3811040          ORR      r1,r1,#0x40
0018d8  e59f2674          LDR      r2,|L1.8020|
0018dc  e5c21040          STRB     r1,[r2,#0x40]
;;;904    }
0018e0  e12fff1e          BX       lr
;;;905    
                          ENDP

                  musb_int_unmask PROC
;;;937    
;;;938    static void musb_int_unmask(void)
0018e4  e92d4010          PUSH     {r4,lr}
;;;939    {
;;;940      f1c100s_intc_unmask_irq(F1C100S_IRQ_USBOTG);
0018e8  e3a0001a          MOV      r0,#0x1a
0018ec  ebfffffe          BL       f1c100s_intc_unmask_irq
;;;941    }
0018f0  e8bd8010          POP      {r4,pc}
;;;942    
                          ENDP

                  musb_int_mask PROC
;;;926    
;;;927    static void musb_int_mask(void)
0018f4  e92d4010          PUSH     {r4,lr}
;;;928    {
;;;929      f1c100s_intc_mask_irq(F1C100S_IRQ_USBOTG);
0018f8  e3a0001a          MOV      r0,#0x1a
0018fc  ebfffffe          BL       f1c100s_intc_mask_irq
;;;930    }
001900  e8bd8010          POP      {r4,pc}
;;;931    
                          ENDP

                  dcd_edpt_close_all PROC
;;;1038   
;;;1039   void dcd_edpt_close_all(uint8_t rhport)
001904  e92d4070          PUSH     {r4-r6,lr}
;;;1040   {
001908  e1a05000          MOV      r5,r0
;;;1041     (void) rhport;
;;;1042     musb_int_mask();
00190c  ebfffffe          BL       musb_int_mask
;;;1043     USBC_Writew(1, USBC_REG_INTTxE(USBC0_BASE)); /* Enable only EP0 */
001910  e3a00001          MOV      r0,#1
001914  e59f1638          LDR      r1,|L1.8020|
001918  e1c104b8          STRH     r0,[r1,#0x48]
;;;1044     USBC_Writew(0, USBC_REG_INTRxE(USBC0_BASE));
00191c  e3a00000          MOV      r0,#0
001920  e1c104ba          STRH     r0,[r1,#0x4a]
;;;1045     for (unsigned i = 1; i < TUP_DCD_ENDPOINT_MAX; ++i) {
001924  e3a04001          MOV      r4,#1
001928  ea000010          B        |L1.6512|
                  |L1.6444|
;;;1046       USBC_SelectActiveEp(i);
00192c  e20400ff          AND      r0,r4,#0xff
001930  ebfffffe          BL       USBC_SelectActiveEp
;;;1047       USBC_Writew(0, USBC_REG_TXMAXP(USBC0_BASE));
001934  e3a00000          MOV      r0,#0
001938  e59f1614          LDR      r1,|L1.8020|
00193c  e1c108b0          STRH     r0,[r1,#0x80]
;;;1048   		USBC_Writew((1 << USBC_BP_TXCSR_D_MODE) | (1 << USBC_BP_TXCSR_D_CLEAR_DATA_TOGGLE) | (1 << USBC_BP_TXCSR_D_FLUSH_FIFO),
001940  e59f0610          LDR      r0,|L1.8024|
001944  e1c108b2          STRH     r0,[r1,#0x82]
;;;1049         USBC_REG_TXCSR(USBC0_BASE));
;;;1050   
;;;1051       USBC_Writew(0, USBC_REG_RXMAXP(USBC0_BASE));
001948  e3a00000          MOV      r0,#0
00194c  e1c108b4          STRH     r0,[r1,#0x84]
;;;1052   	  USBC_Writew((1 << USBC_BP_RXCSR_D_CLEAR_DATA_TOGGLE) | (1 << USBC_BP_RXCSR_D_FLUSH_FIFO),
001950  e3a00090          MOV      r0,#0x90
001954  e1c108b6          STRH     r0,[r1,#0x86]
;;;1053         USBC_REG_RXCSR(USBC0_BASE));
;;;1054   
;;;1055       USBC_Writew(0, USBC_REG_TXFIFOAD(USBC0_BASE));
001958  e3a00000          MOV      r0,#0
00195c  e1c109b2          STRH     r0,[r1,#0x92]
;;;1056       USBC_Writeb(0, USBC_REG_TXFIFOSZ(USBC0_BASE));
001960  e5c10090          STRB     r0,[r1,#0x90]
;;;1057       USBC_Writew(0, USBC_REG_RXFIFOAD(USBC0_BASE));
001964  e1c109b6          STRH     r0,[r1,#0x96]
;;;1058       USBC_Writeb(0, USBC_REG_RXFIFOSZ(USBC0_BASE));
001968  e5c10094          STRB     r0,[r1,#0x94]
00196c  e2844001          ADD      r4,r4,#1              ;1045
                  |L1.6512|
001970  e3540004          CMP      r4,#4                 ;1045
001974  3affffec          BCC      |L1.6444|
;;;1059     }
;;;1060     musb_int_unmask();
001978  ebfffffe          BL       musb_int_unmask
;;;1061   }
00197c  e8bd8070          POP      {r4-r6,pc}
;;;1062   
                          ENDP

                  dcd_disconnect PROC
;;;906    // Disconnect by disabling internal pull-up resistor on D+/D-
;;;907    void dcd_disconnect(uint8_t rhport)
001980  e59f15cc          LDR      r1,|L1.8020|
;;;908    {
;;;909      (void)rhport;
;;;910      USBC_REG_clear_bit_b(USBC_BP_POWER_D_SOFT_CONNECT, USBC_REG_PCTL(USBC0_BASE));
001984  e5d11040          LDRB     r1,[r1,#0x40]
001988  e3c11040          BIC      r1,r1,#0x40
00198c  e59f25c0          LDR      r2,|L1.8020|
001990  e5c21040          STRB     r1,[r2,#0x40]
;;;911    }
001994  e12fff1e          BX       lr
;;;912    
                          ENDP

                  dcd_init PROC
;;;868    
;;;869    void dcd_init(uint8_t rhport)
001998  e92d4010          PUSH     {r4,lr}
;;;870    {
00199c  e1a04000          MOV      r4,r0
;;;871      dcd_disconnect(rhport);
0019a0  e1a00004          MOV      r0,r4
0019a4  ebfffffe          BL       dcd_disconnect
;;;872      USBC_HardwareReset();
0019a8  ebfffffe          BL       USBC_HardwareReset
;;;873      USBC_PhyConfig();
0019ac  ebfffffe          BL       USBC_PhyConfig
;;;874      USBC_ConfigFIFO_Base();
0019b0  ebfffffe          BL       USBC_ConfigFIFO_Base
;;;875      USBC_EnableDpDmPullUp();
0019b4  ebfffffe          BL       USBC_EnableDpDmPullUp
;;;876      USBC_ForceIdToHigh(); // Force device mode
0019b8  ebfffffe          BL       USBC_ForceIdToHigh
;;;877      USBC_ForceVbusValidToHigh();
0019bc  ebfffffe          BL       USBC_ForceVbusValidToHigh
;;;878      USBC_SelectBus(USBC_IO_TYPE_PIO, 0, 0);
0019c0  e3a02000          MOV      r2,#0
0019c4  e1a01002          MOV      r1,r2
0019c8  e1a00002          MOV      r0,r2
0019cc  ebfffffe          BL       USBC_SelectBus
;;;879      dcd_edpt_close_all(rhport);
0019d0  e1a00004          MOV      r0,r4
0019d4  ebfffffe          BL       dcd_edpt_close_all
;;;880    
;;;881      #if TUD_OPT_HIGH_SPEED
;;;882        USBC_REG_set_bit_b(USBC_BP_POWER_D_HIGH_SPEED_EN, USBC_REG_PCTL(USBC0_BASE));
0019d8  e59f0574          LDR      r0,|L1.8020|
0019dc  e5d00040          LDRB     r0,[r0,#0x40]
0019e0  e3800020          ORR      r0,r0,#0x20
0019e4  e59f1568          LDR      r1,|L1.8020|
0019e8  e5c10040          STRB     r0,[r1,#0x40]
;;;883      #else
;;;884        USBC_REG_clear_bit_b(USBC_BP_POWER_D_HIGH_SPEED_EN, USBC_REG_PCTL(USBC0_BASE));
;;;885      #endif
;;;886    
;;;887      USBC_Writeb((1 << USBC_BP_INTUSBE_EN_SUSPEND)
0019ec  e3a0002f          MOV      r0,#0x2f
0019f0  e5c10050          STRB     r0,[r1,#0x50]
;;;888        | (1 << USBC_BP_INTUSBE_EN_RESUME)
;;;889        | (1 << USBC_BP_INTUSBE_EN_RESET)
;;;890        | (1 << USBC_BP_INTUSBE_EN_SOF)
;;;891        | (1 << USBC_BP_INTUSBE_EN_DISCONNECT)
;;;892        , USBC_REG_INTUSBE(USBC0_BASE));
;;;893      f1c100s_intc_clear_pend(F1C100S_IRQ_USBOTG);
0019f4  e3a0001a          MOV      r0,#0x1a
0019f8  ebfffffe          BL       f1c100s_intc_clear_pend
;;;894      f1c100s_intc_set_isr(F1C100S_IRQ_USBOTG, usb_isr_handler);
0019fc  e59f1558          LDR      r1,|L1.8028|
001a00  e3a0001a          MOV      r0,#0x1a
001a04  ebfffffe          BL       f1c100s_intc_set_isr
;;;895    
;;;896      dcd_connect(rhport);
001a08  e1a00004          MOV      r0,r4
001a0c  ebfffffe          BL       dcd_connect
;;;897    }
001a10  e8bd8010          POP      {r4,pc}
;;;898    
                          ENDP

                  dcd_sof_enable PROC
;;;912    
;;;913    void dcd_sof_enable(uint8_t rhport, bool en)
001a14  e12fff1e          BX       lr
;;;914    {
;;;915      (void) rhport;
;;;916      (void) en;
;;;917    
;;;918      // TODO implement later
;;;919    }
;;;920    
                          ENDP

                  dcd_int_enable PROC
;;;921    void dcd_int_enable(uint8_t rhport)
001a18  e92d4010          PUSH     {r4,lr}
;;;922    {
001a1c  e1a04000          MOV      r4,r0
;;;923      (void)rhport;
;;;924      f1c100s_intc_enable_irq(F1C100S_IRQ_USBOTG);
001a20  e3a0001a          MOV      r0,#0x1a
001a24  ebfffffe          BL       f1c100s_intc_enable_irq
;;;925    }
001a28  e8bd8010          POP      {r4,pc}
;;;926    
                          ENDP

                  dcd_int_disable PROC
;;;931    
;;;932    void dcd_int_disable(uint8_t rhport)
001a2c  e92d4010          PUSH     {r4,lr}
;;;933    {
001a30  e1a04000          MOV      r4,r0
;;;934      (void)rhport;
;;;935      f1c100s_intc_disable_irq(F1C100S_IRQ_USBOTG);
001a34  e3a0001a          MOV      r0,#0x1a
001a38  ebfffffe          BL       f1c100s_intc_disable_irq
;;;936    }
001a3c  e8bd8010          POP      {r4,pc}
;;;937    
                          ENDP

                  dcd_set_address PROC
;;;943    // Receive Set Address request, mcu port must also include status IN response
;;;944    void dcd_set_address(uint8_t rhport, uint8_t dev_addr)
001a40  e92d4070          PUSH     {r4-r6,lr}
;;;945    {
001a44  e1a04000          MOV      r4,r0
001a48  e1a05001          MOV      r5,r1
;;;946      (void)rhport;
;;;947      (void)dev_addr;
;;;948      _dcd.pipe0.buf       = NULL;
001a4c  e51f1828          LDR      r1,|L1.4652|
001a50  e3a00000          MOV      r0,#0
001a54  ebfffffe          BL       __aeabi_uwrite4
;;;949      _dcd.pipe0.length    = 0;
001a58  e3a00000          MOV      r0,#0
001a5c  e51f187c          LDR      r1,|L1.4584|
001a60  e5c1000f          STRB     r0,[r1,#0xf]
001a64  e5c10010          STRB     r0,[r1,#0x10]
;;;950      _dcd.pipe0.remaining = 0;
001a68  e5c10011          STRB     r0,[r1,#0x11]
001a6c  e5c10012          STRB     r0,[r1,#0x12]
;;;951      /* Clear RX FIFO to return ACK. */
;;;952      USBC_SelectActiveEp(0);
001a70  ebfffffe          BL       USBC_SelectActiveEp
;;;953      __USBC_Dev_ep0_ReadDataComplete();
001a74  ebfffffe          BL       __USBC_Dev_ep0_ReadDataComplete
;;;954    }
001a78  e8bd8070          POP      {r4-r6,pc}
;;;955    
                          ENDP

                  dcd_remote_wakeup PROC
;;;956    // Wake up host
;;;957    void dcd_remote_wakeup(uint8_t rhport)
001a7c  e92d4010          PUSH     {r4,lr}
;;;958    {
001a80  e1a04000          MOV      r4,r0
;;;959      (void)rhport;
;;;960      USBC_REG_set_bit_b(USBC_BP_POWER_D_RESUME, USBC_REG_PCTL(USBC0_BASE));
001a84  e59f04c8          LDR      r0,|L1.8020|
001a88  e5d00040          LDRB     r0,[r0,#0x40]
001a8c  e3800004          ORR      r0,r0,#4
001a90  e59f14bc          LDR      r1,|L1.8020|
001a94  e5c10040          STRB     r0,[r1,#0x40]
;;;961      delay_ms(10);
001a98  e3a0000a          MOV      r0,#0xa
001a9c  ebfffffe          BL       delay_ms
;;;962      USBC_REG_clear_bit_b(USBC_BP_POWER_D_RESUME, USBC_REG_PCTL(USBC0_BASE));
001aa0  e59f04ac          LDR      r0,|L1.8020|
001aa4  e5d00040          LDRB     r0,[r0,#0x40]
001aa8  e3c00004          BIC      r0,r0,#4
001aac  e59f14a0          LDR      r1,|L1.8020|
001ab0  e5c10040          STRB     r0,[r1,#0x40]
;;;963    }
001ab4  e8bd8010          POP      {r4,pc}
;;;964    
                          ENDP

                  dcd_edpt_open PROC
;;;973    // Configure endpoint's registers according to descriptor
;;;974    bool dcd_edpt_open(uint8_t rhport, tusb_desc_endpoint_t const * ep_desc)
001ab8  e92d5ffc          PUSH     {r2-r12,lr}
;;;975    {
001abc  e1a0a001          MOV      r10,r1
;;;976      (void) rhport;
;;;977    
;;;978      uint16_t reg_val;
;;;979    
;;;980      const unsigned ep_addr = ep_desc->bEndpointAddress;
001ac0  e5da4002          LDRB     r4,[r10,#2]
;;;981      const unsigned epn     = tu_edpt_number(ep_addr);
001ac4  e1a00000          MOV      r0,r0
001ac8  e3c40080          BIC      r0,r4,#0x80
001acc  e1a07000          MOV      r7,r0
;;;982      const unsigned dir_in  = tu_edpt_dir(ep_addr);
001ad0  e1a00000          MOV      r0,r0
001ad4  e2040080          AND      r0,r4,#0x80
001ad8  e1a003a0          LSR      r0,r0,#7
001adc  e58d0004          STR      r0,[sp,#4]
;;;983      const unsigned xfer    = ep_desc->bmAttributes.xfer;
001ae0  e5da0003          LDRB     r0,[r10,#3]
001ae4  e2000003          AND      r0,r0,#3
001ae8  e58d0000          STR      r0,[sp,#0]
;;;984      const unsigned mps     = tu_edpt_packet_size(ep_desc);
001aec  e1a00000          MOV      r0,r0
001af0  e5da0005          LDRB     r0,[r10,#5]
001af4  e5da1004          LDRB     r1,[r10,#4]
001af8  e1810400          ORR      r0,r1,r0,LSL #8
001afc  e3c00b3e          BIC      r0,r0,#0xf800
001b00  e1a08000          MOV      r8,r0
;;;985    
;;;986      TU_ASSERT(epn < TUP_DCD_ENDPOINT_MAX);
001b04  e1a00000          MOV      r0,r0
001b08  e3570004          CMP      r7,#4
001b0c  3a000007          BCC      |L1.6960|
001b10  e59f2448          LDR      r2,|L1.8032|
001b14  e59f1448          LDR      r1,|L1.8036|
001b18  e51f091c          LDR      r0,|L1.4612|
001b1c  ebfffffe          BL       __2printf
001b20  e1a00000          MOV      r0,r0
001b24  e1a00000          MOV      r0,r0
001b28  e3a00000          MOV      r0,#0
                  |L1.6956|
;;;987    
;;;988      pipe_state_t *pipe = &_dcd.pipe[dir_in][epn - 1];
;;;989      pipe->buf       = NULL;
;;;990      pipe->length    = 0;
;;;991      pipe->remaining = 0;
;;;992    
;;;993      musb_int_mask();
;;;994    
;;;995      // volatile hw_endpoint_t *regs = edpt_regs(epn - 1);
;;;996      USBC_SelectActiveEp(epn);
;;;997      if (dir_in) {
;;;998        USBC_Writew(mps, USBC_REG_TXMAXP(USBC0_BASE));
;;;999    
;;;1000       reg_val = (1 << USBC_BP_TXCSR_D_MODE)
;;;1001         | (1 << USBC_BP_TXCSR_D_FLUSH_FIFO)
;;;1002         | (1 << USBC_BP_TXCSR_D_CLEAR_DATA_TOGGLE);
;;;1003       if  (xfer == TUSB_XFER_ISOCHRONOUS)
;;;1004         reg_val |= (1 << USBC_BP_TXCSR_D_ISO);
;;;1005   	  USBC_Writew(reg_val, USBC_REG_TXCSR(USBC0_BASE));
;;;1006   
;;;1007       USBC_INT_EnableTxEp(epn);
;;;1008     } else {
;;;1009       USBC_Writew(mps, USBC_REG_RXMAXP(USBC0_BASE));
;;;1010   
;;;1011       reg_val = (1 << USBC_BP_RXCSR_D_FLUSH_FIFO)
;;;1012         | (1 << USBC_BP_RXCSR_D_CLEAR_DATA_TOGGLE);
;;;1013       if  (xfer == TUSB_XFER_ISOCHRONOUS)
;;;1014         reg_val |= (1 << USBC_BP_RXCSR_D_ISO);
;;;1015       USBC_Writew(reg_val, USBC_REG_RXCSR(USBC0_BASE));
;;;1016   
;;;1017       USBC_INT_EnableRxEp(epn);
;;;1018     }
;;;1019   
;;;1020     /* Setup FIFO */
;;;1021     int size_in_log2_minus3 = 28 - TU_MIN(28, __clz((uint32_t)mps));
;;;1022     if ((8u << size_in_log2_minus3) < mps) ++size_in_log2_minus3;
;;;1023     unsigned addr = find_free_memory(size_in_log2_minus3);
;;;1024     TU_ASSERT(addr);
;;;1025   
;;;1026     if (dir_in) {
;;;1027       USBC_Writew(addr, USBC_REG_TXFIFOAD(USBC0_BASE));
;;;1028       USBC_Writeb(size_in_log2_minus3, USBC_REG_TXFIFOSZ(USBC0_BASE));
;;;1029     } else {
;;;1030       USBC_Writew(addr, USBC_REG_RXFIFOAD(USBC0_BASE));
;;;1031       USBC_Writeb(size_in_log2_minus3, USBC_REG_RXFIFOSZ(USBC0_BASE));
;;;1032     }
;;;1033   
;;;1034     musb_int_unmask();
;;;1035   
;;;1036     return true;
;;;1037   }
001b2c  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.6960|
001b30  e1a00000          MOV      r0,r0                 ;986
001b34  e59d0004          LDR      r0,[sp,#4]            ;988
001b38  e0600180          RSB      r0,r0,r0,LSL #3       ;988
001b3c  e51f1954          LDR      r1,|L1.4592|
001b40  e0810180          ADD      r0,r1,r0,LSL #3       ;988
001b44  e2471001          SUB      r1,r7,#1              ;988
001b48  e080b181          ADD      r11,r0,r1,LSL #3      ;988
001b4c  e1a0100b          MOV      r1,r11                ;989
001b50  e3a00000          MOV      r0,#0                 ;989
001b54  ebfffffe          BL       __aeabi_uwrite4
001b58  e3a00000          MOV      r0,#0                 ;990
001b5c  e5cb0004          STRB     r0,[r11,#4]           ;990
001b60  e5cb0005          STRB     r0,[r11,#5]           ;990
001b64  e5cb0006          STRB     r0,[r11,#6]           ;991
001b68  e5cb0007          STRB     r0,[r11,#7]           ;991
001b6c  ebfffffe          BL       musb_int_mask
001b70  e20700ff          AND      r0,r7,#0xff           ;996
001b74  ebfffffe          BL       USBC_SelectActiveEp
001b78  e59d0004          LDR      r0,[sp,#4]            ;997
001b7c  e3500000          CMP      r0,#0                 ;997
001b80  0a00000b          BEQ      |L1.7092|
001b84  e59f13c8          LDR      r1,|L1.8020|
001b88  e1c188b0          STRH     r8,[r1,#0x80]         ;998
001b8c  e59f53c4          LDR      r5,|L1.8024|
001b90  e59d0000          LDR      r0,[sp,#0]            ;1003
001b94  e3500001          CMP      r0,#1                 ;1003
001b98  1a000000          BNE      |L1.7072|
001b9c  e3855901          ORR      r5,r5,#0x4000         ;1004
                  |L1.7072|
001ba0  e59f03ac          LDR      r0,|L1.8020|
001ba4  e1c058b2          STRH     r5,[r0,#0x82]         ;1005
001ba8  e20700ff          AND      r0,r7,#0xff           ;1007
001bac  ebfffffe          BL       USBC_INT_EnableTxEp
001bb0  ea00000a          B        |L1.7136|
                  |L1.7092|
001bb4  e59f1398          LDR      r1,|L1.8020|
001bb8  e1c188b4          STRH     r8,[r1,#0x84]         ;1009
001bbc  e3a05090          MOV      r5,#0x90              ;1011
001bc0  e59d0000          LDR      r0,[sp,#0]            ;1013
001bc4  e3500001          CMP      r0,#1                 ;1013
001bc8  1a000000          BNE      |L1.7120|
001bcc  e3855901          ORR      r5,r5,#0x4000         ;1014
                  |L1.7120|
001bd0  e59f037c          LDR      r0,|L1.8020|
001bd4  e1c058b6          STRH     r5,[r0,#0x86]         ;1015
001bd8  e20700ff          AND      r0,r7,#0xff           ;1017
001bdc  ebfffffe          BL       USBC_INT_EnableRxEp
                  |L1.7136|
001be0  e16f0f18          CLZ      r0,r8                 ;1021
001be4  e350001c          CMP      r0,#0x1c              ;1021
001be8  da000001          BLE      |L1.7156|
001bec  e3a0001c          MOV      r0,#0x1c              ;1021
001bf0  ea000000          B        |L1.7160|
                  |L1.7156|
001bf4  e16f0f18          CLZ      r0,r8                 ;1021
                  |L1.7160|
001bf8  e260601c          RSB      r6,r0,#0x1c           ;1021
001bfc  e3a00008          MOV      r0,#8                 ;1022
001c00  e1a00610          LSL      r0,r0,r6              ;1022
001c04  e1500008          CMP      r0,r8                 ;1022
001c08  2a000000          BCS      |L1.7184|
001c0c  e2866001          ADD      r6,r6,#1              ;1022
                  |L1.7184|
001c10  e1a00006          MOV      r0,r6                 ;1023
001c14  ebfffffe          BL       find_free_memory
001c18  e1a09000          MOV      r9,r0                 ;1023
001c1c  e1a00000          MOV      r0,r0                 ;1024
001c20  e3590000          CMP      r9,#0                 ;1024
001c24  1a000007          BNE      |L1.7240|
001c28  e3a02b01          MOV      r2,#0x400             ;1024
001c2c  e59f1330          LDR      r1,|L1.8036|
001c30  e51f0a34          LDR      r0,|L1.4612|
001c34  ebfffffe          BL       __2printf
001c38  e1a00000          MOV      r0,r0                 ;1024
001c3c  e1a00000          MOV      r0,r0                 ;1024
001c40  e3a00000          MOV      r0,#0                 ;1024
001c44  eaffffb8          B        |L1.6956|
                  |L1.7240|
001c48  e1a00000          MOV      r0,r0                 ;1024
001c4c  e59d0004          LDR      r0,[sp,#4]            ;1026
001c50  e3500000          CMP      r0,#0                 ;1026
001c54  0a000003          BEQ      |L1.7272|
001c58  e59f12f4          LDR      r1,|L1.8020|
001c5c  e1c199b2          STRH     r9,[r1,#0x92]         ;1027
001c60  e5c16090          STRB     r6,[r1,#0x90]         ;1028
001c64  ea000002          B        |L1.7284|
                  |L1.7272|
001c68  e59f12e4          LDR      r1,|L1.8020|
001c6c  e1c199b6          STRH     r9,[r1,#0x96]         ;1030
001c70  e5c16094          STRB     r6,[r1,#0x94]         ;1031
                  |L1.7284|
001c74  ebfffffe          BL       musb_int_unmask
001c78  e3a00001          MOV      r0,#1                 ;1036
001c7c  eaffffaa          B        |L1.6956|
;;;1038   
                          ENDP

                  dcd_edpt_close PROC
;;;1062   
;;;1063   void dcd_edpt_close(uint8_t rhport, uint8_t ep_addr)
001c80  e92d41f0          PUSH     {r4-r8,lr}
;;;1064   {
001c84  e1a07000          MOV      r7,r0
001c88  e1a04001          MOV      r4,r1
;;;1065     (void)rhport;
;;;1066     unsigned const epn    = tu_edpt_number(ep_addr);
001c8c  e1a00000          MOV      r0,r0
001c90  e3c40080          BIC      r0,r4,#0x80
001c94  e1a05000          MOV      r5,r0
;;;1067     unsigned const dir_in = tu_edpt_dir(ep_addr);
001c98  e1a00000          MOV      r0,r0
001c9c  e2040080          AND      r0,r4,#0x80
001ca0  e1a003a0          LSR      r0,r0,#7
001ca4  e1a06000          MOV      r6,r0
;;;1068   
;;;1069     musb_int_mask();
001ca8  ebfffffe          BL       musb_int_mask
;;;1070     USBC_SelectActiveEp(epn);
001cac  e20500ff          AND      r0,r5,#0xff
001cb0  ebfffffe          BL       USBC_SelectActiveEp
;;;1071     if (dir_in) {
001cb4  e3560000          CMP      r6,#0
001cb8  0a00000a          BEQ      |L1.7400|
;;;1072       USBC_INT_DisableTxEp(epn);
001cbc  e20500ff          AND      r0,r5,#0xff
001cc0  ebfffffe          BL       USBC_INT_DisableTxEp
;;;1073       USBC_Writew(0, USBC_REG_TXMAXP(USBC0_BASE));
001cc4  e3a00000          MOV      r0,#0
001cc8  e59f1284          LDR      r1,|L1.8020|
001ccc  e1c108b0          STRH     r0,[r1,#0x80]
;;;1074   		USBC_Writew((1 << USBC_BP_TXCSR_D_MODE) | (1 << USBC_BP_TXCSR_D_CLEAR_DATA_TOGGLE) | (1 << USBC_BP_TXCSR_D_FLUSH_FIFO),
001cd0  e59f0280          LDR      r0,|L1.8024|
001cd4  e1c108b2          STRH     r0,[r1,#0x82]
;;;1075         USBC_REG_TXCSR(USBC0_BASE));
;;;1076   
;;;1077       USBC_Writew(0, USBC_REG_TXFIFOAD(USBC0_BASE));
001cd8  e3a00000          MOV      r0,#0
001cdc  e1c109b2          STRH     r0,[r1,#0x92]
;;;1078       USBC_Writeb(0, USBC_REG_TXFIFOSZ(USBC0_BASE));
001ce0  e5c10090          STRB     r0,[r1,#0x90]
001ce4  ea000009          B        |L1.7440|
                  |L1.7400|
;;;1079     } else {
;;;1080       USBC_INT_DisableRxEp(epn);
001ce8  e20500ff          AND      r0,r5,#0xff
001cec  ebfffffe          BL       USBC_INT_DisableRxEp
;;;1081       USBC_Writew(0, USBC_REG_RXMAXP(USBC0_BASE));
001cf0  e3a00000          MOV      r0,#0
001cf4  e59f1258          LDR      r1,|L1.8020|
001cf8  e1c108b4          STRH     r0,[r1,#0x84]
;;;1082   	  USBC_Writew((1 << USBC_BP_RXCSR_D_CLEAR_DATA_TOGGLE) | (1 << USBC_BP_RXCSR_D_FLUSH_FIFO),
001cfc  e3a00090          MOV      r0,#0x90
001d00  e1c108b6          STRH     r0,[r1,#0x86]
;;;1083         USBC_REG_RXCSR(USBC0_BASE));
;;;1084   
;;;1085       USBC_Writew(0, USBC_REG_RXFIFOAD(USBC0_BASE));
001d04  e3a00000          MOV      r0,#0
001d08  e1c109b6          STRH     r0,[r1,#0x96]
;;;1086       USBC_Writeb(0, USBC_REG_RXFIFOSZ(USBC0_BASE));
001d0c  e5c10094          STRB     r0,[r1,#0x94]
                  |L1.7440|
;;;1087     }
;;;1088     musb_int_unmask();
001d10  ebfffffe          BL       musb_int_unmask
;;;1089   }
001d14  e8bd81f0          POP      {r4-r8,pc}
;;;1090   
                          ENDP

                  dcd_edpt_xfer PROC
;;;1091   // Submit a transfer, When complete dcd_event_xfer_complete() is invoked to notify the stack
;;;1092   bool dcd_edpt_xfer(uint8_t rhport, uint8_t ep_addr, uint8_t * buffer, uint16_t total_bytes)
001d18  e92d47f0          PUSH     {r4-r10,lr}
;;;1093   {
001d1c  e1a06000          MOV      r6,r0
001d20  e1a04001          MOV      r4,r1
001d24  e1a07002          MOV      r7,r2
001d28  e1a08003          MOV      r8,r3
;;;1094     (void)rhport;
;;;1095     bool ret;
;;;1096     // TU_LOG1("X %x %d\n", ep_addr, total_bytes);
;;;1097     unsigned const epnum = tu_edpt_number(ep_addr);
001d2c  e1a00000          MOV      r0,r0
001d30  e3c40080          BIC      r0,r4,#0x80
001d34  e1a05000          MOV      r5,r0
;;;1098     musb_int_mask();
001d38  ebfffffe          BL       musb_int_mask
;;;1099   
;;;1100     if (epnum) {
001d3c  e3550000          CMP      r5,#0
001d40  0a000010          BEQ      |L1.7560|
;;;1101       _dcd.pipe_buf_is_fifo[tu_edpt_dir(ep_addr)] &= ~TU_BIT(epnum - 1);
001d44  e1a00000          MOV      r0,r0
001d48  e2041080          AND      r1,r4,#0x80
001d4c  e1a013a1          LSR      r1,r1,#7
001d50  e59f2210          LDR      r2,|L1.8040|
001d54  e0820081          ADD      r0,r2,r1,LSL #1
001d58  e1d010b0          LDRH     r1,[r0,#0]
001d5c  e2452001          SUB      r2,r5,#1
001d60  e3a03001          MOV      r3,#1
001d64  e1c11213          BIC      r1,r1,r3,LSL r2
001d68  e1c010b0          STRH     r1,[r0,#0]
;;;1102       ret = edpt_n_xfer(rhport, ep_addr, buffer, total_bytes);
001d6c  e1a03008          MOV      r3,r8
001d70  e1a02007          MOV      r2,r7
001d74  e1a01004          MOV      r1,r4
001d78  e1a00006          MOV      r0,r6
001d7c  ebfffffe          BL       edpt_n_xfer
001d80  e1a09000          MOV      r9,r0
001d84  ea000005          B        |L1.7584|
                  |L1.7560|
;;;1103     } else {
;;;1104       ret = edpt0_xfer(rhport, ep_addr, buffer, total_bytes);
001d88  e1a03008          MOV      r3,r8
001d8c  e1a02007          MOV      r2,r7
001d90  e1a01004          MOV      r1,r4
001d94  e1a00006          MOV      r0,r6
001d98  ebfffffe          BL       edpt0_xfer
001d9c  e1a09000          MOV      r9,r0
                  |L1.7584|
;;;1105     }
;;;1106     musb_int_unmask();
001da0  ebfffffe          BL       musb_int_unmask
;;;1107     return ret;
001da4  e1a00009          MOV      r0,r9
;;;1108   }
001da8  e8bd87f0          POP      {r4-r10,pc}
;;;1109   
                          ENDP

                  dcd_edpt_xfer_fifo PROC
;;;1110   // Submit a transfer where is managed by FIFO, When complete dcd_event_xfer_complete() is invoked to notify the stack - optional, however, must be listed in usbd.c
;;;1111   bool dcd_edpt_xfer_fifo(uint8_t rhport, uint8_t ep_addr, tu_fifo_t * ff, uint16_t total_bytes)
001dac  e92d47f0          PUSH     {r4-r10,lr}
;;;1112   {
001db0  e1a06000          MOV      r6,r0
001db4  e1a04001          MOV      r4,r1
001db8  e1a07002          MOV      r7,r2
001dbc  e1a08003          MOV      r8,r3
;;;1113     (void)rhport;
;;;1114     bool ret;
;;;1115     // TU_LOG1("X %x %d\n", ep_addr, total_bytes);
;;;1116     unsigned const epnum = tu_edpt_number(ep_addr);
001dc0  e1a00000          MOV      r0,r0
001dc4  e3c40080          BIC      r0,r4,#0x80
001dc8  e1a05000          MOV      r5,r0
;;;1117     TU_ASSERT(epnum);
001dcc  e1a00000          MOV      r0,r0
001dd0  e3550000          CMP      r5,#0
001dd4  1a000007          BNE      |L1.7672|
001dd8  e59f218c          LDR      r2,|L1.8044|
001ddc  e59f118c          LDR      r1,|L1.8048|
001de0  e51f0be4          LDR      r0,|L1.4612|
001de4  ebfffffe          BL       __2printf
001de8  e1a00000          MOV      r0,r0
001dec  e1a00000          MOV      r0,r0
001df0  e3a00000          MOV      r0,#0
                  |L1.7668|
;;;1118   
;;;1119     musb_int_mask();
;;;1120     _dcd.pipe_buf_is_fifo[tu_edpt_dir(ep_addr)] |= TU_BIT(epnum - 1);
;;;1121     ret = edpt_n_xfer(rhport, ep_addr, (uint8_t*)ff, total_bytes);
;;;1122     musb_int_unmask();
;;;1123   
;;;1124     return ret;
;;;1125   }
001df4  e8bd87f0          POP      {r4-r10,pc}
                  |L1.7672|
001df8  e1a00000          MOV      r0,r0                 ;1117
001dfc  ebfffffe          BL       musb_int_mask
001e00  e1a00000          MOV      r0,r0                 ;1120
001e04  e2041080          AND      r1,r4,#0x80           ;1120
001e08  e1a013a1          LSR      r1,r1,#7              ;1120
001e0c  e59f2154          LDR      r2,|L1.8040|
001e10  e0820081          ADD      r0,r2,r1,LSL #1       ;1120
001e14  e1d010b0          LDRH     r1,[r0,#0]            ;1120
001e18  e2452001          SUB      r2,r5,#1              ;1120
001e1c  e3a03001          MOV      r3,#1                 ;1120
001e20  e1811213          ORR      r1,r1,r3,LSL r2       ;1120
001e24  e1c010b0          STRH     r1,[r0,#0]            ;1120
001e28  e1a03008          MOV      r3,r8                 ;1121
001e2c  e1a02007          MOV      r2,r7                 ;1121
001e30  e1a01004          MOV      r1,r4                 ;1121
001e34  e1a00006          MOV      r0,r6                 ;1121
001e38  ebfffffe          BL       edpt_n_xfer
001e3c  e1a09000          MOV      r9,r0                 ;1121
001e40  ebfffffe          BL       musb_int_unmask
001e44  e1a00009          MOV      r0,r9                 ;1124
001e48  eaffffe9          B        |L1.7668|
;;;1126   
                          ENDP

                  dcd_edpt_stall PROC
;;;1127   // Stall endpoint
;;;1128   void dcd_edpt_stall(uint8_t rhport, uint8_t ep_addr)
001e4c  e92d4070          PUSH     {r4-r6,lr}
;;;1129   {
001e50  e1a06000          MOV      r6,r0
001e54  e1a04001          MOV      r4,r1
;;;1130     (void)rhport;
;;;1131     unsigned const epn = tu_edpt_number(ep_addr);
001e58  e1a00000          MOV      r0,r0
001e5c  e3c40080          BIC      r0,r4,#0x80
001e60  e1a05000          MOV      r5,r0
;;;1132     musb_int_mask();
001e64  ebfffffe          BL       musb_int_mask
;;;1133     USBC_SelectActiveEp(epn);
001e68  e20500ff          AND      r0,r5,#0xff
001e6c  ebfffffe          BL       USBC_SelectActiveEp
;;;1134     if (0 == epn) {
001e70  e3550000          CMP      r5,#0
001e74  1a000009          BNE      |L1.7840|
;;;1135       if (!ep_addr) { /* Ignore EP80 */
001e78  e3540000          CMP      r4,#0
001e7c  1a00001b          BNE      |L1.7920|
;;;1136         _dcd.setup_packet.bmRequestType = REQUEST_TYPE_INVALID;
001e80  e3a000ff          MOV      r0,#0xff
001e84  e51f1ca4          LDR      r1,|L1.4584|
001e88  e5c10000          STRB     r0,[r1,#0]  ; _dcd
;;;1137         _dcd.pipe0.buf = NULL;
001e8c  e281100b          ADD      r1,r1,#0xb
001e90  e3a00000          MOV      r0,#0
001e94  ebfffffe          BL       __aeabi_uwrite4
;;;1138         __USBC_Dev_ep0_SendStall();
001e98  ebfffffe          BL       __USBC_Dev_ep0_SendStall
001e9c  ea000013          B        |L1.7920|
                  |L1.7840|
;;;1139       }
;;;1140     } else {
;;;1141       if (tu_edpt_dir(ep_addr)) { /* IN */
001ea0  e1a00000          MOV      r0,r0
001ea4  e2040080          AND      r0,r4,#0x80
001ea8  e1a003a0          LSR      r0,r0,#7
001eac  e3500000          CMP      r0,#0
001eb0  0a000001          BEQ      |L1.7868|
;;;1142         __USBC_Dev_Tx_SendStall();
001eb4  ebfffffe          BL       __USBC_Dev_Tx_SendStall
001eb8  ea00000c          B        |L1.7920|
                  |L1.7868|
;;;1143       } else { /* OUT */
;;;1144         TU_ASSERT(!__USBC_Dev_Rx_IsReadDataReady(),);
001ebc  e1a00000          MOV      r0,r0
001ec0  ebfffffe          BL       __USBC_Dev_Rx_IsReadDataReady
001ec4  e3500000          CMP      r0,#0
001ec8  0a000006          BEQ      |L1.7912|
001ecc  e59f20a0          LDR      r2,|L1.8052|
001ed0  e59f10a0          LDR      r1,|L1.8056|
001ed4  e51f0cd8          LDR      r0,|L1.4612|
001ed8  ebfffffe          BL       __2printf
001edc  e1a00000          MOV      r0,r0
001ee0  e1a00000          MOV      r0,r0
                  |L1.7908|
;;;1145         __USBC_Dev_Rx_SendStall();
;;;1146       }
;;;1147     }
;;;1148     musb_int_unmask();
;;;1149   }
001ee4  e8bd8070          POP      {r4-r6,pc}
                  |L1.7912|
001ee8  e1a00000          MOV      r0,r0                 ;1144
001eec  ebfffffe          BL       __USBC_Dev_Rx_SendStall
                  |L1.7920|
001ef0  ebfffffe          BL       musb_int_unmask
001ef4  e1a00000          MOV      r0,r0
001ef8  eafffff9          B        |L1.7908|
;;;1150   
                          ENDP

                  dcd_edpt_clear_stall PROC
;;;1151   // clear stall, data toggle is also reset to DATA0
;;;1152   void dcd_edpt_clear_stall(uint8_t rhport, uint8_t ep_addr)
001efc  e92d4070          PUSH     {r4-r6,lr}
;;;1153   {
001f00  e1a06000          MOV      r6,r0
001f04  e1a04001          MOV      r4,r1
;;;1154     (void)rhport;
;;;1155     unsigned const epn = tu_edpt_number(ep_addr);
001f08  e1a00000          MOV      r0,r0
001f0c  e3c40080          BIC      r0,r4,#0x80
001f10  e1a05000          MOV      r5,r0
;;;1156     musb_int_mask();
001f14  ebfffffe          BL       musb_int_mask
;;;1157     USBC_SelectActiveEp(epn);
001f18  e20500ff          AND      r0,r5,#0xff
001f1c  ebfffffe          BL       USBC_SelectActiveEp
;;;1158     if (0 != epn) {
001f20  e3550000          CMP      r5,#0
001f24  0a000007          BEQ      |L1.8008|
;;;1159       if (tu_edpt_dir(ep_addr)) { /* IN */
001f28  e1a00000          MOV      r0,r0
001f2c  e2040080          AND      r0,r4,#0x80
001f30  e1a003a0          LSR      r0,r0,#7
001f34  e3500000          CMP      r0,#0
001f38  0a000001          BEQ      |L1.8004|
;;;1160         __USBC_Dev_Tx_ClearStall();
001f3c  ebfffffe          BL       __USBC_Dev_Tx_ClearStall
001f40  ea000000          B        |L1.8008|
                  |L1.8004|
;;;1161       } else { /* OUT */
;;;1162         __USBC_Dev_Rx_ClearStall();
001f44  ebfffffe          BL       __USBC_Dev_Rx_ClearStall
                  |L1.8008|
;;;1163       }
;;;1164     }
;;;1165     musb_int_unmask();
001f48  ebfffffe          BL       musb_int_unmask
;;;1166   }
001f4c  e8bd8070          POP      {r4-r6,pc}
;;;1167   
                          ENDP

                  |L1.8016|
                          DCD      ||.constdata||
                  |L1.8020|
                          DCD      0x01c13000
                  |L1.8024|
                          DCD      0x00002048
                  |L1.8028|
                          DCD      usb_isr_handler
                  |L1.8032|
                          DCD      0x000003da
                  |L1.8036|
                          DCD      |symbol_number.21|
                  |L1.8040|
                          DCD      _dcd+0x84
                  |L1.8044|
                          DCD      0x0000045d
                  |L1.8048|
                          DCD      |symbol_number.22|
                  |L1.8052|
                          DCD      0x00000478
                  |L1.8056|
                          DCD      |symbol_number.23|

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  _dcd
                          %        136

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  00010000          DCB      0x00,0x01,0x00,0x00
                          %        8
00000c  00060000          DCB      0x00,0x06,0x00,0x00
                          %        8
000018  00070000          DCB      0x00,0x07,0x00,0x00
                          %        8
                  __func__
000024  75706461          DCB      0x75,0x70,0x64,0x61
000028  74655f66          DCB      0x74,0x65,0x5f,0x66
00002c  7265655f          DCB      0x72,0x65,0x65,0x5f
000030  626c6f63          DCB      0x62,0x6c,0x6f,0x63
000034  6b5f6c69          DCB      0x6b,0x5f,0x6c,0x69
000038  737400            DCB      0x73,0x74,0x00
                  |symbol_number.16|
00003b  66                DCB      0x66
00003c  696e645f          DCB      0x69,0x6e,0x64,0x5f
000040  66726565          DCB      0x66,0x72,0x65,0x65
000044  5f6d656d          DCB      0x5f,0x6d,0x65,0x6d
000048  6f727900          DCB      0x6f,0x72,0x79,0x00
                  ops
                          DCD      tu_fifo_get_write_info
                          DCD      tu_fifo_advance_write_pointer
                          DCD      pipe_read_packet
                          DCD      tu_fifo_get_read_info
                          DCD      tu_fifo_advance_read_pointer
                          DCD      pipe_write_packet
                  |symbol_number.18|
000064  68616e64          DCB      0x68,0x61,0x6e,0x64
000068  6c655f78          DCB      0x6c,0x65,0x5f,0x78
00006c  6665725f          DCB      0x66,0x65,0x72,0x5f
000070  6f757400          DCB      0x6f,0x75,0x74,0x00
                  |symbol_number.19|
000074  65647074          DCB      0x65,0x64,0x70,0x74
000078  305f7866          DCB      0x30,0x5f,0x78,0x66
00007c  657200            DCB      0x65,0x72,0x00
                  |symbol_number.20|
00007f  70                DCB      0x70
000080  726f6365          DCB      0x72,0x6f,0x63,0x65
000084  73735f65          DCB      0x73,0x73,0x5f,0x65
000088  703000            DCB      0x70,0x30,0x00
                  |symbol_number.21|
00008b  64                DCB      0x64
00008c  63645f65          DCB      0x63,0x64,0x5f,0x65
000090  6470745f          DCB      0x64,0x70,0x74,0x5f
000094  6f70656e          DCB      0x6f,0x70,0x65,0x6e
000098  00                DCB      0x00
                  |symbol_number.22|
000099  646364            DCB      0x64,0x63,0x64
00009c  5f656470          DCB      0x5f,0x65,0x64,0x70
0000a0  745f7866          DCB      0x74,0x5f,0x78,0x66
0000a4  65725f66          DCB      0x65,0x72,0x5f,0x66
0000a8  69666f00          DCB      0x69,0x66,0x6f,0x00
                  |symbol_number.23|
0000ac  6463645f          DCB      0x64,0x63,0x64,0x5f
0000b0  65647074          DCB      0x65,0x64,0x70,0x74
0000b4  5f737461          DCB      0x5f,0x73,0x74,0x61
0000b8  6c6c00            DCB      0x6c,0x6c,0x00

                          AREA ||i.__ARM_common_ctz||, COMGROUP=__ARM_common_ctz, CODE, READONLY, ALIGN=2

                  __ARM_common_ctz PROC
000000  e3a01020          MOV      r1,#0x20
000004  e1a02800          LSL      r2,r0,#16
000008  e3520000          CMP      r2,#0
00000c  1a000003          BNE      |L16.32|
                  |L16.16|
000010  e1a02400          LSL      r2,r0,#8
000014  e3520000          CMP      r2,#0
000018  0a000003          BEQ      |L16.44|
00001c  ea000006          B        |L16.60|
                  |L16.32|
000020  e2411010          SUB      r1,r1,#0x10
000024  e1a00002          MOV      r0,r2
000028  eafffff8          B        |L16.16|
                  |L16.44|
00002c  e1a02200          LSL      r2,r0,#4
000030  e3520000          CMP      r2,#0
000034  0a000003          BEQ      |L16.72|
000038  ea000006          B        |L16.88|
                  |L16.60|
00003c  e2411008          SUB      r1,r1,#8
000040  e1a00002          MOV      r0,r2
000044  eafffff8          B        |L16.44|
                  |L16.72|
000048  e1a02100          LSL      r2,r0,#2
00004c  e3520000          CMP      r2,#0
000050  0a000003          BEQ      |L16.100|
000054  ea000006          B        |L16.116|
                  |L16.88|
000058  e2411004          SUB      r1,r1,#4
00005c  e1a00002          MOV      r0,r2
000060  eafffff8          B        |L16.72|
                  |L16.100|
000064  e1a02080          LSL      r2,r0,#1
000068  e3520000          CMP      r2,#0
00006c  0a000003          BEQ      |L16.128|
000070  ea000004          B        |L16.136|
                  |L16.116|
000074  e2411002          SUB      r1,r1,#2
000078  e1a00002          MOV      r0,r2
00007c  eafffff8          B        |L16.100|
                  |L16.128|
000080  e0410fa0          SUB      r0,r1,r0,LSR #31
000084  e12fff1e          BX       lr
                  |L16.136|
000088  e2411001          SUB      r1,r1,#1
00008c  e1a00002          MOV      r0,r2
000090  eafffffa          B        |L16.128|
                          ENDP

