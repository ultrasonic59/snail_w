; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave --gnu -o.\temp\obj\gpio-f1c100s.o --asm_dir=.\Temp\Lst\ --list_dir=.\Temp\Lst\ --depend=.\temp\obj\gpio-f1c100s.d --cpu=ARM9E --apcs=interwork -O3 -Otime --diag_suppress=9931 -I.\users\include -I.\..\machine\include -I.\..\periph\include -I.\..\include -I.\..\emwin\Include -I.\..\tinyusb\src -I.\..\tinyusb\hw -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Atmel\SAM9260 -D__RTX -D__UVISION_VERSION=536 -DPCB_TINY200V2 -DCFG_TUSB_MCU=OPT_MCU_F1C100S -DCFG_TUSB_OS=OPT_OS_RTX4 --omf_browse=.\temp\obj\gpio-f1c100s.crf ..\periph\gpio-f1c100s.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  gpio_f1c100s_set_cfg PROC
;;;81     
;;;82     void gpio_f1c100s_set_cfg(const gpio_port_t* port, int32_t pin, int32_t cfg)
000000  e5903008          LDR      r3,[r0,#8]
;;;83     {
;;;84       uint32_t addr;
;;;85       uint32_t val;
;;;86     
;;;87       if (pin >= port->ngpio)
000004  e1530001          CMP      r3,r1
;;;88         return;
;;;89     
;;;90       addr = port->virt + GPIO_CFG0 + ((pin >> 3) << 2);
;;;91       val = read32(addr);
;;;92       val &= ~(0xf << ((pin & 0x7) << 2));
;;;93       val |= ((cfg & 0x7) << ((pin & 0x7) << 2));
;;;94       write32(addr, val);
;;;95     }
000008  d12fff1e          BXLE     lr
00000c  e52d4004          PUSH     {r4}                  ;83
000010  e5900000          LDR      r0,[r0,#0]            ;90
000014  e1a031c1          ASR      r3,r1,#3              ;90
000018  e7b03103          LDR      r3,[r0,r3,LSL #2]!    ;91
00001c  e1a01e81          LSL      r1,r1,#29             ;92
000020  e3a0c00f          MOV      r12,#0xf              ;92
000024  e1a01da1          LSR      r1,r1,#27             ;92
000028  e2024007          AND      r4,r2,#7              ;93
00002c  e1c3211c          BIC      r2,r3,r12,LSL r1      ;92
000030  e1821114          ORR      r1,r2,r4,LSL r1       ;93
000034  e5801000          STR      r1,[r0,#0]            ;94
000038  e49d4004          POP      {r4}
00003c  e12fff1e          BX       lr
;;;96     
                          ENDP

                  gpio_f1c100s_get_cfg PROC
;;;97     int32_t gpio_f1c100s_get_cfg(const gpio_port_t* port, int32_t pin)
000040  e5902008          LDR      r2,[r0,#8]
;;;98     {
;;;99       uint32_t addr;
;;;100      uint32_t val;
;;;101    
;;;102      if (pin >= port->ngpio)
000044  e1520001          CMP      r2,r1
;;;103        return 0;
000048  d3a00000          MOVLE    r0,#0
;;;104    
;;;105      addr = port->virt + GPIO_CFG0 + ((pin >> 3) << 2);
;;;106      val = (read32(addr) >> ((pin & 0x7) << 2)) & 0x7;
;;;107      return val;
;;;108    }
00004c  d12fff1e          BXLE     lr
000050  e5900000          LDR      r0,[r0,#0]            ;105
000054  e1a021c1          ASR      r2,r1,#3              ;105
000058  e7900102          LDR      r0,[r0,r2,LSL #2]     ;106
00005c  e1a01e81          LSL      r1,r1,#29             ;106
000060  e1a01da1          LSR      r1,r1,#27             ;106
000064  e1a00130          LSR      r0,r0,r1              ;106
000068  e2000007          AND      r0,r0,#7              ;106
00006c  e12fff1e          BX       lr
;;;109    
                          ENDP

                  gpio_f1c100s_set_pull PROC
;;;110    void gpio_f1c100s_set_pull(const gpio_port_t* port, int32_t pin, gpio_pull_t pull)
000070  e5903008          LDR      r3,[r0,#8]
;;;111    {
;;;112      uint32_t addr;
;;;113      uint32_t val, v;
;;;114    
;;;115      if (pin >= port->ngpio)
000074  e1530001          CMP      r3,r1
;;;116        return;
;;;117    
;;;118      switch (pull) {
;;;119        case GPIO_PULL_UP:
;;;120          v = 0x1;
;;;121          break;
;;;122    
;;;123        case GPIO_PULL_DOWN:
;;;124          v = 0x2;
;;;125          break;
;;;126    
;;;127        case GPIO_PULL_NONE:
;;;128          v = 0x0;
;;;129          break;
;;;130    
;;;131        default:
;;;132          v = 0x0;
;;;133          break;
;;;134      }
;;;135    
;;;136      addr = port->virt + GPIO_PUL0 + ((pin >> 4) << 2);
;;;137      val = read32(addr);
;;;138      val &= ~(v << ((pin & 0xf) << 1));
;;;139      val |= (v << ((pin & 0xf) << 1));
;;;140      write32(addr, val);
;;;141    }
000078  d12fff1e          BXLE     lr
00007c  e3520000          CMP      r2,#0                 ;118
000080  03a02001          MOVEQ    r2,#1                 ;120
000084  0a000002          BEQ      |L1.148|
000088  e3520001          CMP      r2,#1                 ;118
00008c  13a02000          MOVNE    r2,#0                 ;128
000090  03a02002          MOVEQ    r2,#2                 ;124
                  |L1.148|
000094  e1a03241          ASR      r3,r1,#4              ;136
000098  e5900000          LDR      r0,[r0,#0]            ;136
00009c  e3a0c01c          MOV      r12,#0x1c             ;136
0000a0  e08c3103          ADD      r3,r12,r3,LSL #2      ;136
0000a4  e1a01e01          LSL      r1,r1,#28             ;138
0000a8  e0800003          ADD      r0,r0,r3              ;136
0000ac  e1a03da1          LSR      r3,r1,#27             ;138
0000b0  e5901000          LDR      r1,[r0,#0]            ;137
0000b4  e1a02312          LSL      r2,r2,r3              ;138
0000b8  e1c11002          BIC      r1,r1,r2              ;138
0000bc  e1811002          ORR      r1,r1,r2              ;139
0000c0  e5801000          STR      r1,[r0,#0]            ;140
0000c4  e12fff1e          BX       lr
;;;142    
                          ENDP

                  gpio_f1c100s_get_pull PROC
;;;143    gpio_pull_t gpio_f1c100s_get_pull(const gpio_port_t* port, int32_t pin)
0000c8  e5902008          LDR      r2,[r0,#8]
;;;144    {
;;;145      uint32_t addr;
;;;146      uint32_t v = 0;
;;;147    
;;;148      if (pin >= port->ngpio)
0000cc  e1520001          CMP      r2,r1
0000d0  da00000f          BLE      |L1.276|
;;;149        return GPIO_PULL_NONE;
;;;150    
;;;151      addr = port->virt + GPIO_PUL0 + ((pin >> 4) << 2);
0000d4  e1a02241          ASR      r2,r1,#4
0000d8  e5900000          LDR      r0,[r0,#0]
0000dc  e3a0301c          MOV      r3,#0x1c
0000e0  e0832102          ADD      r2,r3,r2,LSL #2
;;;152      v = (read32(addr) >> ((pin & 0xf) << 1)) & 0x3;
0000e4  e7900002          LDR      r0,[r0,r2]
0000e8  e1a01e01          LSL      r1,r1,#28
0000ec  e1a01da1          LSR      r1,r1,#27
0000f0  e1a00130          LSR      r0,r0,r1
0000f4  e2100003          ANDS     r0,r0,#3
;;;153    
;;;154      switch (v) {
0000f8  0a000005          BEQ      |L1.276|
0000fc  e3500001          CMP      r0,#1
;;;155        case 0:
;;;156          return GPIO_PULL_NONE;
;;;157        case 1:
;;;158          return GPIO_PULL_UP;
000100  03a00000          MOVEQ    r0,#0
;;;159        case 2:
;;;160          return GPIO_PULL_DOWN;
;;;161        default:
;;;162          break;
;;;163      }
;;;164      return GPIO_PULL_NONE;
;;;165    }
000104  012fff1e          BXEQ     lr
000108  e3500002          CMP      r0,#2                 ;154
00010c  03a00001          MOVEQ    r0,#1                 ;160
000110  012fff1e          BXEQ     lr
                  |L1.276|
000114  e3a00002          MOV      r0,#2                 ;164
000118  e12fff1e          BX       lr
;;;166    
                          ENDP

                  gpio_f1c100s_set_drv PROC
;;;167    void gpio_f1c100s_set_drv(const gpio_port_t* port, int32_t pin, gpio_drv_t drv)
00011c  e5903008          LDR      r3,[r0,#8]
;;;168    {
;;;169      uint32_t addr;
;;;170      uint32_t val, v;
;;;171    
;;;172      if (pin >= port->ngpio)
000120  e1530001          CMP      r3,r1
;;;173        return;
;;;174    
;;;175      switch (drv) {
;;;176        case GPIO_DRV_WEAK:
;;;177          v = 0x0;
;;;178          break;
;;;179    
;;;180        case GPIO_DRV_WEAKER:
;;;181          v = 0x1;
;;;182          break;
;;;183    
;;;184        case GPIO_DRV_STRONGER:
;;;185          v = 0x2;
;;;186          break;
;;;187    
;;;188        case GPIO_DRV_STRONG:
;;;189          v = 0x3;
;;;190          break;
;;;191    
;;;192        default:
;;;193          v = 0x0;
;;;194          break;
;;;195      }
;;;196    
;;;197      addr = port->virt + GPIO_DRV0 + ((pin >> 4) << 2);
;;;198      val = read32(addr);
;;;199      val &= ~(v << ((pin & 0xf) << 1));
;;;200      val |= (v << ((pin & 0xf) << 1));
;;;201      write32(addr, val);
;;;202    }
000124  d12fff1e          BXLE     lr
000128  e3520000          CMP      r2,#0                 ;175
00012c  13520001          CMPNE    r2,#1                 ;175
000130  0a000002          BEQ      |L1.320|
000134  e3520002          CMP      r2,#2                 ;175
000138  13520003          CMPNE    r2,#3                 ;175
00013c  13a02000          MOVNE    r2,#0                 ;193
                  |L1.320|
000140  e1a03241          ASR      r3,r1,#4              ;197
000144  e5900000          LDR      r0,[r0,#0]            ;197
000148  e3a0c014          MOV      r12,#0x14             ;197
00014c  e08c3103          ADD      r3,r12,r3,LSL #2      ;197
000150  e1a01e01          LSL      r1,r1,#28             ;199
000154  e0800003          ADD      r0,r0,r3              ;197
000158  e1a03da1          LSR      r3,r1,#27             ;199
00015c  e5901000          LDR      r1,[r0,#0]            ;198
000160  e1a02312          LSL      r2,r2,r3              ;199
000164  e1c11002          BIC      r1,r1,r2              ;199
000168  e1811002          ORR      r1,r1,r2              ;200
00016c  e5801000          STR      r1,[r0,#0]            ;201
000170  e12fff1e          BX       lr
;;;203    
                          ENDP

                  gpio_f1c100s_get_drv PROC
;;;204    gpio_drv_t gpio_f1c100s_get_drv(const gpio_port_t* port, int32_t pin)
000174  e5902008          LDR      r2,[r0,#8]
;;;205    {
;;;206      uint32_t addr;
;;;207      uint32_t v = 0;
;;;208    
;;;209      if (pin >= port->ngpio)
000178  e1520001          CMP      r2,r1
00017c  da00000d          BLE      |L1.440|
;;;210        return GPIO_DRV_WEAK;
;;;211    
;;;212      addr = port->virt + GPIO_DRV0 + ((pin >> 4) << 2);
000180  e1a02241          ASR      r2,r1,#4
000184  e5900000          LDR      r0,[r0,#0]
000188  e3a03014          MOV      r3,#0x14
00018c  e0832102          ADD      r2,r3,r2,LSL #2
;;;213      v = (read32(addr) >> ((pin & 0xf) << 1)) & 0x3;
000190  e7900002          LDR      r0,[r0,r2]
000194  e1a01e01          LSL      r1,r1,#28
000198  e1a01da1          LSR      r1,r1,#27
00019c  e1a00130          LSR      r0,r0,r1
0001a0  e2100003          ANDS     r0,r0,#3
;;;214    
;;;215      switch (v) {
0001a4  13500001          CMPNE    r0,#1
;;;216        case 0:
;;;217          return GPIO_DRV_WEAK;
;;;218        case 1:
;;;219          return GPIO_DRV_WEAKER;
;;;220        case 2:
;;;221          return GPIO_DRV_STRONGER;
;;;222        case 3:
;;;223          return GPIO_DRV_STRONG;
;;;224        default:
;;;225          break;
;;;226      }
;;;227      return GPIO_DRV_WEAK;
;;;228    }
0001a8  012fff1e          BXEQ     lr
0001ac  e3500002          CMP      r0,#2                 ;215
0001b0  13500003          CMPNE    r0,#3                 ;215
0001b4  012fff1e          BXEQ     lr
                  |L1.440|
0001b8  e3a00000          MOV      r0,#0                 ;227
0001bc  e12fff1e          BX       lr
;;;229    
                          ENDP

                  gpio_f1c100s_set_rate PROC
;;;230    void gpio_f1c100s_set_rate(const gpio_port_t* port, int32_t pin, gpio_rate_t rate)
0001c0  e12fff1e          BX       lr
;;;231    {
;;;232    }
;;;233    
                          ENDP

                  gpio_f1c100s_get_rate PROC
;;;234    gpio_rate_t gpio_f1c100s_get_rate(const gpio_port_t* port, int32_t pin)
0001c4  e3a00000          MOV      r0,#0
;;;235    {
;;;236      return GPIO_RATE_SLOW;
;;;237    }
0001c8  e12fff1e          BX       lr
;;;238    
                          ENDP

                  gpio_f1c100s_set_dir PROC
;;;239    void gpio_f1c100s_set_dir(const gpio_port_t* port, int32_t pin, gpio_direction_t dir)
0001cc  e5903008          LDR      r3,[r0,#8]
;;;240    {
;;;241      if (pin >= port->ngpio)
0001d0  e1530001          CMP      r3,r1
;;;242        return;
;;;243    
;;;244      switch (dir) {
;;;245        case GPIO_DIRECTION_INPUT:
;;;246          gpio_f1c100s_set_cfg(port, pin, 0);
;;;247          break;
;;;248    
;;;249        case GPIO_DIRECTION_OUTPUT:
;;;250          gpio_f1c100s_set_cfg(port, pin, 1);
;;;251          break;
;;;252    
;;;253        default:
;;;254          break;
;;;255      }
;;;256    }
0001d4  d12fff1e          BXLE     lr
0001d8  e1a03e81          LSL      r3,r1,#29
0001dc  e52d4004          PUSH     {r4}                  ;240
0001e0  e3520000          CMP      r2,#0                 ;244
0001e4  e3a0400f          MOV      r4,#0xf               ;244
0001e8  e1a03da3          LSR      r3,r3,#27             ;244
0001ec  e1a0c1c1          ASR      r12,r1,#3             ;244
0001f0  e1a01314          LSL      r1,r4,r3              ;244
0001f4  0a00000b          BEQ      |L1.552|
0001f8  e3520001          CMP      r2,#1                 ;244
0001fc  149d4004          POPNE    {r4}
000200  112fff1e          BXNE     lr
000204  e3a02001          MOV      r2,#1
000208  e5900000          LDR      r0,[r0,#0]
00020c  e1a03312          LSL      r3,r2,r3
000210  e7b0210c          LDR      r2,[r0,r12,LSL #2]!
000214  e1c21001          BIC      r1,r2,r1
000218  e1811003          ORR      r1,r1,r3
00021c  e5801000          STR      r1,[r0,#0]
000220  e49d4004          POP      {r4}
000224  e12fff1e          BX       lr
                  |L1.552|
000228  e3a02000          MOV      r2,#0
00022c  e5900000          LDR      r0,[r0,#0]
000230  e1a03312          LSL      r3,r2,r3
000234  e7b0210c          LDR      r2,[r0,r12,LSL #2]!
000238  e1c21001          BIC      r1,r2,r1
00023c  e1811003          ORR      r1,r1,r3
000240  e5801000          STR      r1,[r0,#0]
000244  e49d4004          POP      {r4}
000248  e12fff1e          BX       lr
;;;257    
                          ENDP

                  gpio_f1c100s_get_dir PROC
;;;258    gpio_direction_t gpio_f1c100s_get_dir(const gpio_port_t* port, int32_t pin)
00024c  e5902008          LDR      r2,[r0,#8]
;;;259    {
;;;260      if (pin >= port->ngpio)
000250  e1520001          CMP      r2,r1
000254  da000008          BLE      |L1.636|
000258  e5900000          LDR      r0,[r0,#0]            ;259
00025c  e1a021c1          ASR      r2,r1,#3              ;259
000260  e7900102          LDR      r0,[r0,r2,LSL #2]     ;259
000264  e1a01e81          LSL      r1,r1,#29             ;259
000268  e1a01da1          LSR      r1,r1,#27             ;259
00026c  e1a00130          LSR      r0,r0,r1              ;259
000270  e2100007          ANDS     r0,r0,#7              ;259
;;;261        return GPIO_DIRECTION_INPUT;
;;;262    
;;;263      switch (gpio_f1c100s_get_cfg(port, pin)) {
000274  13500001          CMPNE    r0,#1
;;;264        case 0:
;;;265          return GPIO_DIRECTION_INPUT;
;;;266        case 1:
;;;267          return GPIO_DIRECTION_OUTPUT;
;;;268        default:
;;;269          break;
;;;270      }
;;;271      return GPIO_DIRECTION_INPUT;
;;;272    }
000278  012fff1e          BXEQ     lr
                  |L1.636|
00027c  e3a00000          MOV      r0,#0                 ;271
000280  e12fff1e          BX       lr
;;;273    
                          ENDP

                  gpio_f1c100s_set_value PROC
;;;274    void gpio_f1c100s_set_value(const gpio_port_t* port, int32_t pin, int32_t value)
000284  e5903008          LDR      r3,[r0,#8]
;;;275    {
;;;276      uint32_t val;
;;;277    
;;;278      if (pin >= port->ngpio)
000288  e1530001          CMP      r3,r1
;;;279        return;
;;;280    
;;;281      val = read32(port->virt + GPIO_DAT);
;;;282      val &= ~(1 << pin);
;;;283      val |= (!!value) << pin;
;;;284      write32(port->virt + GPIO_DAT, val);
;;;285    }
00028c  d12fff1e          BXLE     lr
000290  e5900000          LDR      r0,[r0,#0]            ;281
000294  e3520000          CMP      r2,#0                 ;283
000298  e5b02010          LDR      r2,[r0,#0x10]!        ;283
00029c  e3a03001          MOV      r3,#1                 ;282
0002a0  e1c22113          BIC      r2,r2,r3,LSL r1       ;282
0002a4  03a03000          MOVEQ    r3,#0                 ;283
0002a8  e1821113          ORR      r1,r2,r3,LSL r1       ;283
0002ac  e5801000          STR      r1,[r0,#0]            ;284
0002b0  e12fff1e          BX       lr
;;;286    
                          ENDP

                  gpio_f1c100s_get_value PROC
;;;287    int32_t gpio_f1c100s_get_value(const gpio_port_t* port, int32_t pin)
0002b4  e5902008          LDR      r2,[r0,#8]
;;;288    {
;;;289      uint32_t val;
;;;290    
;;;291      if (pin >= port->ngpio)
0002b8  e1520001          CMP      r2,r1
;;;292        return 0;
0002bc  d3a00000          MOVLE    r0,#0
;;;293    
;;;294      val = read32(port->virt + GPIO_DAT);
;;;295      return !!(val & (1 << pin));
;;;296    }
0002c0  d12fff1e          BXLE     lr
0002c4  e5900000          LDR      r0,[r0,#0]            ;294
0002c8  e3a02001          MOV      r2,#1                 ;295
0002cc  e5900010          LDR      r0,[r0,#0x10]         ;295
0002d0  e0100112          ANDS     r0,r0,r2,LSL r1       ;295
0002d4  13a00001          MOVNE    r0,#1                 ;295
0002d8  e12fff1e          BX       lr
;;;297    
                          ENDP

                  gpio_f1c100s_to_irq PROC
;;;298    int32_t gpio_f1c100s_to_irq(const gpio_port_t* port, int32_t pin)
0002dc  e5902008          LDR      r2,[r0,#8]
;;;299    {
;;;300    
;;;301      if ((pin >= port->ngpio) || (port->oirq < 0))
0002e0  e1510002          CMP      r1,r2
0002e4  aa000003          BGE      |L1.760|
0002e8  e590000c          LDR      r0,[r0,#0xc]
0002ec  e3500000          CMP      r0,#0
;;;302        return -1;
;;;303      return port->oirq + pin;
0002f0  a0800001          ADDGE    r0,r0,r1
;;;304    }
0002f4  a12fff1e          BXGE     lr
                  |L1.760|
0002f8  e3e00000          MVN      r0,#0                 ;302
0002fc  e12fff1e          BX       lr
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  GPIO_PA
                          DCD      0x01c20800
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000000

                          AREA ||area_number.5||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.5||, ||.constdata||
                  GPIO_PB
                          DCD      0x01c20824
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000000

                          AREA ||area_number.6||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.constdata||
                  GPIO_PC
                          DCD      0x01c20848
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000000

                          AREA ||area_number.7||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.constdata||
                  GPIO_PD
                          DCD      0x01c2086c
                          DCD      0x00000000
                          DCD      0x00000016
                          DCD      0x00000000

                          AREA ||area_number.8||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.constdata||
                  GPIO_PE
                          DCD      0x01c20890
                          DCD      0x00000000
                          DCD      0x0000000d
                          DCD      0x00000000

                          AREA ||area_number.9||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.9||, ||.constdata||
                  GPIO_PF
                          DCD      0x01c208b4
                          DCD      0x00000000
                          DCD      0x00000006
                          DCD      0x00000000
