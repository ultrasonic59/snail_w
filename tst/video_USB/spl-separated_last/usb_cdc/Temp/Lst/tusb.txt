; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave --gnu -o.\temp\obj\tusb.o --asm_dir=.\Temp\Lst\ --list_dir=.\Temp\Lst\ --depend=.\temp\obj\tusb.d --cpu=ARM9E --apcs=interwork -O3 -Otime --diag_suppress=9931 -I.\users\include -I.\..\machine\include -I.\..\periph\include -I.\..\include -I.\..\emwin\Include -I.\..\tinyusb\src -I.\..\tinyusb\hw -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Atmel\SAM9260 -D__RTX -D__UVISION_VERSION=536 -DPCB_TINY200V2 -DCFG_TUSB_MCU=OPT_MCU_F1C100S -DCFG_TUSB_OS=OPT_OS_RTX4 --omf_browse=.\temp\obj\tusb.crf ..\tinyusb\src\tusb.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_truncate_unsigned
                          REQUIRE _printf_truncate_signed
                          REQUIRE _printf_sizespec
                          REQUIRE _printf_i
                          REQUIRE _printf_u
                          REQUIRE _printf_o
                          REQUIRE _printf_lc
                          REQUIRE _printf_longlong_oct
                          REQUIRE _printf_str
                          REQUIRE _printf_wctomb
                          REQUIRE _printf_str
                  tusb_init PROC
;;;45     
;;;46     bool tusb_init(void)
000000  e92d4010          PUSH     {r4,lr}
;;;47     {
;;;48     #if CFG_TUD_ENABLED && defined(TUD_OPT_RHPORT)
;;;49       // init device stack CFG_TUSB_RHPORTx_MODE must be defined
;;;50       TU_ASSERT ( tud_init(TUD_OPT_RHPORT) );
000004  e3a00000          MOV      r0,#0
000008  ebfffffe          BL       tud_init
00000c  e3500000          CMP      r0,#0
;;;51     #endif
;;;52     
;;;53     #if CFG_TUH_ENABLED && defined(TUH_OPT_RHPORT)
;;;54       // init host stack CFG_TUSB_RHPORTx_MODE must be defined
;;;55       TU_ASSERT( tuh_init(TUH_OPT_RHPORT) );
;;;56     #endif
;;;57     
;;;58       return true;
000010  13a00001          MOVNE    r0,#1
;;;59     }
000014  18bd8010          POPNE    {r4,pc}
000018  e3a02032          MOV      r2,#0x32              ;50
00001c  e59f100c          LDR      r1,|L1.48|
000020  e28f000c          ADR      r0,|L1.52|
000024  ebfffffe          BL       __2printf
000028  e3a00000          MOV      r0,#0                 ;50
00002c  e8bd8010          POP      {r4,pc}
                  |L1.48|
                          DCD      ||.constdata||
                  |L1.52|
000034  25732025          DCB      "%s %d: ASSERT FAILED\r\n",0
000038  643a2041
00003c  53534552
000040  54204641
000044  494c4544
000048  0d0a00  
00004b  00                DCB      0
                          ENDP

                  tusb_inited PROC
;;;60     
;;;61     bool tusb_inited(void)
00004c  e92d4010          PUSH     {r4,lr}
;;;62     {
;;;63       bool ret = false;
;;;64     
;;;65     #if CFG_TUD_ENABLED
;;;66       ret = ret || tud_inited();
000050  ebfffffe          BL       tud_inited
000054  e3500000          CMP      r0,#0
000058  13a00001          MOVNE    r0,#1
;;;67     #endif
;;;68     
;;;69     #if CFG_TUH_ENABLED
;;;70       ret = ret || tuh_inited();
;;;71     #endif
;;;72     
;;;73       return ret;
;;;74     }
00005c  e8bd8010          POP      {r4,pc}
;;;75     
                          ENDP

                  tu_desc_find PROC
;;;79     
;;;80     uint8_t const * tu_desc_find(uint8_t const* desc, uint8_t const* end, uint8_t byte1)
000060  e2803001          ADD      r3,r0,#1
;;;81     {
;;;82       while(desc+1 < end)
000064  e1530001          CMP      r3,r1
000068  2a000007          BCS      |L1.140|
                  |L1.108|
;;;83       {
;;;84         if ( desc[1] == byte1 ) return desc;
00006c  e5d03001          LDRB     r3,[r0,#1]
000070  e1530002          CMP      r3,r2
;;;85         desc += desc[DESC_OFFSET_LEN];
;;;86       }
;;;87       return NULL;
;;;88     }
000074  012fff1e          BXEQ     lr
000078  e5d03000          LDRB     r3,[r0,#0]            ;85
00007c  e0800003          ADD      r0,r0,r3              ;85
000080  e2803001          ADD      r3,r0,#1              ;82
000084  e1530001          CMP      r3,r1                 ;82
000088  3afffff7          BCC      |L1.108|
                  |L1.140|
00008c  e3a00000          MOV      r0,#0                 ;87
000090  e12fff1e          BX       lr
;;;89     
                          ENDP

                  tu_desc_find2 PROC
;;;90     uint8_t const * tu_desc_find2(uint8_t const* desc, uint8_t const* end, uint8_t byte1, uint8_t byte2)
000094  e280c002          ADD      r12,r0,#2
;;;91     {
;;;92       while(desc+2 < end)
000098  e15c0001          CMP      r12,r1
00009c  2a000009          BCS      |L1.200|
                  |L1.160|
;;;93       {
;;;94         if ( desc[1] == byte1 && desc[2] == byte2) return desc;
0000a0  e5d0c001          LDRB     r12,[r0,#1]
0000a4  e15c0002          CMP      r12,r2
0000a8  05d0c002          LDRBEQ   r12,[r0,#2]
0000ac  015c0003          CMPEQ    r12,r3
;;;95         desc += desc[DESC_OFFSET_LEN];
;;;96       }
;;;97       return NULL;
;;;98     }
0000b0  012fff1e          BXEQ     lr
0000b4  e5d0c000          LDRB     r12,[r0,#0]           ;95
0000b8  e080000c          ADD      r0,r0,r12             ;95
0000bc  e280c002          ADD      r12,r0,#2             ;92
0000c0  e15c0001          CMP      r12,r1                ;92
0000c4  3afffff5          BCC      |L1.160|
                  |L1.200|
0000c8  e3a00000          MOV      r0,#0                 ;97
0000cc  e12fff1e          BX       lr
;;;99     
                          ENDP

                  tu_desc_find3 PROC
;;;100    uint8_t const * tu_desc_find3(uint8_t const* desc, uint8_t const* end, uint8_t byte1, uint8_t byte2, uint8_t byte3)
0000d0  e52d4004          PUSH     {r4}
;;;101    {
;;;102      while(desc+3 < end)
0000d4  e59dc004          LDR      r12,[sp,#4]
0000d8  e2804003          ADD      r4,r0,#3
0000dc  e1540001          CMP      r4,r1
0000e0  2a00000c          BCS      |L1.280|
                  |L1.228|
;;;103      {
;;;104        if (desc[1] == byte1 && desc[2] == byte2 && desc[3] == byte3) return desc;
0000e4  e5d04001          LDRB     r4,[r0,#1]
0000e8  e1540002          CMP      r4,r2
0000ec  05d04002          LDRBEQ   r4,[r0,#2]
0000f0  01540003          CMPEQ    r4,r3
0000f4  05d04003          LDRBEQ   r4,[r0,#3]
0000f8  0154000c          CMPEQ    r4,r12
0000fc  049d4004          POPEQ    {r4}
;;;105        desc += desc[DESC_OFFSET_LEN];
;;;106      }
;;;107      return NULL;
;;;108    }
000100  012fff1e          BXEQ     lr
000104  e5d04000          LDRB     r4,[r0,#0]            ;105
000108  e0800004          ADD      r0,r0,r4              ;105
00010c  e2804003          ADD      r4,r0,#3              ;102
000110  e1540001          CMP      r4,r1                 ;102
000114  3afffff2          BCC      |L1.228|
                  |L1.280|
000118  e49d4004          POP      {r4}                  ;107
00011c  e3a00000          MOV      r0,#0                 ;107
000120  e12fff1e          BX       lr
;;;109    
                          ENDP

                  tu_edpt_claim PROC
;;;114    
;;;115    bool tu_edpt_claim(tu_edpt_state_t* ep_state, osal_mutex_t mutex)
000124  e92d4070          PUSH     {r4-r6,lr}
;;;116    {
000128  e1a04000          MOV      r4,r0
;;;117      (void) mutex;
;;;118    
;;;119      // pre-check to help reducing mutex lock
;;;120      TU_VERIFY((ep_state->busy == 0) && (ep_state->claimed == 0));
00012c  e5d00000          LDRB     r0,[r0,#0]
000130  e1a06001          MOV      r6,r1                 ;116
000134  e3100001          TST      r0,#1
000138  05d40000          LDRBEQ   r0,[r4,#0]
00013c  03100004          TSTEQ    r0,#4
000140  13a00000          MOVNE    r0,#0
;;;121      (void) osal_mutex_lock(mutex, OSAL_TIMEOUT_WAIT_FOREVER);
;;;122    
;;;123      // can only claim the endpoint if it is not busy and not claimed yet.
;;;124      bool const available = (ep_state->busy == 0) && (ep_state->claimed == 0);
;;;125      if (available)
;;;126      {
;;;127        ep_state->claimed = 1;
;;;128      }
;;;129    
;;;130      (void) osal_mutex_unlock(mutex);
;;;131    
;;;132      return available;
;;;133    }
000144  18bd8070          POPNE    {r4-r6,pc}
000148  e1a00006          MOV      r0,r6                 ;121
00014c  e59f13fc          LDR      r1,|L1.1360|
000150  ebfffffe          BL       os_mut_wait
000154  e5d40000          LDRB     r0,[r4,#0]            ;124
000158  e3100001          TST      r0,#1                 ;124
00015c  05d40000          LDRBEQ   r0,[r4,#0]            ;124
000160  03100004          TSTEQ    r0,#4                 ;124
000164  13a05000          MOVNE    r5,#0                 ;124
000168  0a000003          BEQ      |L1.380|
                  |L1.364|
00016c  e1a00006          MOV      r0,r6                 ;130
000170  ebfffffe          BL       os_mut_release
000174  e1a00005          MOV      r0,r5                 ;132
000178  e8bd8070          POP      {r4-r6,pc}
                  |L1.380|
00017c  e5d40000          LDRB     r0,[r4,#0]            ;127
000180  e3a05001          MOV      r5,#1                 ;124
000184  e3800004          ORR      r0,r0,#4              ;127
000188  e5c40000          STRB     r0,[r4,#0]            ;127
00018c  eafffff6          B        |L1.364|
;;;134    
                          ENDP

                  tu_edpt_release PROC
;;;135    bool tu_edpt_release(tu_edpt_state_t* ep_state, osal_mutex_t mutex)
000190  e92d4070          PUSH     {r4-r6,lr}
;;;136    {
000194  e1a06001          MOV      r6,r1
000198  e1a04000          MOV      r4,r0
00019c  e59f13ac          LDR      r1,|L1.1360|
;;;137      (void) mutex;
;;;138    
;;;139      (void) osal_mutex_lock(mutex, OSAL_TIMEOUT_WAIT_FOREVER);
0001a0  e1a00006          MOV      r0,r6
0001a4  ebfffffe          BL       os_mut_wait
;;;140    
;;;141      // can only release the endpoint if it is claimed and not busy
;;;142      bool const ret = (ep_state->claimed == 1) && (ep_state->busy == 0);
0001a8  e5d40000          LDRB     r0,[r4,#0]
0001ac  e3100004          TST      r0,#4
0001b0  0a000002          BEQ      |L1.448|
0001b4  e5d40000          LDRB     r0,[r4,#0]
0001b8  e3100001          TST      r0,#1
0001bc  0a000004          BEQ      |L1.468|
                  |L1.448|
0001c0  e3a05000          MOV      r5,#0
                  |L1.452|
;;;143      if (ret)
;;;144      {
;;;145        ep_state->claimed = 0;
;;;146      }
;;;147    
;;;148      (void) osal_mutex_unlock(mutex);
0001c4  e1a00006          MOV      r0,r6
0001c8  ebfffffe          BL       os_mut_release
;;;149    
;;;150      return ret;
0001cc  e1a00005          MOV      r0,r5
;;;151    }
0001d0  e8bd8070          POP      {r4-r6,pc}
                  |L1.468|
0001d4  e5d40000          LDRB     r0,[r4,#0]            ;145
0001d8  e3a05001          MOV      r5,#1                 ;142
0001dc  e3c00004          BIC      r0,r0,#4              ;145
0001e0  e5c40000          STRB     r0,[r4,#0]            ;145
0001e4  eafffff6          B        |L1.452|
;;;152    
                          ENDP

                  tu_edpt_validate PROC
;;;153    bool tu_edpt_validate(tusb_desc_endpoint_t const * desc_ep, tusb_speed_t speed)
0001e8  e92d4010          PUSH     {r4,lr}
;;;154    {
;;;155      uint16_t const max_packet_size = tu_edpt_packet_size(desc_ep);
0001ec  e5d02005          LDRB     r2,[r0,#5]
0001f0  e5d03004          LDRB     r3,[r0,#4]
;;;156      TU_LOG2("  Open EP %02X with Size = %u\r\n", desc_ep->bEndpointAddress, max_packet_size);
;;;157    
;;;158      switch (desc_ep->bmAttributes.xfer)
0001f4  e5d00003          LDRB     r0,[r0,#3]
0001f8  e1833402          ORR      r3,r3,r2,LSL #8       ;155
0001fc  e2002003          AND      r2,r0,#3
000200  e3520001          CMP      r2,#1
000204  e3c30b3e          BIC      r0,r3,#0xf800         ;155
000208  0a00000f          BEQ      |L1.588|
00020c  e3520002          CMP      r2,#2
000210  0a000018          BEQ      |L1.632|
000214  e3520003          CMP      r2,#3
;;;159      {
;;;160        case TUSB_XFER_ISOCHRONOUS:
;;;161        {
;;;162          uint16_t const spec_size = (speed == TUSB_SPEED_HIGH ? 1024 : 1023);
;;;163          TU_ASSERT(max_packet_size <= spec_size);
;;;164        }
;;;165        break;
;;;166    
;;;167        case TUSB_XFER_BULK:
;;;168          if (speed == TUSB_SPEED_HIGH)
;;;169          {
;;;170            // Bulk highspeed must be EXACTLY 512
;;;171            TU_ASSERT(max_packet_size == 512);
;;;172          }else
;;;173          {
;;;174            // TODO Bulk fullspeed can only be 8, 16, 32, 64
;;;175            TU_ASSERT(max_packet_size <= 64);
;;;176          }
;;;177        break;
;;;178    
;;;179        case TUSB_XFER_INTERRUPT:
;;;180        {
;;;181          uint16_t const spec_size = (speed == TUSB_SPEED_HIGH ? 1024 : 64);
;;;182          TU_ASSERT(max_packet_size <= spec_size);
;;;183        }
;;;184        break;
;;;185    
;;;186        default: return false;
000218  13a00000          MOVNE    r0,#0
;;;187      }
;;;188    
;;;189      return true;
;;;190    }
00021c  18bd8010          POPNE    {r4,pc}
000220  e3510002          CMP      r1,#2                 ;181
000224  03a01b01          MOVEQ    r1,#0x400             ;181
000228  13a01040          MOVNE    r1,#0x40              ;181
00022c  e1500001          CMP      r0,r1                 ;182
000230  9a000022          BLS      |L1.704|
000234  e59f1318          LDR      r1,|L1.1364|
000238  e3a020b6          MOV      r2,#0xb6              ;182
00023c  e24f0e21          ADR      r0,|L1.52|
000240  ebfffffe          BL       __2printf
000244  e3a00000          MOV      r0,#0                 ;182
000248  e8bd8010          POP      {r4,pc}
                  |L1.588|
00024c  e3510002          CMP      r1,#2                 ;162
000250  159f1300          LDRNE    r1,|L1.1368|
000254  03a01b01          MOVEQ    r1,#0x400             ;162
000258  e1500001          CMP      r0,r1                 ;163
00025c  9a000017          BLS      |L1.704|
000260  e59f12ec          LDR      r1,|L1.1364|
000264  e3a020a3          MOV      r2,#0xa3              ;163
000268  e24f0f8f          ADR      r0,|L1.52|
00026c  ebfffffe          BL       __2printf
000270  e3a00000          MOV      r0,#0                 ;163
000274  e8bd8010          POP      {r4,pc}
                  |L1.632|
000278  e3510002          CMP      r1,#2                 ;168
00027c  0a000007          BEQ      |L1.672|
000280  e3500040          CMP      r0,#0x40              ;175
000284  9a00000d          BLS      |L1.704|
000288  e59f12c4          LDR      r1,|L1.1364|
00028c  e3a020af          MOV      r2,#0xaf              ;175
000290  e24f0f99          ADR      r0,|L1.52|
000294  ebfffffe          BL       __2printf
000298  e3a00000          MOV      r0,#0                 ;175
00029c  e8bd8010          POP      {r4,pc}
                  |L1.672|
0002a0  e3500c02          CMP      r0,#0x200             ;171
0002a4  0a000005          BEQ      |L1.704|
0002a8  e59f12a4          LDR      r1,|L1.1364|
0002ac  e3a020ab          MOV      r2,#0xab              ;171
0002b0  e24f0fa1          ADR      r0,|L1.52|
0002b4  ebfffffe          BL       __2printf
0002b8  e3a00000          MOV      r0,#0                 ;171
0002bc  e8bd8010          POP      {r4,pc}
                  |L1.704|
0002c0  e3a00001          MOV      r0,#1                 ;189
0002c4  e8bd8010          POP      {r4,pc}
;;;191    
                          ENDP

                  tu_edpt_bind_driver PROC
;;;192    void tu_edpt_bind_driver(uint8_t ep2drv[][2], tusb_desc_interface_t const* desc_itf, uint16_t desc_len, uint8_t driver_id)
0002c8  e0822001          ADD      r2,r2,r1
;;;193    {
;;;194      uint8_t const* p_desc = (uint8_t const*) desc_itf;
;;;195      uint8_t const* desc_end = p_desc + desc_len;
;;;196    
;;;197      while( p_desc < desc_end )
0002cc  e1510002          CMP      r1,r2
0002d0  e52d4004          PUSH     {r4}                  ;193
;;;198      {
;;;199        if ( TUSB_DESC_ENDPOINT == tu_desc_type(p_desc) )
;;;200        {
;;;201          uint8_t const ep_addr = ((tusb_desc_endpoint_t const*) p_desc)->bEndpointAddress;
;;;202    
;;;203          TU_LOG(2, "  Bind EP %02x to driver id %u\r\n", ep_addr, driver_id);
;;;204          ep2drv[tu_edpt_number(ep_addr)][tu_edpt_dir(ep_addr)] = driver_id;
;;;205        }
;;;206    
;;;207        p_desc = tu_desc_next(p_desc);
;;;208      }
;;;209    }
0002d4  249d4004          POPCS    {r4}
0002d8  212fff1e          BXCS     lr
                  |L1.732|
0002dc  e5d1c001          LDRB     r12,[r1,#1]           ;199
0002e0  e35c0005          CMP      r12,#5                ;199
0002e4  1a000003          BNE      |L1.760|
0002e8  e5d1c002          LDRB     r12,[r1,#2]           ;201
0002ec  e3cc4080          BIC      r4,r12,#0x80          ;204
0002f0  e0804084          ADD      r4,r0,r4,LSL #1       ;204
0002f4  e7c433ac          STRB     r3,[r4,r12,LSR #7]    ;204
                  |L1.760|
0002f8  e5d1c000          LDRB     r12,[r1,#0]           ;204
0002fc  e081100c          ADD      r1,r1,r12             ;204
000300  e1510002          CMP      r1,r2                 ;197
000304  3afffff4          BCC      |L1.732|
000308  e49d4004          POP      {r4}
00030c  e12fff1e          BX       lr
;;;210    
                          ENDP

                  tu_desc_get_interface_total_len PROC
;;;211    uint16_t tu_desc_get_interface_total_len(tusb_desc_interface_t const* desc_itf, uint8_t itf_count, uint16_t max_len)
000310  e2513001          SUBS     r3,r1,#1
;;;212    {
000314  e52d4004          PUSH     {r4}
;;;213      uint8_t const* p_desc = (uint8_t const*) desc_itf;
;;;214      uint16_t len = 0;
;;;215    
;;;216      while (itf_count--)
;;;217      {
;;;218        // Next on interface desc
;;;219        len += tu_desc_len(desc_itf);
000318  25d04000          LDRBCS   r4,[r0,#0]
00031c  e203c0ff          AND      r12,r3,#0xff          ;216
000320  e3a01000          MOV      r1,#0                 ;214
000324  3a000015          BCC      |L1.896|
                  |L1.808|
000328  e5d03000          LDRB     r3,[r0,#0]            ;212
00032c  e0811004          ADD      r1,r1,r4
000330  e3c11801          BIC      r1,r1,#0x10000
;;;220        p_desc = tu_desc_next(p_desc);
;;;221    
;;;222        while (len < max_len)
000334  e1510002          CMP      r1,r2
000338  e0800003          ADD      r0,r0,r3
00033c  2a00000c          BCS      |L1.884|
                  |L1.832|
;;;223        {
;;;224          // return on IAD regardless of itf count
;;;225          if ( tu_desc_type(p_desc) == TUSB_DESC_INTERFACE_ASSOCIATION ) return len;
000340  e5d03001          LDRB     r3,[r0,#1]
000344  e353000b          CMP      r3,#0xb
000348  0a00000c          BEQ      |L1.896|
;;;226    
;;;227          if ( (tu_desc_type(p_desc) == TUSB_DESC_INTERFACE) &&
00034c  e3530004          CMP      r3,#4
;;;228               ((tusb_desc_interface_t const*) p_desc)->bAlternateSetting == 0 )
000350  05d03003          LDRBEQ   r3,[r0,#3]
000354  03530000          CMPEQ    r3,#0
000358  0a000005          BEQ      |L1.884|
;;;229          {
;;;230            break;
;;;231          }
;;;232    
;;;233          len += tu_desc_len(p_desc);
00035c  e5d03000          LDRB     r3,[r0,#0]
000360  e0811003          ADD      r1,r1,r3
000364  e3c11801          BIC      r1,r1,#0x10000
000368  e1510002          CMP      r1,r2                 ;222
00036c  e0800003          ADD      r0,r0,r3              ;222
000370  3afffff2          BCC      |L1.832|
                  |L1.884|
000374  e25c3001          SUBS     r3,r12,#1             ;216
000378  e203c0ff          AND      r12,r3,#0xff          ;216
00037c  2affffe9          BCS      |L1.808|
                  |L1.896|
;;;234          p_desc = tu_desc_next(p_desc);
;;;235        }
;;;236      }
;;;237    
;;;238      return len;
000380  e49d4004          POP      {r4}
000384  e1a00001          MOV      r0,r1
;;;239    }
000388  e12fff1e          BX       lr
;;;240    
                          ENDP

                  tu_edpt_stream_init PROC
;;;244    
;;;245    bool tu_edpt_stream_init(tu_edpt_stream_t* s, bool is_host, bool is_tx, bool overwritable,
00038c  e92d4ff8          PUSH     {r3-r11,lr}
;;;246                             void* ff_buf, uint16_t ff_bufsize, uint8_t* ep_buf, uint16_t ep_bufsize)
;;;247    {
000390  e1a05000          MOV      r5,r0
;;;248      osal_mutex_t new_mutex = osal_mutex_create(&s->ff_mutex);
000394  e2804020          ADD      r4,r0,#0x20
000398  e59d9034          LDR      r9,[sp,#0x34]
00039c  e59da030          LDR      r10,[sp,#0x30]
0003a0  e59db02c          LDR      r11,[sp,#0x2c]
0003a4  e1a06003          MOV      r6,r3                 ;247
0003a8  e1a07002          MOV      r7,r2                 ;247
0003ac  e1a08001          MOV      r8,r1                 ;247
0003b0  e1a00004          MOV      r0,r4                 ;247
0003b4  ebfffffe          BL       os_mut_init
;;;249      (void) new_mutex;
;;;250      (void) is_tx;
;;;251    
;;;252      s->is_host = is_host;
0003b8  e5c58000          STRB     r8,[r5,#0]
;;;253      tu_fifo_config(&s->ff, ff_buf, ff_bufsize, 1, overwritable);
0003bc  e58d6000          STR      r6,[sp,#0]
0003c0  e59d1028          LDR      r1,[sp,#0x28]
0003c4  e3a03001          MOV      r3,#1
0003c8  e1a0200b          MOV      r2,r11
0003cc  e285000c          ADD      r0,r5,#0xc
0003d0  ebfffffe          BL       tu_fifo_config
;;;254      tu_fifo_config_mutex(&s->ff, is_tx ? new_mutex : NULL, is_tx ? NULL : new_mutex);
0003d4  e3570000          CMP      r7,#0
0003d8  13a00000          MOVNE    r0,#0
0003dc  01a00004          MOVEQ    r0,r4
;;;255    
;;;256      s->ep_buf = ep_buf;
0003e0  e585001c          STR      r0,[r5,#0x1c]
0003e4  11a01004          MOVNE    r1,r4                 ;254
0003e8  03a01000          MOVEQ    r1,#0                 ;254
0003ec  e5851018          STR      r1,[r5,#0x18]
0003f0  e585a008          STR      r10,[r5,#8]
;;;257      s->ep_bufsize = ep_bufsize;
;;;258    
;;;259      return true;
0003f4  e3a00001          MOV      r0,#1
0003f8  e1c590b6          STRH     r9,[r5,#6]            ;257
;;;260    }
0003fc  e8bd8ff8          POP      {r3-r11,pc}
;;;261    
                          ENDP

                  tu_edpt_stream_write_zlp_if_needed PROC
;;;319    
;;;320    bool tu_edpt_stream_write_zlp_if_needed(tu_edpt_stream_t* s, uint32_t last_xferred_bytes)
000400  e92d4070          PUSH     {r4-r6,lr}
;;;321    {
000404  e1a04000          MOV      r4,r0
000408  e1a05001          MOV      r5,r1
;;;322      // ZLP condition: no pending data, last transferred bytes is multiple of packet size
;;;323      TU_VERIFY( !tu_fifo_count(&s->ff) && last_xferred_bytes && (0 == (last_xferred_bytes & (s->ep_packetsize-1))) );
00040c  e280000c          ADD      r0,r0,#0xc
000410  ebfffffe          BL       tu_fifo_count
000414  e3500000          CMP      r0,#0
000418  1a000011          BNE      |L1.1124|
00041c  e3550000          CMP      r5,#0
000420  0a00000f          BEQ      |L1.1124|
000424  e1d400b4          LDRH     r0,[r4,#4]
000428  e2400001          SUB      r0,r0,#1
00042c  e1100005          TST      r0,r5
000430  05d40000          LDRBEQ   r0,[r4,#0]
000434  03500000          CMPEQ    r0,#0
000438  1a000009          BNE      |L1.1124|
00043c  e5d41002          LDRB     r1,[r4,#2]
000440  e5d40001          LDRB     r0,[r4,#1]
000444  ebfffffe          BL       usbd_edpt_claim
;;;324    
;;;325      TU_VERIFY( stream_claim(s) );
000448  e3500000          CMP      r0,#0
00044c  0a000004          BEQ      |L1.1124|
000450  e5d40000          LDRB     r0,[r4,#0]
;;;326      TU_ASSERT( stream_xfer(s, 0) );
000454  e3a03000          MOV      r3,#0
000458  e3500000          CMP      r0,#0
00045c  0a000002          BEQ      |L1.1132|
000460  ea000008          B        |L1.1160|
                  |L1.1124|
000464  e3a00000          MOV      r0,#0                 ;325
;;;327    
;;;328      return true;
;;;329    }
000468  e8bd8070          POP      {r4-r6,pc}
                  |L1.1132|
00046c  e5d41002          LDRB     r1,[r4,#2]
000470  e5d40001          LDRB     r0,[r4,#1]
000474  e3a02000          MOV      r2,#0
000478  ebfffffe          BL       usbd_edpt_xfer
00047c  e3500000          CMP      r0,#0                 ;326
000480  13a00001          MOVNE    r0,#1                 ;328
000484  18bd8070          POPNE    {r4-r6,pc}
                  |L1.1160|
000488  e59f20cc          LDR      r2,|L1.1372|
00048c  e59f10cc          LDR      r1,|L1.1376|
000490  e59f00cc          LDR      r0,|L1.1380|
000494  ebfffffe          BL       __2printf
000498  e3a00000          MOV      r0,#0                 ;326
00049c  e8bd8070          POP      {r4-r6,pc}
;;;330    
                          ENDP

                  tu_edpt_stream_write_xfer PROC
;;;331    uint32_t tu_edpt_stream_write_xfer(tu_edpt_stream_t* s)
0004a0  e92d4070          PUSH     {r4-r6,lr}
;;;332    {
0004a4  e1a04000          MOV      r4,r0
;;;333      // skip if no data
;;;334      TU_VERIFY( tu_fifo_count(&s->ff), 0 );
0004a8  e280000c          ADD      r0,r0,#0xc
0004ac  ebfffffe          BL       tu_fifo_count
0004b0  e3500000          CMP      r0,#0
;;;335    
;;;336      // Claim the endpoint
;;;337      TU_VERIFY( stream_claim(s), 0 );
;;;338    
;;;339      // Pull data from FIFO -> EP buf
;;;340      uint16_t const count = tu_fifo_read_n(&s->ff, s->ep_buf, s->ep_bufsize);
;;;341    
;;;342      if ( count )
;;;343      {
;;;344        TU_ASSERT( stream_xfer(s, count), 0 );
;;;345        return count;
;;;346      }else
;;;347      {
;;;348        // Release endpoint since we don't make any transfer
;;;349        // Note: data is dropped if terminal is not connected
;;;350        stream_release(s);
;;;351        return 0;
;;;352      }
;;;353    }
0004b4  08bd8070          POPEQ    {r4-r6,pc}
0004b8  e5d40000          LDRB     r0,[r4,#0]
0004bc  e3500000          CMP      r0,#0
0004c0  1a000020          BNE      |L1.1352|
0004c4  e5d41002          LDRB     r1,[r4,#2]
0004c8  e5d40001          LDRB     r0,[r4,#1]
0004cc  ebfffffe          BL       usbd_edpt_claim
0004d0  e3500000          CMP      r0,#0                 ;337
0004d4  0a00001b          BEQ      |L1.1352|
0004d8  e1d420b6          LDRH     r2,[r4,#6]            ;340
0004dc  e5941008          LDR      r1,[r4,#8]            ;340
0004e0  e284000c          ADD      r0,r4,#0xc            ;340
0004e4  ebfffffe          BL       tu_fifo_read_n
0004e8  e1b05000          MOVS     r5,r0                 ;340
0004ec  e5d40000          LDRB     r0,[r4,#0]            ;340
0004f0  0a00000f          BEQ      |L1.1332|
0004f4  e3500000          CMP      r0,#0                 ;342
0004f8  e1a03005          MOV      r3,r5                 ;344
0004fc  1a000006          BNE      |L1.1308|
000500  e5942008          LDR      r2,[r4,#8]            ;344
000504  e5d41002          LDRB     r1,[r4,#2]            ;344
000508  e5d40001          LDRB     r0,[r4,#1]            ;344
00050c  ebfffffe          BL       usbd_edpt_xfer
000510  e3500000          CMP      r0,#0                 ;344
000514  11a00005          MOVNE    r0,r5                 ;345
000518  18bd8070          POPNE    {r4-r6,pc}
                  |L1.1308|
00051c  e3a02f56          MOV      r2,#0x158             ;344
000520  e59f1040          LDR      r1,|L1.1384|
000524  e28f0040          ADR      r0,|L1.1388|
000528  ebfffffe          BL       __2printf
00052c  e3a00000          MOV      r0,#0                 ;344
000530  e8bd8070          POP      {r4-r6,pc}
                  |L1.1332|
000534  e3500000          CMP      r0,#0
000538  1a000002          BNE      |L1.1352|
00053c  e5d41002          LDRB     r1,[r4,#2]            ;350
000540  e5d40001          LDRB     r0,[r4,#1]            ;350
000544  ebfffffe          BL       usbd_edpt_release
                  |L1.1352|
000548  e3a00000          MOV      r0,#0                 ;351
00054c  e8bd8070          POP      {r4-r6,pc}
                  |L1.1360|
                          DCD      0x0000ffff
                  |L1.1364|
                          DCD      ||.constdata||+0xa
                  |L1.1368|
                          DCD      0x000003ff
                  |L1.1372|
                          DCD      0x00000146
                  |L1.1376|
                          DCD      ||.constdata||+0x1b
                  |L1.1380|
                          DCD      ||.text||+0x34
                  |L1.1384|
                          DCD      ||.constdata||+0x3e
                  |L1.1388|
00056c  25732025          DCB      "%s %d: ASSERT FAILED\r\n",0
000570  643a2041
000574  53534552
000578  54204641
00057c  494c4544
000580  0d0a00  
000583  00                DCB      0
                          ENDP

                  tu_edpt_stream_write PROC
;;;354    
;;;355    uint32_t tu_edpt_stream_write(tu_edpt_stream_t* s, void const *buffer, uint32_t bufsize)
000584  e3520000          CMP      r2,#0
;;;356    {
;;;357      TU_VERIFY(bufsize); // TODO support ZLP
000588  03a00000          MOVEQ    r0,#0
;;;358    
;;;359      uint16_t ret = tu_fifo_write_n(&s->ff, buffer, (uint16_t) bufsize);
;;;360    
;;;361      // flush if fifo has more than packet size or
;;;362      // in rare case: fifo depth is configured too small (which never reach packet size)
;;;363      if ( (tu_fifo_count(&s->ff) >= s->ep_packetsize) || (tu_fifo_depth(&s->ff) < s->ep_packetsize) )
;;;364      {
;;;365        tu_edpt_stream_write_xfer(s);
;;;366      }
;;;367    
;;;368      return ret;
;;;369    }
00058c  012fff1e          BXEQ     lr
000590  e92d4070          PUSH     {r4-r6,lr}            ;356
000594  e1a04000          MOV      r4,r0                 ;356
000598  e1a02802          LSL      r2,r2,#16             ;359
00059c  e1a02822          LSR      r2,r2,#16             ;359
0005a0  e280000c          ADD      r0,r0,#0xc            ;359
0005a4  ebfffffe          BL       tu_fifo_write_n
0005a8  e1a05000          MOV      r5,r0                 ;359
0005ac  e284000c          ADD      r0,r4,#0xc            ;363
0005b0  ebfffffe          BL       tu_fifo_count
0005b4  e1a01000          MOV      r1,r0                 ;363
0005b8  e1d400b4          LDRH     r0,[r4,#4]            ;363
0005bc  e1510000          CMP      r1,r0                 ;363
0005c0  2a000002          BCS      |L1.1488|
0005c4  e1d411b0          LDRH     r1,[r4,#0x10]         ;363
0005c8  e1510000          CMP      r1,r0                 ;363
0005cc  2a000026          BCS      |L1.1644|
                  |L1.1488|
0005d0  e284000c          ADD      r0,r4,#0xc            ;363
0005d4  ebfffffe          BL       tu_fifo_count
0005d8  e3500000          CMP      r0,#0                 ;363
0005dc  0a000022          BEQ      |L1.1644|
0005e0  e5d40000          LDRB     r0,[r4,#0]            ;363
0005e4  e3500000          CMP      r0,#0                 ;363
0005e8  1a00001f          BNE      |L1.1644|
0005ec  e5d41002          LDRB     r1,[r4,#2]            ;363
0005f0  e5d40001          LDRB     r0,[r4,#1]            ;363
0005f4  ebfffffe          BL       usbd_edpt_claim
0005f8  e3500000          CMP      r0,#0                 ;363
0005fc  0a00001a          BEQ      |L1.1644|
000600  e1d420b6          LDRH     r2,[r4,#6]            ;363
000604  e5941008          LDR      r1,[r4,#8]            ;363
000608  e284000c          ADD      r0,r4,#0xc            ;363
00060c  ebfffffe          BL       tu_fifo_read_n
000610  e3500000          CMP      r0,#0                 ;363
000614  0a00000e          BEQ      |L1.1620|
000618  e5d41000          LDRB     r1,[r4,#0]            ;363
00061c  e1a03000          MOV      r3,r0                 ;363
000620  e3510000          CMP      r1,#0                 ;363
000624  1a000005          BNE      |L1.1600|
000628  e5942008          LDR      r2,[r4,#8]            ;363
00062c  e5d41002          LDRB     r1,[r4,#2]            ;363
000630  e5d40001          LDRB     r0,[r4,#1]            ;363
000634  ebfffffe          BL       usbd_edpt_xfer
000638  e3500000          CMP      r0,#0                 ;363
00063c  1a00000a          BNE      |L1.1644|
                  |L1.1600|
000640  e51f10e0          LDR      r1,|L1.1384|
000644  e3a02f56          MOV      r2,#0x158             ;363
000648  e24f00e4          ADR      r0,|L1.1388|
00064c  ebfffffe          BL       __2printf
000650  ea000005          B        |L1.1644|
                  |L1.1620|
000654  e5d40000          LDRB     r0,[r4,#0]            ;363
000658  e3500000          CMP      r0,#0                 ;363
00065c  1a000002          BNE      |L1.1644|
000660  e5d41002          LDRB     r1,[r4,#2]            ;363
000664  e5d40001          LDRB     r0,[r4,#1]            ;363
000668  ebfffffe          BL       usbd_edpt_release
                  |L1.1644|
00066c  e1a00005          MOV      r0,r5                 ;368
000670  e8bd8070          POP      {r4-r6,pc}
;;;370    
                          ENDP

                  tu_edpt_stream_read_xfer PROC
;;;374    
;;;375    uint32_t tu_edpt_stream_read_xfer(tu_edpt_stream_t* s)
000674  e92d4070          PUSH     {r4-r6,lr}
;;;376    {
000678  e1a04000          MOV      r4,r0
;;;377      uint16_t available = tu_fifo_remaining(&s->ff);
00067c  e280000c          ADD      r0,r0,#0xc
000680  ebfffffe          BL       tu_fifo_remaining
;;;378    
;;;379      // Prepare for incoming data but only allow what we can store in the ring buffer.
;;;380      // TODO Actually we can still carry out the transfer, keeping count of received bytes
;;;381      // and slowly move it to the FIFO when read().
;;;382      // This pre-check reduces endpoint claiming
;;;383      TU_VERIFY(available >= s->ep_packetsize);
000684  e1d410b4          LDRH     r1,[r4,#4]
000688  e1510000          CMP      r1,r0
00068c  95d40000          LDRBLS   r0,[r4,#0]
000690  93500000          CMPLS    r0,#0
000694  1a000027          BNE      |L1.1848|
000698  e5d41002          LDRB     r1,[r4,#2]
00069c  e5d40001          LDRB     r0,[r4,#1]
0006a0  ebfffffe          BL       usbd_edpt_claim
;;;384    
;;;385      // claim endpoint
;;;386      TU_VERIFY(stream_claim(s), 0);
0006a4  e3500000          CMP      r0,#0
0006a8  0a000022          BEQ      |L1.1848|
;;;387    
;;;388      // get available again since fifo can be changed before endpoint is claimed
;;;389      available = tu_fifo_remaining(&s->ff);
0006ac  e284000c          ADD      r0,r4,#0xc
0006b0  ebfffffe          BL       tu_fifo_remaining
;;;390    
;;;391      if ( available >= s->ep_packetsize )
0006b4  e1d410b4          LDRH     r1,[r4,#4]
0006b8  e1510000          CMP      r1,r0
0006bc  8a000017          BHI      |L1.1824|
;;;392      {
;;;393        // multiple of packet size limit by ep bufsize
;;;394        uint16_t count = (uint16_t) (available & ~(s->ep_packetsize -1));
;;;395        count = tu_min16(count, s->ep_bufsize);
0006c0  e1d450b6          LDRH     r5,[r4,#6]
0006c4  e2411001          SUB      r1,r1,#1
0006c8  e1c00001          BIC      r0,r0,r1              ;394
0006cc  e1500005          CMP      r0,r5
0006d0  31a05000          MOVCC    r5,r0
0006d4  e5d40000          LDRB     r0,[r4,#0]
;;;396    
;;;397        TU_ASSERT( stream_xfer(s, count), 0 );
0006d8  e1a03005          MOV      r3,r5
0006dc  e3500000          CMP      r0,#0
0006e0  1a000008          BNE      |L1.1800|
0006e4  e3530000          CMP      r3,#0                 ;395
0006e8  15942008          LDRNE    r2,[r4,#8]            ;395
0006ec  e5d41002          LDRB     r1,[r4,#2]            ;395
0006f0  e5d40001          LDRB     r0,[r4,#1]            ;395
0006f4  03a02000          MOVEQ    r2,#0                 ;395
0006f8  ebfffffe          BL       usbd_edpt_xfer
0006fc  e3500000          CMP      r0,#0
;;;398    
;;;399        return count;
000700  11a00005          MOVNE    r0,r5
;;;400      }else
;;;401      {
;;;402        // Release endpoint since we don't make any transfer
;;;403        stream_release(s);
;;;404        return 0;
;;;405      }
;;;406    }
000704  18bd8070          POPNE    {r4-r6,pc}
                  |L1.1800|
000708  e59f22bc          LDR      r2,|L1.2508|
00070c  e59f12bc          LDR      r1,|L1.2512|
000710  e24f0f6b          ADR      r0,|L1.1388|
000714  ebfffffe          BL       __2printf
000718  e3a00000          MOV      r0,#0                 ;397
00071c  e8bd8070          POP      {r4-r6,pc}
                  |L1.1824|
000720  e5d40000          LDRB     r0,[r4,#0]
000724  e3500000          CMP      r0,#0
000728  1a000002          BNE      |L1.1848|
00072c  e5d41002          LDRB     r1,[r4,#2]            ;403
000730  e5d40001          LDRB     r0,[r4,#1]            ;403
000734  ebfffffe          BL       usbd_edpt_release
                  |L1.1848|
000738  e3a00000          MOV      r0,#0                 ;404
00073c  e8bd8070          POP      {r4-r6,pc}
;;;407    
                          ENDP

                  tu_edpt_stream_read PROC
;;;408    uint32_t tu_edpt_stream_read(tu_edpt_stream_t* s, void* buffer, uint32_t bufsize)
000740  e92d4070          PUSH     {r4-r6,lr}
;;;409    {
000744  e1a04000          MOV      r4,r0
;;;410      uint32_t num_read = tu_fifo_read_n(&s->ff, buffer, (uint16_t) bufsize);
000748  e1a02802          LSL      r2,r2,#16
00074c  e1a02822          LSR      r2,r2,#16
000750  e280000c          ADD      r0,r0,#0xc
000754  ebfffffe          BL       tu_fifo_read_n
000758  e1a05000          MOV      r5,r0
00075c  e284000c          ADD      r0,r4,#0xc
000760  ebfffffe          BL       tu_fifo_remaining
000764  e1d410b4          LDRH     r1,[r4,#4]
000768  e1510000          CMP      r1,r0
00076c  95d40000          LDRBLS   r0,[r4,#0]
000770  93500000          CMPLS    r0,#0
000774  1a000024          BNE      |L1.2060|
000778  e5d41002          LDRB     r1,[r4,#2]
00077c  e5d40001          LDRB     r0,[r4,#1]
000780  ebfffffe          BL       usbd_edpt_claim
000784  e3500000          CMP      r0,#0
000788  0a00001f          BEQ      |L1.2060|
00078c  e284000c          ADD      r0,r4,#0xc
000790  ebfffffe          BL       tu_fifo_remaining
000794  e1d410b4          LDRH     r1,[r4,#4]
000798  e1510000          CMP      r1,r0
00079c  8a000014          BHI      |L1.2036|
0007a0  e1d430b6          LDRH     r3,[r4,#6]
0007a4  e2411001          SUB      r1,r1,#1
0007a8  e1c00001          BIC      r0,r0,r1
0007ac  e1500003          CMP      r0,r3
0007b0  31a03000          MOVCC    r3,r0
0007b4  e5d40000          LDRB     r0,[r4,#0]
0007b8  e3500000          CMP      r0,#0
0007bc  1a000007          BNE      |L1.2016|
0007c0  e3530000          CMP      r3,#0
0007c4  15942008          LDRNE    r2,[r4,#8]
0007c8  e5d41002          LDRB     r1,[r4,#2]
0007cc  e5d40001          LDRB     r0,[r4,#1]
0007d0  03a02000          MOVEQ    r2,#0
0007d4  ebfffffe          BL       usbd_edpt_xfer
0007d8  e3500000          CMP      r0,#0
0007dc  1a00000a          BNE      |L1.2060|
                  |L1.2016|
0007e0  e59f21e4          LDR      r2,|L1.2508|
0007e4  e59f11e4          LDR      r1,|L1.2512|
0007e8  e24f0fa1          ADR      r0,|L1.1388|
0007ec  ebfffffe          BL       __2printf
0007f0  ea000005          B        |L1.2060|
                  |L1.2036|
0007f4  e5d40000          LDRB     r0,[r4,#0]
0007f8  e3500000          CMP      r0,#0
0007fc  1a000002          BNE      |L1.2060|
000800  e5d41002          LDRB     r1,[r4,#2]
000804  e5d40001          LDRB     r0,[r4,#1]
000808  ebfffffe          BL       usbd_edpt_release
                  |L1.2060|
;;;411      tu_edpt_stream_read_xfer(s);
;;;412      return num_read;
00080c  e1a00005          MOV      r0,r5
;;;413    }
000810  e8bd8070          POP      {r4-r6,pc}
;;;414    
                          ENDP

                  tu_print_mem PROC
;;;466     */
;;;467    void tu_print_mem(void const *buf, uint32_t count, uint8_t indent)
000814  e92d4ff0          PUSH     {r4-r11,lr}
;;;468    {
;;;469      uint8_t const size = 1; // fixed 1 byte for now
;;;470    
;;;471      if ( !buf || !count )
000818  e3500000          CMP      r0,#0
00081c  e1a0a001          MOV      r10,r1                ;468
000820  135a0000          CMPNE    r10,#0
000824  e24dd014          SUB      sp,sp,#0x14           ;468
000828  e1a07002          MOV      r7,r2                 ;468
;;;472      {
;;;473        tu_printf("NULL\r\n");
00082c  028f0e1a          ADREQ    r0,|L1.2516|
000830  0a000062          BEQ      |L1.2496|
;;;474        return;
;;;475      }
;;;476    
;;;477      uint8_t const *buf8 = (uint8_t const *) buf;
;;;478    
;;;479      char format[] = "%00X";
000834  e28f1e1a          ADR      r1,|L1.2524|
000838  e1a05000          MOV      r5,r0                 ;477
00083c  e8910003          LDM      r1,{r0,r1}            ;477
000840  e1cd00f0          STRD     r0,r1,[sp,#0]         ;477
;;;480      format[2] += 2*size;
000844  e5dd0002          LDRB     r0,[sp,#2]
;;;481    
;;;482      const uint8_t item_per_line  = 16 / size;
;;;483    
;;;484      for(unsigned int i=0; i<count; i++)
000848  e3a06000          MOV      r6,#0
00084c  23a0b000          MOVCS    r11,#0
000850  e2800002          ADD      r0,r0,#2              ;480
000854  e5cd0002          STRB     r0,[sp,#2]            ;480
000858  9a000032          BLS      |L1.2344|
                  |L1.2140|
;;;485      {
;;;486        unsigned int value=0;
;;;487    
;;;488        if ( i%item_per_line == 0 )
00085c  e316000f          TST      r6,#0xf
000860  e58db008          STR      r11,[sp,#8]           ;486
000864  1a000022          BNE      |L1.2292|
;;;489        {
;;;490          // Print Ascii
;;;491          if ( i != 0 )
000868  e3560000          CMP      r6,#0
00086c  0a000014          BEQ      |L1.2244|
;;;492          {
;;;493            dump_str_line(buf8-16, 16);
000870  e2459010          SUB      r9,r5,#0x10
000874  e3a08010          MOV      r8,#0x10
000878  e28f0f59          ADR      r0,|L1.2532|
00087c  ebfffffe          BL       __2printf
000880  e3a04000          MOV      r4,#0
000884  ebfffffe          BL       __rt_ctype_table
000888  e58d000c          STR      r0,[sp,#0xc]
                  |L1.2188|
00088c  e59d000c          LDR      r0,[sp,#0xc]
000890  e7d91004          LDRB     r1,[r9,r4]
000894  e5900000          LDR      r0,[r0,#0]
000898  e7d00001          LDRB     r0,[r0,r1]
00089c  e310003e          TST      r0,#0x3e
0008a0  03a0102e          MOVEQ    r1,#0x2e
0008a4  e28f0f4f          ADR      r0,|L1.2536|
0008a8  ebfffffe          BL       __2printf
0008ac  e2840001          ADD      r0,r4,#1
0008b0  e3c04801          BIC      r4,r0,#0x10000
0008b4  e1540008          CMP      r4,r8
0008b8  3afffff3          BCC      |L1.2188|
0008bc  e28f0f4a          ADR      r0,|L1.2540|
0008c0  ebfffffe          BL       __2printf
                  |L1.2244|
;;;494          }
;;;495    
;;;496          for(uint8_t s=0; s < indent; s++) tu_printf(" ");
0008c4  e3570000          CMP      r7,#0
0008c8  e3a04000          MOV      r4,#0
0008cc  9a000005          BLS      |L1.2280|
                  |L1.2256|
0008d0  e28f0f46          ADR      r0,|L1.2544|
0008d4  ebfffffe          BL       __2printf
0008d8  e2840001          ADD      r0,r4,#1
0008dc  e20040ff          AND      r4,r0,#0xff
0008e0  e1570004          CMP      r7,r4
0008e4  8afffff9          BHI      |L1.2256|
                  |L1.2280|
;;;497    
;;;498          // print offset or absolute address
;;;499          tu_printf("%04X: ", 16*i/item_per_line);
0008e8  e3c6120f          BIC      r1,r6,#0xf0000000
0008ec  e28f0c01          ADR      r0,|L1.2548|
0008f0  ebfffffe          BL       __2printf
                  |L1.2292|
;;;500        }
;;;501    
;;;502        tu_memcpy_s(&value, sizeof(value), buf8, size);
0008f4  e28d0008          ADD      r0,sp,#8
0008f8  e1a01005          MOV      r1,r5
0008fc  e3a02001          MOV      r2,#1
000900  ebfffffe          BL       __aeabi_memcpy
;;;503        buf8 += size;
;;;504    
;;;505        tu_printf(" ");
000904  e28f00e4          ADR      r0,|L1.2544|
000908  e2855001          ADD      r5,r5,#1
00090c  ebfffffe          BL       __2printf
;;;506        tu_printf(format, value);
000910  e59d1008          LDR      r1,[sp,#8]
000914  e1a0000d          MOV      r0,sp
000918  ebfffffe          BL       __2printf
00091c  e2866001          ADD      r6,r6,#1
000920  e156000a          CMP      r6,r10                ;484
000924  3affffcc          BCC      |L1.2140|
                  |L1.2344|
;;;507      }
;;;508    
;;;509      // fill up last row to 16 for printing ascii
;;;510      const uint32_t remain = count%16;
000928  e21a700f          ANDS     r7,r10,#0xf
;;;511      uint8_t nback = (uint8_t)(remain ? remain : 16);
00092c  03a07010          MOVEQ    r7,#0x10
000930  0a00000e          BEQ      |L1.2416|
;;;512    
;;;513      if ( remain )
;;;514      {
;;;515        for(uint32_t i=0; i< 16-remain; i++)
000934  e2770010          RSBS     r0,r7,#0x10
000938  e3a06000          MOV      r6,#0
00093c  12678010          RSBNE    r8,r7,#0x10
000940  0a00000a          BEQ      |L1.2416|
                  |L1.2372|
;;;516        {
;;;517          tu_printf(" ");
000944  e28f00a4          ADR      r0,|L1.2544|
000948  ebfffffe          BL       __2printf
;;;518          for(int j=0; j<2*size; j++) tu_printf(" ");
00094c  e3a04000          MOV      r4,#0
                  |L1.2384|
000950  e28f0098          ADR      r0,|L1.2544|
000954  ebfffffe          BL       __2printf
000958  e2844001          ADD      r4,r4,#1
00095c  e3540002          CMP      r4,#2
000960  bafffffa          BLT      |L1.2384|
000964  e2866001          ADD      r6,r6,#1
000968  e1580006          CMP      r8,r6                 ;515
00096c  8afffff4          BHI      |L1.2372|
                  |L1.2416|
;;;519        }
;;;520      }
;;;521    
;;;522      dump_str_line(buf8-nback, nback);
000970  e0455007          SUB      r5,r5,r7
000974  e28f0068          ADR      r0,|L1.2532|
000978  ebfffffe          BL       __2printf
00097c  e3570000          CMP      r7,#0
000980  e3a04000          MOV      r4,#0
000984  9a00000c          BLS      |L1.2492|
000988  ebfffffe          BL       __rt_ctype_table
00098c  e1a06000          MOV      r6,r0
                  |L1.2448|
000990  e7d51004          LDRB     r1,[r5,r4]
000994  e5960000          LDR      r0,[r6,#0]
000998  e7d00001          LDRB     r0,[r0,r1]
00099c  e310003e          TST      r0,#0x3e
0009a0  03a0102e          MOVEQ    r1,#0x2e
0009a4  e28f003c          ADR      r0,|L1.2536|
0009a8  ebfffffe          BL       __2printf
0009ac  e2840001          ADD      r0,r4,#1
0009b0  e3c04801          BIC      r4,r0,#0x10000
0009b4  e1540007          CMP      r4,r7
0009b8  3afffff4          BCC      |L1.2448|
                  |L1.2492|
0009bc  e28f0028          ADR      r0,|L1.2540|
                  |L1.2496|
0009c0  ebfffffe          BL       __2printf
;;;523    }
0009c4  e28dd014          ADD      sp,sp,#0x14
0009c8  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.2508|
                          DCD      0x0000018d
                  |L1.2512|
                          DCD      ||.constdata||+0x58
                  |L1.2516|
0009d4  4e554c4c          DCB      "NULL\r\n",0
0009d8  0d0a00  
0009db  00                DCB      0
                  |L1.2524|
0009dc  25303058          DCB      "%00X",0
0009e0  00      
0009e1  00                DCB      0
0009e2  00                DCB      0
0009e3  00                DCB      0
                  |L1.2532|
0009e4  20207c00          DCB      "  |",0
                  |L1.2536|
0009e8  256300            DCB      "%c",0
0009eb  00                DCB      0
                  |L1.2540|
0009ec  7c0d0a00          DCB      "|\r\n",0
                  |L1.2544|
0009f0  2000              DCB      " ",0
0009f2  00                DCB      0
0009f3  00                DCB      0
                  |L1.2548|
0009f4  25303458          DCB      "%04X: ",0
0009f8  3a2000  
0009fb  00                DCB      0
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __func__
000000  74757362          DCB      0x74,0x75,0x73,0x62
000004  5f696e69          DCB      0x5f,0x69,0x6e,0x69
000008  7400              DCB      0x74,0x00
                  |symbol_number.12|
00000a  7475              DCB      0x74,0x75
00000c  5f656470          DCB      0x5f,0x65,0x64,0x70
000010  745f7661          DCB      0x74,0x5f,0x76,0x61
000014  6c696461          DCB      0x6c,0x69,0x64,0x61
000018  746500            DCB      0x74,0x65,0x00
                  |symbol_number.13|
00001b  74                DCB      0x74
00001c  755f6564          DCB      0x75,0x5f,0x65,0x64
000020  70745f73          DCB      0x70,0x74,0x5f,0x73
000024  74726561          DCB      0x74,0x72,0x65,0x61
000028  6d5f7772          DCB      0x6d,0x5f,0x77,0x72
00002c  6974655f          DCB      0x69,0x74,0x65,0x5f
000030  7a6c705f          DCB      0x7a,0x6c,0x70,0x5f
000034  69665f6e          DCB      0x69,0x66,0x5f,0x6e
000038  65656465          DCB      0x65,0x65,0x64,0x65
00003c  6400              DCB      0x64,0x00
                  |symbol_number.14|
00003e  7475              DCB      0x74,0x75
000040  5f656470          DCB      0x5f,0x65,0x64,0x70
000044  745f7374          DCB      0x74,0x5f,0x73,0x74
000048  7265616d          DCB      0x72,0x65,0x61,0x6d
00004c  5f777269          DCB      0x5f,0x77,0x72,0x69
000050  74655f78          DCB      0x74,0x65,0x5f,0x78
000054  66657200          DCB      0x66,0x65,0x72,0x00
                  |symbol_number.15|
000058  74755f65          DCB      0x74,0x75,0x5f,0x65
00005c  6470745f          DCB      0x64,0x70,0x74,0x5f
000060  73747265          DCB      0x73,0x74,0x72,0x65
000064  616d5f72          DCB      0x61,0x6d,0x5f,0x72
000068  6561645f          DCB      0x65,0x61,0x64,0x5f
00006c  78666572          DCB      0x78,0x66,0x65,0x72
000070  00                DCB      0x00
